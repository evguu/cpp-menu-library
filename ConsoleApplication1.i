

#pragma once

#pragma once

// string standard header
#pragma once




// istream standard header
#pragma once




// ostream standard header
#pragma once




// ios standard header
#pragma once




// xlocnum internal header (from <locale>)
#pragma once




// climits standard header
#pragma once





// yvals.h internal header
#pragma once





// yvals_core.h internal header (core)
#pragma once




// _HAS_CXX17 directly controls:
// P0005R4 not_fn()
// P0024R2 Parallel Algorithms
// P0025R1 clamp()
// P0030R1 hypot(x, y, z)
// P0031R0 constexpr For <array> (Again) And <iterator>
// P0032R3 Homogeneous Interface For variant/any/optional
// P0040R3 Extending Memory Management Tools
// P0067R5 Elementary String Conversions
//     (partially implemented)
// P0083R3 Splicing Maps And Sets
// P0084R2 Emplace Return Type
// P0088R3 <variant>
// P0137R1 launder()
// P0152R1 atomic::is_always_lock_free
// P0154R1 hardware_destructive_interference_size, etc.
// P0156R2 scoped_lock
// P0163R0 shared_ptr::weak_type
// P0185R1 is_swappable, is_nothrow_swappable
// P0209R2 make_from_tuple()
// P0218R1 <filesystem>
// P0220R1 <any>, <memory_resource>, <optional>, <string_view>, apply(), sample(), Boyer-Moore search()
// P0253R1 Fixing Searcher Return Types
// P0254R2 Integrating string_view And std::string
// P0258R2 has_unique_object_representations
// P0272R1 Non-const basic_string::data()
// P0295R0 gcd(), lcm()
// P0307R2 Making Optional Greater Equal Again
// P0336R1 Renaming Parallel Execution Policies
// P0337R0 Deleting polymorphic_allocator Assignment
// P0358R1 Fixes For not_fn()
// P0393R3 Making Variant Greater Equal
// P0394R4 Parallel Algorithms Should terminate() For Exceptions
// P0403R1 UDLs For <string_view> ("meow"sv, etc.)
// P0426R1 constexpr For char_traits
// P0433R2 Deduction Guides For The STL
// P0452R1 Unifying <numeric> Parallel Algorithms
// P0504R0 Revisiting in_place_t/in_place_type_t<T>/in_place_index_t<I>
// P0505R0 constexpr For <chrono> (Again)
// P0508R0 Clarifying insert_return_type
// P0510R0 Rejecting variants Of Nothing, Arrays, References, And Incomplete Types
// P0604R0 invoke_result, is_invocable, is_nothrow_invocable
// P0607R0 Inline Variables For The STL
// P0682R1 Repairing Elementary String Conversions
// P0739R0 Improving Class Template Argument Deduction For The STL

// _HAS_CXX17 indirectly controls:
// N4190 Removing auto_ptr, random_shuffle(), And Old <functional> Stuff
// P0003R5 Removing Dynamic Exception Specifications
// P0004R1 Removing Deprecated Iostreams Aliases
// P0226R1 Mathematical Special Functions
// P0298R3 std::byte
// P0302R1 Removing Allocator Support In std::function
// LWG 2385 function::assign allocator argument doesn't make sense
// LWG 2921 packaged_task and type-erased allocators
// LWG 2976 Dangling uses_allocator specialization for packaged_task
// The non-Standard std::tr1 namespace and TR1-only machinery
// The non-Standard std::identity struct
// The non-Standard std::tr2::sys namespace
// Enforcement of matching allocator value_types
// [[nodiscard]] attributes on STL functions

// _HAS_CXX17 and _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS control:
// P0174R2 Deprecating Vestigial Library Parts
// P0521R0 Deprecating shared_ptr::unique()
// P0618R0 Deprecating <codecvt>
// Other C++17 deprecation warnings

// Implemented unconditionally:
// N3911 void_t
// N4089 Safe Conversions In unique_ptr<T[]>
// N4169 invoke()
// N4258 noexcept Cleanups
// N4259 uncaught_exceptions()
// N4277 Trivially Copyable reference_wrapper
// N4279 insert_or_assign()/try_emplace() For map/unordered_map
// N4280 size(), empty(), data()
// N4366 Precisely Constraining unique_ptr Assignment
// N4387 Improving pair And tuple
// N4389 bool_constant
// N4508 shared_mutex (Untimed)
// N4510 Supporting Incomplete Types In vector/list/forward_list
// P0006R0 Variable Templates For Type Traits (is_same_v, etc.)
// P0007R1 as_const()
// P0013R1 Logical Operator Type Traits (conjunction, etc.)
// P0033R1 Rewording enable_shared_from_this
// P0063R3 C11 Standard Library
// P0074R0 owner_less<>
// P0092R1 <chrono> floor(), ceil(), round(), abs()
// P0414R2 shared_ptr<T[]>, shared_ptr<T[N]>
// P0418R2 atomic compare_exchange memory_order Requirements
// P0435R1 Overhauling common_type
// P0497R0 Fixing shared_ptr For Arrays
// P0513R0 Poisoning hash
// P0516R0 Marking shared_future Copying As noexcept
// P0517R0 Constructing future_error From future_errc
// P0548R1 Tweaking common_type And duration
// P0558R1 Resolving atomic<T> Named Base Class Inconsistencies
// P0599R1 noexcept hash
// P0777R1 Avoiding Unnecessary decay
// P0941R2 Feature-Test Macros

// Parallel Algorithms Notes
// C++ allows an implementation to implement parallel algorithms as calls to the
// serial algorithms. This implementation parallelizes several common algorithm
// calls, but not all.
//
// The following algorithms are parallelized.
// * adjacent_difference
// * adjacent_find
// * all_of
// * any_of
// * count
// * count_if
// * equal
// * exclusive_scan
// * find
// * find_end
// * find_first_of
// * find_if
// * for_each
// * for_each_n
// * inclusive_scan
// * mismatch
// * none_of
// * reduce
// * remove
// * remove_if
// * search
// * search_n
// * sort
// * stable_sort
// * transform
// * transform_exclusive_scan
// * transform_inclusive_scan
// * transform_reduce
//
// The following are not presently parallelized:
//
// No apparent parallelism performance improvement on target hardware; all
// algorithms which merely copy or permute elements with no branches are
// typically memory bandwidth limited.
// * copy
// * copy_backward
// * copy_n
// * fill
// * fill_n
// * move
// * move_backward
// * remove
// * remove_if
// * replace
// * replace_if
// * reverse
// * reverse_copy
// * rotate
// * rotate_copy
// * swap_ranges
//
// Confusion over user parallelism requirements exists; likely in the above
// category anyway.
// * generate
// * generate_n
//
// Effective parallelism suspected to be infeasible.
// * partial_sort
// * partial_sort_copy
//
// Not yet evaluated; parallelism may be implemented in a future release and is
// suspected to be beneficial.
// * copy_if
// * includes
// * inplace_merge
// * is_heap
// * is_heap_until
// * is_partitioned
// * is_sorted
// * is_sorted_until
// * lexicographical_compare
// * max_element
// * merge
// * min_element
// * minmax_element
// * nth_element
// * partition_copy
// * remove_copy
// * remove_copy_if
// * replace_copy
// * replace_copy_if
// * set_difference
// * set_intersection
// * set_symmetric_difference
// * set_union
// * stable_partition
// * unique
// * unique_copy


 
  


   
  
 









/* xkeycheck.h internal header */
#pragma once






 


















































































  

























































































 






/*
 * Copyright (c) by P.J. Plauger. All rights reserved.
 * Consult your license regarding permissions and restrictions.
V6.50:0009 */


//
// crtdefs.h
//
//      Copyright (c) Microsoft Corporation. All rights reserved.
//
// Declarations used across the Visual C++ Libraries.  The lack of #pragma once
// is deliberate.
//

//
// vcruntime.h
//
//      Copyright (c) Microsoft Corporation. All rights reserved.
//
// Declarations used throughout the VCRuntime library.
//
#pragma once
//
// Note on use of "deprecate":
//
// Various places in this header and other headers use
// __declspec(deprecate) or macros that have the term DEPRECATE in them.
// We use "deprecate" here ONLY to signal the compiler to emit a warning
// about these items. The use of "deprecate" should NOT be taken to imply
// that any standard committee has deprecated these functions from the
// relevant standards.  In fact, these functions are NOT deprecated from
// the standard.
//
// Full details can be found in our documentation by searching for
// "Security Enhancements in the CRT".
//




    


// The _CRTIMP macro is not used in the VCRuntime or the CoreCRT anymore, but
// there is a lot of existing code that declares CRT functions using this macro,
// and if we remove its definition, we break that existing code.  It is thus
// defined here only for compatibility.

    
    


        
            
        


    



/***
*sal.h - markers for documenting the semantics of APIs
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       sal.h provides a set of annotations to describe how a function uses its
*       parameters - the assumptions it makes about them, and the guarantees it makes
*       upon finishing.
*
*       [Public]
*
****/
#pragma once

/*==========================================================================

   The comments in this file are intended to give basic understanding of
   the usage of SAL, the Microsoft Source Code Annotation Language.
   For more details, please see https://go.microsoft.com/fwlink/?LinkID=242134

   The macros are defined in 3 layers, plus the structural set:

   _In_/_Out_/_Ret_ Layer:
   ----------------------
   This layer provides the highest abstraction and its macros should be used
   in most cases. These macros typically start with:
      _In_     : input parameter to a function, unmodified by called function
      _Out_    : output parameter, written to by called function, pointed-to
                 location not expected to be initialized prior to call
      _Outptr_ : like _Out_ when returned variable is a pointer type
                 (so param is pointer-to-pointer type). Called function
                 provides/allocated space.
      _Outref_ : like _Outptr_, except param is reference-to-pointer type.
      _Inout_  : inout parameter, read from and potentially modified by
                 called function.
      _Ret_    : for return values
      _Field_  : class/struct field invariants
   For common usage, this class of SAL provides the most concise annotations.
   Note that _In_/_Out_/_Inout_/_Outptr_ annotations are designed to be used
   with a parameter target. Using them with _At_ to specify non-parameter
   targets may yield unexpected results.

   This layer also includes a number of other properties that can be specified
   to extend the ability of code analysis, most notably:
      -- Designating parameters as format strings for printf/scanf/scanf_s
      -- Requesting stricter type checking for C enum parameters

   _Pre_/_Post_ Layer:
   ------------------
   The macros of this layer only should be used when there is no suitable macro
   in the _In_/_Out_ layer. Its macros start with _Pre_ or _Post_.
   This layer provides the most flexibility for annotations.

   Implementation Abstraction Layer:
   --------------------------------
   Macros from this layer should never be used directly. The layer only exists
   to hide the implementation of the annotation macros.

   Structural Layer:
   ----------------
   These annotations, like _At_ and _When_, are used with annotations from
   any of the other layers as modifiers, indicating exactly when and where
   the annotations apply.


   Common syntactic conventions:
   ----------------------------

   Usage:
   -----
   _In_, _Out_, _Inout_, _Pre_, _Post_, are for formal parameters.
   _Ret_, _Deref_ret_ must be used for return values.

   Nullness:
   --------
   If the parameter can be NULL as a precondition to the function, the
   annotation contains _opt. If the macro does not contain '_opt' the
   parameter cannot be NULL.

   If an out/inout parameter returns a null pointer as a postcondition, this is
   indicated by _Ret_maybenull_ or _result_maybenull_. If the macro is not
   of this form, then the result will not be NULL as a postcondition.
     _Outptr_ - output value is not NULL
     _Outptr_result_maybenull_ - output value might be NULL

   String Type:
   -----------
   _z: NullTerminated string
   for _In_ parameters the buffer must have the specified stringtype before the call
   for _Out_ parameters the buffer must have the specified stringtype after the call
   for _Inout_ parameters both conditions apply

   Extent Syntax:
   -------------
   Buffer sizes are expressed as element counts, unless the macro explicitly
   contains _byte_ or _bytes_. Some annotations specify two buffer sizes, in
   which case the second is used to indicate how much of the buffer is valid
   as a postcondition. This table outlines the precondition buffer allocation
   size, precondition number of valid elements, postcondition allocation size,
   and postcondition number of valid elements for representative buffer size
   annotations:
                                     Pre    |  Pre    |  Post   |  Post
                                     alloc  |  valid  |  alloc  |  valid
      Annotation                     elems  |  elems  |  elems  |  elems
      ----------                     ------------------------------------
      _In_reads_(s)                    s    |   s     |   s     |   s
      _Inout_updates_(s)               s    |   s     |   s     |   s
      _Inout_updates_to_(s,c)          s    |   s     |   s     |   c
      _Out_writes_(s)                  s    |   0     |   s     |   s
      _Out_writes_to_(s,c)             s    |   0     |   s     |   c
      _Outptr_result_buffer_(s)        ?    |   ?     |   s     |   s
      _Outptr_result_buffer_to_(s,c)   ?    |   ?     |   s     |   c

   For the _Outptr_ annotations, the buffer in question is at one level of
   dereference. The called function is responsible for supplying the buffer.

   Success and failure:
   -------------------
   The SAL concept of success allows functions to define expressions that can
   be tested by the caller, which if it evaluates to non-zero, indicates the
   function succeeded, which means that its postconditions are guaranteed to
   hold.  Otherwise, if the expression evaluates to zero, the function is
   considered to have failed, and the postconditions are not guaranteed.

   The success criteria can be specified with the _Success_(expr) annotation:
     _Success_(return != FALSE) BOOL
     PathCanonicalizeA(_Out_writes_(MAX_PATH) LPSTR pszBuf, LPCSTR pszPath) :
        pszBuf is only guaranteed to be NULL-terminated when TRUE is returned,
        and FALSE indiates failure. In common practice, callers check for zero
        vs. non-zero returns, so it is preferable to express the success
        criteria in terms of zero/non-zero, not checked for exactly TRUE.

   Functions can specify that some postconditions will still hold, even when
   the function fails, using _On_failure_(anno-list), or postconditions that
   hold regardless of success or failure using _Always_(anno-list).

   The annotation _Return_type_success_(expr) may be used with a typedef to
   give a default _Success_ criteria to all functions returning that type.
   This is the case for common Windows API status types, including
   HRESULT and NTSTATUS.  This may be overridden on a per-function basis by
   specifying a _Success_ annotation locally.

============================================================================*/



































// Disable expansion of SAL macros in non-Prefast mode to
// improve compiler throughput.









// safeguard for MIDL and RC builds

































// Some annotations aren't officially SAL2 yet.





//============================================================================
//   Structural SAL:
//     These annotations modify the use of other annotations.  They may
//     express the annotation target (i.e. what parameter/field the annotation
//     applies to) or the condition under which the annotation is applicable.
//============================================================================

// _At_(target, annos) specifies that the annotations listed in 'annos' is to
// be applied to 'target' rather than to the identifier which is the current
// lexical target.


// _At_buffer_(target, iter, bound, annos) is similar to _At_, except that
// target names a buffer, and each annotation in annos is applied to each
// element of target up to bound, with the variable named in iter usable
// by the annotations to refer to relevant offsets within target.


// _When_(expr, annos) specifies that the annotations listed in 'annos' only
// apply when 'expr' evaluates to non-zero.




// <expr> indicates whether normal post conditions apply to a function


// <expr> indicates whether post conditions apply to a function returning
// the type that this annotation is applied to


// Establish postconditions that apply only if the function does not succeed


// Establish postconditions that apply in both success and failure cases.
// Only applicable with functions that have  _Success_ or _Return_type_succss_.


// Usable on a function defintion. Asserts that a function declaration is
// in scope, and its annotations are to be used. There are no other annotations
// allowed on the function definition.


// _Notref_ may precede a _Deref_ or "real" annotation, and removes one
// level of dereference if the parameter is a C++ reference (&).  If the
// net deref on a "real" annotation is negative, it is simply discarded.


// Annotations for defensive programming styles.







//============================================================================
//   _In_/_Out_ Layer:
//============================================================================

// Reserved pointer parameters, must always be NULL.


// _Const_ allows specification that any namable memory location is considered
// readonly for a given call.



// Input parameters --------------------------

//   _In_ - Annotations for parameters where data is passed into the function, but not modified.
//          _In_ by itself can be used with non-pointer types (although it is redundant).

// e.g. void SetPoint( _In_ const POINT* pPT );



// nullterminated 'in' parameters.
// e.g. void CopyStr( _In_z_ const char* szFrom, _Out_z_cap_(cchTo) char* szTo, size_t cchTo );




// 'input' buffers with given size











// 'input' buffers valid to the given end pointer








// Output parameters --------------------------

//   _Out_ - Annotations for pointer or reference parameters where data passed back to the caller.
//           These are mostly used where the pointer/reference is to a non-pointer type.
//           _Outptr_/_Outref) (see below) are typically used to return pointers via parameters.

// e.g. void GetPoint( _Out_ POINT* pPT );


























// Inout parameters ----------------------------

//   _Inout_ - Annotations for pointer or reference parameters where data is passed in and
//        potentially modified.
//          void ModifyPoint( _Inout_ POINT* pPT );
//          void ModifyPointByRef( _Inout_ POINT& pPT );




// For modifying string buffers
//   void toupper( _Inout_z_ char* sz );



// For modifying buffers with explicit element size











// For modifying buffers with explicit byte size










// Pointer to pointer parameters -------------------------

//   _Outptr_ - Annotations for output params returning pointers
//      These describe parameters where the called function provides the buffer:
//        HRESULT SHStrDupW(_In_ LPCWSTR psz, _Outptr_ LPWSTR *ppwsz);
//      The caller passes the address of an LPWSTR variable as ppwsz, and SHStrDupW allocates
//      and initializes memory and returns the pointer to the new LPWSTR in *ppwsz.
//
//    _Outptr_opt_ - describes parameters that are allowed to be NULL.
//    _Outptr_*_result_maybenull_ - describes parameters where the called function might return NULL to the caller.
//
//    Example:
//       void MyFunc(_Outptr_opt_ int **ppData1, _Outptr_result_maybenull_ int **ppData2);
//    Callers:
//       MyFunc(NULL, NULL);           // error: parameter 2, ppData2, should not be NULL
//       MyFunc(&pData1, &pData2);     // ok: both non-NULL
//       if (*pData1 == *pData2) ...   // error: pData2 might be NULL after call






// Annotations for _Outptr_ parameters returning pointers to null terminated strings.






// Annotations for _Outptr_ parameters where the output pointer is set to NULL if the function fails.




// Annotations for _Outptr_ parameters which return a pointer to a ref-counted COM object,
// following the COM convention of setting the output to NULL on failure.
// The current implementation is identical to _Outptr_result_nullonfailure_.
// For pointers to types that are not COM objects, _Outptr_result_nullonfailure_ is preferred.






// Annotations for _Outptr_ parameters returning a pointer to buffer with a specified number of elements/bytes

































// Annotations for output reference to pointer parameters.


















// Annotations for output reference to pointer parameters that guarantee
// that the pointer is set to NULL on failure.


// Generic annotations to set output value of a by-pointer or by-reference parameter to null/zero on failure.




// return values -------------------------------

//
// _Ret_ annotations
//
// describing conditions that hold for return values after the call

// e.g. _Ret_z_ CString::operator const wchar_t*() const noexcept;



// used with allocated but not yet initialized objects




// used with allocated and initialized objects
//    returns single valid object


//    returns pointer to initialized buffer of specified size







//    returns pointer to partially initialized buffer, with total size 'size' and initialized size 'count'






// Annotations for strict type checking




// Check the return value of a function e.g. _Check_return_ ErrorCode Foo();



// e.g. MyPrintF( _Printf_format_string_ const wchar_t* wzFormat, ... );









// annotations to express value of integral or pointer parameter









// annotation to express that a value (usually a field of a mutable class)
// is not changed by a function call


// Annotations to allow expressing generalized pre and post conditions.
// 'cond' may be any valid SAL expression that is considered to be true as a precondition
// or postcondition (respsectively).



// Annotations to express struct, class and field invariants




















//============================================================================
//   _Pre_/_Post_ Layer:
//============================================================================

//
// Raw Pre/Post for declaring custom pre/post conditions
//




//
// Validity property
//





//
// Buffer size properties
//

// Expressing buffer sizes without specifying pre or post condition








// Expressing buffer size as pre or post condition










//
// Pointer null-ness properties
//




//
// _Pre_ annotations ---
//
// describing conditions that must be met before the call of the function

// e.g. int strlen( _Pre_z_ const char* sz );
// buffer is a zero terminated string


// valid size unknown or indicated by type (e.g.:LPSTR)





// Overrides recursive valid when some field is not yet initialized when using _Inout_


// used with allocated but not yet initialized objects




//
// _Post_ annotations ---
//
// describing conditions that hold after the function call

// void CopyStr( _In_z_ const char* szFrom, _Pre_cap_(cch) _Post_z_ char* szFrom, size_t cchFrom );
// buffer will be a zero-terminated string after the call


// e.g. HRESULT InitStruct( _Post_valid_ Struct* pobj );



// e.g. void free( _Post_ptr_invalid_ void* pv );


// e.g. void ThrowExceptionIfNull( _Post_notnull_ const void* pv );


// e.g. HRESULT GetObject(_Outptr_ _On_failure_(_At_(*p, _Post_null_)) T **p);







#pragma region Input Buffer SAL 1 compatibility macros

/*==========================================================================

   This section contains definitions for macros defined for VS2010 and earlier.
   Usage of these macros is still supported, but the SAL 2 macros defined above
   are recommended instead.  This comment block is retained to assist in
   understanding SAL that still uses the older syntax.

   The macros are defined in 3 layers:

   _In_/_Out_ Layer:
   ----------------
   This layer provides the highest abstraction and its macros should be used
   in most cases. Its macros start with _In_, _Out_ or _Inout_. For the
   typical case they provide the most concise annotations.

   _Pre_/_Post_ Layer:
   ------------------
   The macros of this layer only should be used when there is no suitable macro
   in the _In_/_Out_ layer. Its macros start with _Pre_, _Post_, _Ret_,
   _Deref_pre_ _Deref_post_ and _Deref_ret_. This layer provides the most
   flexibility for annotations.

   Implementation Abstraction Layer:
   --------------------------------
   Macros from this layer should never be used directly. The layer only exists
   to hide the implementation of the annotation macros.


   Annotation Syntax:
   |--------------|----------|----------------|-----------------------------|
   |   Usage      | Nullness | ZeroTerminated |  Extent                     |
   |--------------|----------|----------------|-----------------------------|
   | _In_         | <>       | <>             | <>                          |
   | _Out_        | opt_     | z_             | [byte]cap_[c_|x_]( size )   |
   | _Inout_      |          |                | [byte]count_[c_|x_]( size ) |
   | _Deref_out_  |          |                | ptrdiff_cap_( ptr )         |
   |--------------|          |                | ptrdiff_count_( ptr )       |
   | _Ret_        |          |                |                             |
   | _Deref_ret_  |          |                |                             |
   |--------------|          |                |                             |
   | _Pre_        |          |                |                             |
   | _Post_       |          |                |                             |
   | _Deref_pre_  |          |                |                             |
   | _Deref_post_ |          |                |                             |
   |--------------|----------|----------------|-----------------------------|

   Usage:
   -----
   _In_, _Out_, _Inout_, _Pre_, _Post_, _Deref_pre_, _Deref_post_ are for
   formal parameters.
   _Ret_, _Deref_ret_ must be used for return values.

   Nullness:
   --------
   If the pointer can be NULL the annotation contains _opt. If the macro
   does not contain '_opt' the pointer may not be NULL.

   String Type:
   -----------
   _z: NullTerminated string
   for _In_ parameters the buffer must have the specified stringtype before the call
   for _Out_ parameters the buffer must have the specified stringtype after the call
   for _Inout_ parameters both conditions apply

   Extent Syntax:
   |------|---------------|---------------|
   | Unit | Writ/Readable | Argument Type |
   |------|---------------|---------------|
   |  <>  | cap_          | <>            |
   | byte | count_        | c_            |
   |      |               | x_            |
   |------|---------------|---------------|

   'cap' (capacity) describes the writable size of the buffer and is typically used
   with _Out_. The default unit is elements. Use 'bytecap' if the size is given in bytes
   'count' describes the readable size of the buffer and is typically used with _In_.
   The default unit is elements. Use 'bytecount' if the size is given in bytes.

   Argument syntax for cap_, bytecap_, count_, bytecount_:
   (<parameter>|return)[+n]  e.g. cch, return, cb+2

   If the buffer size is a constant expression use the c_ postfix.
   E.g. cap_c_(20), count_c_(MAX_PATH), bytecount_c_(16)

   If the buffer size is given by a limiting pointer use the ptrdiff_ versions
   of the macros.

   If the buffer size is neither a parameter nor a constant expression use the x_
   postfix. e.g. bytecount_x_(num*size) x_ annotations accept any arbitrary string.
   No analysis can be done for x_ annotations but they at least tell the tool that
   the buffer has some sort of extent description. x_ annotations might be supported
   by future compiler versions.

============================================================================*/

// e.g. void SetCharRange( _In_count_(cch) const char* rgch, size_t cch )
// valid buffer extent described by another parameter





// valid buffer extent described by a constant extression





// nullterminated  'input' buffers with given size

// e.g. void SetCharRange( _In_count_(cch) const char* rgch, size_t cch )
// nullterminated valid buffer extent described by another parameter





// nullterminated valid buffer extent described by a constant extression





// buffer capacity is described by another pointer
// e.g. void Foo( _In_ptrdiff_count_(pchMax) const char* pch, const char* pchMax ) { while pch < pchMax ) pch++; }



// 'x' version for complex expressions that are not supported by the current compiler version
// e.g. void Set3ColMatrix( _In_count_x_(3*cRows) const Elem* matrix, int cRows );






// 'out' with buffer size
// e.g. void GetIndeces( _Out_cap_(cIndeces) int* rgIndeces, size_t cIndices );
// buffer capacity is described by another parameter





// buffer capacity is described by a constant expression





// buffer capacity is described by another parameter multiplied by a constant expression





// buffer capacity is described by another pointer
// e.g. void Foo( _Out_ptrdiff_cap_(pchMax) char* pch, const char* pchMax ) { while pch < pchMax ) pch++; }



// buffer capacity is described by a complex expression





// a zero terminated string is filled into a buffer of given capacity
// e.g. void CopyStr( _In_z_ const char* szFrom, _Out_z_cap_(cchTo) char* szTo, size_t cchTo );
// buffer capacity is described by another parameter





// buffer capacity is described by a constant expression





// buffer capacity is described by a complex expression





// a zero terminated string is filled into a buffer of given capacity
// e.g. size_t CopyCharRange( _In_count_(cchFrom) const char* rgchFrom, size_t cchFrom, _Out_cap_post_count_(cchTo,return)) char* rgchTo, size_t cchTo );





// a zero terminated string is filled into a buffer of given capacity
// e.g. size_t CopyStr( _In_z_ const char* szFrom, _Out_z_cap_post_count_(cchTo,return+1) char* szTo, size_t cchTo );





// only use with dereferenced arguments e.g. '*pcch'










// e.g. GetString( _Out_z_capcount_(*pLen+1) char* sz, size_t* pLen );






// 'inout' buffers with initialized elements before and after the call
// e.g. void ModifyIndices( _Inout_count_(cIndices) int* rgIndeces, size_t cIndices );










// nullterminated 'inout' buffers with initialized elements before and after the call
// e.g. void ModifyIndices( _Inout_count_(cIndices) int* rgIndeces, size_t cIndices );


















// e.g. void AppendToLPSTR( _In_ LPCSTR szFrom, _Inout_cap_(cchTo) LPSTR* szTo, size_t cchTo );















// inout string buffers with writable size
// e.g. void AppendStr( _In_z_ const char* szFrom, _Inout_z_cap_(cchTo) char* szTo, size_t cchTo );
















// returning pointers to valid objects



// annotations to express 'boundedness' of integral value parameter








// e.g.  HRESULT HrCreatePoint( _Deref_out_opt_ POINT** ppPT );





// e.g.  void CloneString( _In_z_ const wchar_t* wzFrom, _Deref_out_z_ wchar_t** pWzTo );





//
// _Deref_pre_ ---
//
// describing conditions for array elements of dereferenced pointer parameters that must be met before the call

// e.g. void SaveStringArray( _In_count_(cStrings) _Deref_pre_z_ const wchar_t* const rgpwch[] );



// e.g. void FillInArrayOfStr32( _In_count_(cStrings) _Deref_pre_cap_c_(32) _Deref_post_z_ wchar_t* const rgpwch[] );
// buffer capacity is described by another parameter





// buffer capacity is described by a constant expression





// buffer capacity is described by a complex condition





// convenience macros for nullterminated buffers with given capacity















// known capacity and valid but unknown readable extent















// e.g. void SaveMatrix( _In_count_(n) _Deref_pre_count_(n) const Elem** matrix, size_t n );
// valid buffer extent is described by another parameter





// valid buffer extent is described by a constant expression





// valid buffer extent is described by a complex expression





// e.g. void PrintStringArray( _In_count_(cElems) _Deref_pre_valid_ LPCSTR rgStr[], size_t cElems );








// restrict access rights



//
// _Deref_post_ ---
//
// describing conditions for array elements or dereferenced pointer parameters that hold after the call

// e.g. void CloneString( _In_z_ const Wchar_t* wzIn _Out_ _Deref_post_z_ wchar_t** pWzOut );



// e.g. HRESULT HrAllocateMemory( size_t cb, _Out_ _Deref_post_bytecap_(cb) void** ppv );
// buffer capacity is described by another parameter





// buffer capacity is described by a constant expression





// buffer capacity is described by a complex expression





// convenience macros for nullterminated buffers with given capacity















// known capacity and valid but unknown readable extent















// e.g. HRESULT HrAllocateZeroInitializedMemory( size_t cb, _Out_ _Deref_post_bytecount_(cb) void** ppv );
// valid buffer extent is described by another parameter





// buffer capacity is described by a constant expression





// buffer capacity is described by a complex expression





// e.g. void GetStrings( _Out_count_(cElems) _Deref_post_valid_ LPSTR const rgStr[], size_t cElems );







//
// _Deref_ret_ ---
//




//
// special _Deref_ ---
//


//
// _Ret_ ---
//

// e.g. _Ret_opt_valid_ LPSTR void* CloneSTR( _Pre_valid_ LPSTR src );



// e.g. _Ret_opt_bytecap_(cb) void* AllocateMemory( size_t cb );
// Buffer capacity is described by another parameter





// Buffer capacity is described by a constant expression





// Buffer capacity is described by a complex condition





// return value is nullterminated and capacity is given by another parameter





// e.g. _Ret_opt_bytecount_(cb) void* AllocateZeroInitializedMemory( size_t cb );
// Valid Buffer extent is described by another parameter





// Valid Buffer extent is described by a constant expression





// Valid Buffer extent is described by a complex expression





// return value is nullterminated and length is given by another parameter






// _Pre_ annotations ---


// restrict access rights



// e.g. void FreeMemory( _Pre_bytecap_(cb) _Post_ptr_invalid_ void* pv, size_t cb );
// buffer capacity described by another parameter





// buffer capacity described by a constant expression







// buffer capacity is described by another parameter multiplied by a constant expression



// buffer capacity described by size of other buffer, only used by dangerous legacy APIs
// e.g. int strcpy(_Pre_cap_for_(src) char* dst, const char* src);



// buffer capacity described by a complex condition





// buffer capacity described by the difference to another pointer parameter



// e.g. void AppendStr( _Pre_z_ const char* szFrom, _Pre_z_cap_(cchTo) _Post_z_ char* szTo, size_t cchTo );















// known capacity and valid but unknown readable extent















// e.g. void AppendCharRange( _Pre_count_(cchFrom) const char* rgFrom, size_t cchFrom, _Out_z_cap_(cchTo) char* szTo, size_t cchTo );
// Valid buffer extent described by another parameter





// Valid buffer extent described by a constant expression





// Valid buffer extent described by a complex expression





// Valid buffer extent described by the difference to another pointer parameter




// char * strncpy(_Out_cap_(_Count) _Post_maybez_ char * _Dest, _In_z_ const char * _Source, _In_ size_t _Count)
// buffer maybe zero-terminated after the call


// e.g. SIZE_T HeapSize( _In_ HANDLE hHeap, DWORD dwFlags, _Pre_notnull_ _Post_bytecap_(return) LPCVOID lpMem );



// e.g. int strlen( _In_z_ _Post_count_(return+1) const char* sz );







// e.g. size_t CopyStr( _In_z_ const char* szFrom, _Pre_cap_(cch) _Post_z_count_(return+1) char* szFrom, size_t cchFrom );







//
// _Prepost_ ---
//
// describing conditions that hold before and after the function call



















//
// _Deref_<both> ---
//
// short version for _Deref_pre_<ann> _Deref_post_<ann>
// describing conditions for array elements or dereferenced pointer parameters that hold before and after the call










































//
// _Deref_<miscellaneous>
//
// used with references to arrays







#pragma endregion Input Buffer SAL 1 compatibility macros


//============================================================================
//   Implementation Layer:
//============================================================================


// Naming conventions:
// A symbol the begins with _SA_ is for the machinery of creating any
// annotations; many of those come from sourceannotations.h in the case
// of attributes.

// A symbol that ends with _impl is the very lowest level macro.  It is
// not required to be a legal standalone annotation, and in the case
// of attribute annotations, usually is not.  (In the case of some declspec
// annotations, it might be, but it should not be assumed so.)  Those
// symols will be used in the _PreN..., _PostN... and _RetN... annotations
// to build up more complete annotations.

// A symbol ending in _impl_ is reserved to the implementation as well,
// but it does form a complete annotation; usually they are used to build
// up even higher level annotations.





















































































































// Using "nothing" for sal



















































































































































































































































































































































































































































































































































// Obsolete -- may be needed for transition to attributes.





// This section contains the deprecated annotations

/*
 -------------------------------------------------------------------------------
 Introduction

 sal.h provides a set of annotations to describe how a function uses its
 parameters - the assumptions it makes about them, and the guarantees it makes
 upon finishing.

 Annotations may be placed before either a function parameter's type or its return
 type, and describe the function's behavior regarding the parameter or return value.
 There are two classes of annotations: buffer annotations and advanced annotations.
 Buffer annotations describe how functions use their pointer parameters, and
 advanced annotations either describe complex/unusual buffer behavior, or provide
 additional information about a parameter that is not otherwise expressible.

 -------------------------------------------------------------------------------
 Buffer Annotations

 The most important annotations in sal.h provide a consistent way to annotate
 buffer parameters or return values for a function. Each of these annotations describes
 a single buffer (which could be a string, a fixed-length or variable-length array,
 or just a pointer) that the function interacts with: where it is, how large it is,
 how much is initialized, and what the function does with it.

 The appropriate macro for a given buffer can be constructed using the table below.
 Just pick the appropriate values from each category, and combine them together
 with a leading underscore. Some combinations of values do not make sense as buffer
 annotations. Only meaningful annotations can be added to your code; for a list of
 these, see the buffer annotation definitions section.

 Only a single buffer annotation should be used for each parameter.

 |------------|------------|---------|--------|----------|----------|---------------|
 |   Level    |   Usage    |  Size   | Output | NullTerm | Optional |  Parameters   |
 |------------|------------|---------|--------|----------|----------|---------------|
 | <>         | <>         | <>      | <>     | _z       | <>       | <>            |
 | _deref     | _in        | _ecount | _full  | _nz      | _opt     | (size)        |
 | _deref_opt | _out       | _bcount | _part  |          |          | (size,length) |
 |            | _inout     |         |        |          |          |               |
 |            |            |         |        |          |          |               |
 |------------|------------|---------|--------|----------|----------|---------------|

 Level: Describes the buffer pointer's level of indirection from the parameter or
          return value 'p'.

 <>         : p is the buffer pointer.
 _deref     : *p is the buffer pointer. p must not be NULL.
 _deref_opt : *p may be the buffer pointer. p may be NULL, in which case the rest of
                the annotation is ignored.

 Usage: Describes how the function uses the buffer.

 <>     : The buffer is not accessed. If used on the return value or with _deref, the
            function will provide the buffer, and it will be uninitialized at exit.
            Otherwise, the caller must provide the buffer. This should only be used
            for alloc and free functions.
 _in    : The function will only read from the buffer. The caller must provide the
            buffer and initialize it. Cannot be used with _deref.
 _out   : The function will only write to the buffer. If used on the return value or
            with _deref, the function will provide the buffer and initialize it.
            Otherwise, the caller must provide the buffer, and the function will
            initialize it.
 _inout : The function may freely read from and write to the buffer. The caller must
            provide the buffer and initialize it. If used with _deref, the buffer may
            be reallocated by the function.

 Size: Describes the total size of the buffer. This may be less than the space actually
         allocated for the buffer, in which case it describes the accessible amount.

 <>      : No buffer size is given. If the type specifies the buffer size (such as
             with LPSTR and LPWSTR), that amount is used. Otherwise, the buffer is one
             element long. Must be used with _in, _out, or _inout.
 _ecount : The buffer size is an explicit element count.
 _bcount : The buffer size is an explicit byte count.

 Output: Describes how much of the buffer will be initialized by the function. For
           _inout buffers, this also describes how much is initialized at entry. Omit this
           category for _in buffers; they must be fully initialized by the caller.

 <>    : The type specifies how much is initialized. For instance, a function initializing
           an LPWSTR must NULL-terminate the string.
 _full : The function initializes the entire buffer.
 _part : The function initializes part of the buffer, and explicitly indicates how much.

 NullTerm: States if the present of a '\0' marks the end of valid elements in the buffer.
 _z    : A '\0' indicated the end of the buffer
 _nz     : The buffer may not be null terminated and a '\0' does not indicate the end of the
          buffer.
 Optional: Describes if the buffer itself is optional.

 <>   : The pointer to the buffer must not be NULL.
 _opt : The pointer to the buffer might be NULL. It will be checked before being dereferenced.

 Parameters: Gives explicit counts for the size and length of the buffer.

 <>            : There is no explicit count. Use when neither _ecount nor _bcount is used.
 (size)        : Only the buffer's total size is given. Use with _ecount or _bcount but not _part.
 (size,length) : The buffer's total size and initialized length are given. Use with _ecount_part
                   and _bcount_part.

 -------------------------------------------------------------------------------
 Buffer Annotation Examples

 LWSTDAPI_(BOOL) StrToIntExA(
     __in LPCSTR pszString,
     DWORD dwFlags,
     __out int *piRet                     -- A pointer whose dereference will be filled in.
 );

 void MyPaintingFunction(
     __in HWND hwndControl,               -- An initialized read-only parameter.
     __in_opt HDC hdcOptional,            -- An initialized read-only parameter that might be NULL.
     __inout IPropertyStore *ppsStore     -- An initialized parameter that may be freely used
                                          --   and modified.
 );

 LWSTDAPI_(BOOL) PathCompactPathExA(
     __out_ecount(cchMax) LPSTR pszOut,   -- A string buffer with cch elements that will
                                          --   be NULL terminated on exit.
     __in LPCSTR pszSrc,
     UINT cchMax,
     DWORD dwFlags
 );

 HRESULT SHLocalAllocBytes(
     size_t cb,
     __deref_bcount(cb) T **ppv           -- A pointer whose dereference will be set to an
                                          --   uninitialized buffer with cb bytes.
 );

 __inout_bcount_full(cb) : A buffer with cb elements that is fully initialized at
     entry and exit, and may be written to by this function.

 __out_ecount_part(count, *countOut) : A buffer with count elements that will be
     partially initialized by this function. The function indicates how much it
     initialized by setting *countOut.

 -------------------------------------------------------------------------------
 Advanced Annotations

 Advanced annotations describe behavior that is not expressible with the regular
 buffer macros. These may be used either to annotate buffer parameters that involve
 complex or conditional behavior, or to enrich existing annotations with additional
 information.

 __success(expr) f :
     <expr> indicates whether function f succeeded or not. If <expr> is true at exit,
     all the function's guarantees (as given by other annotations) must hold. If <expr>
     is false at exit, the caller should not expect any of the function's guarantees
     to hold. If not used, the function must always satisfy its guarantees. Added
     automatically to functions that indicate success in standard ways, such as by
     returning an HRESULT.

 __nullterminated p :
     Pointer p is a buffer that may be read or written up to and including the first
     NULL character or pointer. May be used on typedefs, which marks valid (properly
     initialized) instances of that type as being NULL-terminated.

 __nullnullterminated p :
     Pointer p is a buffer that may be read or written up to and including the first
     sequence of two NULL characters or pointers. May be used on typedefs, which marks
     valid instances of that type as being double-NULL terminated.

 __reserved v :
     Value v must be 0/NULL, reserved for future use.

 __checkReturn v :
     Return value v must not be ignored by callers of this function.

 __typefix(ctype) v :
     Value v should be treated as an instance of ctype, rather than its declared type.

 __override f :
     Specify C#-style 'override' behaviour for overriding virtual methods.

 __callback f :
     Function f can be used as a function pointer.

 __format_string p :
     Pointer p is a string that contains % markers in the style of printf.

 __blocksOn(resource) f :
     Function f blocks on the resource 'resource'.

 __fallthrough :
     Annotates switch statement labels where fall-through is desired, to distinguish
     from forgotten break statements.

 -------------------------------------------------------------------------------
 Advanced Annotation Examples

 __success(return != FALSE) LWSTDAPI_(BOOL)
 PathCanonicalizeA(__out_ecount(MAX_PATH) LPSTR pszBuf, LPCSTR pszPath) :
    pszBuf is only guaranteed to be NULL-terminated when TRUE is returned.

 typedef __nullterminated WCHAR* LPWSTR : Initialized LPWSTRs are NULL-terminated strings.

 __out_ecount(cch) __typefix(LPWSTR) void *psz : psz is a buffer parameter which will be
     a NULL-terminated WCHAR string at exit, and which initially contains cch WCHARs.

 -------------------------------------------------------------------------------
*/







extern "C" {







/*
 -------------------------------------------------------------------------------
 Helper Macro Definitions

 These express behavior common to many of the high-level annotations.
 DO NOT USE THESE IN YOUR CODE.
 -------------------------------------------------------------------------------
*/

/*
    The helper annotations are only understood by the compiler version used by
    various defect detection tools. When the regular compiler is running, they
    are defined into nothing, and do not affect the compiled code.
*/




















































































































































































































    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    

    
    
    
    

    
    



/*
-------------------------------------------------------------------------------
Buffer Annotation Definitions

Any of these may be used to directly annotate functions, but only one should
be used for each parameter. To determine which annotation to use for a given
buffer, use the table in the buffer annotations section.
-------------------------------------------------------------------------------
*/
































































































































































































/*
-------------------------------------------------------------------------------
Advanced Annotation Definitions

Any of these may be used to directly annotate functions, and may be used in
combination with each other or with regular buffer macros. For an explanation
of each annotation, see the advanced annotations section.
-------------------------------------------------------------------------------
*/



































    
    






























//
// Set the analysis mode (global flags to analysis).
// They take effect at the point of declaration; use at global scope
// as a declaration.
//

// Synthesize a unique symbol.








//
// Floating point warnings are only meaningful in kernel-mode on x86
// so avoid reporting them on other platforms.
//















// The following are predefined:
//  _Analysis_operator_new_throw_   (operator new throws)
//  _Analysis_operator_new_null_        (operator new returns null)
//  _Analysis_operator_new_never_fails_ (operator new never fails)
//

// Function class annotations.














}



/***
*concurrencysal.h - markers for documenting the concurrent semantics of APIs
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file contains macros for Concurrency SAL annotations. Definitions
*       starting with _Internal are low level macros that are subject to change.
*       Users should not use those low level macros directly.
*       [ANSI]
*
*       [Public]
*
****/




#pragma once


extern "C" {



































































































































































































































































































/*
 * Old spelling: will be deprecated
 */





































}







//
// vadefs.h
//
//      Copyright (c) Microsoft Corporation. All rights reserved.
//
// Definitions of macro helpers used by <stdarg.h>.  This is the topmost header
// in the CRT header lattice, and is always the first CRT header to be included,
// explicitly or implicitly.  Therefore, this header also has several definitions
// that are used throughout the CRT.
//
#pragma once



#pragma pack(push, 8)


extern "C" {







    
    
        typedef unsigned __int64  uintptr_t;
    





    
    


        typedef char* va_list;
    



    













    
    




















































    void __cdecl __va_start(va_list* , ...);

    
    



    




} // extern "C"



    extern "C++"
    {
        template <typename _Ty>
        struct __vcrt_va_list_is_reference
        {
            enum : bool { __the_value = false };
        };

        template <typename _Ty>
        struct __vcrt_va_list_is_reference<_Ty&>
        {
            enum : bool { __the_value = true };
        };

        template <typename _Ty>
        struct __vcrt_va_list_is_reference<_Ty&&>
        {
            enum : bool { __the_value = true };
        };

        template <typename _Ty>
        struct __vcrt_assert_va_start_is_not_reference
        {
            static_assert(!__vcrt_va_list_is_reference<_Ty>::__the_value,
                "va_start argument must not have reference type and must not be parenthesized");
        };
    } // extern "C++"

    







#pragma pack(pop)


// All C headers have a common prologue and epilogue, to enclose the header in
// an extern "C" declaration when the header is #included in a C++ translation
// unit and to push/pop the packing.


    



    























__pragma(pack(push, 8)) extern "C" {




    


        
    

















    




        
    



    


        
    


// Definitions of calling conventions used code sometimes compiled as managed




    
    





    




// Definitions of common __declspecs




    







    





    



    
        
        
    




// For backwards compatibility


// Definitions of common types

    typedef unsigned __int64 size_t;
    typedef __int64          ptrdiff_t;
    typedef __int64          intptr_t;







    typedef bool  __vcrt_bool;








// Indicate that these common types are defined

    



    



    


// Provide a typedef for wchar_t for use under /Zc:wchar_t-






    
        
    





    





    extern "C++"
    {
        template <typename _CountofType, size_t _SizeOfArray>
        char (*__countof_helper(__unaligned _CountofType (&_Array)[_SizeOfArray]))[_SizeOfArray];

        
    }




// See note on use of "deprecate" at the top of this file







    


        




    







    
        
    






    void __cdecl __security_init_cookie(void);

    



        void __cdecl __security_check_cookie(  uintptr_t _StackCookie);
        __declspec(noreturn) void __cdecl __report_gsfailure(  uintptr_t _StackCookie);
    


extern uintptr_t __security_cookie;


    
    
    


} __pragma(pack(pop))




//
// corecrt.h
//
//      Copyright (c) Microsoft Corporation. All rights reserved.
//
// Declarations used throughout the CoreCRT library.
//
#pragma once



__pragma(pack(push, 8)) extern "C" {



//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// Annotation Macros
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

    


        
    




// If you need the ability to remove __declspec(import) from an API, to support static replacement,
// declare the API using _ACRTIMP_ALT instead of _ACRTIMP.

    



    


        
    







    



    









    


// __declspec(guard(overflow)) enabled by /sdl compiler switch for CRT allocators

    







    


// The CLR requires code calling other SecurityCritical code or using SecurityCritical types
// to be marked as SecurityCritical.
// _CRT_SECURITYCRITICAL_ATTRIBUTE covers this for internal function definitions.
// _CRT_INLINE_PURE_SECURITYCRITICAL_ATTRIBUTE is for inline pure functions defined in the header.
// This is clr:pure-only because for mixed mode we compile inline functions as native.



    














    


        
    





    





    





    




//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// Miscellaneous Stuff
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

extern "C++"
{
    template<bool _Enable, typename _Ty>
    struct _CrtEnableIf;

    template<typename _Ty>
    struct _CrtEnableIf<true, _Ty>
    {
        typedef _Ty _Type;
    };
}



    typedef bool  __crt_bool;

















    










// CRT headers are included into some kinds of source files where only data type
// definitions and macro definitions are required but function declarations and
// inline function definitions are not.  These files include assembly files, IDL
// files, and resource files.  The tools that process these files often have a
// limited ability to process C and C++ code.  The _CRT_FUNCTIONS_REQUIRED macro
// is defined to 1 when we are compiling a file that actually needs functions to
// be declared (and defined, where applicable), and to 0 when we are compiling a
// file that does not.  This allows us to suppress declarations and definitions
// that are not compilable with the aforementioned tools.

    


        
    







    



 
  


   
  
 








//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// Windows API Partitioning and ARM Desktop Support
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

    











        
    



    



    
        
    




// Verify that the ARM Desktop SDK is available when building an ARM Desktop app








//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// Invalid Parameter Handler
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

    __declspec(dllimport) void __cdecl _invalid_parameter(
          wchar_t const*,
          wchar_t const*,
          wchar_t const*,
                unsigned int,
                uintptr_t
        );


__declspec(dllimport) void __cdecl _invalid_parameter_noinfo(void);
__declspec(dllimport) __declspec(noreturn) void __cdecl _invalid_parameter_noinfo_noreturn(void);

__declspec(noreturn)
__declspec(dllimport) void __cdecl _invoke_watson(
      wchar_t const* _Expression,
      wchar_t const* _FunctionName,
      wchar_t const* _FileName,
            unsigned int _LineNo,
            uintptr_t _Reserved);


    
        

    


















//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// Deprecation and Warnings
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+














    


        


    




//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// Managed CRT Support
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

    






        
    



    


        
    








//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// SecureCRT Configuration
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+



























    







    





    


        


            
        
    













    


        



    



    
        
    





    
        // _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_COUNT is ignored if
        // _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES is set to 0
        
    





    
        
              
        


    





    
        
    





    
        
    







    




//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// Basic Types
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
typedef int                           errno_t;
typedef unsigned short                wint_t;
typedef unsigned short                wctype_t;
typedef long                          __time32_t;
typedef __int64                       __time64_t;

typedef struct __crt_locale_data_public
{
      unsigned short const* _locale_pctype;
      int _locale_mb_cur_max;
               unsigned int _locale_lc_codepage;
} __crt_locale_data_public;

typedef struct __crt_locale_pointers
{
    struct __crt_locale_data*    locinfo;
    struct __crt_multibyte_data* mbcinfo;
} __crt_locale_pointers;

typedef __crt_locale_pointers* _locale_t;

typedef struct _Mbstatet
{ // state of a multibyte translation
    unsigned long _Wchar;
    unsigned short _Byte, _State;
} _Mbstatet;

typedef _Mbstatet mbstate_t;










    


        typedef __time64_t time_t;
    


// Indicate that these common types are defined

    



    typedef size_t rsize_t;





//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// C++ Secure Overload Generation Macros
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

    

        










        










        










        










        










        










        










        










        










        















        















        
















    






















































































//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// C++ Standard Overload Generation Macros
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

    







































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































        
        
        
        

        

            


            


            


            


            


            


            


            


            



            



            


            


            


            


            


            


            


            


            


            


            



            



            



            


            



            




            

            




            

            




            

            




            

            




            

            




            

            




            

            




            

        












































    




} __pragma(pack(pop))




//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// CRT DLL Export/Import Macros
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

    


        
    


// functions defined in msvcp140_1 are annotated with _CRTIMP3

    


        
    


// functions defined in msvcp140_2 are annotated with _CRTIMP4

    


        
    



    


        
            
        


    



    




        
    




 


  
 










// warning C4577: 'noexcept' used with no exception handling mode specified;
// termination on exception is not guaranteed. Specify /EHsc

 





 


// warning C4455: literal suffix identifiers that do not start with an underscore are reserved
// warning C4494: Ignoring __declspec(allocator) because the function return
// type is not a pointer or reference
// warning C4619: #pragma warning: there is no warning number 'number'
// warning C4643: Forward declaring 'meow' in namespace std is not permitted by the C++ Standard.
// warning C4702: unreachable code
// error C4984: 'if constexpr' is a C++17 language extension
// warning C4988: variable declared outside class/function scope (/Wall /d1WarnOnGlobals)

 


// warning: constexpr if is a C++17 extension [-Wc++17-extensions]
// warning: user-defined literal suffixes not starting with '_' are reserved [-Wuser-defined-literals]
// warning: unknown pragma ignored [-Wunknown-pragmas]

 





  
 



 


  
 







 






  


 





 
 






 






// C++17 constexpr additions



 


// P0607R0 Inline Variables For The STL



 


// N4190 Removing auto_ptr, random_shuffle(), And Old <functional> Stuff

 


// P0003R5 Removing Dynamic Exception Specifications

 


// P0004R1 Removing Deprecated Iostreams Aliases

 


// P0067R5 Elementary String Conversions

 


// P0226R1 Mathematical Special Functions

 


// P0298R3 std::byte

 


// P0302R1 Removing Allocator Support In std::function
// LWG 2385 function::assign allocator argument doesn't make sense
// LWG 2921 packaged_task and type-erased allocators
// LWG 2976 Dangling uses_allocator specialization for packaged_task

 


// The non-Standard std::tr1 namespace and TR1-only machinery

 



 


  


 


// The non-Standard std::identity struct

 



 


  


 


// The non-Standard std::tr2::sys namespace

 



 


  



 


// Enforcement of matching allocator value_types

 








// [[nodiscard]] attributes on STL functions

 






 
 


// Controls whether the STL uses "if constexpr" internally

 





 


// Controls whether the STL will force /fp:fast to enable vectorization of algorithms defined
// in the standard as special cases; such as reduce, transform_reduce, inclusive_scan, exclusive_scan

 


  
 


// P0174R2 Deprecating Vestigial Library Parts
// P0521R0 Deprecating shared_ptr::unique()
// Other C++17 deprecation warnings

// N4659 D.4 [depr.cpp.headers]






 


// N4659 D.6 [depr.str.strstreams]





 


// N4659 D.7 [depr.uncaught]







 


// N4659 D.8.1 [depr.weak.result_type]
// N4659 D.8.2 [depr.func.adaptor.typedefs]






 


// N4659 D.8.3 [depr.negators]







 


// N4659 D.9 [depr.default.allocator]






 


// N4659 D.9 [depr.default.allocator]







 


// N4659 D.10 [depr.storage.iterator]







 


// N4659 D.11 [depr.temporary.buffer]






 


// N4659 D.12 [depr.meta.types]






 


// N4659 D.12 [depr.meta.types]







 


// N4659 D.13 [depr.iterator.primitives]










 


// N4659 D.14 [depr.util.smartptr.shared.obs]






 


// N4659 D.15 [depr.locale.stdcvt]
// N4659 D.16 [depr.conversions]










 





 










// next warning number: STL4020


 








  
 



 


  
 



 


  
 



// LIBRARY FEATURE-TEST MACROS

// C++14




















// C++17



















































 














// EXPERIMENTAL












 


  
 






		/* NAMESPACE */




/*
We use the stdext (standard extension) namespace to contain extensions that are not part of the current standard
*/





 

 
 










/*
 * Copyright (c) by P.J. Plauger. All rights reserved.
 * Consult your license regarding permissions and restrictions.
V6.50:0009 */


//
// crtdbg.h
//
//      Copyright (c) Microsoft Corporation. All rights reserved.
//
// Public debugging facilities for the CRT
//
#pragma once





//
// vcruntime_new_debug.h
//
//      Copyright (c) Microsoft Corporation. All rights reserved.
//
// Declarations and definitions of the debug operators new and delete.
//
#pragma once


//
// vcruntime_new.h
//
//      Copyright (c) Microsoft Corporation. All rights reserved.
//
// Declarations and definitions of memory management functions in the VCRuntime.
//
#pragma once




extern "C++" {

#pragma pack(push, 8)

#pragma warning(push)
#pragma warning(disable: 4985) 




// C++17 or greater only

























    namespace std
    {
        struct nothrow_t {

            explicit nothrow_t() = default;

        };

        


            extern nothrow_t const nothrow;
        
    }


   
__declspec(allocator) void* __cdecl operator new(
    size_t _Size
    );

     
__declspec(allocator) void* __cdecl operator new(
    size_t _Size,
    std::nothrow_t const&
    ) noexcept;

   
__declspec(allocator) void* __cdecl operator new[](
    size_t _Size
    );

     
__declspec(allocator) void* __cdecl operator new[](
    size_t _Size,
    std::nothrow_t const&
    ) noexcept;

void __cdecl operator delete(
    void* _Block
    ) noexcept;

void __cdecl operator delete(
    void* _Block,
    std::nothrow_t const&
    ) noexcept;

void __cdecl operator delete[](
    void* _Block
    ) noexcept;

void __cdecl operator delete[](
    void* _Block,
    std::nothrow_t const&
    ) noexcept;

void __cdecl operator delete(
    void*  _Block,
    size_t _Size
    ) noexcept;

void __cdecl operator delete[](
    void* _Block,
    size_t _Size
    ) noexcept;
































































#pragma warning(push)
#pragma warning(disable: 4577) 
#pragma warning(disable: 4514) 

    
         
    inline void* __cdecl operator new(size_t _Size,   void* _Where) noexcept
    {
        (void)_Size;
        return _Where;
    }

    inline void __cdecl operator delete(void*, void*) noexcept
    {
        return;
    }



    
         
    inline void* __cdecl operator new[](size_t _Size,
          void* _Where) noexcept
    {
        (void)_Size;
        return _Where;
    }

    inline void __cdecl operator delete[](void*, void*) noexcept
    {
    }

#pragma warning(pop)



#pragma warning(pop)
#pragma pack(pop)

} // extern "C++"




extern "C++" {

#pragma pack(push, 8)






         
    __declspec(allocator) void* __cdecl operator new(
            size_t      _Size,
            int         _BlockUse,
          char const* _FileName,
            int         _LineNumber
        );

         
    __declspec(allocator) void* __cdecl operator new[](
            size_t      _Size,
            int         _BlockUse,
          char const* _FileName,
            int         _LineNumber
        );

    void __cdecl operator delete(
        void*       _Block,
        int         _BlockUse,
        char const* _FileName,
        int         _LineNumber
        ) noexcept;

    void __cdecl operator delete[](
        void*       _Block,
        int         _BlockUse,
        char const* _FileName,
        int         _LineNumber
        ) noexcept;





#pragma pack(pop)

} // extern "C++"



__pragma(pack(push, 8)) extern "C" {



typedef void* _HFILE; // file handle pointer



















//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// Client-defined reporting and allocation hooks
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

typedef int (__cdecl* _CRT_REPORT_HOOK )(int, char*,    int*);
typedef int (__cdecl* _CRT_REPORT_HOOKW)(int, wchar_t*, int*);





typedef int (__cdecl* _CRT_ALLOC_HOOK)(int, void*, size_t, int, long, unsigned char const*, int);











//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// Memory Management and State Tracking
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

// Bit values for _crtDbgFlag flag. These bitflags control debug heap behavior.







// Some bit values for _crtDbgFlag which correspond to frequencies for checking
// the heap.




// We do not check the heap by default at this point because the cost was too
// high for some applications. You can still turn this feature on manually.







// Memory block identification







// _UNKNOWN_BLOCK is a sentinel value that may be passed to some functions that
// expect a block type as an argument.  If this value is passed, those functions
// will use the block type specified in the block header instead.  This is used
// in cases where the heap lock cannot be acquired to compute the block type
// before calling the function (e.g. when the caller is outside of the CoreCRT).


typedef void (__cdecl* _CRT_DUMP_CLIENT)(void*, size_t);





struct _CrtMemBlockHeader;

typedef struct _CrtMemState
{
    struct _CrtMemBlockHeader* pBlockHeader;
    size_t lCounts[5];
    size_t lSizes[5];
    size_t lHighWaterCount;
    size_t lTotalCount;
} _CrtMemState;


























    

        __declspec(dllimport) int*  __cdecl __p__crtDbgFlag(void);
        __declspec(dllimport) long* __cdecl __p__crtBreakAlloc(void);

        
        

        __declspec(dllimport) _CRT_ALLOC_HOOK __cdecl _CrtGetAllocHook(void);

        __declspec(dllimport) _CRT_ALLOC_HOOK __cdecl _CrtSetAllocHook(
              _CRT_ALLOC_HOOK _PfnNewHook
            );

        __declspec(dllimport) _CRT_DUMP_CLIENT __cdecl _CrtGetDumpClient(void);

        __declspec(dllimport) _CRT_DUMP_CLIENT __cdecl _CrtSetDumpClient(
              _CRT_DUMP_CLIENT _PFnNewDump
            );

    

    __declspec(dllimport) int __cdecl _CrtCheckMemory(void);

    typedef void (__cdecl* _CrtDoForAllClientObjectsCallback)(void*, void*);

    __declspec(dllimport) void __cdecl _CrtDoForAllClientObjects(
          _CrtDoForAllClientObjectsCallback _Callback,
          void*                             _Context
        );

    __declspec(dllimport) int __cdecl _CrtDumpMemoryLeaks(void);

    __declspec(dllimport) int __cdecl _CrtIsMemoryBlock(
           void const*  _Block,
               unsigned int _Size,
          long*        _RequestNumber,
          char**       _FileName,
          int*         _LineNumber
        );

     
    __declspec(dllimport) int __cdecl _CrtIsValidHeapPointer(
          void const* _Pointer
        );

     
    __declspec(dllimport) int __cdecl _CrtIsValidPointer(
          void const*  _Pointer,
              unsigned int _Size,
              int          _ReadWrite
        );

    __declspec(dllimport) void __cdecl _CrtMemCheckpoint(
          _CrtMemState* _State
        );

    __declspec(dllimport) int __cdecl _CrtMemDifference(
          _CrtMemState*       _State,
           _CrtMemState const* _OldState,
           _CrtMemState const* _NewState
        );

    __declspec(dllimport) void __cdecl _CrtMemDumpAllObjectsSince(
          _CrtMemState const* _State
        );

    __declspec(dllimport) void __cdecl _CrtMemDumpStatistics(
          _CrtMemState const* _State
        );

     
    __declspec(dllimport) int __cdecl _CrtReportBlockType(
          void const* _Block
        );

    __declspec(dllimport) long __cdecl _CrtSetBreakAlloc(
          long _NewValue
        );

    __declspec(dllimport) int __cdecl _CrtSetDbgFlag(
          int _NewFlag
        );





//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// Debug Heap Routines
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+








































    












































    __declspec(dllimport) void __cdecl _aligned_free_dbg(
            void* _Block
        );

         
    __declspec(dllimport) __declspec(allocator) void* __cdecl _aligned_malloc_dbg(
                size_t      _Size,
                size_t      _Alignment,
          char const* _FileName,
                int         _LineNumber
        );

    __declspec(dllimport) size_t __cdecl _aligned_msize_dbg(
          void*  _Block,
                   size_t _Alignment,
                   size_t _Offset
        );

         
    __declspec(dllimport) __declspec(allocator) void* __cdecl _aligned_offset_malloc_dbg(
                size_t      _Size,
                size_t      _Alignment,
                size_t      _Offset,
          char const* _FileName,
                int         _LineNumber
        );

           
    __declspec(dllimport) __declspec(allocator) void* __cdecl _aligned_offset_realloc_dbg(
            void*       _Block,
                                    size_t      _Size,
                                    size_t      _Alignment,
                                    size_t      _Offset,
                              char const* _FileName,
                                    int         _LineNumber
        );

           
    __declspec(dllimport) __declspec(allocator) void* __cdecl _aligned_offset_recalloc_dbg(
            void*       _Block,
                                    size_t      _Count,
                                    size_t      _Size,
                                    size_t      _Alignment,
                                    size_t      _Offset,
                              char const* _FileName,
                                    int         _LineNumber
        );

           
    __declspec(dllimport) __declspec(allocator) void* __cdecl _aligned_realloc_dbg(
            void*       _Block,
                                    size_t      _Size,
                                    size_t      _Alignment,
                              char const* _FileName,
                                    int         _LineNumber
        );

           
    __declspec(dllimport) __declspec(allocator) void* __cdecl _aligned_recalloc_dbg(
            void*       _Block,
                                    size_t      _Count,
                                    size_t      _Size,
                                    size_t      _Alignment,
                              char const* _FileName,
                                    int         _LineNumber
        );

         
    __declspec(dllimport) __declspec(allocator) void* __cdecl _calloc_dbg(
                size_t      _Count,
                size_t      _Size,
                int         _BlockUse,
          char const* _FileName,
                int         _LineNumber
        );

         
    __declspec(dllimport) __declspec(allocator) void* __cdecl _expand_dbg(
          void*       _Block,
                   size_t      _Size,
                   int         _BlockUse,
             char const* _FileName,
                   int         _LineNumber
        );

    __declspec(dllimport) void __cdecl _free_dbg(
            void* _Block,
                                    int   _BlockUse
        );

         
    __declspec(dllimport) __declspec(allocator) void* __cdecl _malloc_dbg(
                size_t      _Size,
                int         _BlockUse,
          char const* _FileName,
                int         _LineNumber
        );

    __declspec(dllimport) size_t __cdecl _msize_dbg(
          void* _Block,
                   int   _BlockUse
        );

           
    __declspec(dllimport) __declspec(allocator) void* __cdecl _realloc_dbg(
            void*       _Block,
                                    size_t      _Size,
                                    int         _BlockUse,
                              char const* _FileName,
                                    int         _LineNumber
        );

           
    __declspec(dllimport) __declspec(allocator) void* __cdecl _recalloc_dbg(
            void*       _Block,
                                    size_t      _Count,
                                    size_t      _Size,
                                    int         _BlockUse,
                              char const* _FileName,
                                    int         _LineNumber
        );

     
    
    __declspec(dllimport) errno_t __cdecl _dupenv_s_dbg(
          char** _PBuffer,
                               size_t*     _PBufferSizeInBytes,
                                  char const* _VarName,
                                    int          _BlockType,
                              char const* _FileName,
                                    int          _LineNumber
        );

     
       
    __declspec(dllimport) __declspec(allocator) char* __cdecl _fullpath_dbg(
          char*       _FullPath,
                                    char const* _Path,
                                      size_t      _SizeInBytes,
                                      int         _BlockType,
                                char const* _FileName,
                                      int         _LineNumber
        );

     
       
    __declspec(dllimport) __declspec(allocator) char* __cdecl _getcwd_dbg(
          char*       _DstBuf,
                                      int         _SizeInBytes,
                                      int         _BlockType,
                                char const* _FileName,
                                      int         _LineNumber
        );


     
       
    __declspec(dllimport) __declspec(allocator) char* __cdecl _getdcwd_dbg(
                                      int         _Drive,
          char*       _DstBuf,
                                      int         _SizeInBytes,
                                      int         _BlockType,
                                char const* _FileName,
                                      int         _LineNumber
        );

       
    __declspec(dllimport) __declspec(allocator) char* __cdecl _strdup_dbg(
          char const* _String,
                int         _BlockUse,
          char const* _FileName,
                int         _LineNumber
        );

       
    __declspec(dllimport) __declspec(allocator) char* __cdecl _tempnam_dbg(
          char const* _DirName,
          char const* _FilePrefix,
                int         _BlockType,
          char const* _FileName,
                int         _LineNumber
        );

     
       
    __declspec(dllimport) __declspec(allocator) wchar_t* __cdecl _wcsdup_dbg(
          wchar_t const* _String,
                int            _BlockUse,
          char const*    _FileName,
                int            _LineNumber
        );

     
    
    __declspec(dllimport) errno_t __cdecl _wdupenv_s_dbg(
          wchar_t** _PBuffer,
                                 size_t*         _PBufferSizeInWords,
                                    wchar_t const* _VarName,
                                      int             _BlockType,
                                char const*    _FileName,
                                      int             _LineNumber
        );

     
       
    __declspec(dllimport) __declspec(allocator) wchar_t* __cdecl _wfullpath_dbg(
          wchar_t*       _FullPath,
                                    wchar_t const* _Path,
                                      size_t         _SizeInWords,
                                      int            _BlockType,
                                char const*    _FileName,
                                      int            _LineNumber
        );

     
       
    __declspec(dllimport) __declspec(allocator) wchar_t* __cdecl _wgetcwd_dbg(
          wchar_t*    _DstBuf,
                                      int         _SizeInWords,
                                      int         _BlockType,
                                char const* _FileName,
                                      int         _LineNumber
        );

     
       
    __declspec(dllimport) __declspec(allocator) wchar_t* __cdecl _wgetdcwd_dbg(
                                      int         _Drive,
          wchar_t*    _DstBuf,
                                      int         _SizeInWords,
                                      int         _BlockType,
                                char const* _FileName,
                                      int         _LineNumber
        );

       
    __declspec(dllimport) __declspec(allocator) wchar_t* __cdecl _wtempnam_dbg(
          wchar_t const* _DirName,
          wchar_t const* _FilePrefix,
                int            _BlockType,
          char const*    _FileName,
                int            _LineNumber
        );

    
    

    













//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// Debug Reporting
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+













    __declspec(dllimport) int __cdecl _CrtDbgReport(
                int         _ReportType,
          char const* _FileName,
                int         _Linenumber,
          char const* _ModuleName,
          char const* _Format,
        ...);

    __declspec(dllimport) int __cdecl _CrtDbgReportW(
                int            _ReportType,
          wchar_t const* _FileName,
                int            _LineNumber,
          wchar_t const* _ModuleName,
          wchar_t const* _Format,
        ...);


    __declspec(dllimport) int __cdecl _VCrtDbgReportA(
                int         _ReportType,
            void*       _ReturnAddress,
          char const* _FileName,
                int         _LineNumber,
          char const* _ModuleName,
          char const* _Format,
                   va_list     _ArgList
        );

    __declspec(dllimport) int __cdecl _VCrtDbgReportW(
                int            _ReportType,
            void*          _ReturnAddress,
          wchar_t const* _FileName,
                int            _LineNumber,
          wchar_t const* _ModuleName,
          wchar_t const* _Format,
                   va_list        _ArgList
        );

    __declspec(dllimport) size_t __cdecl _CrtSetDebugFillThreshold(
          size_t _NewDebugFillThreshold
        );

    __declspec(dllimport) size_t __cdecl _CrtGetDebugFillThreshold(void);

    __declspec(dllimport) _HFILE __cdecl _CrtSetReportFile(
              int    _ReportType,
          _HFILE _ReportFile
        );

    __declspec(dllimport) int __cdecl _CrtSetReportMode(
          int _ReportType,
          int _ReportMode
        );

    

        extern long _crtAssertBusy;

        __declspec(dllimport) _CRT_REPORT_HOOK __cdecl _CrtGetReportHook(void);

        // _CrtSetReportHook[[W]2]:
        // For IJW, we need two versions:  one for clrcall and one for cdecl.
        // For pure and native, we just need clrcall and cdecl, respectively.
        __declspec(dllimport) _CRT_REPORT_HOOK __cdecl _CrtSetReportHook(
              _CRT_REPORT_HOOK _PFnNewHook
            );

        __declspec(dllimport) int __cdecl _CrtSetReportHook2(
                  int              _Mode,
              _CRT_REPORT_HOOK _PFnNewHook
            );

        __declspec(dllimport) int __cdecl _CrtSetReportHookW2(
                  int               _Mode,
              _CRT_REPORT_HOOKW _PFnNewHook
            );

    






//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// Assertions and Error Reporting Macros
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+






























    

    // !! is used to ensure that any overloaded operators used to evaluate expr
    // do not end up at &&.
    
        





    

    
        
    

    
        
    

    



    



    
    

    
    

    
    

    
    



// Asserts in debug.  Invokes Watson in both debug and release









// _ASSERT_BASE is provided only for backwards compatibility.

    




























} __pragma(pack(pop))



#pragma pack(push,8)
#pragma warning(push,3)
#pragma warning(disable: 4455 4494  4619 4643 4702 4984 4988 )


















		/* CURRENT DLL NAMES */

	







		/* Visual Studio */
		
			
		


	











































	/* B1. Inspect _HAS_ITERATOR_DEBUGGING. */
	






		
			
		


	

	/* B2. Inspect _SECURE_SCL. */
	




		
			
		


	

	/* B3. Derive _ITERATOR_DEBUG_LEVEL. */
	
		
	








	
		#pragma detect_mismatch("_MSC_VER", "1900")
	

	
		#pragma detect_mismatch("_ITERATOR_DEBUG_LEVEL", "2")
	

	
		






			#pragma detect_mismatch("RuntimeLibrary", "MDd_DynamicDebug")
		
	









	


		
	


























 







 



/***
*use_ansi.h - pragmas for ANSI Standard C++ libraries
*
*	Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This header is intended to force the use of the appropriate ANSI
*       Standard C++ libraries whenever it is included.
*
*       [Public]
*
****/

#pragma once




















    
    






    










    


#pragma comment(lib, "msvcprt" "d" "")


































 
  


   
  
 

 
  


   
  
 

/* Define _MRTIMP2_NPURE */
 
  






   
  
 

 
  
 

 
  


   


     
   
  
 

 








 


  
   
  


 



 


  


   
  
 



 


  
 



 


  
 


		/* INTEGER PROPERTIES */





		/* MULTITHREAD PROPERTIES */
		/* LOCK MACROS */






 
namespace std {
enum _Uninitialized
	{	// tag for suppressing initialization
	_Noinit
	};

		// CLASS _Lockit
class __declspec(dllimport) _Lockit
	{	// lock while object in existence -- MUST NEST
public:
 

















	__thiscall _Lockit();	// default construct
	explicit __thiscall _Lockit(int);	// set the lock
	__thiscall ~_Lockit() noexcept;	// clear the lock
 

	static  void __cdecl _Lockit_ctor(int);
	static  void __cdecl _Lockit_dtor(int);

private:
	static  void __cdecl _Lockit_ctor(_Lockit *);
	static  void __cdecl _Lockit_ctor(_Lockit *, int);
	static  void __cdecl _Lockit_dtor(_Lockit *);

public:
	 _Lockit(const _Lockit&) = delete;
	_Lockit&  operator=(const _Lockit&) = delete;

private:
	int _Locktype;
	};

 


































































  



  


  



  


  
 

class __declspec(dllimport) _Init_locks
	{	// initialize mutexes
public:
 











	__thiscall _Init_locks();
	__thiscall ~_Init_locks() noexcept;
 

private:
	static  void __cdecl _Init_locks_ctor(_Init_locks *);
	static  void __cdecl _Init_locks_dtor(_Init_locks *);
	};

		// EXCEPTION MACROS

 
 
 
 

 
 

 






  
 
















}
 





 
 
 #pragma warning(pop)
 #pragma pack(pop)



/*
 * Copyright (c) by P.J. Plauger. All rights reserved.
 * Consult your license regarding permissions and restrictions.
V6.50:0009 */


//
// limits.h
//
//      Copyright (c) Microsoft Corporation. All rights reserved.
//
// The C Standard Library <limits.h> header.
//
#pragma once




__pragma(pack(push, 8)) extern "C" {









    
    































// minimum signed 64 bit value

// maximum signed 64 bit value

// maximum unsigned 64 bit value












    
        
    





    
        
    




} __pragma(pack(pop))





/*
 * Copyright (c) by P.J. Plauger. All rights reserved.
 * Consult your license regarding permissions and restrictions.
V6.50:0009 */


// cmath standard header
#pragma once






// cstdlib standard header (core)
#pragma once






//
// stdlib.h
//
//      Copyright (c) Microsoft Corporation. All rights reserved.
//
// The C Standard Library <stdlib.h> header.
//
#pragma once





//
// corecrt_malloc.h
//
//      Copyright (c) Microsoft Corporation. All rights reserved.
//
// The memory allocation library.  These pieces of the allocation library are
// shared by both <stdlib.h> and <malloc.h>.
//
#pragma once



__pragma(pack(push, 8)) extern "C" {







































     
__declspec(dllimport) __declspec(allocator) __declspec(restrict)
void* __cdecl _calloc_base(
      size_t _Count,
      size_t _Size
    );

     
__declspec(dllimport)  __declspec(allocator) __declspec(restrict) 
void* __cdecl calloc(
      __declspec(guard(overflow)) size_t _Count,
      __declspec(guard(overflow)) size_t _Size
    );

 
__declspec(dllimport) int __cdecl _callnewh(
      size_t _Size
    );

     
__declspec(dllimport) __declspec(allocator) 
void* __cdecl _expand(
                void*  _Block,
      __declspec(guard(overflow)) size_t _Size
    );

__declspec(dllimport)
void __cdecl _free_base(
        void* _Block
    );

__declspec(dllimport) 
void __cdecl free(
        void* _Block
    );

     
__declspec(dllimport) __declspec(allocator) __declspec(restrict)
void* __cdecl _malloc_base(
      size_t _Size
    );

     
__declspec(dllimport) __declspec(allocator)  __declspec(restrict) 
void* __cdecl malloc(
      __declspec(guard(overflow)) size_t _Size
    );

 
__declspec(dllimport)
size_t __cdecl _msize_base(
      void* _Block
    );

 
__declspec(dllimport) 
size_t __cdecl _msize(
      void* _Block
    );

       
__declspec(dllimport) __declspec(allocator) __declspec(restrict)
void* __cdecl _realloc_base(
         void*  _Block,
                                 size_t _Size
    );

       
__declspec(dllimport) __declspec(allocator) __declspec(restrict) 
void* __cdecl realloc(
        void*  _Block,
      __declspec(guard(overflow))        size_t _Size
    );

       
__declspec(dllimport) __declspec(allocator) __declspec(restrict)
void* __cdecl _recalloc_base(
        void*  _Block,
                                size_t _Count,
                                size_t _Size
    );

       
__declspec(dllimport) __declspec(allocator) __declspec(restrict)
void* __cdecl _recalloc(
        void*  _Block,
      __declspec(guard(overflow))        size_t _Count,
      __declspec(guard(overflow))        size_t _Size
    );

__declspec(dllimport)
void __cdecl _aligned_free(
        void* _Block
    );

     
__declspec(dllimport) __declspec(allocator) __declspec(restrict)
void* __cdecl _aligned_malloc(
      __declspec(guard(overflow)) size_t _Size,
                         size_t _Alignment
    );

     
__declspec(dllimport) __declspec(allocator) __declspec(restrict)
void* __cdecl _aligned_offset_malloc(
      __declspec(guard(overflow)) size_t _Size,
                         size_t _Alignment,
                         size_t _Offset
    );

 
__declspec(dllimport)
size_t __cdecl _aligned_msize(
      void*  _Block,
               size_t _Alignment,
               size_t _Offset
    );

       
__declspec(dllimport) __declspec(allocator) __declspec(restrict)
void* __cdecl _aligned_offset_realloc(
        void*  _Block,
      __declspec(guard(overflow))        size_t _Size,
                                size_t _Alignment,
                                size_t _Offset
    );

       
__declspec(dllimport) __declspec(allocator) __declspec(restrict)
void* __cdecl _aligned_offset_recalloc(
        void*  _Block,
      __declspec(guard(overflow))        size_t _Count,
      __declspec(guard(overflow))        size_t _Size,
                                size_t _Alignment,
                                size_t _Offset
    );

       
__declspec(dllimport) __declspec(allocator) __declspec(restrict)
void* __cdecl _aligned_realloc(
        void*  _Block,
      __declspec(guard(overflow))        size_t _Size,
                                size_t _Alignment
    );

       
__declspec(dllimport) __declspec(allocator) __declspec(restrict)
void* __cdecl _aligned_recalloc(
        void*  _Block,
      __declspec(guard(overflow))        size_t _Count,
      __declspec(guard(overflow))        size_t _Size,
                                size_t _Alignment
    );






















} __pragma(pack(pop))


//
// corecrt_search.h
//
//      Copyright (c) Microsoft Corporation. All rights reserved.
//
// Declarations of functions for sorting and searching.  These declarations are
// split out so that they may be included by both <stdlib.h> and <search.h>.
// <stdlib.h> does not include <search.h> to avoid introducing conflicts with
// other user headers named <search.h>.
//
#pragma once



//
// stddef.h
//
//      Copyright (c) Microsoft Corporation. All rights reserved.
//
// The C <stddef.h> Standard Library header.
//
#pragma once





__pragma(pack(push, 8)) extern "C" {




    namespace std
    {
        typedef decltype(__nullptr) nullptr_t;
    }

    using ::std::nullptr_t;






    __declspec(dllimport) int* __cdecl _errno(void);
    

    __declspec(dllimport) errno_t __cdecl _set_errno(  int _Value);
    __declspec(dllimport) errno_t __cdecl _get_errno(  int* _Value);












    


__declspec(dllimport) extern unsigned long  __cdecl __threadid(void);

__declspec(dllimport) extern uintptr_t __cdecl __threadhandle(void);



} __pragma(pack(pop))



__pragma(pack(push, 8)) extern "C" {


    typedef int (__cdecl* _CoreCrtSecureSearchSortCompareFunction)(void*, void const*, void const*);
    typedef int (__cdecl* _CoreCrtNonSecureSearchSortCompareFunction)(void const*, void const*);




     
    __declspec(dllimport) void* __cdecl bsearch_s(
                                                        void const* _Key,
          void const* _Base,
                                                        rsize_t     _NumOfElements,
                                                        rsize_t     _SizeOfElements,
                            _CoreCrtSecureSearchSortCompareFunction _CompareFunction,
                                                    void*       _Context
        );

    __declspec(dllimport) void __cdecl qsort_s(
          void*   _Base,
                                                             rsize_t _NumOfElements,
                                                             rsize_t _SizeOfElements,
                             _CoreCrtSecureSearchSortCompareFunction _CompareFunction,
                                                         void*   _Context
        );





 
__declspec(dllimport) void* __cdecl bsearch(
                                                    void const* _Key,
      void const* _Base,
                                                    size_t      _NumOfElements,
                                                    size_t      _SizeOfElements,
                     _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction
    );

__declspec(dllimport) void __cdecl qsort(
      void*  _Base,
                                                         size_t _NumOfElements,
                                                         size_t _SizeOfElements,
                     _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction
    );

 
__declspec(dllimport) void* __cdecl _lfind_s(
                                                       void const*   _Key,
      void const*   _Base,
                                                    unsigned int* _NumOfElements,
                                                       size_t        _SizeOfElements,
                             _CoreCrtSecureSearchSortCompareFunction _CompareFunction,
                                                       void*         _Context
    );

 
__declspec(dllimport) void* __cdecl _lfind(
                                                       void const*   _Key,
      void const*   _Base,
                                                    unsigned int* _NumOfElements,
                                                       unsigned int  _SizeOfElements,
                          _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction
    );

 
__declspec(dllimport) void* __cdecl _lsearch_s(
                                                             void const*   _Key,
      void*         _Base,
                                                          unsigned int* _NumOfElements,
                                                             size_t        _SizeOfElements,
                                   _CoreCrtSecureSearchSortCompareFunction _CompareFunction,
                                                             void*         _Context
    );

 
__declspec(dllimport) void* __cdecl _lsearch(
                                                             void const*   _Key,
      void*         _Base,
                                                          unsigned int* _NumOfElements,
                                                             unsigned int  _SizeOfElements,
                                _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction
    );



// Managed search routines






















































































      __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_lfind" ". See online help for details."))
    __declspec(dllimport) void* __cdecl lfind(
                                                           void const*   _Key,
          void const*   _Base,
                                                        unsigned int* _NumOfElements,
                                                           unsigned int  _SizeOfElements,
                              _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction
        );

      __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_lsearch" ". See online help for details."))
    __declspec(dllimport) void* __cdecl lsearch(
                                                                void const*   _Key,
          void*         _Base,
                                                             unsigned int* _NumOfElements,
                                                                unsigned int  _SizeOfElements,
                                   _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction
        );





} __pragma(pack(pop))


//
// corecrt_wstdlib.h
//
//      Copyright (c) Microsoft Corporation. All rights reserved.
//
// This file declares the wide character (wchar_t) C Standard Library functions
// that are declared by both <stdlib.h> and <wchar.h>.
//
#pragma once



__pragma(pack(push, 8)) extern "C" {



// Maximum number of elements, including null terminator (and negative sign
// where appropriate), needed for integer-to-string conversions for several
// bases and integer types.




























     
    
    __declspec(dllimport) errno_t __cdecl _itow_s(
                                  int      _Value,
          wchar_t* _Buffer,
                                  size_t   _BufferCount,
                                  int      _Radix
        );

    extern "C++" { template <size_t _Size> inline errno_t __cdecl _itow_s(  int _Value, wchar_t (&_Buffer)[_Size],   int _Radix) throw() { return _itow_s(_Value, _Buffer, _Size, _Radix); } }

    __declspec(deprecated("This function or variable may be unsafe. Consider using " "_itow_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) wchar_t* __cdecl _itow( int _Value,   wchar_t *_Buffer,  int _Radix);

     
    
    __declspec(dllimport) errno_t __cdecl _ltow_s(
                                  long     _Value,
          wchar_t* _Buffer,
                                  size_t   _BufferCount,
                                  int      _Radix
        );

    extern "C++" { template <size_t _Size> inline errno_t __cdecl _ltow_s(  long _Value, wchar_t (&_Buffer)[_Size],   int _Radix) throw() { return _ltow_s(_Value, _Buffer, _Size, _Radix); } }

    __declspec(deprecated("This function or variable may be unsafe. Consider using " "_ltow_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) wchar_t* __cdecl _ltow( long _Value,   wchar_t *_Buffer,  int _Radix);

    
    __declspec(dllimport) errno_t __cdecl _ultow_s(
                                  unsigned long _Value,
          wchar_t*      _Buffer,
                                  size_t        _BufferCount,
                                  int           _Radix
        );

    extern "C++" { template <size_t _Size> inline errno_t __cdecl _ultow_s(  unsigned long _Value, wchar_t (&_Buffer)[_Size],   int _Radix) throw() { return _ultow_s(_Value, _Buffer, _Size, _Radix); } }

    __declspec(deprecated("This function or variable may be unsafe. Consider using " "_ultow_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) wchar_t* __cdecl _ultow( unsigned long _Value,   wchar_t *_Buffer,  int _Radix);

     
    __declspec(dllimport) double __cdecl wcstod(
                            wchar_t const* _String,
            wchar_t**      _EndPtr
        );

     
    __declspec(dllimport) double __cdecl _wcstod_l(
                            wchar_t const* _String,
            wchar_t**      _EndPtr,
                          _locale_t      _Locale
        );

     
    __declspec(dllimport) long __cdecl wcstol(
                            wchar_t const* _String,
            wchar_t**      _EndPtr,
                              int            _Radix
        );

     
    __declspec(dllimport) long __cdecl _wcstol_l(
                            wchar_t const* _String,
            wchar_t**      _EndPtr,
                              int            _Radix,
                          _locale_t      _Locale
        );

     
    __declspec(dllimport) long long __cdecl wcstoll(
                            wchar_t const* _String,
            wchar_t**      _EndPtr,
                              int            _Radix
        );

     
    __declspec(dllimport) long long __cdecl _wcstoll_l(
                            wchar_t const* _String,
            wchar_t**      _EndPtr,
                              int            _Radix,
                          _locale_t      _Locale
        );

     
    __declspec(dllimport) unsigned long __cdecl wcstoul(
                            wchar_t const* _String,
            wchar_t**      _EndPtr,
                              int            _Radix
        );

     
    __declspec(dllimport) unsigned long __cdecl _wcstoul_l(
                            wchar_t const* _String,
            wchar_t**      _EndPtr,
                              int            _Radix,
                          _locale_t      _Locale
        );

     
    __declspec(dllimport) unsigned long long __cdecl wcstoull(
                            wchar_t const* _String,
            wchar_t**      _EndPtr,
                              int            _Radix
        );

     
    __declspec(dllimport) unsigned long long __cdecl _wcstoull_l(
                            wchar_t const* _String,
            wchar_t**      _EndPtr,
                              int            _Radix,
                          _locale_t      _Locale
        );

     
    __declspec(dllimport) long double __cdecl wcstold(
                            wchar_t const* _String,
            wchar_t**      _EndPtr
        );

     
    __declspec(dllimport) long double __cdecl _wcstold_l(
                            wchar_t const* _String,
            wchar_t**      _EndPtr,
                          _locale_t      _Locale
        );

     
    __declspec(dllimport) float __cdecl wcstof(
                            wchar_t const* _String,
            wchar_t**      _EndPtr
        );

     
    __declspec(dllimport) float __cdecl _wcstof_l(
                            wchar_t const* _String,
            wchar_t**      _EndPtr,
                          _locale_t      _Locale
        );

     
    __declspec(dllimport) double __cdecl _wtof(
          wchar_t const* _String
        );

     
    __declspec(dllimport) double __cdecl _wtof_l(
            wchar_t const* _String,
          _locale_t      _Locale
        );

     
    __declspec(dllimport) int __cdecl _wtoi(
          wchar_t const* _String
        );

     
    __declspec(dllimport) int __cdecl _wtoi_l(
            wchar_t const* _String,
          _locale_t      _Locale
        );

     
    __declspec(dllimport) long __cdecl _wtol(
          wchar_t const* _String
        );

     
    __declspec(dllimport) long __cdecl _wtol_l(
            wchar_t const* _String,
          _locale_t      _Locale
        );

     
    __declspec(dllimport) long long __cdecl _wtoll(
          wchar_t const* _String
        );

     
    __declspec(dllimport) long long __cdecl _wtoll_l(
            wchar_t const* _String,
          _locale_t      _Locale
        );

    
    __declspec(dllimport) errno_t __cdecl _i64tow_s(
                                  __int64  _Value,
          wchar_t* _Buffer,
                                  size_t   _BufferCount,
                                  int      _Radix
        );

    __declspec(deprecated("This function or variable may be unsafe. Consider using " "_i64tow_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __declspec(dllimport) wchar_t* __cdecl _i64tow(
                            __int64  _Value,
            wchar_t* _Buffer,
                            int      _Radix
        );

    
    __declspec(dllimport) errno_t __cdecl _ui64tow_s(
                                  unsigned __int64 _Value,
          wchar_t*         _Buffer,
                                  size_t           _BufferCount,
                                  int              _Radix
        );

    __declspec(deprecated("This function or variable may be unsafe. Consider using " "_ui64tow_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __declspec(dllimport) wchar_t* __cdecl _ui64tow(
                            unsigned __int64 _Value,
            wchar_t*         _Buffer,
                            int              _Radix
        );

     
    __declspec(dllimport) __int64 __cdecl _wtoi64(
          wchar_t const* _String
        );

     
    __declspec(dllimport) __int64 __cdecl _wtoi64_l(
            wchar_t const* _String,
          _locale_t      _Locale
        );

     
    __declspec(dllimport) __int64 __cdecl _wcstoi64(
                            wchar_t const* _String,
            wchar_t**      _EndPtr,
                              int            _Radix
        );

     
    __declspec(dllimport) __int64 __cdecl _wcstoi64_l(
                            wchar_t const* _String,
            wchar_t**      _EndPtr,
                              int            _Radix,
                          _locale_t      _Locale
        );

     
    __declspec(dllimport) unsigned __int64 __cdecl _wcstoui64(
                            wchar_t const* _String,
            wchar_t**      _EndPtr,
                              int            _Radix
        );

     
    __declspec(dllimport) unsigned __int64 __cdecl _wcstoui64_l(
                            wchar_t const* _String,
            wchar_t**      _EndPtr,
                              int            _Radix,
                          _locale_t      _Locale
        );

    
    

     
     
    __declspec(dllimport) __declspec(allocator) wchar_t* __cdecl _wfullpath(
          wchar_t*       _Buffer,
                                    wchar_t const* _Path,
                                      size_t         _BufferCount
        );

    

    
    __declspec(dllimport) errno_t __cdecl _wmakepath_s(
          wchar_t*       _Buffer,
                                  size_t         _BufferCount,
                            wchar_t const* _Drive,
                            wchar_t const* _Dir,
                            wchar_t const* _Filename,
                            wchar_t const* _Ext
        );

    extern "C++" { template <size_t _Size> inline errno_t __cdecl _wmakepath_s(wchar_t (&_Buffer)[_Size],   wchar_t const* _Drive,   wchar_t const* _Dir,   wchar_t const* _Filename,   wchar_t const* _Ext) throw() { return _wmakepath_s(_Buffer, _Size, _Drive, _Dir, _Filename, _Ext); } }

#pragma warning(push)
#pragma warning(disable: 28719) 
#pragma warning(disable: 28726) 
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_wmakepath_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) void __cdecl _wmakepath(  wchar_t *_Buffer,  wchar_t const* _Drive,  wchar_t const* _Dir,  wchar_t const* _Filename,  wchar_t const* _Ext);
#pragma warning(pop)

    __declspec(dllimport) void __cdecl _wperror(
          wchar_t const* _ErrorMessage
        );

    __declspec(deprecated("This function or variable may be unsafe. Consider using " "_wsplitpath_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __declspec(dllimport) void __cdecl _wsplitpath(
                            wchar_t const* _FullPath,
            wchar_t*       _Drive,
            wchar_t*       _Dir,
            wchar_t*       _Filename,
            wchar_t*       _Ext
        );

    __declspec(dllimport) errno_t __cdecl _wsplitpath_s(
                                      wchar_t const* _FullPath,
             wchar_t*       _Drive,
                                        size_t         _DriveCount,
               wchar_t*       _Dir,
                                        size_t         _DirCount,
          wchar_t*       _Filename,
                                        size_t         _FilenameCount,
               wchar_t*       _Ext,
                                        size_t         _ExtCount
        );

    extern "C++" { template <size_t _DriveSize, size_t _DirSize, size_t _NameSize, size_t _ExtSize> inline errno_t __cdecl _wsplitpath_s(   wchar_t const* _Path,   wchar_t (&_Drive)[_DriveSize],   wchar_t (&_Dir)[_DirSize],   wchar_t (&_Name)[_NameSize],   wchar_t (&_Ext)[_ExtSize] ) throw() { return _wsplitpath_s(_Path, _Drive, _DriveSize, _Dir, _DirSize, _Name, _NameSize, _Ext, _ExtSize); } }

        
        

        
        __declspec(dllimport) errno_t __cdecl _wdupenv_s(
                wchar_t**      _Buffer,
                                                                                size_t*        _BufferCount,
                                                                                   wchar_t const* _VarName
            );

        

          __declspec(deprecated("This function or variable may be unsafe. Consider using " "_wdupenv_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
        __declspec(dllimport) wchar_t* __cdecl _wgetenv(
              wchar_t const* _VarName
            );

         
        
        __declspec(dllimport) errno_t __cdecl _wgetenv_s(
                                         size_t*        _RequiredCount,
              wchar_t*       _Buffer,
                                          size_t         _BufferCount,
                                        wchar_t const* _VarName
            );

        extern "C++" { template <size_t _Size> inline   errno_t __cdecl _wgetenv_s(  size_t* _RequiredCount, wchar_t (&_Buffer)[_Size],   wchar_t const* _VarName) throw() { return _wgetenv_s(_RequiredCount, _Buffer, _Size, _VarName); } }

         
        __declspec(dllimport) int __cdecl _wputenv(
              wchar_t const* _EnvString
            );

        
        __declspec(dllimport) errno_t __cdecl _wputenv_s(
              wchar_t const* _Name,
              wchar_t const* _Value
            );

        __declspec(dllimport) errno_t __cdecl _wsearchenv_s(
                                    wchar_t const* _Filename,
                                    wchar_t const* _VarName,
              wchar_t*       _Buffer,
                                      size_t         _BufferCount
            );

        extern "C++" { template <size_t _Size> inline errno_t __cdecl _wsearchenv_s(  wchar_t const* _Filename,   wchar_t const* _VarName, wchar_t (&_ResultPath)[_Size]) throw() { return _wsearchenv_s(_Filename, _VarName, _ResultPath, _Size); } }

        __declspec(deprecated("This function or variable may be unsafe. Consider using " "_wsearchenv_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) void __cdecl _wsearchenv( wchar_t const* _Filename,  wchar_t const* _VarName,   wchar_t *_ResultPath);

        __declspec(dllimport) int __cdecl _wsystem(
              wchar_t const* _Command
            );





} __pragma(pack(pop))



__pragma(pack(push, 8)) extern "C" {




    




// Minimum and maximum macros





__declspec(dllimport) void __cdecl _swab(
        char* _Buf1,
        char* _Buf2,
                                                                  int   _SizeInBytes
    );



//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// Exit and Abort
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
// Argument values for exit()




    __declspec(dllimport) __declspec(noreturn) void __cdecl exit(  int _Code);
    __declspec(dllimport) __declspec(noreturn) void __cdecl _exit(  int _Code);
    __declspec(dllimport) __declspec(noreturn) void __cdecl _Exit(  int _Code);
    __declspec(dllimport) __declspec(noreturn) void __cdecl quick_exit(  int _Code);
    __declspec(dllimport) __declspec(noreturn) void __cdecl abort(void);


// Argument values for _set_abort_behavior().



__declspec(dllimport) unsigned int __cdecl _set_abort_behavior(
      unsigned int _Flags,
      unsigned int _Mask
    );




    

    typedef int (__cdecl* _onexit_t)(void);
    





    // Non-ANSI name for compatibility
    


























































    int       __cdecl atexit(void (__cdecl*)(void));
    _onexit_t __cdecl _onexit(  _onexit_t _Func);


int __cdecl at_quick_exit(void (__cdecl*)(void));



//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// Global State (errno, global handlers, etc.)
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

    // a purecall handler procedure. Never returns normally
    typedef void (__cdecl* _purecall_handler)(void);

    // Invalid parameter handler function pointer type
    typedef void (__cdecl* _invalid_parameter_handler)(
        wchar_t const*,
        wchar_t const*,
        wchar_t const*,
        unsigned int,
        uintptr_t
        );

    // Establishes a purecall handler
     _purecall_handler __cdecl _set_purecall_handler(
          _purecall_handler _Handler
        );

     _purecall_handler __cdecl _get_purecall_handler(void);

    // Establishes an invalid parameter handler
    __declspec(dllimport) _invalid_parameter_handler __cdecl _set_invalid_parameter_handler(
          _invalid_parameter_handler _Handler
        );

    __declspec(dllimport) _invalid_parameter_handler __cdecl _get_invalid_parameter_handler(void);

    __declspec(dllimport) _invalid_parameter_handler __cdecl _set_thread_local_invalid_parameter_handler(
          _invalid_parameter_handler _Handler
        );

    __declspec(dllimport) _invalid_parameter_handler __cdecl _get_thread_local_invalid_parameter_handler(void);

















// Argument values for _set_error_mode().





 __declspec(dllimport) int __cdecl _set_error_mode(  int _Mode);




    __declspec(dllimport) int* __cdecl _errno(void);
    

    __declspec(dllimport) errno_t __cdecl _set_errno(  int _Value);
    __declspec(dllimport) errno_t __cdecl _get_errno(  int* _Value);

    __declspec(dllimport) unsigned long* __cdecl __doserrno(void);
    

    __declspec(dllimport) errno_t __cdecl _set_doserrno(  unsigned long _Value);
    __declspec(dllimport) errno_t __cdecl _get_doserrno(  unsigned long * _Value);

    // This is non-const for backwards compatibility; do not modify it.
    __declspec(dllimport) __declspec(deprecated("This function or variable may be unsafe. Consider using " "strerror" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) char** __cdecl __sys_errlist(void);
    

    __declspec(dllimport) __declspec(deprecated("This function or variable may be unsafe. Consider using " "strerror" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) int * __cdecl __sys_nerr(void);
    

    __declspec(dllimport) void __cdecl perror(  char const* _ErrMsg);




// These point to the executable module name.
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_get_pgmptr" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) char**    __cdecl __p__pgmptr (void);
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_get_wpgmptr" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) wchar_t** __cdecl __p__wpgmptr(void);
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_get_fmode" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) int*      __cdecl __p__fmode  (void);








    
    
    


 
__declspec(dllimport) errno_t __cdecl _get_pgmptr (  char**    _Value);

 
__declspec(dllimport) errno_t __cdecl _get_wpgmptr(  wchar_t** _Value);

__declspec(dllimport) errno_t __cdecl _set_fmode  (               int       _Mode );

__declspec(dllimport) errno_t __cdecl _get_fmode  (              int*      _PMode);



//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// Math
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
typedef struct _div_t
{
    int quot;
    int rem;
} div_t;

typedef struct _ldiv_t
{
    long quot;
    long rem;
} ldiv_t;

typedef struct _lldiv_t
{
    long long quot;
    long long rem;
} lldiv_t;

  int       __cdecl abs   (  int       _Number);
  long      __cdecl labs  (  long      _Number);
  long long __cdecl llabs (  long long _Number);
  __int64   __cdecl _abs64(  __int64   _Number);

  unsigned short   __cdecl _byteswap_ushort(  unsigned short   _Number);
  unsigned long    __cdecl _byteswap_ulong (  unsigned long    _Number);
  unsigned __int64 __cdecl _byteswap_uint64(  unsigned __int64 _Number);

  __declspec(dllimport) div_t   __cdecl div  (  int       _Numerator,   int       _Denominator);
  __declspec(dllimport) ldiv_t  __cdecl ldiv (  long      _Numerator,   long      _Denominator);
  __declspec(dllimport) lldiv_t __cdecl lldiv(  long long _Numerator,   long long _Denominator);

// These functions have declspecs in their declarations in the Windows headers,
// which cause PREfast to fire 6540.
#pragma warning (push)
#pragma warning (disable:6540)

unsigned int __cdecl _rotl(
      unsigned int _Value,
      int          _Shift
    );

 
unsigned long __cdecl _lrotl(
      unsigned long _Value,
      int           _Shift
    );

unsigned __int64 __cdecl _rotl64(
      unsigned __int64 _Value,
      int              _Shift
    );

unsigned int __cdecl _rotr(
      unsigned int _Value,
      int          _Shift
    );

 
unsigned long __cdecl _lrotr(
      unsigned long _Value,
      int           _Shift
    );

unsigned __int64 __cdecl _rotr64(
      unsigned __int64 _Value,
      int              _Shift
    );

#pragma warning (pop)



// Maximum value that can be returned by the rand function:


__declspec(dllimport) void __cdecl srand(  unsigned int _Seed);

  __declspec(dllimport) int __cdecl rand(void);








extern "C++"
{
    inline long abs(long const _X) throw()
    {
        return labs(_X);
    }

    inline long long abs(long long const _X) throw()
    {
        return llabs(_X);
    }

    inline ldiv_t div(long const _A1, long const _A2) throw()
    {
        return ldiv(_A1, _A2);
    }

    inline lldiv_t div(long long const _A1, long long const _A2) throw()
    {
        return lldiv(_A1, _A2);
    }
}





// Structs used to fool the compiler into not generating floating point
// instructions when copying and pushing [long] double values




    #pragma pack(push, 4)
    typedef struct
    {
        unsigned char ld[10];
    } _LDOUBLE;
    #pragma pack(pop)

    













typedef struct
{
    double x;
} _CRT_DOUBLE;

typedef struct
{
    float f;
} _CRT_FLOAT;

// push and pop long, which is #defined as __int64 by a spec2k test



typedef struct
{
    long double x;
} _LONGDOUBLE;



#pragma pack(push, 4)
typedef struct
{
    unsigned char ld12[12];
} _LDBL12;
#pragma pack(pop)



//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// Narrow String to Number Conversions
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
                     __declspec(dllimport) double    __cdecl atof   (  char const* _String);
   __declspec(dllimport) int       __cdecl atoi   (  char const* _String);
                     __declspec(dllimport) long      __cdecl atol   (  char const* _String);
                     __declspec(dllimport) long long __cdecl atoll  (  char const* _String);
                     __declspec(dllimport) __int64   __cdecl _atoi64(  char const* _String);

  __declspec(dllimport) double    __cdecl _atof_l  (  char const* _String,   _locale_t _Locale);
  __declspec(dllimport) int       __cdecl _atoi_l  (  char const* _String,   _locale_t _Locale);
  __declspec(dllimport) long      __cdecl _atol_l  (  char const* _String,   _locale_t _Locale);
  __declspec(dllimport) long long __cdecl _atoll_l (  char const* _String,   _locale_t _Locale);
  __declspec(dllimport) __int64   __cdecl _atoi64_l(  char const* _String,   _locale_t _Locale);

  __declspec(dllimport) int __cdecl _atoflt (  _CRT_FLOAT*  _Result,   char const* _String);
  __declspec(dllimport) int __cdecl _atodbl (  _CRT_DOUBLE* _Result,   char*       _String);
  __declspec(dllimport) int __cdecl _atoldbl(  _LDOUBLE*    _Result,   char*       _String);

 
__declspec(dllimport) int __cdecl _atoflt_l(
         _CRT_FLOAT* _Result,
        char const* _String,
      _locale_t   _Locale
    );

 
__declspec(dllimport) int __cdecl _atodbl_l(
         _CRT_DOUBLE* _Result,
        char*        _String,
      _locale_t    _Locale
    );


 
__declspec(dllimport) int __cdecl _atoldbl_l(
         _LDOUBLE* _Result,
        char*     _String,
      _locale_t _Locale
    );

 
__declspec(dllimport) float __cdecl strtof(
                        char const* _String,
        char**      _EndPtr
    );

 
__declspec(dllimport) float __cdecl _strtof_l(
                        char const* _String,
        char**      _EndPtr,
                      _locale_t   _Locale
    );

 
__declspec(dllimport) double __cdecl strtod(
                        char const* _String,
        char**      _EndPtr
    );

 
__declspec(dllimport) double __cdecl _strtod_l(
                        char const* _String,
        char**      _EndPtr,
                      _locale_t   _Locale
    );

 
__declspec(dllimport) long double __cdecl strtold(
                        char const* _String,
        char**      _EndPtr
    );

 
__declspec(dllimport) long double __cdecl _strtold_l(
                        char const* _String,
        char**      _EndPtr,
                      _locale_t   _Locale
    );

 
__declspec(dllimport) long __cdecl strtol(
                        char const* _String,
        char**      _EndPtr,
                          int         _Radix
    );

 
__declspec(dllimport) long __cdecl _strtol_l(
                        char const* _String,
        char**      _EndPtr,
                          int         _Radix,
                      _locale_t   _Locale
    );

 
__declspec(dllimport) long long __cdecl strtoll(
                        char const* _String,
        char**      _EndPtr,
                          int         _Radix
    );

 
__declspec(dllimport) long long __cdecl _strtoll_l(
                        char const* _String,
        char**      _EndPtr,
                          int         _Radix,
                      _locale_t   _Locale
    );

 
__declspec(dllimport) unsigned long __cdecl strtoul(
                        char const* _String,
        char**      _EndPtr,
                          int         _Radix
    );

 
__declspec(dllimport) unsigned long __cdecl _strtoul_l(
                        char const* _String,
        char**      _EndPtr,
                          int         _Radix,
                      _locale_t   _Locale
    );

 
__declspec(dllimport) unsigned long long __cdecl strtoull(
                        char const* _String,
        char**      _EndPtr,
                          int         _Radix
    );

 
__declspec(dllimport) unsigned long long __cdecl _strtoull_l(
                        char const* _String,
        char**      _EndPtr,
                          int         _Radix,
                      _locale_t   _Locale
    );

 
__declspec(dllimport) __int64 __cdecl _strtoi64(
                        char const* _String,
        char**      _EndPtr,
                          int         _Radix
    );

 
__declspec(dllimport) __int64 __cdecl _strtoi64_l(
                        char const* _String,
        char**      _EndPtr,
                          int         _Radix,
                      _locale_t   _Locale
    );

 
__declspec(dllimport) unsigned __int64 __cdecl _strtoui64(
                        char const* _String,
        char**      _EndPtr,
                          int         _Radix
    );

 
__declspec(dllimport) unsigned __int64 __cdecl _strtoui64_l(
                        char const* _String,
        char**      _EndPtr,
                          int         _Radix,
                      _locale_t   _Locale
    );



//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// Number to Narrow String Conversions
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 

__declspec(dllimport) errno_t __cdecl _itoa_s(
                              int    _Value,
      char*  _Buffer,
                              size_t _BufferCount,
                              int    _Radix
    );

extern "C++" { template <size_t _Size> inline   errno_t __cdecl _itoa_s(  int _Value, char (&_Buffer)[_Size],   int _Radix) throw() { return _itoa_s(_Value, _Buffer, _Size, _Radix); } }

#pragma warning(push)
#pragma warning(disable: 28719) 
#pragma warning(disable: 28726) 
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_itoa_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) char* __cdecl _itoa( int _Value,   char *_Buffer,  int _Radix);
#pragma warning(pop)

 

__declspec(dllimport) errno_t __cdecl _ltoa_s(
                              long   _Value,
      char*  _Buffer,
                              size_t _BufferCount,
                              int    _Radix
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _ltoa_s(  long _Value, char (&_Buffer)[_Size],   int _Radix) throw() { return _ltoa_s(_Value, _Buffer, _Size, _Radix); } }

__declspec(deprecated("This function or variable may be unsafe. Consider using " "_ltoa_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) char* __cdecl _ltoa( long _Value,   char *_Buffer,  int _Radix);

 

__declspec(dllimport) errno_t __cdecl _ultoa_s(
                              unsigned long _Value,
      char*         _Buffer,
                              size_t        _BufferCount,
                              int           _Radix
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _ultoa_s(  unsigned long _Value, char (&_Buffer)[_Size],   int _Radix) throw() { return _ultoa_s(_Value, _Buffer, _Size, _Radix); } }

#pragma warning(push)
#pragma warning(disable: 28726) 
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_ultoa_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) char* __cdecl _ultoa( unsigned long _Value,   char *_Buffer,  int _Radix);
#pragma warning(pop)

 

__declspec(dllimport) errno_t __cdecl _i64toa_s(
                              __int64 _Value,
      char*   _Buffer,
                              size_t  _BufferCount,
                              int     _Radix
    );

 
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_i64toa_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__declspec(dllimport) char* __cdecl _i64toa(
                        __int64 _Value,
        char*   _Buffer,
                        int     _Radix
    );

 

__declspec(dllimport) errno_t __cdecl _ui64toa_s(
                              unsigned __int64 _Value,
      char*            _Buffer,
                              size_t           _BufferCount,
                              int              _Radix
    );

__declspec(deprecated("This function or variable may be unsafe. Consider using " "_ui64toa_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__declspec(dllimport) char* __cdecl _ui64toa(
                        unsigned __int64 _Value,
        char*            _Buffer,
                        int              _Radix
    );



// _CVTBUFSIZE is the maximum size for the per-thread conversion buffer.  It
// should be at least as long as the number of digits in the largest double
// precision value (?.?e308 in IEEE arithmetic).  We will use the same size
// buffer as is used in the printf support routines.
//
// (This value actually allows 40 additional decimal places; even though there
// are only 16 digits of accuracy in a double precision IEEE number, the user may
// ask for more to effect zero padding.)


 

__declspec(dllimport) errno_t __cdecl _ecvt_s(
      char* _Buffer,
       size_t                       _BufferCount,
       double                       _Value,
       int                          _DigitCount,
      int*                         _PtDec,
      int*                         _PtSign
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _ecvt_s(char (&_Buffer)[_Size],   double _Value,   int _DigitCount,   int* _PtDec,   int* _PtSign) throw() { return _ecvt_s(_Buffer, _Size, _Value, _DigitCount, _PtDec, _PtSign); } }

  __declspec(deprecated("This function or variable may be unsafe. Consider using " "_ecvt_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__declspec(dllimport) char* __cdecl _ecvt(
       double _Value,
       int    _DigitCount,
      int*   _PtDec,
      int*   _PtSign
    );

 

__declspec(dllimport) errno_t __cdecl _fcvt_s(
      char*  _Buffer,
                              size_t _BufferCount,
                              double _Value,
                              int    _FractionalDigitCount,
                             int*   _PtDec,
                             int*   _PtSign
    );

extern "C++" { template <size_t _Size> inline   errno_t __cdecl _fcvt_s(char (&_Buffer)[_Size],   double _Value,   int _FractionalDigitCount,   int* _PtDec,   int* _PtSign) throw() { return _fcvt_s(_Buffer, _Size, _Value, _FractionalDigitCount, _PtDec, _PtSign); } }

 
  __declspec(deprecated("This function or variable may be unsafe. Consider using " "_fcvt_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__declspec(dllimport) char* __cdecl _fcvt(
       double _Value,
       int    _FractionalDigitCount,
      int*   _PtDec,
      int*   _PtSign
    );

 
__declspec(dllimport) errno_t __cdecl _gcvt_s(
      char*  _Buffer,
                              size_t _BufferCount,
                              double _Value,
                              int    _DigitCount
    );

extern "C++" { template <size_t _Size> inline   errno_t __cdecl _gcvt_s(char (&_Buffer)[_Size],   double _Value,   int _DigitCount) throw() { return _gcvt_s(_Buffer, _Size, _Value, _DigitCount); } }

__declspec(deprecated("This function or variable may be unsafe. Consider using " "_gcvt_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__declspec(dllimport) char* __cdecl _gcvt(
                        double _Value,
                        int    _DigitCount,
        char*  _Buffer
    );



//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// Multibyte String Operations and Conversions
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
// Maximum number of bytes in multi-byte character in the current locale
// (also defined in ctype.h).

    


        
    

    


        
    

     
    __declspec(dllimport) int __cdecl ___mb_cur_max_func(void);

     
    __declspec(dllimport) int __cdecl ___mb_cur_max_l_func(_locale_t _Locale);




 
__declspec(dllimport) int __cdecl mblen(
        char const* _Ch,
                                             size_t      _MaxCount
    );

 
__declspec(dllimport) int __cdecl _mblen_l(
        char const* _Ch,
                                             size_t      _MaxCount,
                                         _locale_t   _Locale
    );

 
 
__declspec(dllimport) size_t __cdecl _mbstrlen(
      char const* _String
    );

 
 
__declspec(dllimport) size_t __cdecl _mbstrlen_l(
        char const* _String,
      _locale_t   _Locale
    );

 
 
__declspec(dllimport) size_t __cdecl _mbstrnlen(
      char const* _String,
        size_t      _MaxCount
    );

 
 
__declspec(dllimport) size_t __cdecl _mbstrnlen_l(
        char const* _String,
          size_t      _MaxCount,
      _locale_t   _Locale
    );

 
__declspec(dllimport) int __cdecl mbtowc(
                      wchar_t*    _DstCh,
      char const* _SrcCh,
                                      size_t      _SrcSizeInBytes
    );

 
__declspec(dllimport) int __cdecl _mbtowc_l(
                      wchar_t*    _DstCh,
      char const* _SrcCh,
                                      size_t      _SrcSizeInBytes,
                                  _locale_t   _Locale
    );


__declspec(dllimport) errno_t __cdecl mbstowcs_s(
                                                      size_t*     _PtNumOfCharConverted,
      wchar_t*    _DstBuf,
                                                           size_t      _SizeInWords,
                                     char const* _SrcBuf,
                                                           size_t      _MaxCount
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl mbstowcs_s(  size_t* _PtNumOfCharConverted,   wchar_t (&_Dest)[_Size],   char const* _Source,   size_t _MaxCount) throw() { return mbstowcs_s(_PtNumOfCharConverted, _Dest, _Size, _Source, _MaxCount); } }

__declspec(deprecated("This function or variable may be unsafe. Consider using " "mbstowcs_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) size_t __cdecl mbstowcs( wchar_t *_Dest,  char const* _Source,  size_t _MaxCount);


__declspec(dllimport) errno_t __cdecl _mbstowcs_s_l(
                                                      size_t*     _PtNumOfCharConverted,
      wchar_t*    _DstBuf,
                                                           size_t      _SizeInWords,
                                     char const* _SrcBuf,
                                                           size_t      _MaxCount,
                                                       _locale_t   _Locale
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _mbstowcs_s_l(  size_t* _PtNumOfCharConverted,   wchar_t (&_Dest)[_Size],   char const* _Source,   size_t _MaxCount,   _locale_t _Locale) throw() { return _mbstowcs_s_l(_PtNumOfCharConverted, _Dest, _Size, _Source, _MaxCount, _Locale); } }

__declspec(deprecated("This function or variable may be unsafe. Consider using " "_mbstowcs_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) size_t __cdecl _mbstowcs_l(  wchar_t *_Dest,   char const* _Source,   size_t _MaxCount,   _locale_t _Locale);




__declspec(deprecated("This function or variable may be unsafe. Consider using " "wctomb_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__declspec(dllimport) int __cdecl wctomb(
      char*   _MbCh,
                                wchar_t _WCh
    );

__declspec(deprecated("This function or variable may be unsafe. Consider using " "_wctomb_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__declspec(dllimport) int __cdecl _wctomb_l(
        char*     _MbCh,
                          wchar_t   _WCh,
                      _locale_t _Locale
    );



    
    __declspec(dllimport) errno_t __cdecl wctomb_s(
                                                         int*    _SizeConverted,
          char*   _MbCh,
                                                              rsize_t _SizeInBytes,
                                                              wchar_t _WCh
        );




__declspec(dllimport) errno_t __cdecl _wctomb_s_l(
                             int*     _SizeConverted,
      char*     _MbCh,
                                  size_t    _SizeInBytes,
                                  wchar_t   _WCh,
                              _locale_t _Locale);


__declspec(dllimport) errno_t __cdecl wcstombs_s(
                                                               size_t*        _PtNumOfCharConverted,
      char*          _Dst,
                                                                    size_t         _DstSizeInBytes,
                                                                  wchar_t const* _Src,
                                                                    size_t         _MaxCountInBytes
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl wcstombs_s(  size_t* _PtNumOfCharConverted,   char (&_Dest)[_Size],   wchar_t const* _Source,   size_t _MaxCount) throw() { return wcstombs_s(_PtNumOfCharConverted, _Dest, _Size, _Source, _MaxCount); } }

__declspec(deprecated("This function or variable may be unsafe. Consider using " "wcstombs_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) size_t __cdecl wcstombs( char *_Dest,  wchar_t const* _Source,  size_t _MaxCount);


__declspec(dllimport) errno_t __cdecl _wcstombs_s_l(
                                                               size_t*        _PtNumOfCharConverted,
      char*          _Dst,
                                                                    size_t         _DstSizeInBytes,
                                                                  wchar_t const* _Src,
                                                                    size_t         _MaxCountInBytes,
                                                                _locale_t      _Locale
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _wcstombs_s_l(  size_t* _PtNumOfCharConverted,   char (&_Dest)[_Size],   wchar_t const* _Source,   size_t _MaxCount,   _locale_t _Locale) throw() { return _wcstombs_s_l(_PtNumOfCharConverted, _Dest, _Size, _Source, _MaxCount, _Locale); } }

__declspec(deprecated("This function or variable may be unsafe. Consider using " "_wcstombs_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) size_t __cdecl _wcstombs_l(  char *_Dest,   wchar_t const* _Source,   size_t _MaxCount,   _locale_t _Locale);



//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// Path Manipulation
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
// Sizes for buffers used by the _makepath() and _splitpath() functions.
// note that the sizes include space for 0-terminator










 
 
__declspec(dllimport) __declspec(allocator) char* __cdecl _fullpath(
      char*       _Buffer,
                                char const* _Path,
                                  size_t      _BufferCount
    );




__declspec(dllimport) errno_t __cdecl _makepath_s(
      char*       _Buffer,
                              size_t      _BufferCount,
                        char const* _Drive,
                        char const* _Dir,
                        char const* _Filename,
                        char const* _Ext
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _makepath_s(char (&_Buffer)[_Size],   char const* _Drive,   char const* _Dir,   char const* _Filename,   char const* _Ext) throw() { return _makepath_s(_Buffer, _Size, _Drive, _Dir, _Filename, _Ext); } }

#pragma warning(push)
#pragma warning(disable: 28719) 
#pragma warning(disable: 28726) 
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_makepath_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) void __cdecl _makepath(  char *_Buffer,  char const* _Drive,  char const* _Dir,  char const* _Filename,  char const* _Ext);
#pragma warning(pop)

__declspec(deprecated("This function or variable may be unsafe. Consider using " "_splitpath_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__declspec(dllimport) void __cdecl _splitpath(
                        char const* _FullPath,
        char*       _Drive,
        char*       _Dir,
        char*       _Filename,
        char*       _Ext
    );


__declspec(dllimport) errno_t __cdecl _splitpath_s(
                                  char const* _FullPath,
         char*       _Drive,
                                    size_t      _DriveCount,
           char*       _Dir,
                                    size_t      _DirCount,
      char*       _Filename,
                                    size_t      _FilenameCount,
           char*       _Ext,
                                    size_t      _ExtCount
    );

extern "C++" { template <size_t _DriveSize, size_t _DirSize, size_t _NameSize, size_t _ExtSize> inline errno_t __cdecl _splitpath_s(   char const* _Dest,   char (&_Drive)[_DriveSize],   char (&_Dir)[_DirSize],   char (&_Name)[_NameSize],   char (&_Ext)[_ExtSize] ) throw() { return _splitpath_s(_Dest, _Drive, _DriveSize, _Dir, _DirSize, _Name, _NameSize, _Ext, _ExtSize); } }




 
__declspec(dllimport) errno_t __cdecl getenv_s(
                                 size_t*     _RequiredCount,
      char*       _Buffer,
                                  rsize_t     _BufferCount,
                                char const* _VarName
    );






__declspec(dllimport) int*       __cdecl __p___argc (void);
__declspec(dllimport) char***    __cdecl __p___argv (void);
__declspec(dllimport) wchar_t*** __cdecl __p___wargv(void);






    
    
    


__declspec(dllimport) char***    __cdecl __p__environ (void);
__declspec(dllimport) wchar_t*** __cdecl __p__wenviron(void);


    








    
    




// Sizes for buffers used by the getenv/putenv family of functions.





      __declspec(deprecated("This function or variable may be unsafe. Consider using " "_dupenv_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __declspec(dllimport) char* __cdecl getenv(
          char const* _VarName
        );

    extern "C++" { template <size_t _Size> inline errno_t __cdecl getenv_s(  size_t* _RequiredCount, char (&_Buffer)[_Size],   char const* _VarName) throw() { return getenv_s(_RequiredCount, _Buffer, _Size, _VarName); } }

    




    
    __declspec(dllimport) errno_t __cdecl _dupenv_s(
            char**      _Buffer,
                                                                            size_t*     _BufferCount,
                                                                               char const* _VarName
        );

    



    __declspec(dllimport) int __cdecl system(
          char const* _Command
        );

    // The functions below have declspecs in their declarations in the Windows
    // headers, causing PREfast to fire 6540 here
    #pragma warning (push)
    #pragma warning (disable:6540)

     
    __declspec(dllimport) int __cdecl _putenv(
          char const* _EnvString
        );

    
    __declspec(dllimport) errno_t __cdecl _putenv_s(
          char const* _Name,
          char const* _Value
        );

    #pragma warning (pop)

    __declspec(dllimport) errno_t __cdecl _searchenv_s(
                                char const* _Filename,
                                char const* _VarName,
          char*       _Buffer,
                                  size_t      _BufferCount
        );

    extern "C++" { template <size_t _Size> inline errno_t __cdecl _searchenv_s(  char const* _Filename,   char const* _VarName, char (&_Buffer)[_Size]) throw() { return _searchenv_s(_Filename, _VarName, _Buffer, _Size); } }

    __declspec(deprecated("This function or variable may be unsafe. Consider using " "_searchenv_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) void __cdecl _searchenv( char const* _Filename,  char const* _VarName,   char *_Buffer);

    // The Win32 API SetErrorMode, Beep and Sleep should be used instead.
    __declspec(deprecated("This function or variable has been superceded by newer library " "or operating system functionality. Consider using " "SetErrorMode" " " "instead. See online help for details."))
    __declspec(dllimport) void __cdecl _seterrormode(
          int _Mode
        );

    __declspec(deprecated("This function or variable has been superceded by newer library " "or operating system functionality. Consider using " "Beep" " " "instead. See online help for details."))
    __declspec(dllimport) void __cdecl _beep(
          unsigned _Frequency,
          unsigned _Duration
        );

    __declspec(deprecated("This function or variable has been superceded by newer library " "or operating system functionality. Consider using " "Sleep" " " "instead. See online help for details."))
    __declspec(dllimport) void __cdecl _sleep(
          unsigned long _Duration
        );




//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// Non-ANSI Names for Compatibility
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+


    




    
    

    #pragma warning(push)
    #pragma warning(disable: 4141) 

      __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_ecvt" ". See online help for details.")) __declspec(deprecated("This function or variable may be unsafe. Consider using " "_ecvt_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __declspec(dllimport) char* __cdecl ecvt(
           double _Value,
           int    _DigitCount,
          int*   _PtDec,
          int*   _PtSign
        );

      __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_fcvt" ". See online help for details.")) __declspec(deprecated("This function or variable may be unsafe. Consider using " "_fcvt_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __declspec(dllimport) char* __cdecl fcvt(
           double _Value,
           int    _FractionalDigitCount,
          int*   _PtDec,
          int*   _PtSign
        );

    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_gcvt" ". See online help for details.")) __declspec(deprecated("This function or variable may be unsafe. Consider using " "_fcvt_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __declspec(dllimport) char* __cdecl gcvt(
                            double _Value,
                            int    _DigitCount,
            char*  _DstBuf
        );

    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_itoa" ". See online help for details.")) __declspec(deprecated("This function or variable may be unsafe. Consider using " "_itoa_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __declspec(dllimport) char* __cdecl itoa(
                            int   _Value,
            char* _Buffer,
                            int   _Radix
        );

    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_ltoa" ". See online help for details.")) __declspec(deprecated("This function or variable may be unsafe. Consider using " "_ltoa_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __declspec(dllimport) char* __cdecl ltoa(
                            long  _Value,
            char* _Buffer,
                            int   _Radix
        );


    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_swab" ". See online help for details."))
    __declspec(dllimport) void __cdecl swab(
          char* _Buf1,
          char* _Buf2,
                                     int   _SizeInBytes
        );

    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_ultoa" ". See online help for details.")) __declspec(deprecated("This function or variable may be unsafe. Consider using " "_ultoa_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __declspec(dllimport) char* __cdecl ultoa(
                            unsigned long _Value,
            char*         _Buffer,
                            int           _Radix
        );

    

      __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_putenv" ". See online help for details."))
    __declspec(dllimport) int __cdecl putenv(
          char const* _EnvString
        );

    #pragma warning(pop)

    _onexit_t __cdecl onexit(  _onexit_t _Func);





} __pragma(pack(pop))



//
// math.h
//
//      Copyright (c) Microsoft Corporation. All rights reserved.
//
// The C Standard Library <math.h> header.  This header consists of two parts:
// <corecrt_math.h> contains the math library; <corecrt_math_defines.h> contains
// the nonstandard but useful constant definitions.  The headers are divided in
// this way for modularity (to support the C++ modules feature).
//

//
// corecrt_math.h
//
//      Copyright (c) Microsoft Corporation. All rights reserved.
//
// The majority of the C Standard Library <math.h> functionality.
//
#pragma once





__pragma(pack(push, 8)) extern "C" {

#pragma warning(push)
#pragma warning(disable:4738) 
#pragma warning(disable:4820) 




    // Definition of the _exception struct, which is passed to the matherr function
    // when a floating point exception is detected:
    struct _exception
    {
        int    type;   // exception type - see below
        char*  name;   // name of function where error occurred
        double arg1;   // first argument to function
        double arg2;   // second argument (if any) to function
        double retval; // value to be returned by function
    };

    // Definition of the _complex struct to be used by those who use the complex
    // functions and want type checking.
    
        

        struct _complex
        {
            double x, y; // real and imaginary parts
        };

        



    




// On x86, when not using /arch:SSE2 or greater, floating point operations
// are performed using the x87 instruction set and FLT_EVAL_METHOD is 2.
// (When /fp:fast is used, floating point operations may be consistent, so
// we use the default types.)




    typedef float  float_t;
    typedef double double_t;




// Constant definitions for the exception type passed in the _exception struct







// Definitions of _HUGE and HUGE_VAL - respectively the XENIX and ANSI names
// for a value returned in case of error by a number of the floating point
// math routines.

    
        extern double const _HUGE;
    





    



























// Values for use as arguments to the _fperrraise function





























// IEEE 754 double properties





// IEEE 754 float properties





// IEEE 754 long double properties













void __cdecl _fperrraise(  int _Except);

  __declspec(dllimport) short __cdecl _dclass(  double _X);
  __declspec(dllimport) short __cdecl _ldclass(  long double _X);
  __declspec(dllimport) short __cdecl _fdclass(  float _X);

  __declspec(dllimport) int __cdecl _dsign(  double _X);
  __declspec(dllimport) int __cdecl _ldsign(  long double _X);
  __declspec(dllimport) int __cdecl _fdsign(  float _X);

  __declspec(dllimport) int __cdecl _dpcomp(  double _X,   double _Y);
  __declspec(dllimport) int __cdecl _ldpcomp(  long double _X,   long double _Y);
  __declspec(dllimport) int __cdecl _fdpcomp(  float _X,   float _Y);

  __declspec(dllimport) short __cdecl _dtest(  double* _Px);
  __declspec(dllimport) short __cdecl _ldtest(  long double* _Px);
  __declspec(dllimport) short __cdecl _fdtest(  float* _Px);

__declspec(dllimport) short __cdecl _d_int(  double* _Px,   short _Xexp);
__declspec(dllimport) short __cdecl _ld_int(  long double* _Px,   short _Xexp);
__declspec(dllimport) short __cdecl _fd_int(  float* _Px,   short _Xexp);

__declspec(dllimport) short __cdecl _dscale(  double* _Px,   long _Lexp);
__declspec(dllimport) short __cdecl _ldscale(  long double* _Px,   long _Lexp);
__declspec(dllimport) short __cdecl _fdscale(  float* _Px,   long _Lexp);

__declspec(dllimport) short __cdecl _dunscale(  short* _Pex,   double* _Px);
__declspec(dllimport) short __cdecl _ldunscale(  short* _Pex,   long double* _Px);
__declspec(dllimport) short __cdecl _fdunscale(  short* _Pex,   float* _Px);

  __declspec(dllimport) short __cdecl _dexp(  double* _Px,   double _Y,   long _Eoff);
  __declspec(dllimport) short __cdecl _ldexp(  long double* _Px,   long double _Y,   long _Eoff);
  __declspec(dllimport) short __cdecl _fdexp(  float* _Px,   float _Y,   long _Eoff);

  __declspec(dllimport) short __cdecl _dnorm(  unsigned short* _Ps);
  __declspec(dllimport) short __cdecl _fdnorm(  unsigned short* _Ps);

  __declspec(dllimport) double __cdecl _dpoly(  double _X,   double const* _Tab,   int _N);
  __declspec(dllimport) long double __cdecl _ldpoly(  long double _X,   long double const* _Tab,   int _N);
  __declspec(dllimport) float __cdecl _fdpoly(  float _X,   float const* _Tab,   int _N);

  __declspec(dllimport) double __cdecl _dlog(  double _X,   int _Baseflag);
  __declspec(dllimport) long double __cdecl _ldlog(  long double _X,   int _Baseflag);
  __declspec(dllimport) float __cdecl _fdlog(  float _X,   int _Baseflag);

  __declspec(dllimport) double __cdecl _dsin(  double _X,   unsigned int _Qoff);
  __declspec(dllimport) long double __cdecl _ldsin(  long double _X,   unsigned int _Qoff);
  __declspec(dllimport) float __cdecl _fdsin(  float _X,   unsigned int _Qoff);

// double declarations
typedef union
{   // pun floating type as integer array
    unsigned short _Sh[4];
    double _Val;
} _double_val;

// float declarations
typedef union
{   // pun floating type as integer array
    unsigned short _Sh[2];
    float _Val;
} _float_val;

// long double declarations
typedef union
{   // pun floating type as integer array
    unsigned short _Sh[4];
    long double _Val;
} _ldouble_val;

typedef union
{   // pun float types as integer array
    unsigned short _Word[4];
    float _Float;
    double _Double;
    long double _Long_double;
} _float_const;

extern const _float_const _Denorm_C,  _Inf_C,  _Nan_C,  _Snan_C, _Hugeval_C;
extern const _float_const _FDenorm_C, _FInf_C, _FNan_C, _FSnan_C;
extern const _float_const _LDenorm_C, _LInf_C, _LNan_C, _LSnan_C;

extern const _float_const _Eps_C,  _Rteps_C;
extern const _float_const _FEps_C, _FRteps_C;
extern const _float_const _LEps_C, _LRteps_C;

extern const double      _Zero_C,  _Xbig_C;
extern const float       _FZero_C, _FXbig_C;
extern const long double _LZero_C, _LXbig_C;




























extern "C++"
{
      inline int fpclassify(  float _X) throw()
    {
        return _fdtest(&_X);
    }

      inline int fpclassify(  double _X) throw()
    {
        return _dtest(&_X);
    }

      inline int fpclassify(  long double _X) throw()
    {
        return _ldtest(&_X);
    }

      inline bool signbit(  float _X) throw()
    {
        return _fdsign(_X) != 0;
    }

      inline bool signbit(  double _X) throw()
    {
        return _dsign(_X) != 0;
    }

      inline bool signbit(  long double _X) throw()
    {
        return _ldsign(_X) != 0;
    }

      inline int _fpcomp(  float _X,   float _Y) throw()
    {
        return _fdpcomp(_X, _Y);
    }

      inline int _fpcomp(  double _X,   double _Y) throw()
    {
        return _dpcomp(_X, _Y);
    }

      inline int _fpcomp(  long double _X,   long double _Y) throw()
    {
        return _ldpcomp(_X, _Y);
    }

    template <class _Trc, class _Tre> struct _Combined_type
    {   // determine combined type
        typedef float _Type;
    };

    template <> struct _Combined_type<float, double>
    {   // determine combined type
        typedef double _Type;
    };

    template <> struct _Combined_type<float, long double>
    {   // determine combined type
        typedef long double _Type;
    };

    template <class _Ty, class _T2> struct _Real_widened
    {   // determine widened real type
        typedef long double _Type;
    };

    template <> struct _Real_widened<float, float>
    {   // determine widened real type
        typedef float _Type;
    };

    template <> struct _Real_widened<float, double>
    {   // determine widened real type
        typedef double _Type;
    };

    template <> struct _Real_widened<double, float>
    {   // determine widened real type
        typedef double _Type;
    };

    template <> struct _Real_widened<double, double>
    {   // determine widened real type
        typedef double _Type;
    };

    template <class _Ty> struct _Real_type
    {   // determine equivalent real type
        typedef double _Type;   // default is double
    };

    template <> struct _Real_type<float>
    {   // determine equivalent real type
        typedef float _Type;
    };

    template <> struct _Real_type<long double>
    {   // determine equivalent real type
        typedef long double _Type;
    };

    template <class _T1, class _T2>
      inline int _fpcomp(  _T1 _X,   _T2 _Y) throw()
    {   // compare _Left and _Right
        typedef typename _Combined_type<float,
            typename _Real_widened<
            typename _Real_type<_T1>::_Type,
            typename _Real_type<_T2>::_Type>::_Type>::_Type _Tw;
        return _fpcomp((_Tw)_X, (_Tw)_Y);
    }

    template <class _Ty>
      inline bool isfinite(  _Ty _X) throw()
    {
        return fpclassify(_X) <= 0;
    }

    template <class _Ty>
      inline bool isinf(  _Ty _X) throw()
    {
        return fpclassify(_X) == 1;
    }

    template <class _Ty>
      inline bool isnan(  _Ty _X) throw()
    {
        return fpclassify(_X) == 2;
    }

    template <class _Ty>
      inline bool isnormal(  _Ty _X) throw()
    {
        return fpclassify(_X) == (-1);
    }

    template <class _Ty1, class _Ty2>
      inline bool isgreater(  _Ty1 _X,   _Ty2 _Y) throw()
    {
        return (_fpcomp(_X, _Y) & 4) != 0;
    }

    template <class _Ty1, class _Ty2>
      inline bool isgreaterequal(  _Ty1 _X,   _Ty2 _Y) throw()
    {
        return (_fpcomp(_X, _Y) & (2 | 4)) != 0;
    }

    template <class _Ty1, class _Ty2>
      inline bool isless(  _Ty1 _X,   _Ty2 _Y) throw()
    {
        return (_fpcomp(_X, _Y) & 1) != 0;
    }

    template <class _Ty1, class _Ty2>
      inline bool islessequal(  _Ty1 _X,   _Ty2 _Y) throw()
    {
        return (_fpcomp(_X, _Y) & (1 | 2)) != 0;
    }

    template <class _Ty1, class _Ty2>
      inline bool islessgreater(  _Ty1 _X,   _Ty2 _Y) throw()
    {
        return (_fpcomp(_X, _Y) & (1 | 4)) != 0;
    }

    template <class _Ty1, class _Ty2>
      inline bool isunordered(  _Ty1 _X,   _Ty2 _Y) throw()
    {
        return _fpcomp(_X, _Y) == 0;
    }
}  // extern "C++"






      int       __cdecl abs(  int _X);
      long      __cdecl labs(  long _X);
      long long __cdecl llabs(  long long _X);

      double __cdecl acos(  double _X);
      double __cdecl asin(  double _X);
      double __cdecl atan(  double _X);
      double __cdecl atan2(  double _Y,   double _X);

      double __cdecl cos(  double _X);
      double __cdecl cosh(  double _X);
      double __cdecl exp(  double _X);
       double __cdecl fabs(  double _X);
      double __cdecl fmod(  double _X,   double _Y);
      double __cdecl log(  double _X);
      double __cdecl log10(  double _X);
      double __cdecl pow(  double _X,   double _Y);
      double __cdecl sin(  double _X);
      double __cdecl sinh(  double _X);
       double __cdecl sqrt(  double _X);
      double __cdecl tan(  double _X);
      double __cdecl tanh(  double _X);

      __declspec(dllimport) double    __cdecl acosh(  double _X);
      __declspec(dllimport) double    __cdecl asinh(  double _X);
      __declspec(dllimport) double    __cdecl atanh(  double _X);
      __declspec(dllimport)  double    __cdecl atof(  char const* _String);
      __declspec(dllimport)  double    __cdecl _atof_l(  char const* _String,   _locale_t _Locale);
      __declspec(dllimport) double    __cdecl _cabs(  struct _complex _Complex_value);
      __declspec(dllimport) double    __cdecl cbrt(  double _X);
      __declspec(dllimport) double    __cdecl ceil(  double _X);
      __declspec(dllimport) double    __cdecl _chgsign(  double _X);
      __declspec(dllimport) double    __cdecl copysign(  double _Number,   double _Sign);
      __declspec(dllimport) double    __cdecl _copysign(  double _Number,   double _Sign);
      __declspec(dllimport) double    __cdecl erf(  double _X);
      __declspec(dllimport) double    __cdecl erfc(  double _X);
      __declspec(dllimport) double    __cdecl exp2(  double _X);
      __declspec(dllimport) double    __cdecl expm1(  double _X);
      __declspec(dllimport) double    __cdecl fdim(  double _X,   double _Y);
      __declspec(dllimport) double    __cdecl floor(  double _X);
      __declspec(dllimport) double    __cdecl fma(  double _X,   double _Y,   double _Z);
      __declspec(dllimport) double    __cdecl fmax(  double _X,   double _Y);
      __declspec(dllimport) double    __cdecl fmin(  double _X,   double _Y);
      __declspec(dllimport) double    __cdecl frexp(  double _X,   int* _Y);
      __declspec(dllimport) double    __cdecl hypot(  double _X,   double _Y);
      __declspec(dllimport) double    __cdecl _hypot(  double _X,   double _Y);
      __declspec(dllimport) int       __cdecl ilogb(  double _X);
      __declspec(dllimport) double    __cdecl ldexp(  double _X,   int _Y);
      __declspec(dllimport) double    __cdecl lgamma(  double _X);
      __declspec(dllimport) long long __cdecl llrint(  double _X);
      __declspec(dllimport) long long __cdecl llround(  double _X);
      __declspec(dllimport) double    __cdecl log1p(  double _X);
      __declspec(dllimport) double    __cdecl log2(  double _X);
      __declspec(dllimport) double    __cdecl logb(  double _X);
      __declspec(dllimport) long      __cdecl lrint(  double _X);
      __declspec(dllimport) long      __cdecl lround(  double _X);

    int __cdecl _matherr(  struct _exception* _Except);

      __declspec(dllimport) double __cdecl modf(  double _X,   double* _Y);
      __declspec(dllimport) double __cdecl nan(  char const* _X);
      __declspec(dllimport) double __cdecl nearbyint(  double _X);
      __declspec(dllimport) double __cdecl nextafter(  double _X,   double _Y);
      __declspec(dllimport) double __cdecl nexttoward(  double _X,   long double _Y);
      __declspec(dllimport) double __cdecl remainder(  double _X,   double _Y);
      __declspec(dllimport) double __cdecl remquo(  double _X,   double _Y,   int* _Z);
      __declspec(dllimport) double __cdecl rint(  double _X);
      __declspec(dllimport) double __cdecl round(  double _X);
      __declspec(dllimport) double __cdecl scalbln(  double _X,   long _Y);
      __declspec(dllimport) double __cdecl scalbn(  double _X,   int _Y);
      __declspec(dllimport) double __cdecl tgamma(  double _X);
      __declspec(dllimport) double __cdecl trunc(  double _X);
      __declspec(dllimport) double __cdecl _j0(  double _X );
      __declspec(dllimport) double __cdecl _j1(  double _X );
      __declspec(dllimport) double __cdecl _jn(int _X,   double _Y);
      __declspec(dllimport) double __cdecl _y0(  double _X);
      __declspec(dllimport) double __cdecl _y1(  double _X);
      __declspec(dllimport) double __cdecl _yn(  int _X,   double _Y);

      __declspec(dllimport) float     __cdecl acoshf(  float _X);
      __declspec(dllimport) float     __cdecl asinhf(  float _X);
      __declspec(dllimport) float     __cdecl atanhf(  float _X);
      __declspec(dllimport) float     __cdecl cbrtf(  float _X);
      __declspec(dllimport) float     __cdecl _chgsignf(  float _X);
      __declspec(dllimport) float     __cdecl copysignf(  float _Number,   float _Sign);
      __declspec(dllimport) float     __cdecl _copysignf(  float _Number,   float _Sign);
      __declspec(dllimport) float     __cdecl erff(  float _X);
      __declspec(dllimport) float     __cdecl erfcf(  float _X);
      __declspec(dllimport) float     __cdecl expm1f(  float _X);
      __declspec(dllimport) float     __cdecl exp2f(  float _X);
      __declspec(dllimport) float     __cdecl fdimf(  float _X,   float _Y);
      __declspec(dllimport) float     __cdecl fmaf(  float _X,   float _Y,   float _Z);
      __declspec(dllimport) float     __cdecl fmaxf(  float _X,   float _Y);
      __declspec(dllimport) float     __cdecl fminf(  float _X,   float _Y);
      __declspec(dllimport) float     __cdecl _hypotf(  float _X,   float _Y);
      __declspec(dllimport) int       __cdecl ilogbf(  float _X);
      __declspec(dllimport) float     __cdecl lgammaf(  float _X);
      __declspec(dllimport) long long __cdecl llrintf(  float _X);
      __declspec(dllimport) long long __cdecl llroundf(  float _X);
      __declspec(dllimport) float     __cdecl log1pf(  float _X);
      __declspec(dllimport) float     __cdecl log2f(  float _X);
      __declspec(dllimport) float     __cdecl logbf(  float _X);
      __declspec(dllimport) long      __cdecl lrintf(  float _X);
      __declspec(dllimport) long      __cdecl lroundf(  float _X);
      __declspec(dllimport) float     __cdecl nanf(  char const* _X);
      __declspec(dllimport) float     __cdecl nearbyintf(  float _X);
      __declspec(dllimport) float     __cdecl nextafterf(  float _X,   float _Y);
      __declspec(dllimport) float     __cdecl nexttowardf(  float _X,   long double _Y);
      __declspec(dllimport) float     __cdecl remainderf(  float _X,   float _Y);
      __declspec(dllimport) float     __cdecl remquof(  float _X,   float _Y,   int* _Z);
      __declspec(dllimport) float     __cdecl rintf(  float _X);
      __declspec(dllimport) float     __cdecl roundf(  float _X);
      __declspec(dllimport) float     __cdecl scalblnf(  float _X,   long _Y);
      __declspec(dllimport) float     __cdecl scalbnf(  float _X,   int _Y);
      __declspec(dllimport) float     __cdecl tgammaf(  float _X);
      __declspec(dllimport) float     __cdecl truncf(  float _X);

    





    

          __declspec(dllimport) float __cdecl _logbf(  float _X);
          __declspec(dllimport) float __cdecl _nextafterf(  float _X,   float _Y);
          __declspec(dllimport) int   __cdecl _finitef(  float _X);
          __declspec(dllimport) int   __cdecl _isnanf(  float _X);
          __declspec(dllimport) int   __cdecl _fpclassf(  float _X);

          __declspec(dllimport) int   __cdecl _set_FMA3_enable(  int _Flag);
          __declspec(dllimport) int   __cdecl _get_FMA3_enable(void);

    








    

          __declspec(dllimport) float __cdecl acosf(  float _X);
          __declspec(dllimport) float __cdecl asinf(  float _X);
          __declspec(dllimport) float __cdecl atan2f(  float _Y,   float _X);
          __declspec(dllimport) float __cdecl atanf(  float _X);
          __declspec(dllimport) float __cdecl ceilf(  float _X);
          __declspec(dllimport) float __cdecl cosf(  float _X);
          __declspec(dllimport) float __cdecl coshf(  float _X);
          __declspec(dllimport) float __cdecl expf(  float _X);

    











































    





          __inline float __cdecl fabsf(  float _X)
        {
            return (float)fabs(_X);
        }

    

    

          __declspec(dllimport) float __cdecl floorf(  float _X);
          __declspec(dllimport) float __cdecl fmodf(  float _X,   float _Y);

    













      __inline float __cdecl frexpf(  float _X,   int *_Y)
    {
        return (float)frexp(_X, _Y);
    }

      __inline float __cdecl hypotf(  float _X,   float _Y)
    {
        return _hypotf(_X, _Y);
    }

      __inline float __cdecl ldexpf(  float _X,   int _Y)
    {
        return (float)ldexp(_X, _Y);
    }

    

          __declspec(dllimport) float  __cdecl log10f(  float _X);
          __declspec(dllimport) float  __cdecl logf(  float _X);
          __declspec(dllimport) float  __cdecl modff(  float _X,   float *_Y);
          __declspec(dllimport) float  __cdecl powf(  float _X,   float _Y);
          __declspec(dllimport) float  __cdecl sinf(  float _X);
          __declspec(dllimport) float  __cdecl sinhf(  float _X);
          __declspec(dllimport) float  __cdecl sqrtf(  float _X);
          __declspec(dllimport) float  __cdecl tanf(  float _X);
          __declspec(dllimport) float  __cdecl tanhf(  float _X);

    



















































      __declspec(dllimport) long double __cdecl acoshl(  long double _X);

      __inline long double __cdecl acosl(  long double _X)
    {
        return acos((double)_X);
    }

      __declspec(dllimport) long double __cdecl asinhl(  long double _X);

      __inline long double __cdecl asinl(  long double _X)
    {
        return asin((double)_X);
    }

      __inline long double __cdecl atan2l(  long double _Y,   long double _X)
    {
        return atan2((double)_Y, (double)_X);
    }

      __declspec(dllimport) long double __cdecl atanhl(  long double _X);

      __inline long double __cdecl atanl(  long double _X)
    {
        return atan((double)_X);
    }

      __declspec(dllimport) long double __cdecl cbrtl(  long double _X);

      __inline long double __cdecl ceill(  long double _X)
    {
        return ceil((double)_X);
    }

      __inline long double __cdecl _chgsignl(  long double _X)
    {
        return _chgsign((double)_X);
    }

      __declspec(dllimport) long double __cdecl copysignl(  long double _Number,   long double _Sign);

      __inline long double __cdecl _copysignl(  long double _Number,   long double _Sign)
    {
        return _copysign((double)_Number, (double)_Sign);
    }

      __inline long double __cdecl coshl(  long double _X)
    {
        return cosh((double)_X);
    }

      __inline long double __cdecl cosl(  long double _X)
    {
        return cos((double)_X);
    }

      __declspec(dllimport) long double __cdecl erfl(  long double _X);
      __declspec(dllimport) long double __cdecl erfcl(  long double _X);

      __inline long double __cdecl expl(  long double _X)
    {
        return exp((double)_X);
    }

      __declspec(dllimport) long double __cdecl exp2l(  long double _X);
      __declspec(dllimport) long double __cdecl expm1l(  long double _X);

      __inline long double __cdecl fabsl(  long double _X)
    {
        return fabs((double)_X);
    }

      __declspec(dllimport) long double __cdecl fdiml(  long double _X,   long double _Y);

      __inline long double __cdecl floorl(  long double _X)
    {
        return floor((double)_X);
    }

      __declspec(dllimport) long double __cdecl fmal(  long double _X,   long double _Y,   long double _Z);
      __declspec(dllimport) long double __cdecl fmaxl(  long double _X,   long double _Y);
      __declspec(dllimport) long double __cdecl fminl(  long double _X,   long double _Y);

      __inline long double __cdecl fmodl(  long double _X,   long double _Y)
    {
        return fmod((double)_X, (double)_Y);
    }

      __inline long double __cdecl frexpl(  long double _X,   int *_Y)
    {
        return frexp((double)_X, _Y);
    }

      __declspec(dllimport) int __cdecl ilogbl(  long double _X);

      __inline long double __cdecl _hypotl(  long double _X,   long double _Y)
    {
        return _hypot((double)_X, (double)_Y);
    }

      __inline long double __cdecl hypotl(  long double _X,   long double _Y)
    {
        return _hypot((double)_X, (double)_Y);
    }

      __inline long double __cdecl ldexpl(  long double _X,   int _Y)
    {
        return ldexp((double)_X, _Y);
    }

      __declspec(dllimport) long double __cdecl lgammal(  long double _X);
      __declspec(dllimport) long long __cdecl llrintl(  long double _X);
      __declspec(dllimport) long long __cdecl llroundl(  long double _X);

      __inline long double __cdecl logl(  long double _X)
    {
        return log((double)_X);
    }

      __inline long double __cdecl log10l(  long double _X)
    {
        return log10((double)_X);
    }

      __declspec(dllimport) long double __cdecl log1pl(  long double _X);
      __declspec(dllimport) long double __cdecl log2l(  long double _X);
      __declspec(dllimport) long double __cdecl logbl(  long double _X);
      __declspec(dllimport) long __cdecl lrintl(  long double _X);
      __declspec(dllimport) long __cdecl lroundl(  long double _X);

      __inline long double __cdecl modfl(  long double _X,   long double* _Y)
    {
        double _F, _I;
        _F = modf((double)_X, &_I);
        *_Y = _I;
        return _F;
    }

      __declspec(dllimport) long double __cdecl nanl(  char const* _X);
      __declspec(dllimport) long double __cdecl nearbyintl(  long double _X);
      __declspec(dllimport) long double __cdecl nextafterl(  long double _X,   long double _Y);
      __declspec(dllimport) long double __cdecl nexttowardl(  long double _X,   long double _Y);

      __inline long double __cdecl powl(  long double _X,   long double _Y)
    {
        return pow((double)_X, (double)_Y);
    }

      __declspec(dllimport) long double __cdecl remainderl(  long double _X,   long double _Y);
      __declspec(dllimport) long double __cdecl remquol(  long double _X,   long double _Y,   int* _Z);
      __declspec(dllimport) long double __cdecl rintl(  long double _X);
      __declspec(dllimport) long double __cdecl roundl(  long double _X);
      __declspec(dllimport) long double __cdecl scalblnl(  long double _X,   long _Y);
      __declspec(dllimport) long double __cdecl scalbnl(  long double _X,   int _Y);

      __inline long double __cdecl sinhl(  long double _X)
    {
        return sinh((double)_X);
    }

      __inline long double __cdecl sinl(  long double _X)
    {
        return sin((double)_X);
    }

      __inline long double __cdecl sqrtl(  long double _X)
    {
        return sqrt((double)_X);
    }

      __inline long double __cdecl tanhl(  long double _X)
    {
        return tanh((double)_X);
    }

      __inline long double __cdecl tanl(  long double _X)
    {
        return tan((double)_X);
    }

      __declspec(dllimport) long double __cdecl tgammal(  long double _X);
      __declspec(dllimport) long double __cdecl truncl(  long double _X);

    







    
    
    
    
    
    

    

    
        
            extern double HUGE;
        



        __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_j0" ". See online help for details."))   __declspec(dllimport) double __cdecl j0(  double _X);
        __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_j1" ". See online help for details."))   __declspec(dllimport) double __cdecl j1(  double _X);
        __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_jn" ". See online help for details."))   __declspec(dllimport) double __cdecl jn(  int _X,   double _Y);
        __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_y0" ". See online help for details."))   __declspec(dllimport) double __cdecl y0(  double _X);
        __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_y1" ". See online help for details."))   __declspec(dllimport) double __cdecl y1(  double _X);
        __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_yn" ". See online help for details."))   __declspec(dllimport) double __cdecl yn(  int _X,   double _Y);
    




#pragma warning(pop)

} __pragma(pack(pop))








#pragma pack(push,8)
#pragma warning(push,3)
#pragma warning(disable: 4455 4494  4619 4643 4702 4984 4988 )




// <stdlib.h> has abs(long) and abs(long long)
  inline double abs(  double _Xx) noexcept
	{
	return (:: fabs(_Xx));
	}

  inline float abs(  float _Xx) noexcept
	{
	return (:: fabsf(_Xx));
	}

  inline long double abs(  long double _Xx) noexcept
	{
	return (:: fabsl(_Xx));
	}

namespace std {
using :: size_t; using :: div_t; using :: ldiv_t;
using :: abort; using :: abs; using :: atexit;
using :: atof; using :: atoi; using :: atol;
using :: bsearch; using :: calloc; using :: div;
using :: exit; using :: free;
using :: labs; using :: ldiv; using :: malloc;
using :: mblen; using :: mbstowcs; using :: mbtowc;
using :: qsort; using :: rand; using :: realloc;
using :: srand; using :: strtod; using :: strtol;
using :: strtoul;
using :: wcstombs; using :: wctomb;

using :: lldiv_t;

 
using :: getenv;
using :: system;
 

using :: atoll; using :: llabs; using :: lldiv;
using :: strtof; using :: strtold;
using :: strtoll; using :: strtoull;

using :: _Exit; using :: at_quick_exit; using :: quick_exit;
}



#pragma warning(pop)
#pragma pack(pop)




/*
 * Copyright (c) by P.J. Plauger. All rights reserved.
 * Consult your license regarding permissions and restrictions.
V6.50:0009 */


#pragma pack(push,8)
#pragma warning(push,3)
#pragma warning(disable: 4455 4494  4619 4643 4702 4984 4988 )




  inline double pow(  double _Xx,   int _Yx) noexcept
	{
	if (_Yx == 2)
		return (_Xx * _Xx);

	return (:: pow(_Xx, static_cast<double>(_Yx)));
	}

  inline float acos(  float _Xx) noexcept
	{
	return (:: acosf(_Xx));
	}

  inline float acosh(  float _Xx) noexcept
	{
	return (:: acoshf(_Xx));
	}

  inline float asin(  float _Xx) noexcept
	{
	return (:: asinf(_Xx));
	}

  inline float asinh(  float _Xx) noexcept
	{
	return (:: asinhf(_Xx));
	}

  inline float atan(  float _Xx) noexcept
	{
	return (:: atanf(_Xx));
	}

  inline float atanh(  float _Xx) noexcept
	{
	return (:: atanhf(_Xx));
	}

  inline float atan2(  float _Yx,   float _Xx) noexcept
	{
	return (:: atan2f(_Yx, _Xx));
	}

  inline float cbrt(  float _Xx) noexcept
	{
	return (:: cbrtf(_Xx));
	}

  inline float ceil(  float _Xx) noexcept
	{
	return (:: ceilf(_Xx));
	}

  inline float copysign(  float _Number,
	  float _Sign) noexcept
	{
	return (:: copysignf(_Number, _Sign));
	}

  inline float cos(  float _Xx) noexcept
	{
	return (:: cosf(_Xx));
	}

  inline float cosh(  float _Xx) noexcept
	{
	return (:: coshf(_Xx));
	}

  inline float erf(  float _Xx) noexcept
	{
	return (:: erff(_Xx));
	}

  inline float erfc(  float _Xx) noexcept
	{
	return (:: erfcf(_Xx));
	}

  inline float exp(  float _Xx) noexcept
	{
	return (:: expf(_Xx));
	}

  inline float exp2(  float _Xx) noexcept
	{
	return (:: exp2f(_Xx));
	}

  inline float expm1(  float _Xx) noexcept
	{
	return (:: expm1f(_Xx));
	}

  inline float fabs(  float _Xx) noexcept
	{
	return (:: fabsf(_Xx));
	}

  inline float fdim(  float _Xx,   float _Yx) noexcept
	{
	return (:: fdimf(_Xx, _Yx));
	}

  inline float floor(  float _Xx) noexcept
	{
	return (:: floorf(_Xx));
	}

  inline float fma(  float _Xx,   float _Yx,
	  float _Zx) noexcept
	{
	return (:: fmaf(_Xx, _Yx, _Zx));
	}

  inline float fmax(  float _Xx,   float _Yx) noexcept
	{
	return (:: fmaxf(_Xx, _Yx));
	}

  inline float fmin(  float _Xx,   float _Yx) noexcept
	{
	return (:: fminf(_Xx, _Yx));
	}

  inline float fmod(  float _Xx,   float _Yx) noexcept
	{
	return (:: fmodf(_Xx, _Yx));
	}

  inline float frexp(  float _Xx,   int* _Yx) noexcept
	{
	return (:: frexpf(_Xx, _Yx));
	}

  inline float hypot(  float _Xx,   float _Yx) noexcept
	{
	return (:: hypotf(_Xx, _Yx));
	}

  inline int ilogb(  float _Xx) noexcept
	{
	return (:: ilogbf(_Xx));
	}

  inline float ldexp(  float _Xx,   int _Yx) noexcept
	{
	return (:: ldexpf(_Xx, _Yx));
	}

  inline float lgamma(  float _Xx) noexcept
	{
	return (:: lgammaf(_Xx));
	}

  inline long long llrint(  float _Xx) noexcept
	{
	return (:: llrintf(_Xx));
	}

  inline long long llround(  float _Xx) noexcept
	{
	return (:: llroundf(_Xx));
	}

  inline float log(  float _Xx) noexcept
	{
	return (:: logf(_Xx));
	}

  inline float log10(  float _Xx) noexcept
	{
	return (:: log10f(_Xx));
	}

  inline float log1p(  float _Xx) noexcept
	{
	return (:: log1pf(_Xx));
	}

  inline float log2(  float _Xx) noexcept
	{
	return (:: log2f(_Xx));
	}

  inline float logb(  float _Xx) noexcept
	{
	return (:: logbf(_Xx));
	}

  inline long lrint(  float _Xx) noexcept
	{
	return (:: lrintf(_Xx));
	}

  inline long lround(  float _Xx) noexcept
	{
	return (:: lroundf(_Xx));
	}

  inline float modf(  float _Xx,   float* _Yx) noexcept
	{
	return (:: modff(_Xx, _Yx));
	}

  inline float nearbyint(  float _Xx) noexcept
	{
	return (:: nearbyintf(_Xx));
	}

  inline float nextafter(  float _Xx,   float _Yx) noexcept
	{
	return (:: nextafterf(_Xx, _Yx));
	}

  inline float nexttoward(  float _Xx,
	  long double _Yx) noexcept
	{
	return (:: nexttowardf(_Xx, _Yx));
	}

  inline float pow(  float _Xx,
	  float _Yx) noexcept
	{
	return (:: powf(_Xx, _Yx));
	}

  inline float pow(  float _Xx,   int _Yx) noexcept
	{
	if (_Yx == 2)
		return (_Xx * _Xx);

	return (:: powf(_Xx, static_cast<float>(_Yx)));
	}

  inline float remainder(  float _Xx,   float _Yx) noexcept
	{
	return (:: remainderf(_Xx, _Yx));
	}

  inline float remquo(  float _Xx,   float _Yx,
	  int *_Zx) noexcept
	{
	return (:: remquof(_Xx, _Yx, _Zx));
	}

  inline float rint(  float _Xx) noexcept
	{
	return (:: rintf(_Xx));
	}

  inline float round(  float _Xx) noexcept
	{
	return (:: roundf(_Xx));
	}

  inline float scalbln(  float _Xx,   long _Yx) noexcept
	{
	return (:: scalblnf(_Xx, _Yx));
	}

  inline float scalbn(  float _Xx,   int _Yx) noexcept
	{
	return (:: scalbnf(_Xx, _Yx));
	}

  inline float sin(  float _Xx) noexcept
	{
	return (:: sinf(_Xx));
	}

  inline float sinh(  float _Xx) noexcept
	{
	return (:: sinhf(_Xx));
	}

  inline float sqrt(  float _Xx) noexcept
	{
	return (:: sqrtf(_Xx));
	}

  inline float tan(  float _Xx) noexcept
	{
	return (:: tanf(_Xx));
	}

  inline float tanh(  float _Xx) noexcept
	{
	return (:: tanhf(_Xx));
	}

  inline float tgamma(  float _Xx) noexcept
	{
	return (:: tgammaf(_Xx));
	}

  inline float trunc(  float _Xx) noexcept
	{
	return (:: truncf(_Xx));
	}

  inline long double acos(  long double _Xx) noexcept
	{
	return (:: acosl(_Xx));
	}

  inline long double acosh(  long double _Xx) noexcept
	{
	return (:: acoshl(_Xx));
	}

  inline long double asin(  long double _Xx) noexcept
	{
	return (:: asinl(_Xx));
	}

  inline long double asinh(  long double _Xx) noexcept
	{
	return (:: asinhl(_Xx));
	}

  inline long double atan(  long double _Xx) noexcept
	{
	return (:: atanl(_Xx));
	}

  inline long double atanh(  long double _Xx) noexcept
	{
	return (:: atanhl(_Xx));
	}

  inline long double atan2(  long double _Yx,
	  long double _Xx) noexcept
	{
	return (:: atan2l(_Yx, _Xx));
	}

  inline long double cbrt(  long double _Xx) noexcept
	{
	return (:: cbrtl(_Xx));
	}

  inline long double ceil(  long double _Xx) noexcept
	{
	return (:: ceill(_Xx));
	}

  inline long double copysign(  long double _Number,
	  long double _Sign) noexcept
	{
	return (:: copysignl(_Number, _Sign));
	}

  inline long double cos(  long double _Xx) noexcept
	{
	return (:: cosl(_Xx));
	}

  inline long double cosh(  long double _Xx) noexcept
	{
	return (:: coshl(_Xx));
	}

  inline long double erf(  long double _Xx) noexcept
	{
	return (:: erfl(_Xx));
	}

  inline long double erfc(  long double _Xx) noexcept
	{
	return (:: erfcl(_Xx));
	}

  inline long double exp(  long double _Xx) noexcept
	{
	return (:: expl(_Xx));
	}

  inline long double exp2(  long double _Xx) noexcept
	{
	return (:: exp2l(_Xx));
	}

  inline long double expm1(  long double _Xx) noexcept
	{
	return (:: expm1l(_Xx));
	}

  inline long double fabs(  long double _Xx) noexcept
	{
	return (:: fabsl(_Xx));
	}

  inline long double fdim(  long double _Xx,
	  long double _Yx) noexcept
	{
	return (:: fdiml(_Xx, _Yx));
	}

  inline long double floor(  long double _Xx) noexcept
	{
	return (:: floorl(_Xx));
	}

  inline long double fma(  long double _Xx,
	  long double _Yx,   long double _Zx) noexcept
	{
	return (:: fmal(_Xx, _Yx, _Zx));
	}

  inline long double fmax(  long double _Xx,
	  long double _Yx) noexcept
	{
	return (:: fmaxl(_Xx, _Yx));
	}

  inline long double fmin(  long double _Xx,
	  long double _Yx) noexcept
	{
	return (:: fminl(_Xx, _Yx));
	}

  inline long double fmod(  long double _Xx,
	  long double _Yx) noexcept
	{
	return (:: fmodl(_Xx, _Yx));
	}

  inline long double frexp(  long double _Xx,
	  int* _Yx) noexcept
	{
	return (:: frexpl(_Xx, _Yx));
	}

  inline long double hypot(  long double _Xx,
	  long double _Yx) noexcept
	{
	return (:: hypotl(_Xx, _Yx));
	}

  inline int ilogb(  long double _Xx) noexcept
	{
	return (:: ilogbl(_Xx));
	}

  inline long double ldexp(  long double _Xx,
	  int _Yx) noexcept
	{
	return (:: ldexpl(_Xx, _Yx));
	}

  inline long double lgamma(  long double _Xx) noexcept
	{
	return (:: lgammal(_Xx));
	}

  inline long long llrint(  long double _Xx) noexcept
	{
	return (:: llrintl(_Xx));
	}

  inline long long llround(  long double _Xx) noexcept
	{
	return (:: llroundl(_Xx));
	}

  inline long double log(  long double _Xx) noexcept
	{
	return (:: logl(_Xx));
	}

  inline long double log10(  long double _Xx) noexcept
	{
	return (:: log10l(_Xx));
	}

  inline long double log1p(  long double _Xx) noexcept
	{
	return (:: log1pl(_Xx));
	}

  inline long double log2(  long double _Xx) noexcept
	{
	return (:: log2l(_Xx));
	}

  inline long double logb(  long double _Xx) noexcept
	{
	return (:: logbl(_Xx));
	}

  inline long lrint(  long double _Xx) noexcept
	{
	return (:: lrintl(_Xx));
	}

  inline long lround(  long double _Xx) noexcept
	{
	return (:: lroundl(_Xx));
	}

  inline long double modf(  long double _Xx,
	  long double* _Yx) noexcept
	{
	return (:: modfl(_Xx, _Yx));
	}

  inline long double nearbyint(  long double _Xx) noexcept
	{
	return (:: nearbyintl(_Xx));
	}

  inline long double nextafter(  long double _Xx,
	  long double _Yx) noexcept
	{
	return (:: nextafterl(_Xx, _Yx));
	}

  inline long double nexttoward(  long double _Xx,
	  long double _Yx) noexcept
	{
	return (:: nexttowardl(_Xx, _Yx));
	}

  inline long double pow(  long double _Xx,
	  long double _Yx) noexcept
	{
	return (:: powl(_Xx, _Yx));
	}

  inline long double pow(  long double _Xx,
	  int _Yx) noexcept
	{
	if (_Yx == 2)
		return (_Xx * _Xx);

	return (:: powl(_Xx, static_cast<long double>(_Yx)));
	}

  inline long double remainder(  long double _Xx,
	  long double _Yx) noexcept
	{
	return (:: remainderl(_Xx, _Yx));
	}

  inline long double remquo(  long double _Xx,
	  long double _Yx,   int *_Zx) noexcept
	{
	return (:: remquol(_Xx, _Yx, _Zx));
	}

  inline long double rint(  long double _Xx) noexcept
	{
	return (:: rintl(_Xx));
	}

  inline long double round(  long double _Xx) noexcept
	{
	return (:: roundl(_Xx));
	}

  inline long double scalbln(  long double _Xx,
	  long _Yx) noexcept
	{
	return (:: scalblnl(_Xx, _Yx));
	}

  inline long double scalbn(  long double _Xx,
	  int _Yx) noexcept
	{
	return (:: scalbnl(_Xx, _Yx));
	}

  inline long double sin(  long double _Xx) noexcept
	{
	return (:: sinl(_Xx));
	}

  inline long double sinh(  long double _Xx) noexcept
	{
	return (:: sinhl(_Xx));
	}

  inline long double sqrt(  long double _Xx) noexcept
	{
	return (:: sqrtl(_Xx));
	}

  inline long double tan(  long double _Xx) noexcept
	{
	return (:: tanl(_Xx));
	}

  inline long double tanh(  long double _Xx) noexcept
	{
	return (:: tanhl(_Xx));
	}

  inline long double tgamma(  long double _Xx) noexcept
	{
	return (:: tgammal(_Xx));
	}

  inline long double trunc(  long double _Xx) noexcept
	{
	return (:: truncl(_Xx));
	}


/* xtgmath.h internal header */

 
#pragma once





// xtr1common internal header (core)
#pragma once





 #pragma pack(push,8)
 #pragma warning(push,3)
 #pragma warning(disable: 4455 4494  4619 4643 4702 4984 4988 )
 
 
 

namespace std {
	// STRUCT TEMPLATE integral_constant
template<class _Ty,
	_Ty _Val>
	struct integral_constant
	{	// convenient template for integral constant types
	static constexpr _Ty value = _Val;

	using value_type = _Ty;
	using type = integral_constant;

	constexpr operator value_type() const noexcept
		{	// return stored value
		return (value);
		}

	 constexpr value_type operator()() const noexcept
		{	// return stored value
		return (value);
		}
	};

	// ALIAS TEMPLATE bool_constant
template<bool _Val>
	using bool_constant = integral_constant<bool, _Val>;

using true_type = bool_constant<true>;
using false_type = bool_constant<false>;

	// STRUCT TEMPLATE enable_if
template<bool _Test,
	class _Ty = void>
	struct enable_if
	{	// type is undefined for assumed !_Test
	};

template<class _Ty>
	struct enable_if<true, _Ty>
	{	// type is _Ty for _Test
	using type = _Ty;
	};

template<bool _Test,
	class _Ty = void>
	using enable_if_t = typename enable_if<_Test, _Ty>::type;

	// STRUCT TEMPLATE conditional
template<bool _Test,
	class _Ty1,
	class _Ty2>
	struct conditional
	{	// type is _Ty2 for assumed !_Test
	using type = _Ty2;
	};

template<class _Ty1,
	class _Ty2>
	struct conditional<true, _Ty1, _Ty2>
	{	// type is _Ty1 for _Test
	using type = _Ty1;
	};

template<bool _Test,
	class _Ty1,
	class _Ty2>
	using conditional_t = typename conditional<_Test, _Ty1, _Ty2>::type;

	// STRUCT TEMPLATE is_same
template<class _Ty1,
	class _Ty2>
	struct is_same
		: false_type
	{	// determine whether _Ty1 and _Ty2 are the same type
	};

template<class _Ty1>
	struct is_same<_Ty1, _Ty1>
		: true_type
	{	// determine whether _Ty1 and _Ty2 are the same type
	};

template<class _Ty,
	class _Uty>
	 constexpr bool is_same_v = is_same<_Ty, _Uty>::value;

	// STRUCT TEMPLATE remove_const
template<class _Ty>
	struct remove_const
	{	// remove top level const qualifier
	using type = _Ty;
	};

template<class _Ty>
	struct remove_const<const _Ty>
	{	// remove top level const qualifier
	using type = _Ty;
	};

template<class _Ty>
	using remove_const_t = typename remove_const<_Ty>::type;

	// STRUCT TEMPLATE remove_volatile
template<class _Ty>
	struct remove_volatile
	{	// remove top level volatile qualifier
	using type = _Ty;
	};

template<class _Ty>
	struct remove_volatile<volatile _Ty>
	{	// remove top level volatile qualifier
	using type = _Ty;
	};

template<class _Ty>
	using remove_volatile_t = typename remove_volatile<_Ty>::type;

	// STRUCT TEMPLATE remove_cv
template<class _Ty>
	struct remove_cv
	{	// remove top level const and volatile qualifiers
	using type = _Ty;
	};

template<class _Ty>
	struct remove_cv<const _Ty>
	{	// remove top level const and volatile qualifiers
	using type = _Ty;
	};

template<class _Ty>
	struct remove_cv<volatile _Ty>
	{	// remove top level const and volatile qualifiers
	using type = _Ty;
	};

template<class _Ty>
	struct remove_cv<const volatile _Ty>
	{	// remove top level const and volatile qualifiers
	using type = _Ty;
	};

template<class _Ty>
	using remove_cv_t = typename remove_cv<_Ty>::type;

	// STRUCT TEMPLATE _Is_integral
template<class _Ty>
	struct _Is_integral
		: false_type
	{	// determine whether _Ty is integral
	};

template<>
	struct _Is_integral<bool>
		: true_type
	{	// determine whether _Ty is integral
	};

template<>
	struct _Is_integral<char>
		: true_type
	{	// determine whether _Ty is integral
	};

template<>
	struct _Is_integral<unsigned char>
		: true_type
	{	// determine whether _Ty is integral
	};

template<>
	struct _Is_integral<signed char>
		: true_type
	{	// determine whether _Ty is integral
	};

 
template<>
	struct _Is_integral<wchar_t>
		: true_type
	{	// determine whether _Ty is integral
	};
 

template<>
	struct _Is_integral<char16_t>
		: true_type
	{	// determine whether _Ty is integral
	};

template<>
	struct _Is_integral<char32_t>
		: true_type
	{	// determine whether _Ty is integral
	};

template<>
	struct _Is_integral<unsigned short>
		: true_type
	{	// determine whether _Ty is integral
	};

template<>
	struct _Is_integral<short>
		: true_type
	{	// determine whether _Ty is integral
	};

template<>
	struct _Is_integral<unsigned int>
		: true_type
	{	// determine whether _Ty is integral
	};

template<>
	struct _Is_integral<int>
		: true_type
	{	// determine whether _Ty is integral
	};

template<>
	struct _Is_integral<unsigned long>
		: true_type
	{	// determine whether _Ty is integral
	};

template<>
	struct _Is_integral<long>
		: true_type
	{	// determine whether _Ty is integral
	};

template<>
	struct _Is_integral<unsigned long long>
		: true_type
	{	// determine whether _Ty is integral
	};

template<>
	struct _Is_integral<long long>
		: true_type
	{	// determine whether _Ty is integral
	};

	// STRUCT TEMPLATE is_integral
template<class _Ty>
	struct is_integral
		: _Is_integral<remove_cv_t<_Ty>>::type
	{	// determine whether _Ty is integral
	};

template<class _Ty>
	 constexpr bool is_integral_v = is_integral<_Ty>::value;

	// STRUCT TEMPLATE _Is_floating_point
template<class _Ty>
	struct _Is_floating_point
		: false_type
	{	// determine whether _Ty is floating point
	};

template<>
	struct _Is_floating_point<float>
		: true_type
	{	// determine whether _Ty is floating point
	};

template<>
	struct _Is_floating_point<double>
		: true_type
	{	// determine whether _Ty is floating point
	};

template<>
	struct _Is_floating_point<long double>
		: true_type
	{	// determine whether _Ty is floating point
	};

	// STRUCT TEMPLATE is_floating_point
template<class _Ty>
	struct is_floating_point
		: _Is_floating_point<remove_cv_t<_Ty>>::type
	{	// determine whether _Ty is floating point
	};

template<class _Ty>
	 constexpr bool is_floating_point_v = is_floating_point<_Ty>::value;

	// STRUCT TEMPLATE is_arithmetic
template<class _Ty>
	struct is_arithmetic
		: bool_constant<is_integral_v<_Ty>
			|| is_floating_point_v<_Ty>>
	{	// determine whether _Ty is an arithmetic type
	};

template<class _Ty>
	 constexpr bool is_arithmetic_v = is_arithmetic<_Ty>::value;

	// STRUCT TEMPLATE remove_reference
template<class _Ty>
	struct remove_reference
	{	// remove reference
	using type = _Ty;
	};

template<class _Ty>
	struct remove_reference<_Ty&>
	{	// remove reference
	using type = _Ty;
	};

template<class _Ty>
	struct remove_reference<_Ty&&>
	{	// remove rvalue reference
	using type = _Ty;
	};

template<class _Ty>
	using remove_reference_t = typename remove_reference<_Ty>::type;

}
 
 
 #pragma warning(pop)
 #pragma pack(pop)



/*
 * Copyright (c) by P.J. Plauger. All rights reserved.
 * Consult your license regarding permissions and restrictions.
V6.50:0009 */



 #pragma pack(push,8)
 #pragma warning(push,3)
 #pragma warning(disable: 4455 4494  4619 4643 4702 4984 4988 )
 
 
 

namespace std {
template<class _Ty1,
	class _Ty2>
	using _Common_float_type_t =
		conditional_t<is_same_v<_Ty1, long double> || is_same_v<_Ty2, long double>, long double,
		conditional_t<is_same_v<_Ty1, float> && is_same_v<_Ty2, float>, float,
		double>>;	// find type for two-argument math function
}







































template<class _Ty1,
	class _Ty2,
	class = ::std:: enable_if_t<::std:: is_arithmetic_v<_Ty1> && ::std:: is_arithmetic_v<_Ty2>>>  inline
	::std:: _Common_float_type_t<_Ty1, _Ty2> pow(const _Ty1 _Left, const _Ty2 _Right)
	{	// bring mixed types to a common type
	using _Common = ::std:: _Common_float_type_t<_Ty1, _Ty2>;
	return (:: pow(static_cast<_Common>(_Left), static_cast<_Common>(_Right)));
	}

//_GENERIC_MATH1(abs, _CRTDEFAULT)	// has integer overloads
extern "C"    double __cdecl acos(  double); template<class _Ty, class = ::std:: enable_if_t<::std:: is_integral_v<_Ty>>>  inline double acos(_Ty _Left) { return (:: acos(static_cast<double>(_Left))); }
extern "C"    double __cdecl asin(  double); template<class _Ty, class = ::std:: enable_if_t<::std:: is_integral_v<_Ty>>>  inline double asin(_Ty _Left) { return (:: asin(static_cast<double>(_Left))); }
extern "C"    double __cdecl atan(  double); template<class _Ty, class = ::std:: enable_if_t<::std:: is_integral_v<_Ty>>>  inline double atan(_Ty _Left) { return (:: atan(static_cast<double>(_Left))); }
extern "C"    double __cdecl atan2(  double,   double); template<class _Ty1, class _Ty2, class = ::std:: enable_if_t<::std:: is_arithmetic_v<_Ty1> && ::std:: is_arithmetic_v<_Ty2>>>  inline ::std:: _Common_float_type_t<_Ty1, _Ty2> atan2(_Ty1 _Left, _Ty2 _Right) { using _Common = ::std:: _Common_float_type_t<_Ty1, _Ty2>; return (:: atan2(static_cast<_Common>(_Left), static_cast<_Common>(_Right))); }
extern "C"   __declspec(dllimport) double __cdecl ceil(  double); template<class _Ty, class = ::std:: enable_if_t<::std:: is_integral_v<_Ty>>>  inline double ceil(_Ty _Left) { return (:: ceil(static_cast<double>(_Left))); }
extern "C"    double __cdecl cos(  double); template<class _Ty, class = ::std:: enable_if_t<::std:: is_integral_v<_Ty>>>  inline double cos(_Ty _Left) { return (:: cos(static_cast<double>(_Left))); }
extern "C"    double __cdecl cosh(  double); template<class _Ty, class = ::std:: enable_if_t<::std:: is_integral_v<_Ty>>>  inline double cosh(_Ty _Left) { return (:: cosh(static_cast<double>(_Left))); }
extern "C"    double __cdecl exp(  double); template<class _Ty, class = ::std:: enable_if_t<::std:: is_integral_v<_Ty>>>  inline double exp(_Ty _Left) { return (:: exp(static_cast<double>(_Left))); }

extern "C"    double __cdecl fabs(  double); template<class _Ty, class = ::std:: enable_if_t<::std:: is_integral_v<_Ty>>>  inline double fabs(_Ty _Left) { return (:: fabs(static_cast<double>(_Left))); }

extern "C"   __declspec(dllimport) double __cdecl floor(  double); template<class _Ty, class = ::std:: enable_if_t<::std:: is_integral_v<_Ty>>>  inline double floor(_Ty _Left) { return (:: floor(static_cast<double>(_Left))); }
extern "C"    double __cdecl fmod(  double,   double); template<class _Ty1, class _Ty2, class = ::std:: enable_if_t<::std:: is_arithmetic_v<_Ty1> && ::std:: is_arithmetic_v<_Ty2>>>  inline ::std:: _Common_float_type_t<_Ty1, _Ty2> fmod(_Ty1 _Left, _Ty2 _Right) { using _Common = ::std:: _Common_float_type_t<_Ty1, _Ty2>; return (:: fmod(static_cast<_Common>(_Left), static_cast<_Common>(_Right))); }
extern "C"   __declspec(dllimport) double __cdecl frexp(  double,   int *); template<class _Ty, class = ::std:: enable_if_t<::std:: is_integral_v<_Ty>>>  inline double frexp(_Ty _Left,   int * _Arg2) { return (:: frexp(static_cast<double>(_Left), _Arg2)); }
extern "C"   __declspec(dllimport) double __cdecl ldexp(  double,   int); template<class _Ty, class = ::std:: enable_if_t<::std:: is_integral_v<_Ty>>>  inline double ldexp(_Ty _Left,   int _Arg2) { return (:: ldexp(static_cast<double>(_Left), _Arg2)); }
extern "C"    double __cdecl log(  double); template<class _Ty, class = ::std:: enable_if_t<::std:: is_integral_v<_Ty>>>  inline double log(_Ty _Left) { return (:: log(static_cast<double>(_Left))); }
extern "C"    double __cdecl log10(  double); template<class _Ty, class = ::std:: enable_if_t<::std:: is_integral_v<_Ty>>>  inline double log10(_Ty _Left) { return (:: log10(static_cast<double>(_Left))); }
//_GENERIC_MATH1(modf, _CRTDEFAULT)		// types must match
//_GENERIC_MATH2(pow, _CRTDEFAULT)	// hand crafted
extern "C"    double __cdecl sin(  double); template<class _Ty, class = ::std:: enable_if_t<::std:: is_integral_v<_Ty>>>  inline double sin(_Ty _Left) { return (:: sin(static_cast<double>(_Left))); }
extern "C"    double __cdecl sinh(  double); template<class _Ty, class = ::std:: enable_if_t<::std:: is_integral_v<_Ty>>>  inline double sinh(_Ty _Left) { return (:: sinh(static_cast<double>(_Left))); }
extern "C"    double __cdecl sqrt(  double); template<class _Ty, class = ::std:: enable_if_t<::std:: is_integral_v<_Ty>>>  inline double sqrt(_Ty _Left) { return (:: sqrt(static_cast<double>(_Left))); }
extern "C"    double __cdecl tan(  double); template<class _Ty, class = ::std:: enable_if_t<::std:: is_integral_v<_Ty>>>  inline double tan(_Ty _Left) { return (:: tan(static_cast<double>(_Left))); }
extern "C"    double __cdecl tanh(  double); template<class _Ty, class = ::std:: enable_if_t<::std:: is_integral_v<_Ty>>>  inline double tanh(_Ty _Left) { return (:: tanh(static_cast<double>(_Left))); }

		// C99 MATH FUNCTIONS

		// FUNCTION TEMPLATE fma

inline float _Fma(float _Left, float _Middle, float _Right)
	{	// call float fma
	return (:: fmaf(_Left, _Middle, _Right));
	}

inline double _Fma(double _Left, double _Middle, double _Right)
	{	// call double fma
	return (:: fma(_Left, _Middle, _Right));
	}

inline long double _Fma(long double _Left, long double _Middle,
	long double _Right)
	{	// call long double fma
	return (:: fmal(_Left, _Middle, _Right));
	}


template<class _Ty1,
	class _Ty2,
	class _Ty3,
	class = ::std:: enable_if_t<::std:: is_arithmetic_v<_Ty1> && ::std:: is_arithmetic_v<_Ty2>
		&& ::std:: is_arithmetic_v<_Ty3>>>  inline
	::std:: _Common_float_type_t<_Ty1, ::std:: _Common_float_type_t<_Ty2, _Ty3>>
	fma(_Ty1 _Left, _Ty2 _Middle, _Ty3 _Right)
	{	// bring mixed types to a common type
	using _Common = ::std:: _Common_float_type_t<_Ty1, ::std:: _Common_float_type_t<_Ty2, _Ty3>>;














	return (_Fma(static_cast<_Common>(_Left), static_cast<_Common>(_Middle), static_cast<_Common>(_Right)));

	}

		// FUNCTION TEMPLATE remquo

inline float _Remquo(float _Left, float _Right, int *_Pquo)
	{	// call float remquo
	return (:: remquof(_Left, _Right, _Pquo));
	}

inline double _Remquo(double _Left, double _Right, int *_Pquo)
	{	// call double remquo
	return (:: remquo(_Left, _Right, _Pquo));
	}

inline long double _Remquo(long double _Left, long double _Right, int *_Pquo)
	{	// call long double remquo
	return (:: remquol(_Left, _Right, _Pquo));
	}


template<class _Ty1,
	class _Ty2,
	class = ::std:: enable_if_t<::std:: is_arithmetic_v<_Ty1> && ::std:: is_arithmetic_v<_Ty2>>> inline
	::std:: _Common_float_type_t<_Ty1, _Ty2>
	remquo(_Ty1 _Left, _Ty2 _Right, int *_Pquo)
	{	// bring mixed types to a common type
	using _Common = ::std:: _Common_float_type_t<_Ty1, _Ty2>;














	return (_Remquo(static_cast<_Common>(_Left), static_cast<_Common>(_Right), _Pquo));

	}

extern "C"   __declspec(dllimport) double __cdecl acosh(  double); template<class _Ty, class = ::std:: enable_if_t<::std:: is_integral_v<_Ty>>>  inline double acosh(_Ty _Left) { return (:: acosh(static_cast<double>(_Left))); }
extern "C"   __declspec(dllimport) double __cdecl asinh(  double); template<class _Ty, class = ::std:: enable_if_t<::std:: is_integral_v<_Ty>>>  inline double asinh(_Ty _Left) { return (:: asinh(static_cast<double>(_Left))); }
extern "C"   __declspec(dllimport) double __cdecl atanh(  double); template<class _Ty, class = ::std:: enable_if_t<::std:: is_integral_v<_Ty>>>  inline double atanh(_Ty _Left) { return (:: atanh(static_cast<double>(_Left))); }
extern "C"   __declspec(dllimport) double __cdecl cbrt(  double); template<class _Ty, class = ::std:: enable_if_t<::std:: is_integral_v<_Ty>>>  inline double cbrt(_Ty _Left) { return (:: cbrt(static_cast<double>(_Left))); }
extern "C"   __declspec(dllimport) double __cdecl copysign(  double,   double); template<class _Ty1, class _Ty2, class = ::std:: enable_if_t<::std:: is_arithmetic_v<_Ty1> && ::std:: is_arithmetic_v<_Ty2>>>  inline ::std:: _Common_float_type_t<_Ty1, _Ty2> copysign(_Ty1 _Left, _Ty2 _Right) { using _Common = ::std:: _Common_float_type_t<_Ty1, _Ty2>; return (:: copysign(static_cast<_Common>(_Left), static_cast<_Common>(_Right))); }
extern "C"   __declspec(dllimport) double __cdecl erf(  double); template<class _Ty, class = ::std:: enable_if_t<::std:: is_integral_v<_Ty>>>  inline double erf(_Ty _Left) { return (:: erf(static_cast<double>(_Left))); }
extern "C"   __declspec(dllimport) double __cdecl erfc(  double); template<class _Ty, class = ::std:: enable_if_t<::std:: is_integral_v<_Ty>>>  inline double erfc(_Ty _Left) { return (:: erfc(static_cast<double>(_Left))); }
extern "C"   __declspec(dllimport) double __cdecl expm1(  double); template<class _Ty, class = ::std:: enable_if_t<::std:: is_integral_v<_Ty>>>  inline double expm1(_Ty _Left) { return (:: expm1(static_cast<double>(_Left))); }
extern "C"   __declspec(dllimport) double __cdecl exp2(  double); template<class _Ty, class = ::std:: enable_if_t<::std:: is_integral_v<_Ty>>>  inline double exp2(_Ty _Left) { return (:: exp2(static_cast<double>(_Left))); }
extern "C"   __declspec(dllimport) double __cdecl fdim(  double,   double); template<class _Ty1, class _Ty2, class = ::std:: enable_if_t<::std:: is_arithmetic_v<_Ty1> && ::std:: is_arithmetic_v<_Ty2>>>  inline ::std:: _Common_float_type_t<_Ty1, _Ty2> fdim(_Ty1 _Left, _Ty2 _Right) { using _Common = ::std:: _Common_float_type_t<_Ty1, _Ty2>; return (:: fdim(static_cast<_Common>(_Left), static_cast<_Common>(_Right))); }
//_GENERIC_MATH3(fma, _CRTSPECIAL)	// hand crafted
extern "C"   __declspec(dllimport) double __cdecl fmax(  double,   double); template<class _Ty1, class _Ty2, class = ::std:: enable_if_t<::std:: is_arithmetic_v<_Ty1> && ::std:: is_arithmetic_v<_Ty2>>>  inline ::std:: _Common_float_type_t<_Ty1, _Ty2> fmax(_Ty1 _Left, _Ty2 _Right) { using _Common = ::std:: _Common_float_type_t<_Ty1, _Ty2>; return (:: fmax(static_cast<_Common>(_Left), static_cast<_Common>(_Right))); }
extern "C"   __declspec(dllimport) double __cdecl fmin(  double,   double); template<class _Ty1, class _Ty2, class = ::std:: enable_if_t<::std:: is_arithmetic_v<_Ty1> && ::std:: is_arithmetic_v<_Ty2>>>  inline ::std:: _Common_float_type_t<_Ty1, _Ty2> fmin(_Ty1 _Left, _Ty2 _Right) { using _Common = ::std:: _Common_float_type_t<_Ty1, _Ty2>; return (:: fmin(static_cast<_Common>(_Left), static_cast<_Common>(_Right))); }
extern "C"   __declspec(dllimport) double __cdecl hypot(  double,   double); template<class _Ty1, class _Ty2, class = ::std:: enable_if_t<::std:: is_arithmetic_v<_Ty1> && ::std:: is_arithmetic_v<_Ty2>>>  inline ::std:: _Common_float_type_t<_Ty1, _Ty2> hypot(_Ty1 _Left, _Ty2 _Right) { using _Common = ::std:: _Common_float_type_t<_Ty1, _Ty2>; return (:: hypot(static_cast<_Common>(_Left), static_cast<_Common>(_Right))); }
extern "C"   __declspec(dllimport) int __cdecl ilogb(  double); template<class _Ty, class = ::std:: enable_if_t<::std:: is_integral_v<_Ty>>>  inline int ilogb(_Ty _Left) { return (:: ilogb(static_cast<double>(_Left))); }
extern "C"   __declspec(dllimport) double __cdecl lgamma(  double); template<class _Ty, class = ::std:: enable_if_t<::std:: is_integral_v<_Ty>>>  inline double lgamma(_Ty _Left) { return (:: lgamma(static_cast<double>(_Left))); }
extern "C"   __declspec(dllimport) long long __cdecl llrint(  double); template<class _Ty, class = ::std:: enable_if_t<::std:: is_integral_v<_Ty>>>  inline long long llrint(_Ty _Left) { return (:: llrint(static_cast<double>(_Left))); }
extern "C"   __declspec(dllimport) long long __cdecl llround(  double); template<class _Ty, class = ::std:: enable_if_t<::std:: is_integral_v<_Ty>>>  inline long long llround(_Ty _Left) { return (:: llround(static_cast<double>(_Left))); }
extern "C"   __declspec(dllimport) double __cdecl log1p(  double); template<class _Ty, class = ::std:: enable_if_t<::std:: is_integral_v<_Ty>>>  inline double log1p(_Ty _Left) { return (:: log1p(static_cast<double>(_Left))); }
extern "C"   __declspec(dllimport) double __cdecl log2(  double); template<class _Ty, class = ::std:: enable_if_t<::std:: is_integral_v<_Ty>>>  inline double log2(_Ty _Left) { return (:: log2(static_cast<double>(_Left))); }
extern "C"   __declspec(dllimport) double __cdecl logb(  double); template<class _Ty, class = ::std:: enable_if_t<::std:: is_integral_v<_Ty>>>  inline double logb(_Ty _Left) { return (:: logb(static_cast<double>(_Left))); }
extern "C"   __declspec(dllimport) long __cdecl lrint(  double); template<class _Ty, class = ::std:: enable_if_t<::std:: is_integral_v<_Ty>>>  inline long lrint(_Ty _Left) { return (:: lrint(static_cast<double>(_Left))); }
extern "C"   __declspec(dllimport) long __cdecl lround(  double); template<class _Ty, class = ::std:: enable_if_t<::std:: is_integral_v<_Ty>>>  inline long lround(_Ty _Left) { return (:: lround(static_cast<double>(_Left))); }
extern "C"   __declspec(dllimport) double __cdecl nearbyint(  double); template<class _Ty, class = ::std:: enable_if_t<::std:: is_integral_v<_Ty>>>  inline double nearbyint(_Ty _Left) { return (:: nearbyint(static_cast<double>(_Left))); }
extern "C"   __declspec(dllimport) double __cdecl nextafter(  double,   double); template<class _Ty1, class _Ty2, class = ::std:: enable_if_t<::std:: is_arithmetic_v<_Ty1> && ::std:: is_arithmetic_v<_Ty2>>>  inline ::std:: _Common_float_type_t<_Ty1, _Ty2> nextafter(_Ty1 _Left, _Ty2 _Right) { using _Common = ::std:: _Common_float_type_t<_Ty1, _Ty2>; return (:: nextafter(static_cast<_Common>(_Left), static_cast<_Common>(_Right))); }
extern "C"   __declspec(dllimport) double __cdecl nexttoward(  double,   long double); template<class _Ty, class = ::std:: enable_if_t<::std:: is_integral_v<_Ty>>>  inline double nexttoward(_Ty _Left,   long double _Arg2) { return (:: nexttoward(static_cast<double>(_Left), _Arg2)); }
extern "C"   __declspec(dllimport) double __cdecl remainder(  double,   double); template<class _Ty1, class _Ty2, class = ::std:: enable_if_t<::std:: is_arithmetic_v<_Ty1> && ::std:: is_arithmetic_v<_Ty2>>>  inline ::std:: _Common_float_type_t<_Ty1, _Ty2> remainder(_Ty1 _Left, _Ty2 _Right) { using _Common = ::std:: _Common_float_type_t<_Ty1, _Ty2>; return (:: remainder(static_cast<_Common>(_Left), static_cast<_Common>(_Right))); }
//_GENERIC_MATH2X(remquo, _CRTSPECIAL)	// hand crafted
extern "C"   __declspec(dllimport) double __cdecl rint(  double); template<class _Ty, class = ::std:: enable_if_t<::std:: is_integral_v<_Ty>>>  inline double rint(_Ty _Left) { return (:: rint(static_cast<double>(_Left))); }
extern "C"   __declspec(dllimport) double __cdecl round(  double); template<class _Ty, class = ::std:: enable_if_t<::std:: is_integral_v<_Ty>>>  inline double round(_Ty _Left) { return (:: round(static_cast<double>(_Left))); }
extern "C"   __declspec(dllimport) double __cdecl scalbln(  double,   long); template<class _Ty, class = ::std:: enable_if_t<::std:: is_integral_v<_Ty>>>  inline double scalbln(_Ty _Left,   long _Arg2) { return (:: scalbln(static_cast<double>(_Left), _Arg2)); }
extern "C"   __declspec(dllimport) double __cdecl scalbn(  double,   int); template<class _Ty, class = ::std:: enable_if_t<::std:: is_integral_v<_Ty>>>  inline double scalbn(_Ty _Left,   int _Arg2) { return (:: scalbn(static_cast<double>(_Left), _Arg2)); }
extern "C"   __declspec(dllimport) double __cdecl tgamma(  double); template<class _Ty, class = ::std:: enable_if_t<::std:: is_integral_v<_Ty>>>  inline double tgamma(_Ty _Left) { return (:: tgamma(static_cast<double>(_Left))); }
extern "C"   __declspec(dllimport) double __cdecl trunc(  double); template<class _Ty, class = ::std:: enable_if_t<::std:: is_integral_v<_Ty>>>  inline double trunc(_Ty _Left) { return (:: trunc(static_cast<double>(_Left))); }









 
 
 #pragma warning(pop)
 #pragma pack(pop)


 

/*
 * Copyright (c) by P.J. Plauger. All rights reserved.
 * Consult your license regarding permissions and restrictions.
V6.50:0009 */


namespace std {
using :: abs; using :: acos; using :: asin;
using :: atan; using :: atan2; using :: ceil;
using :: cos; using :: cosh; using :: exp;
using :: fabs; using :: floor; using :: fmod;
using :: frexp; using :: ldexp; using :: log;
using :: log10; using :: modf; using :: pow;
using :: sin; using :: sinh; using :: sqrt;
using :: tan; using :: tanh;

using :: acosf; using :: asinf;
using :: atanf; using :: atan2f; using :: ceilf;
using :: cosf; using :: coshf; using :: expf;
using :: fabsf; using :: floorf; using :: fmodf;
using :: frexpf; using :: ldexpf; using :: logf;
using :: log10f; using :: modff; using :: powf;
using :: sinf; using :: sinhf; using :: sqrtf;
using :: tanf; using :: tanhf;

using :: acosl; using :: asinl;
using :: atanl; using :: atan2l; using :: ceill;
using :: cosl; using :: coshl; using :: expl;
using :: fabsl; using :: floorl; using :: fmodl;
using :: frexpl; using :: ldexpl; using :: logl;
using :: log10l; using :: modfl; using :: powl;
using :: sinl; using :: sinhl; using :: sqrtl;
using :: tanl; using :: tanhl;

using :: float_t; using :: double_t;

using :: acosh; using :: asinh; using :: atanh;
using :: cbrt; using :: erf; using :: erfc;
using :: expm1; using :: exp2;
using :: hypot; using :: ilogb; using :: lgamma;
using :: log1p; using :: log2; using :: logb;
using :: llrint; using :: lrint; using :: nearbyint;
using :: rint; using :: llround; using :: lround;
using :: fdim; using :: fma; using :: fmax; using :: fmin;
using :: round; using :: trunc;
using :: remainder; using :: remquo;
using :: copysign; using :: nan; using :: nextafter;
using :: scalbn; using :: scalbln;
using :: nexttoward; using :: tgamma;

using :: acoshf; using :: asinhf; using :: atanhf;
using :: cbrtf; using :: erff; using :: erfcf;
using :: expm1f; using :: exp2f;
using :: hypotf; using :: ilogbf; using :: lgammaf;
using :: log1pf; using :: log2f; using :: logbf;
using :: llrintf; using :: lrintf; using :: nearbyintf;
using :: rintf; using :: llroundf; using :: lroundf;
using :: fdimf; using :: fmaf; using :: fmaxf; using :: fminf;
using :: roundf; using :: truncf;
using :: remainderf; using :: remquof;
using :: copysignf; using :: nanf;
using :: nextafterf; using :: scalbnf; using :: scalblnf;
using :: nexttowardf; using :: tgammaf;

using :: acoshl; using :: asinhl; using :: atanhl;
using :: cbrtl; using :: erfl; using :: erfcl;
using :: expm1l; using :: exp2l;
using :: hypotl; using :: ilogbl; using :: lgammal;
using :: log1pl; using :: log2l; using :: logbl;
using :: llrintl; using :: lrintl; using :: nearbyintl;
using :: rintl; using :: llroundl; using :: lroundl;
using :: fdiml; using :: fmal; using :: fmaxl; using :: fminl;
using :: roundl; using :: truncl;
using :: remainderl; using :: remquol;
using :: copysignl; using :: nanl;
using :: nextafterl; using :: scalbnl; using :: scalblnl;
using :: nexttowardl; using :: tgammal;

using :: fpclassify; using :: signbit;
using :: isfinite; using :: isinf;
using :: isnan; using :: isnormal;
using :: isgreater; using :: isgreaterequal;
using :: isless; using :: islessequal;
using :: islessgreater; using :: isunordered;
}





























































































































































































































































































































































































































































































#pragma warning(pop)
#pragma pack(pop)




/*
 * Copyright (c) by P.J. Plauger. All rights reserved.
 * Consult your license regarding permissions and restrictions.
V6.50:0009 */


// cstdio standard header
#pragma once






//
// stdio.h
//
//      Copyright (c) Microsoft Corporation. All rights reserved.
//
// The C Standard Library <stdio.h> header.
//
#pragma once





//
// corecrt_wstdio.h
//
//      Copyright (c) Microsoft Corporation. All rights reserved.
//
// This file declares the wide character (wchar_t) I/O functionality, shared by
// <stdio.h> and <wchar.h>.  It also defines several core I/O types, which are
// also shared by those two headers.
//
#pragma once



//
// corecrt_stdio_config.h
//
//      Copyright (c) Microsoft Corporation. All rights reserved.
//
// Per-module <stdio.h> configuration.
//
#pragma once



__pragma(pack(push, 8)) extern "C" {









    



    


        
    






// Predefine _CRT_STDIO_ISO_WIDE_SPECIFIERS to use ISO-conforming behavior for
// the wide string printf and scanf functions (%s, %c, and %[] specifiers).
//
// Predefine _CRT_STDIO_LEGACY_WIDE_SPECIFIERS to use VC++ 2013 and earlier behavior for
// the wide string printf and scanf functions (%s, %c, and %[] specifiers).
//
// Predefine _CRT_STDIO_ARBITRARY_WIDE_SPECIFIERS when building code that does
// not use these format specifiers without a length modifier and thus can be
// used with either the legacy (default) or the conforming mode.  (This option
// is intended for use by static libraries).

    















    
        


            #pragma detect_mismatch("_CRT_STDIO_ISO_WIDE_SPECIFIERS", "0")
        
    


// If we're compiling mixed managed code, make sure these inline functions are
// compiled as native to ensure that there is only one instance of each of the
// function-local static variables.





    // This function must not be inlined into callers to avoid ODR violations.  The
    // static local variable has different names in C and in C++ translation units.
       
    
    __declspec(noinline) __inline unsigned __int64* __cdecl __local_stdio_printf_options(void)
    {
        static unsigned __int64 _OptionsStorage;
        return &_OptionsStorage;
    }

    // This function must not be inlined into callers to avoid ODR violations.  The
    // static local variable has different names in C and in C++ translation units.
       
    
    __declspec(noinline) __inline unsigned __int64* __cdecl __local_stdio_scanf_options(void)
    {
        static unsigned __int64 _OptionsStorage;
        return &_OptionsStorage;
    }
























} __pragma(pack(pop))


__pragma(pack(push, 8)) extern "C" {


//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// Stream I/O Declarations Required by this Header
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

    
    typedef struct _iobuf
    {
        void* _Placeholder;
    } FILE;


__declspec(dllimport) FILE* __cdecl __acrt_iob_func(unsigned _Ix);










    //-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    //
    // Wide Character Stream I/O Functions
    //
    //-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    
    __declspec(dllimport) wint_t __cdecl fgetwc(
          FILE* _Stream
        );

    
    __declspec(dllimport) wint_t __cdecl _fgetwchar(void);

    
    __declspec(dllimport) wint_t __cdecl fputwc(
             wchar_t _Character,
          FILE*   _Stream);

    
    __declspec(dllimport) wint_t __cdecl _fputwchar(
          wchar_t _Character
        );

     
    __declspec(dllimport) wint_t __cdecl getwc(
          FILE* _Stream
        );

     
    __declspec(dllimport) wint_t __cdecl getwchar(void);


    
     
    __declspec(dllimport) wchar_t* __cdecl fgetws(
          wchar_t* _Buffer,
                                  int      _BufferCount,
                               FILE*    _Stream
        );

    
    __declspec(dllimport) int __cdecl fputws(
           wchar_t const* _Buffer,
          FILE*          _Stream
        );

    
     
    __declspec(dllimport) wchar_t* __cdecl _getws_s(
          wchar_t* _Buffer,
                                  size_t   _BufferCount
        );

    extern "C++" { template <size_t _Size> inline   wchar_t* __cdecl _getws_s( wchar_t (&_Buffer)[_Size]) throw() { return _getws_s(_Buffer, _Size); } }

    
    __declspec(dllimport) wint_t __cdecl putwc(
             wchar_t _Character,
          FILE*   _Stream
        );

    
    __declspec(dllimport) wint_t __cdecl putwchar(
          wchar_t _Character
        );

    
    __declspec(dllimport) int __cdecl _putws(
          wchar_t const* _Buffer
        );

    
    __declspec(dllimport) wint_t __cdecl ungetwc(
             wint_t _Character,
          FILE*  _Stream
        );

     
    __declspec(dllimport) FILE * __cdecl _wfdopen(
            int            _FileHandle,
          wchar_t const* _Mode
        );

      __declspec(deprecated("This function or variable may be unsafe. Consider using " "_wfopen_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __declspec(dllimport) FILE* __cdecl _wfopen(
          wchar_t const* _FileName,
          wchar_t const* _Mode
        );

    
    __declspec(dllimport) errno_t __cdecl _wfopen_s(
          FILE**         _Stream,
                             wchar_t const* _FileName,
                             wchar_t const* _Mode
        );

     
    __declspec(deprecated("This function or variable may be unsafe. Consider using " "_wfreopen_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __declspec(dllimport) FILE* __cdecl _wfreopen(
           wchar_t const* _FileName,
           wchar_t const* _Mode,
          FILE*          _OldStream
        );

    
    __declspec(dllimport) errno_t __cdecl _wfreopen_s(
          FILE**         _Stream,
                             wchar_t const* _FileName,
                             wchar_t const* _Mode,
                            FILE*          _OldStream
        );

     
    __declspec(dllimport) FILE* __cdecl _wfsopen(
          wchar_t const* _FileName,
          wchar_t const* _Mode,
            int            _ShFlag
        );

    __declspec(dllimport) void __cdecl _wperror(
          wchar_t const* _ErrorMessage
        );

    

         
        __declspec(dllimport) FILE* __cdecl _wpopen(
              wchar_t const* _Command,
              wchar_t const* _Mode
            );

    

    __declspec(dllimport) int __cdecl _wremove(
          wchar_t const* _FileName
        );

    
    

     
    __declspec(dllimport) __declspec(allocator) wchar_t* __cdecl _wtempnam(
          wchar_t const* _Directory,
          wchar_t const* _FilePrefix
        );

    

     
    
    __declspec(dllimport) errno_t __cdecl _wtmpnam_s(
          wchar_t* _Buffer,
                                  size_t   _BufferCount
        );

    extern "C++" { template <size_t _Size> inline   errno_t __cdecl _wtmpnam_s( wchar_t (&_Buffer)[_Size]) throw() { return _wtmpnam_s(_Buffer, _Size); } }

    __declspec(deprecated("This function or variable may be unsafe. Consider using " "_wtmpnam_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport)  wchar_t* __cdecl _wtmpnam(  wchar_t *_Buffer);



    //-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    //
    // I/O Synchronization and _nolock family of I/O functions
    //
    //-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    
    __declspec(dllimport) wint_t __cdecl _fgetwc_nolock(
          FILE* _Stream
        );

    
    __declspec(dllimport) wint_t __cdecl _fputwc_nolock(
             wchar_t _Character,
          FILE*   _Stream
        );

    
    __declspec(dllimport) wint_t __cdecl _getwc_nolock(
          FILE* _Stream
        );

    
    __declspec(dllimport) wint_t __cdecl _putwc_nolock(
             wchar_t _Character,
          FILE*   _Stream
        );

    
    __declspec(dllimport) wint_t __cdecl _ungetwc_nolock(
             wint_t _Character,
          FILE*  _Stream
        );

    







    // Variadic functions are not supported in managed code under /clr
    





    //-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    //
    // Wide Character Formatted Output Functions (Stream)
    //
    //-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    
    __declspec(dllimport) int __cdecl __stdio_common_vfwprintf(
                                             unsigned __int64 _Options,
                                          FILE*            _Stream,
            wchar_t const*   _Format,
                                         _locale_t        _Locale,
                                                va_list          _ArgList
        );

    
    __declspec(dllimport) int __cdecl __stdio_common_vfwprintf_s(
                                             unsigned __int64 _Options,
                                          FILE*            _Stream,
            wchar_t const*   _Format,
                                         _locale_t        _Locale,
                                                va_list          _ArgList
        );

    
    __declspec(dllimport) int __cdecl __stdio_common_vfwprintf_p(
                                             unsigned __int64 _Options,
                                          FILE*            _Stream,
            wchar_t const*   _Format,
                                         _locale_t        _Locale,
                                                va_list          _ArgList
        );

    
    __inline int __cdecl _vfwprintf_l(
                                          FILE*          const _Stream,
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
                                                va_list              _ArgList
        )
    


    {
        return __stdio_common_vfwprintf((*__local_stdio_printf_options()), _Stream, _Format, _Locale, _ArgList);
    }
    

    
    __inline int __cdecl vfwprintf(
                                FILE*          const _Stream,
            wchar_t const* const _Format,
                                      va_list              _ArgList
        )
    


    {
        return _vfwprintf_l(_Stream, _Format, 0, _ArgList);
    }
    

    
    __inline int __cdecl _vfwprintf_s_l(
                                          FILE*          const _Stream,
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
                                                va_list              _ArgList
        )
    


    {
        return __stdio_common_vfwprintf_s((*__local_stdio_printf_options()), _Stream, _Format, _Locale, _ArgList);
    }
    

    

        
        __inline int __cdecl vfwprintf_s(
                                    FILE*          const _Stream,
                wchar_t const* const _Format,
                                          va_list              _ArgList
            )
    


        {
            return _vfwprintf_s_l(_Stream, _Format, 0, _ArgList);
        }
    

    

    
    __inline int __cdecl _vfwprintf_p_l(
                                          FILE*          const _Stream,
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
                                                va_list              _ArgList
        )
    


    {
        return __stdio_common_vfwprintf_p((*__local_stdio_printf_options()), _Stream, _Format, _Locale, _ArgList);
    }
    

    
    __inline int __cdecl _vfwprintf_p(
                                FILE*          const _Stream,
            wchar_t const* const _Format,
                                      va_list              _ArgList
        )
    


    {
        return _vfwprintf_p_l(_Stream, _Format, 0, _ArgList);
    }
    

    
    __inline int __cdecl _vwprintf_l(
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
                                                va_list              _ArgList
        )
    


    {
        return _vfwprintf_l((__acrt_iob_func(1)), _Format, _Locale, _ArgList);
    }
    

    
    __inline int __cdecl vwprintf(
            wchar_t const* const _Format,
                                      va_list              _ArgList
        )
    


    {
        return _vfwprintf_l((__acrt_iob_func(1)), _Format, 0, _ArgList);
    }
    

    
    __inline int __cdecl _vwprintf_s_l(
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
                                                va_list              _ArgList
        )
    


    {
        return _vfwprintf_s_l((__acrt_iob_func(1)), _Format, _Locale, _ArgList);
    }
    

    

        
        __inline int __cdecl vwprintf_s(
                wchar_t const* const _Format,
                                          va_list              _ArgList
            )
    


        {
            return _vfwprintf_s_l((__acrt_iob_func(1)), _Format, 0, _ArgList);
        }
    

    

    
    __inline int __cdecl _vwprintf_p_l(
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
                                                va_list              _ArgList
        )
    


    {
        return _vfwprintf_p_l((__acrt_iob_func(1)), _Format, _Locale, _ArgList);
    }
    

    
    __inline int __cdecl _vwprintf_p(
            wchar_t const* const _Format,
                                      va_list              _ArgList
        )
    


    {
        return _vfwprintf_p_l((__acrt_iob_func(1)), _Format, 0, _ArgList);
    }
    

    
    __inline int __cdecl _fwprintf_l(
                                          FILE*          const _Stream,
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
        ...)
    


    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vfwprintf_l(_Stream, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    

    
    __inline int __cdecl fwprintf(
                                FILE*          const _Stream,
            wchar_t const* const _Format,
        ...)
    


    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vfwprintf_l(_Stream, _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    

    
    __inline int __cdecl _fwprintf_s_l(
                                          FILE*          const _Stream,
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
        ...)
    


    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vfwprintf_s_l(_Stream, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    

    

        
        __inline int __cdecl fwprintf_s(
                                    FILE*          const _Stream,
                wchar_t const* const _Format,
            ...)
    


        {
            int _Result;
            va_list _ArgList;
            ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
            _Result = _vfwprintf_s_l(_Stream, _Format, 0, _ArgList);
            ((void)(_ArgList = (va_list)0));
            return _Result;
        }
    

    

    
    __inline int __cdecl _fwprintf_p_l(
                                          FILE*          const _Stream,
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
        ...)
    


    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vfwprintf_p_l(_Stream, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    

    
    __inline int __cdecl _fwprintf_p(
                                FILE*          const _Stream,
            wchar_t const* const _Format,
        ...)
    


    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vfwprintf_p_l(_Stream, _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    

    
    __inline int __cdecl _wprintf_l(
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
        ...)
    


    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vfwprintf_l((__acrt_iob_func(1)), _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    

    
    __inline int __cdecl wprintf(
            wchar_t const* const _Format,
        ...)
    


    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vfwprintf_l((__acrt_iob_func(1)), _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    

    
    __inline int __cdecl _wprintf_s_l(
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
        ...)
    


    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vfwprintf_s_l((__acrt_iob_func(1)), _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    

    

        
        __inline int __cdecl wprintf_s(
                wchar_t const* const _Format,
            ...)
    


        {
            int _Result;
            va_list _ArgList;
            ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
            _Result = _vfwprintf_s_l((__acrt_iob_func(1)), _Format, 0, _ArgList);
            ((void)(_ArgList = (va_list)0));
            return _Result;
        }
    

    

    
    __inline int __cdecl _wprintf_p_l(
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
        ...)
    


    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vfwprintf_p_l((__acrt_iob_func(1)), _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    

    
    __inline int __cdecl _wprintf_p(
            wchar_t const* const _Format,
        ...)
    


    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vfwprintf_p_l((__acrt_iob_func(1)), _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    


    //-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    //
    // Wide Character Formatted Input Functions (Stream)
    //
    //-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    
    __declspec(dllimport) int __cdecl __stdio_common_vfwscanf(
                                            unsigned __int64 _Options,
                                         FILE*            _Stream,
            wchar_t const*   _Format,
                                        _locale_t        _Locale,
                                               va_list          _ArgList
        );

    
    __inline int __cdecl _vfwscanf_l(
          FILE*                                const _Stream,
            wchar_t const* const _Format,
                               _locale_t      const _Locale,
                                      va_list              _ArgList
        )
    


    {
        return __stdio_common_vfwscanf(
            (*__local_stdio_scanf_options ()),
            _Stream, _Format, _Locale, _ArgList);
    }
    

    
    __inline int __cdecl vfwscanf(
          FILE*                                const _Stream,
            wchar_t const* const _Format,
                                      va_list              _ArgList
        )
    


    {
        return _vfwscanf_l(_Stream, _Format, 0, _ArgList);
    }
    

    
    __inline int __cdecl _vfwscanf_s_l(
                                FILE*          const _Stream,
            wchar_t const* const _Format,
                               _locale_t      const _Locale,
                                      va_list              _ArgList
        )
    


    {
        return __stdio_common_vfwscanf(
            (*__local_stdio_scanf_options ()) | (1ULL << 0),
            _Stream, _Format, _Locale, _ArgList);
    }
    

    

        
        __inline int __cdecl vfwscanf_s(
                                    FILE*          const _Stream,
                wchar_t const* const _Format,
                                          va_list              _ArgList
            )
    


        {
            return _vfwscanf_s_l(_Stream, _Format, 0, _ArgList);
        }
    

    

    __inline int __cdecl _vwscanf_l(
            wchar_t const* const _Format,
                               _locale_t      const _Locale,
                                      va_list              _ArgList
        )
    


    {
        return _vfwscanf_l((__acrt_iob_func(0)), _Format, _Locale, _ArgList);
    }
    

    
    __inline int __cdecl vwscanf(
            wchar_t const* const _Format,
                                      va_list              _ArgList
        )
    


    {
        return _vfwscanf_l((__acrt_iob_func(0)), _Format, 0, _ArgList);
    }
    

    
    __inline int __cdecl _vwscanf_s_l(
            wchar_t const* const _Format,
                               _locale_t      const _Locale,
                                      va_list              _ArgList
        )
    


    {
        return _vfwscanf_s_l((__acrt_iob_func(0)), _Format, _Locale, _ArgList);
    }
    

    

        
        __inline int __cdecl vwscanf_s(
                wchar_t const* const _Format,
                                          va_list              _ArgList
            )
    


        {
            return _vfwscanf_s_l((__acrt_iob_func(0)), _Format, 0, _ArgList);
        }
    

    

     __declspec(deprecated("This function or variable may be unsafe. Consider using " "_fwscanf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl _fwscanf_l(
                                         FILE*          const _Stream,
            wchar_t const* const _Format,
                                        _locale_t      const _Locale,
        ...)
    


    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vfwscanf_l(_Stream, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    

      __declspec(deprecated("This function or variable may be unsafe. Consider using " "fwscanf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl fwscanf(
                               FILE*          const _Stream,
            wchar_t const* const _Format,
        ...)
    


    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vfwscanf_l(_Stream, _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    

    
    __inline int __cdecl _fwscanf_s_l(
                                           FILE*          const _Stream,
            wchar_t const* const _Format,
                                          _locale_t      const _Locale,
        ...)
    


    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vfwscanf_s_l(_Stream, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    

    

        
        __inline int __cdecl fwscanf_s(
                                     FILE*          const _Stream,
                wchar_t const* const _Format,
            ...)
    


        {
            int _Result;
            va_list _ArgList;
            ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
            _Result = _vfwscanf_s_l(_Stream, _Format, 0, _ArgList);
            ((void)(_ArgList = (va_list)0));
            return _Result;
        }
    

    

     __declspec(deprecated("This function or variable may be unsafe. Consider using " "_wscanf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl _wscanf_l(
            wchar_t const* const _Format,
                                        _locale_t      const _Locale,
        ...)
    


    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vfwscanf_l((__acrt_iob_func(0)), _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    

      __declspec(deprecated("This function or variable may be unsafe. Consider using " "wscanf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl wscanf(
            wchar_t const* const _Format,
        ...)
    


    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vfwscanf_l((__acrt_iob_func(0)), _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    

    
    __inline int __cdecl _wscanf_s_l(
            wchar_t const* const _Format,
                                          _locale_t      const _Locale,
        ...)
    


    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vfwscanf_s_l((__acrt_iob_func(0)), _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    

    

        
        __inline int __cdecl wscanf_s(
                wchar_t const* const _Format,
            ...)
    


        {
            int _Result;
            va_list _ArgList;
            ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
            _Result = _vfwscanf_s_l((__acrt_iob_func(0)), _Format, 0, _ArgList);
            ((void)(_ArgList = (va_list)0));
            return _Result;
        }
    

    



    //-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    //
    // Wide Character Formatted Output Functions (String)
    //
    //-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    
        



    



     
    
    __declspec(dllimport) int __cdecl __stdio_common_vswprintf(
                                             unsigned __int64 _Options,
                 wchar_t*         _Buffer,
                                             size_t           _BufferCount,
            wchar_t const*   _Format,
                                         _locale_t        _Locale,
                                                va_list          _ArgList
        );

     
    
    __declspec(dllimport) int __cdecl __stdio_common_vswprintf_s(
                                             unsigned __int64 _Options,
                     wchar_t*         _Buffer,
                                             size_t           _BufferCount,
            wchar_t const*   _Format,
                                         _locale_t        _Locale,
                                                va_list          _ArgList
        );

     
    
    __declspec(dllimport) int __cdecl __stdio_common_vsnwprintf_s(
                                             unsigned __int64 _Options,
                 wchar_t*         _Buffer,
                                             size_t           _BufferCount,
                                             size_t           _MaxCount,
            wchar_t const*   _Format,
                                         _locale_t        _Locale,
                                                va_list          _ArgList
        );

     
    
    __declspec(dllimport) int __cdecl __stdio_common_vswprintf_p(
                                             unsigned __int64 _Options,
                     wchar_t*         _Buffer,
                                             size_t           _BufferCount,
            wchar_t const*   _Format,
                                         _locale_t        _Locale,
                                                va_list          _ArgList
        );

     
     __declspec(deprecated("This function or variable may be unsafe. Consider using " "_vsnwprintf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl _vsnwprintf_l(
            wchar_t*       const _Buffer,
                                                  size_t         const _BufferCount,
                 wchar_t const* const _Format,
                                              _locale_t      const _Locale,
                                                     va_list              _ArgList
        )
    


    {
        int const _Result = __stdio_common_vswprintf(
            (*__local_stdio_printf_options()) | (1ULL << 0),
            _Buffer, _BufferCount, _Format, _Locale, _ArgList);

        return _Result < 0 ? -1 : _Result;
    }
    

    #pragma warning(push)
    #pragma warning(disable: 4793)

     
    
    __inline int __cdecl _vsnwprintf_s_l(
           wchar_t*       const _Buffer,
                                                       size_t         const _BufferCount,
                                                       size_t         const _MaxCount,
                      wchar_t const* const _Format,
                                                   _locale_t      const _Locale,
                                                          va_list              _ArgList
        )
    


    {
        int const _Result = __stdio_common_vsnwprintf_s(
            (*__local_stdio_printf_options()),
            _Buffer, _BufferCount, _MaxCount, _Format, _Locale, _ArgList);

        return _Result < 0 ? -1 : _Result;
    }
    

     
    
    __inline int __cdecl _vsnwprintf_s(
           wchar_t*       const _Buffer,
                                                       size_t         const _BufferCount,
                                                       size_t         const _MaxCount,
                                wchar_t const* const _Format,
                                                          va_list              _ArgList
        )
    


    {
        return _vsnwprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, 0, _ArgList);
    }
    

    __declspec(deprecated("This function or variable may be unsafe. Consider using " "_snwprintf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __inline   int __cdecl _snwprintf(    wchar_t *_Buffer,   size_t _BufferCount,     wchar_t const* _Format, ...); __declspec(deprecated("This function or variable may be unsafe. Consider using " "_vsnwprintf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __inline   int __cdecl _vsnwprintf(    wchar_t *_Buffer,   size_t _BufferCount,     wchar_t const* _Format, va_list _Args);

    #pragma warning(pop)

     
     __declspec(deprecated("This function or variable may be unsafe. Consider using " "_vsnwprintf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl _vsnwprintf(
            wchar_t*       _Buffer,
                                                  size_t         _BufferCount,
                           wchar_t const* _Format,
                                                     va_list        _ArgList
        )
    


    {
        #pragma warning(push)
        #pragma warning(disable: 4996) 
        return _vsnwprintf_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
        #pragma warning(pop)
    }
    

    extern "C++" { template <size_t _Size> inline   int __cdecl _vsnwprintf_s( wchar_t (&_Buffer)[_Size],   size_t _BufferCount,     wchar_t const* _Format, va_list _ArgList) throw() { return _vsnwprintf_s(_Buffer, _Size, _BufferCount, _Format, _ArgList); } }

     
    
    __inline int __cdecl _vswprintf_c_l(
           wchar_t*       const _Buffer,
                                                       size_t         const _BufferCount,
                      wchar_t const* const _Format,
                                                   _locale_t      const _Locale,
                                                          va_list              _ArgList
        )
    


    {
        int const _Result = __stdio_common_vswprintf(
            (*__local_stdio_printf_options()),
            _Buffer, _BufferCount, _Format, _Locale, _ArgList);

        return _Result < 0 ? -1 : _Result;
    }
    

     
    
    __inline int __cdecl _vswprintf_c(
           wchar_t*       const _Buffer,
                                                       size_t         const _BufferCount,
                                wchar_t const* const _Format,
                                                          va_list              _ArgList
        )
    


    {
        return _vswprintf_c_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
    }
    

     
    
    __inline int __cdecl _vswprintf_l(
           wchar_t*       const _Buffer,
                                                       size_t         const _BufferCount,
                      wchar_t const* const _Format,
                                                   _locale_t      const _Locale,
                                                          va_list              _ArgList
        )
    


    {
        #pragma warning(push)
        #pragma warning(disable: 4996) 
        return _vswprintf_c_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
        #pragma warning(pop)
    }
    

     
    
    __inline int __cdecl __vswprintf_l(
                  wchar_t*       const _Buffer,
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
                                                va_list              _ArgList
        )
    


    {
        return _vswprintf_l(_Buffer, (size_t)-1, _Format, _Locale, _ArgList);
    }
    

     
    
    __inline int __cdecl _vswprintf(
           wchar_t*       const _Buffer,
               wchar_t const* const _Format,
                                         va_list              _ArgList
        )
    


    {
        return _vswprintf_l(_Buffer, (size_t)-1, _Format, 0, _ArgList);
    }
    

     
    
    __inline int __cdecl vswprintf(
           wchar_t*       const _Buffer,
                                                       size_t         const _BufferCount,
                      wchar_t const* const _Format,
                                                          va_list              _ArgList
        )
    


    {
        return _vswprintf_c_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
    }
    

     
    
    __inline int __cdecl _vswprintf_s_l(
           wchar_t*       const _Buffer,
                                                   size_t         const _BufferCount,
                  wchar_t const* const _Format,
                                               _locale_t      const _Locale,
                                                      va_list              _ArgList
        )
    


    {
        int const _Result = __stdio_common_vswprintf_s(
            (*__local_stdio_printf_options()),
            _Buffer, _BufferCount, _Format, _Locale, _ArgList);

        return _Result < 0 ? -1 : _Result;
    }
    

    

         
        __inline int __cdecl vswprintf_s(
               wchar_t*       const _Buffer,
                                                       size_t         const _BufferCount,
                                wchar_t const* const _Format,
                                                          va_list              _ArgList
            )
    


        {
            return _vswprintf_s_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
        }
    

    

    extern "C++" { template <size_t _Size> inline   int __cdecl vswprintf_s( wchar_t (&_Buffer)[_Size],     wchar_t const* _Format, va_list _ArgList) throw() { return vswprintf_s(_Buffer, _Size, _Format, _ArgList); } }

     
    
    __inline int __cdecl _vswprintf_p_l(
           wchar_t*       const _Buffer,
                                                   size_t         const _BufferCount,
                  wchar_t const* const _Format,
                                               _locale_t      const _Locale,
                                                      va_list              _ArgList
        )
    


    {
        int const _Result = __stdio_common_vswprintf_p(
            (*__local_stdio_printf_options()),
            _Buffer, _BufferCount, _Format, _Locale, _ArgList);

        return _Result < 0 ? -1 : _Result;
    }
    

     
    
    __inline int __cdecl _vswprintf_p(
           wchar_t*       const _Buffer,
                                                   size_t         const _BufferCount,
                            wchar_t const* const _Format,
                                                      va_list              _ArgList
        )
    


    {
        return _vswprintf_p_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
    }
    

     
     
    __inline int __cdecl _vscwprintf_l(
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
                                                va_list              _ArgList
        )
    


    {
        int const _Result = __stdio_common_vswprintf(
            (*__local_stdio_printf_options()) | (1ULL << 1),
            0, 0, _Format, _Locale, _ArgList);

        return _Result < 0 ? -1 : _Result;
    }
    

     
     
    __inline int __cdecl _vscwprintf(
            wchar_t const* const _Format,
                                      va_list              _ArgList
        )
    


    {
        return _vscwprintf_l(_Format, 0, _ArgList);
    }
    

     
     
    __inline int __cdecl _vscwprintf_p_l(
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
                                                va_list              _ArgList
        )
    


    {
        int const _Result = __stdio_common_vswprintf_p(
            (*__local_stdio_printf_options()) | (1ULL << 1),
            0, 0, _Format, _Locale, _ArgList);

        return _Result < 0 ? -1 : _Result;
    }
    

     
     
    __inline int __cdecl _vscwprintf_p(
            wchar_t const* const _Format,
                                      va_list              _ArgList
        )
    


    {
        return _vscwprintf_p_l(_Format, 0, _ArgList);
    }
    

     
    
    __inline int __cdecl __swprintf_l(
                  wchar_t*       const _Buffer,
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
        ...)
    


    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = __vswprintf_l(_Buffer, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    

     
    
    __inline int __cdecl _swprintf_l(
           wchar_t*       const _Buffer,
                                                       size_t         const _BufferCount,
                      wchar_t const* const _Format,
                                                   _locale_t      const _Locale,
        ...)
    


    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vswprintf_c_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    

     
    
    __inline int __cdecl _swprintf(
           wchar_t*       const _Buffer,
               wchar_t const* const _Format,
        ...)
    


    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = __vswprintf_l(_Buffer, _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    

     
    
    __inline int __cdecl swprintf(
           wchar_t*       const _Buffer,
                                                       size_t         const _BufferCount,
                                wchar_t const* const _Format,
        ...)
    


    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vswprintf_c_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    

    #pragma warning(push)
    // Warning 4793: The compiler cannot compile function into managed code, even though the /clr compiler option is specified.
    // Warning 4996: 'function': was declared deprecated
    #pragma warning(disable:4793 4996)

    __declspec(deprecated("This function or variable may be unsafe. Consider using " "__swprintf_l_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __inline   int __cdecl __swprintf_l(   wchar_t *_Buffer,     wchar_t const* _Format,   _locale_t _Locale, ...); __declspec(deprecated("This function or variable may be unsafe. Consider using " "_vswprintf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __inline   int __cdecl __vswprintf_l(   wchar_t *_Buffer,     wchar_t const* _Format,   _locale_t _Locale, va_list _Args);

    __declspec(deprecated("This function or variable may be unsafe. Consider using " "swprintf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __inline   int __cdecl _swprintf(   wchar_t *_Buffer,     wchar_t const* _Format, ...); __declspec(deprecated("This function or variable may be unsafe. Consider using " "vswprintf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __inline   int __cdecl _vswprintf(   wchar_t *_Buffer,     wchar_t const* _Format, va_list _Args);

    #pragma warning(pop)

     
    
    __inline int __cdecl _swprintf_s_l(
           wchar_t*       const _Buffer,
                                                   size_t         const _BufferCount,
                  wchar_t const* const _Format,
                                               _locale_t      const _Locale,
        ...)
    


    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vswprintf_s_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    

    

         
        __inline int __cdecl swprintf_s(
               wchar_t*       const _Buffer,
                                                       size_t         const _BufferCount,
                                wchar_t const* const _Format,
            ...)
    


        {
            int _Result;
            va_list _ArgList;
            ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
            _Result = _vswprintf_s_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
            ((void)(_ArgList = (va_list)0));
            return _Result;
        }
    

    

    extern "C++" { __pragma(warning(push)); __pragma(warning(disable: 4793)); template <size_t _Size> inline   int __cdecl swprintf_s( wchar_t (&_Buffer)[_Size],     wchar_t const* _Format, ...) throw() { va_list _ArgList; ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format))))); return vswprintf_s(_Buffer, _Size, _Format, _ArgList); } __pragma(warning(pop)); }

     
    
    __inline int __cdecl _swprintf_p_l(
           wchar_t*       const _Buffer,
                                                   size_t         const _BufferCount,
                  wchar_t const* const _Format,
                                               _locale_t      const _Locale,
        ...)
    


    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vswprintf_p_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    

     
    
    __inline int __cdecl _swprintf_p(
           wchar_t*       const _Buffer,
                                                   size_t         const _BufferCount,
                            wchar_t const* const _Format,
        ...)
    


    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vswprintf_p_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    

     
    
    __inline int __cdecl _swprintf_c_l(
           wchar_t*       const _Buffer,
                                                       size_t         const _BufferCount,
                      wchar_t const* const _Format,
                                                   _locale_t      const _Locale,
        ...)
    


    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vswprintf_c_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    

     
    
    __inline int __cdecl _swprintf_c(
           wchar_t*       const _Buffer,
                                                       size_t         const _BufferCount,
                                wchar_t const* const _Format,
        ...)
    


    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vswprintf_c_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    

     
     __declspec(deprecated("This function or variable may be unsafe. Consider using " "_snwprintf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl _snwprintf_l(
            wchar_t*       const _Buffer,
                                                  size_t         const _BufferCount,
                 wchar_t const* const _Format,
                                              _locale_t      const _Locale,
        ...)
    


    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));

        #pragma warning(push)
        #pragma warning(disable: 4996) 
        _Result = _vsnwprintf_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
        #pragma warning(pop)

        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    

     
    
    __inline int __cdecl _snwprintf(
            wchar_t*       _Buffer,
                                                  size_t         _BufferCount,
                           wchar_t const* _Format,
        ...)
    


    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));

        #pragma warning(push)
        #pragma warning(disable: 4996) 
        _Result = _vsnwprintf_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
        #pragma warning(pop)

        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    

     
    
    __inline int __cdecl _snwprintf_s_l(
           wchar_t*       const _Buffer,
                                                       size_t         const _BufferCount,
                                                       size_t         const _MaxCount,
                      wchar_t const* const _Format,
                                                   _locale_t      const _Locale,
        ...)
    


    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vsnwprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    

     
    
    __inline int __cdecl _snwprintf_s(
           wchar_t*       const _Buffer,
                                                       size_t         const _BufferCount,
                                                       size_t         const _MaxCount,
                                wchar_t const* const _Format,
        ...)
    


    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vsnwprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    

    extern "C++" { __pragma(warning(push)); __pragma(warning(disable: 4793)); template <size_t _Size> inline   int __cdecl _snwprintf_s( wchar_t (&_Buffer)[_Size],   size_t _BufferCount,     wchar_t const* _Format, ...) throw() { va_list _ArgList; ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format))))); return _vsnwprintf_s(_Buffer, _Size, _BufferCount, _Format, _ArgList); } __pragma(warning(pop)); }

     
    __inline int __cdecl _scwprintf_l(
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
        ...)
    


    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vscwprintf_l(_Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    

     
     
    __inline int __cdecl _scwprintf(
            wchar_t const* const _Format,
        ...)
    


    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vscwprintf_l(_Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    

     
     
    __inline int __cdecl _scwprintf_p_l(
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
        ...)
    


    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vscwprintf_p_l(_Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    

     
     
    __inline int __cdecl _scwprintf_p(
            wchar_t const* const _Format,
        ...)
    


    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vscwprintf_p_l(_Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    


    
        #pragma warning(push)
        #pragma warning(disable: 4141 4412 4793 4996 6054)

        

            extern "C++" __declspec(deprecated("function has been changed to conform with the ISO C standard, " "adding an extra character count parameter. To use the traditional " "Microsoft version, set _CRT_NON_CONFORMING_SWPRINTFS.")) __declspec(deprecated("This function or variable may be unsafe. Consider using " "swprintf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
            inline int swprintf(
                           wchar_t*       const _Buffer,
                    wchar_t const* const _Format,
                ...) throw()
            {
                int _Result;
                va_list _ArgList;
                ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
                #pragma warning(suppress: 28719)
                _Result = vswprintf(_Buffer, 2147483647, _Format, _ArgList);
                ((void)(_ArgList = (va_list)0));
                return _Result;
            }

            extern "C++" __declspec(deprecated("function has been changed to conform with the ISO C standard, " "adding an extra character count parameter. To use the traditional " "Microsoft version, set _CRT_NON_CONFORMING_SWPRINTFS.")) __declspec(deprecated("This function or variable may be unsafe. Consider using " "vswprintf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
            inline int __cdecl vswprintf(
                           wchar_t*       const _Buffer,
                    wchar_t const* const _Format,
                                              va_list              _ArgList
                ) throw()
            {
                #pragma warning(suppress: 28719)
                return vswprintf(_Buffer, 2147483647, _Format, _ArgList);
            }

            extern "C++" __declspec(deprecated("function has been changed to conform with the ISO C standard, " "adding an extra character count parameter. To use the traditional " "Microsoft version, set _CRT_NON_CONFORMING_SWPRINTFS.")) __declspec(deprecated("This function or variable may be unsafe. Consider using " "_swprintf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
            inline int _swprintf_l(
                                     wchar_t*       const _Buffer,
                    wchar_t const* const _Format,
                                                 _locale_t      const _Locale,
                ...) throw()
            {
                int _Result;
                va_list _ArgList;
                ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
                _Result = _vswprintf_l(_Buffer, (size_t)-1, _Format, _Locale, _ArgList);
                ((void)(_ArgList = (va_list)0));
                return _Result;
            }

            extern "C++" __declspec(deprecated("function has been changed to conform with the ISO C standard, " "adding an extra character count parameter. To use the traditional " "Microsoft version, set _CRT_NON_CONFORMING_SWPRINTFS.")) __declspec(deprecated("This function or variable may be unsafe. Consider using " "_vswprintf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
            inline int __cdecl _vswprintf_l(
                                     wchar_t*       const _Buffer,
                    wchar_t const* const _Format,
                                                 _locale_t      const _Locale,
                                                        va_list              _ArgList
                ) throw()
            {
                return _vswprintf_l(_Buffer, (size_t)-1, _Format, _Locale, _ArgList);
            }

        

        #pragma warning(pop)
    

    







    //-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    //
    // Wide Character Formatted Input Functions (String)
    //
    //-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     
    __declspec(dllimport) int __cdecl __stdio_common_vswscanf(
                                            unsigned __int64 _Options,
                  wchar_t const*   _Buffer,
                                            size_t           _BufferCount,
            wchar_t const*   _Format,
                                        _locale_t        _Locale,
                                               va_list          _ArgList
        );

     
    
    __inline int __cdecl _vswscanf_l(
                                 wchar_t const* const _Buffer,
            wchar_t const* const _Format,
                               _locale_t      const _Locale,
                                      va_list              _ArgList
        )
    


    {
        return __stdio_common_vswscanf(
            (*__local_stdio_scanf_options ()),
            _Buffer, (size_t)-1, _Format, _Locale, _ArgList);
    }
    

     
    
    __inline int __cdecl vswscanf(
                                 wchar_t const* _Buffer,
            wchar_t const* _Format,
                                      va_list        _ArgList
        )
    


    {
        return _vswscanf_l(_Buffer, _Format, 0, _ArgList);
    }
    

     
    
    __inline int __cdecl _vswscanf_s_l(
                                 wchar_t const* const _Buffer,
            wchar_t const* const _Format,
                               _locale_t      const _Locale,
                                      va_list              _ArgList
        )
    


    {
        return __stdio_common_vswscanf(
            (*__local_stdio_scanf_options ()) | (1ULL << 0),
            _Buffer, (size_t)-1, _Format, _Locale, _ArgList);
    }
    

    

         
        
        __inline int __cdecl vswscanf_s(
                                     wchar_t const* const _Buffer,
                wchar_t const* const _Format,
                                          va_list              _ArgList
            )
    


        {
            return _vswscanf_s_l(_Buffer, _Format, 0, _ArgList);
        }
    

    

    extern "C++" { template <size_t _Size> inline   int __cdecl vswscanf_s(  wchar_t (&_Buffer)[_Size],     wchar_t const* _Format, va_list _ArgList) throw() { return vswscanf_s(_Buffer, _Size, _Format, _ArgList); } }

     
     __declspec(deprecated("This function or variable may be unsafe. Consider using " "_vsnwscanf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl _vsnwscanf_l(
                  wchar_t const* const _Buffer,
                                            size_t         const _BufferCount,
            wchar_t const* const _Format,
                                        _locale_t      const _Locale,
                                               va_list              _ArgList
        )
    


    {
        return __stdio_common_vswscanf(
            (*__local_stdio_scanf_options ()),
            _Buffer, _BufferCount, _Format, _Locale, _ArgList);
    }
    

     
    
    __inline int __cdecl _vsnwscanf_s_l(
                    wchar_t const* const _Buffer,
                                              size_t         const _BufferCount,
            wchar_t const* const _Format,
                                          _locale_t      const _Locale,
                                                 va_list              _ArgList
        )
    


    {
        return __stdio_common_vswscanf(
            (*__local_stdio_scanf_options ()) | (1ULL << 0),
            _Buffer, _BufferCount, _Format, _Locale, _ArgList);
    }
    

     
     __declspec(deprecated("This function or variable may be unsafe. Consider using " "_swscanf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl _swscanf_l(
                                          wchar_t const* const _Buffer,
            wchar_t const* const _Format,
                                        _locale_t            _Locale,
        ...)
    


    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vswscanf_l(_Buffer, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    

     
      __declspec(deprecated("This function or variable may be unsafe. Consider using " "swscanf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl swscanf(
                                wchar_t const* const _Buffer,
            wchar_t const* const _Format,
        ...)
    


    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vswscanf_l(_Buffer, _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    

     
    
    __inline int __cdecl _swscanf_s_l(
                                            wchar_t const* const _Buffer,
            wchar_t const* const _Format,
                                          _locale_t      const _Locale,
        ...)
    


    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vswscanf_s_l(_Buffer, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    

    

         
        
        __inline int __cdecl swscanf_s(
                                      wchar_t const* const _Buffer,
                wchar_t const* const _Format,
            ...)
    


        {
            int _Result;
            va_list _ArgList;
            ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
            _Result = _vswscanf_s_l(_Buffer, _Format, 0, _ArgList);
            ((void)(_ArgList = (va_list)0));
            return _Result;
        }
    

    

     
     __declspec(deprecated("This function or variable may be unsafe. Consider using " "_snwscanf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl _snwscanf_l(
                  wchar_t const* const _Buffer,
                                            size_t         const _BufferCount,
            wchar_t const* const _Format,
                                        _locale_t      const _Locale,
        ...)
    


    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));

        #pragma warning(push)
        #pragma warning(disable: 4996) 
        _Result = _vsnwscanf_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
        #pragma warning(pop)

        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    

     
     __declspec(deprecated("This function or variable may be unsafe. Consider using " "_snwscanf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl _snwscanf(
            wchar_t const* const _Buffer,
                                      size_t         const _BufferCount,
                wchar_t const* const _Format,
        ...)
    


    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));

        #pragma warning(push)
        #pragma warning(disable: 4996) 
        _Result = _vsnwscanf_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
        #pragma warning(pop)

        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    

     
    
    __inline int __cdecl _snwscanf_s_l(
                    wchar_t const* const _Buffer,
                                              size_t         const _BufferCount,
            wchar_t const* const _Format,
                                          _locale_t      const _Locale,
        ...)
    


    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vsnwscanf_s_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    

     
    
    __inline int __cdecl _snwscanf_s(
             wchar_t const* const _Buffer,
                                       size_t         const _BufferCount,
               wchar_t const* const _Format,
        ...)
    


    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vsnwscanf_s_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    

    






} __pragma(pack(pop))


__pragma(pack(push, 8)) extern "C" {

/* Buffered I/O macros */





/*
 * Default number of supported streams. _NFILE is confusing and obsolete, but
 * supported anyway for backwards compatibility.
 */




/*
 * Number of entries in _iob[] (declared below). Note that _NSTREAM_ must be
 * greater than or equal to _IOB_ENTRIES.
 */












    




/* Seek method constants */











    
    



typedef __int64 fpos_t;





    
    __declspec(dllimport) errno_t __cdecl _get_stream_buffer_pointers(
               FILE*   _Stream,
          char*** _Base,
          char*** _Pointer,
          int**   _Count
        );


    //-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    //
    // Narrow Character Stream I/O Functions
    //
    //-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    

        
        __declspec(dllimport) errno_t __cdecl clearerr_s(
              FILE* _Stream
            );

        
        __declspec(dllimport) errno_t __cdecl fopen_s(
              FILE**      _Stream,
                                 char const* _FileName,
                                 char const* _Mode
            );

        
         
        __declspec(dllimport) size_t __cdecl fread_s(
                void*  _Buffer,
                                    size_t _BufferSize,
                                                                            size_t _ElementSize,
                                                                            size_t _ElementCount,
                                                                         FILE*  _Stream
            );

        
        __declspec(dllimport) errno_t __cdecl freopen_s(
              FILE**      _Stream,
                                 char const* _FileName,
                                 char const* _Mode,
                                FILE*       _OldStream
            );

         
        __declspec(dllimport) char* __cdecl gets_s(
              char*   _Buffer,
                               rsize_t _Size
            );

        
        __declspec(dllimport) errno_t __cdecl tmpfile_s(
                FILE** _Stream
            );

         
        
        __declspec(dllimport) errno_t __cdecl tmpnam_s(
              char*   _Buffer,
                               rsize_t _Size
            );

    

    __declspec(dllimport) void __cdecl clearerr(
          FILE* _Stream
        );

     
    
    __declspec(dllimport) int __cdecl fclose(
          FILE* _Stream
        );

    
    __declspec(dllimport) int __cdecl _fcloseall(void);

     
    __declspec(dllimport) FILE* __cdecl _fdopen(
            int         _FileHandle,
          char const* _Mode
        );

     
    __declspec(dllimport) int __cdecl feof(
          FILE* _Stream
        );

     
    __declspec(dllimport) int __cdecl ferror(
          FILE* _Stream
        );

    
    __declspec(dllimport) int __cdecl fflush(
          FILE* _Stream
        );

     
    
    __declspec(dllimport) int __cdecl fgetc(
          FILE* _Stream
        );

    
    __declspec(dllimport) int __cdecl _fgetchar(void);

     
    
    __declspec(dllimport) int __cdecl fgetpos(
          FILE*   _Stream,
            fpos_t* _Position
        );

     
    
    __declspec(dllimport) char* __cdecl fgets(
          char* _Buffer,
                               int   _MaxCount,
                            FILE* _Stream
        );

     
    __declspec(dllimport) int __cdecl _fileno(
          FILE* _Stream
        );

    
    __declspec(dllimport) int __cdecl _flushall(void);

      __declspec(deprecated("This function or variable may be unsafe. Consider using " "fopen_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __declspec(dllimport) FILE* __cdecl fopen(
          char const* _FileName,
          char const* _Mode
        );


     
    
    __declspec(dllimport) int __cdecl fputc(
             int   _Character,
          FILE* _Stream
        );

    
    __declspec(dllimport) int __cdecl _fputchar(
          int _Character
        );

     
    
    __declspec(dllimport) int __cdecl fputs(
           char const* _Buffer,
          FILE*       _Stream
        );

    
    __declspec(dllimport) size_t __cdecl fread(
          void*  _Buffer,
                                                      size_t _ElementSize,
                                                      size_t _ElementCount,
                                                   FILE*  _Stream
        );

     
      __declspec(deprecated("This function or variable may be unsafe. Consider using " "freopen_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __declspec(dllimport) FILE* __cdecl freopen(
           char const* _FileName,
           char const* _Mode,
          FILE*       _Stream
        );

     
    __declspec(dllimport) FILE* __cdecl _fsopen(
          char const* _FileName,
          char const* _Mode,
            int         _ShFlag
        );

     
    
    __declspec(dllimport) int __cdecl fsetpos(
          FILE*         _Stream,
             fpos_t const* _Position
        );

     
    
    __declspec(dllimport) int __cdecl fseek(
          FILE* _Stream,
             long  _Offset,
             int   _Origin
        );

     
    
    __declspec(dllimport) int __cdecl _fseeki64(
          FILE*   _Stream,
             __int64 _Offset,
             int     _Origin
        );

     
     
    __declspec(dllimport) long __cdecl ftell(
          FILE* _Stream
        );

     
     
    __declspec(dllimport) __int64 __cdecl _ftelli64(
          FILE* _Stream
        );

    
    __declspec(dllimport) size_t __cdecl fwrite(
          void const* _Buffer,
                                                    size_t      _ElementSize,
                                                    size_t      _ElementCount,
                                                 FILE*       _Stream
        );

     
     
    __declspec(dllimport) int __cdecl getc(
          FILE* _Stream
        );

     
    __declspec(dllimport) int __cdecl getchar(void);

     
    __declspec(dllimport) int __cdecl _getmaxstdio(void);

    extern "C++" { template <size_t _Size> inline char* __cdecl gets_s(char (&_Buffer)[_Size]) throw() { return gets_s(_Buffer, _Size); } }

     
    __declspec(dllimport) int __cdecl _getw(
          FILE* _Stream
        );

    __declspec(dllimport) void __cdecl perror(
          char const* _ErrorMessage
        );

    

         
        
        __declspec(dllimport) int __cdecl _pclose(
              FILE* _Stream
            );

         
        __declspec(dllimport) FILE* __cdecl _popen(
              char const* _Command,
              char const* _Mode
            );

    

     
    
    __declspec(dllimport) int __cdecl putc(
             int   _Character,
          FILE* _Stream
        );

    
    __declspec(dllimport) int __cdecl putchar(
          int _Character
        );

    
    __declspec(dllimport) int __cdecl puts(
          char const* _Buffer
        );

     
    
    __declspec(dllimport) int __cdecl _putw(
             int   _Word,
          FILE* _Stream
        );

    __declspec(dllimport) int __cdecl remove(
          char const* _FileName
        );

     
    __declspec(dllimport) int __cdecl rename(
          char const* _OldFileName,
          char const* _NewFileName
        );

    __declspec(dllimport) int __cdecl _unlink(
          char const* _FileName
        );

    

        __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_unlink" ". See online help for details."))
        __declspec(dllimport) int __cdecl unlink(
              char const* _FileName
            );

    

    __declspec(dllimport) void __cdecl rewind(
          FILE* _Stream
        );

    
    __declspec(dllimport) int __cdecl _rmtmp(void);

    __declspec(deprecated("This function or variable may be unsafe. Consider using " "setvbuf" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __declspec(dllimport) void __cdecl setbuf(
                                                      FILE* _Stream,
            char* _Buffer
        );

    
    __declspec(dllimport) int __cdecl _setmaxstdio(
          int _Maximum
        );

     
    
    __declspec(dllimport) int __cdecl setvbuf(
                               FILE*  _Stream,
            char*  _Buffer,
                                  int    _Mode,
                                  size_t _Size
        );

    




     
    __declspec(dllimport) __declspec(allocator) char* __cdecl _tempnam(
          char const* _DirectoryName,
          char const* _FilePrefix
        );

    



      __declspec(deprecated("This function or variable may be unsafe. Consider using " "tmpfile_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __declspec(dllimport) FILE* __cdecl tmpfile(void);

    extern "C++" { template <size_t _Size> inline   errno_t __cdecl tmpnam_s( char (&_Buffer)[_Size]) throw() { return tmpnam_s(_Buffer, _Size); } }

#pragma warning(push)
#pragma warning(disable: 28726) 
__declspec(deprecated("This function or variable may be unsafe. Consider using " "tmpnam_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport)  char* __cdecl tmpnam(  char *_Buffer);
#pragma warning(pop)

     
    
    __declspec(dllimport) int __cdecl ungetc(
             int   _Character,
          FILE* _Stream
        );



    //-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    //
    // I/O Synchronization and _nolock family of I/O functions
    //
    //-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    __declspec(dllimport) void __cdecl _lock_file(
          FILE* _Stream
        );

    __declspec(dllimport) void __cdecl _unlock_file(
          FILE* _Stream
        );

     
    
    __declspec(dllimport) int __cdecl _fclose_nolock(
          FILE* _Stream
        );

     
    
    __declspec(dllimport) int __cdecl _fflush_nolock(
          FILE* _Stream
        );

     
    
    __declspec(dllimport) int __cdecl _fgetc_nolock(
          FILE* _Stream
        );

     
    
    __declspec(dllimport) int __cdecl _fputc_nolock(
             int   _Character,
          FILE* _Stream
        );

    
    __declspec(dllimport) size_t __cdecl _fread_nolock(
          void*  _Buffer,
                                                      size_t _ElementSize,
                                                      size_t _ElementCount,
                                                   FILE*  _Stream
        );

    
     
    __declspec(dllimport) size_t __cdecl _fread_nolock_s(
          void*  _Buffer,
                              size_t _BufferSize,
                                                                      size_t _ElementSize,
                                                                      size_t _ElementCount,
                                                                   FILE*  _Stream
        );

    
    __declspec(dllimport) int __cdecl _fseek_nolock(
          FILE* _Stream,
             long  _Offset,
             int   _Origin
        );

    
    __declspec(dllimport) int __cdecl _fseeki64_nolock(
          FILE*   _Stream,
             __int64 _Offset,
             int     _Origin
        );

     
    __declspec(dllimport) long __cdecl _ftell_nolock(
          FILE* _Stream
        );

     
    __declspec(dllimport) __int64 __cdecl _ftelli64_nolock(
          FILE* _Stream
        );

    
    __declspec(dllimport) size_t __cdecl _fwrite_nolock(
          void const* _Buffer,
                                                    size_t      _ElementSize,
                                                    size_t      _ElementCount,
                                                 FILE*       _Stream
        );

    
    __declspec(dllimport) int __cdecl _getc_nolock(
          FILE* _Stream
        );

    
    __declspec(dllimport) int __cdecl _putc_nolock(
             int   _Character,
          FILE* _Stream
        );

    
    __declspec(dllimport) int __cdecl _ungetc_nolock(
             int   _Character,
          FILE* _Stream
        );

    
    
    
    



    


















    __declspec(dllimport) int* __cdecl __p__commode(void);

    


        
    



    // Variadic functions are not supported in managed code under /clr
    



    //-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    //
    // Narrow Character Formatted Output Functions (Stream)
    //
    //-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    __declspec(dllimport) int __cdecl __stdio_common_vfprintf(
                                             unsigned __int64 _Options,
                                          FILE*            _Stream,
            char const*      _Format,
                                         _locale_t        _Locale,
                                                va_list          _ArgList
        );

    __declspec(dllimport) int __cdecl __stdio_common_vfprintf_s(
                                             unsigned __int64 _Options,
                                          FILE*            _Stream,
            char const*      _Format,
                                         _locale_t        _Locale,
                                                va_list          _ArgList
        );

     
    __declspec(dllimport) int __cdecl __stdio_common_vfprintf_p(
                                             unsigned __int64 _Options,
                                          FILE*            _Stream,
            char const*      _Format,
                                         _locale_t        _Locale,
                                                va_list          _ArgList
        );

    
    __inline int __cdecl _vfprintf_l(
           FILE*       const _Stream,
            char const* const _Format,
          _locale_t   const _Locale,
                 va_list           _ArgList
        )
    


    {
        return __stdio_common_vfprintf((*__local_stdio_printf_options()), _Stream, _Format, _Locale, _ArgList);
    }
    

    
    __inline int __cdecl vfprintf(
                                FILE*       const _Stream,
            char const* const _Format,
                                      va_list           _ArgList
        )
    


    {
        return _vfprintf_l(_Stream, _Format, 0, _ArgList);
    }
    

    
    __inline int __cdecl _vfprintf_s_l(
           FILE*       const _Stream,
            char const* const _Format,
          _locale_t   const _Locale,
                 va_list           _ArgList
        )
    


    {
        return __stdio_common_vfprintf_s((*__local_stdio_printf_options()), _Stream, _Format, _Locale, _ArgList);
    }
    

    

        
        __inline int __cdecl vfprintf_s(
                                    FILE*       const _Stream,
                char const* const _Format,
                                          va_list           _ArgList
            )
    


        {
            return _vfprintf_s_l(_Stream, _Format, 0, _ArgList);
        }
    

    

    
    __inline int __cdecl _vfprintf_p_l(
           FILE*       const _Stream,
            char const* const _Format,
          _locale_t   const _Locale,
                 va_list           _ArgList
        )
    


    {
        return __stdio_common_vfprintf_p((*__local_stdio_printf_options()), _Stream, _Format, _Locale, _ArgList);
    }
    

    
    __inline int __cdecl _vfprintf_p(
                                FILE*       const _Stream,
            char const* const _Format,
                                      va_list           _ArgList
        )
    


    {
        return _vfprintf_p_l(_Stream, _Format, 0, _ArgList);
    }
    

    
    __inline int __cdecl _vprintf_l(
            char const* const _Format,
                                         _locale_t   const _Locale,
                                                va_list           _ArgList
        )
    


    {
        return _vfprintf_l((__acrt_iob_func(1)), _Format, _Locale, _ArgList);
    }
    

    
    __inline int __cdecl vprintf(
            char const* const _Format,
                                      va_list           _ArgList
        )
    


    {
        return _vfprintf_l((__acrt_iob_func(1)), _Format, 0, _ArgList);
    }
    

    
    __inline int __cdecl _vprintf_s_l(
            char const* const _Format,
                                         _locale_t   const _Locale,
                                                va_list           _ArgList
        )
    


    {
        return _vfprintf_s_l((__acrt_iob_func(1)), _Format, _Locale, _ArgList);
    }
    

    

        
        __inline int __cdecl vprintf_s(
                char const* const _Format,
                                          va_list           _ArgList
            )
    


        {
            return _vfprintf_s_l((__acrt_iob_func(1)), _Format, 0, _ArgList);
        }
    

    

    
    __inline int __cdecl _vprintf_p_l(
            char const* const _Format,
                                         _locale_t   const _Locale,
                                                va_list           _ArgList
        )
    


    {
        return _vfprintf_p_l((__acrt_iob_func(1)), _Format, _Locale, _ArgList);
    }
    

    
    __inline int __cdecl _vprintf_p(
            char const* const _Format,
                                      va_list           _ArgList
        )
    


    {
        return _vfprintf_p_l((__acrt_iob_func(1)), _Format, 0, _ArgList);
    }
    

    
    __inline int __cdecl _fprintf_l(
                                          FILE*       const _Stream,
            char const* const _Format,
                                         _locale_t   const _Locale,
        ...)
    


    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vfprintf_l(_Stream, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    

    
    __inline int __cdecl fprintf(
                                FILE*       const _Stream,
            char const* const _Format,
        ...)
    


    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vfprintf_l(_Stream, _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    

    __declspec(dllimport) int __cdecl _set_printf_count_output(
          int _Value
        );

    __declspec(dllimport) int __cdecl _get_printf_count_output(void);

    
    __inline int __cdecl _fprintf_s_l(
                                          FILE*       const _Stream,
            char const* const _Format,
                                         _locale_t   const _Locale,
        ...)
    


    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vfprintf_s_l(_Stream, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    

    

        
        __inline int __cdecl fprintf_s(
                                    FILE*       const _Stream,
                char const* const _Format,
            ...)
    


        {
            int _Result;
            va_list _ArgList;
            ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
            _Result = _vfprintf_s_l(_Stream, _Format, 0, _ArgList);
            ((void)(_ArgList = (va_list)0));
            return _Result;
        }
    

    

    
    __inline int __cdecl _fprintf_p_l(
                                          FILE*       const _Stream,
            char const* const _Format,
                                         _locale_t   const _Locale,
        ...)
    


    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vfprintf_p_l(_Stream, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    

    
    __inline int __cdecl _fprintf_p(
                                FILE*       const _Stream,
            char const* const _Format,
        ...)
    


    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vfprintf_p_l(_Stream, _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    

    
    __inline int __cdecl _printf_l(
            char const* const _Format,
                                         _locale_t   const _Locale,
        ...)
    


    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vfprintf_l((__acrt_iob_func(1)), _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    

    
    __inline int __cdecl printf(
            char const* const _Format,
        ...)
    


    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vfprintf_l((__acrt_iob_func(1)), _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    

    
    __inline int __cdecl _printf_s_l(
            char const* const _Format,
                                         _locale_t   const _Locale,
        ...)
    


    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vfprintf_s_l((__acrt_iob_func(1)), _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    

    

        
        __inline int __cdecl printf_s(
                char const* const _Format,
            ...)
    


        {
            int _Result;
            va_list _ArgList;
            ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
            _Result = _vfprintf_s_l((__acrt_iob_func(1)), _Format, 0, _ArgList);
            ((void)(_ArgList = (va_list)0));
            return _Result;
        }
    

    

    
    __inline int __cdecl _printf_p_l(
            char const* const _Format,
                                         _locale_t   const _Locale,
        ...)
    


    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vfprintf_p_l((__acrt_iob_func(1)), _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    

    
    __inline int __cdecl _printf_p(
            char const* const _Format,
        ...)
    


    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vfprintf_p_l((__acrt_iob_func(1)), _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    


    //-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    //
    // Narrow Character Formatted Input Functions (Stream)
    //
    //-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    __declspec(dllimport) int __cdecl __stdio_common_vfscanf(
                                            unsigned __int64 _Options,
                                         FILE*            _Stream,
            char const*      _Format,
                                        _locale_t        _Locale,
                                               va_list          _Arglist
        );

    
    __inline int __cdecl _vfscanf_l(
                                FILE*       const _Stream,
            char const* const _Format,
                               _locale_t   const _Locale,
                                      va_list           _ArgList
        )
    


    {
        return __stdio_common_vfscanf(
            (*__local_stdio_scanf_options ()),
            _Stream, _Format, _Locale, _ArgList);
    }
    

    
    __inline int __cdecl vfscanf(
                                FILE*       const _Stream,
            char const* const _Format,
                                      va_list           _ArgList
        )
    


    {
        return _vfscanf_l(_Stream, _Format, 0, _ArgList);
    }
    

    
    __inline int __cdecl _vfscanf_s_l(
                                FILE*       const _Stream,
            char const* const _Format,
                               _locale_t   const _Locale,
                                      va_list           _ArgList
        )
    


    {
        return __stdio_common_vfscanf(
            (*__local_stdio_scanf_options ()) | (1ULL << 0),
            _Stream, _Format, _Locale, _ArgList);
    }
    


    

        
        __inline int __cdecl vfscanf_s(
                                    FILE*       const _Stream,
                char const* const _Format,
                                          va_list           _ArgList
            )
    


        {
            return _vfscanf_s_l(_Stream, _Format, 0, _ArgList);
        }
    

    

    
    __inline int __cdecl _vscanf_l(
            char const* const _Format,
                               _locale_t   const _Locale,
                                      va_list           _ArgList
        )
    


    {
        return _vfscanf_l((__acrt_iob_func(0)), _Format, _Locale, _ArgList);
    }
    

    
    __inline int __cdecl vscanf(
            char const* const _Format,
                                      va_list           _ArgList
        )
    


    {
        return _vfscanf_l((__acrt_iob_func(0)), _Format, 0, _ArgList);
    }
    

    
    __inline int __cdecl _vscanf_s_l(
            char const* const _Format,
                               _locale_t   const _Locale,
                                      va_list           _ArgList
        )
    


    {
        return _vfscanf_s_l((__acrt_iob_func(0)), _Format, _Locale, _ArgList);
    }
    

    

        
        __inline int __cdecl vscanf_s(
                char const* const _Format,
                                          va_list           _ArgList
            )
    


        {
            return _vfscanf_s_l((__acrt_iob_func(0)), _Format, 0, _ArgList);
        }
    

    

     __declspec(deprecated("This function or variable may be unsafe. Consider using " "_fscanf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl _fscanf_l(
                                         FILE*       const _Stream,
            char const* const _Format,
                                        _locale_t   const _Locale,
        ...)
    


    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vfscanf_l(_Stream, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    

      __declspec(deprecated("This function or variable may be unsafe. Consider using " "fscanf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl fscanf(
                               FILE*       const _Stream,
            char const* const _Format,
        ...)
    


    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vfscanf_l(_Stream, _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    

    
    __inline int __cdecl _fscanf_s_l(
                                           FILE*       const _Stream,
            char const* const _Format,
                                          _locale_t   const _Locale,
        ...)
    


    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vfscanf_s_l(_Stream, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    

    

        
        __inline int __cdecl fscanf_s(
                                     FILE*       const _Stream,
                char const* const _Format,
            ...)
    


        {
            int _Result;
            va_list _ArgList;
            ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
            _Result = _vfscanf_s_l(_Stream, _Format, 0, _ArgList);
            ((void)(_ArgList = (va_list)0));
            return _Result;
        }
    

    

     __declspec(deprecated("This function or variable may be unsafe. Consider using " "_scanf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl _scanf_l(
            char const* const _Format,
                                        _locale_t   const _Locale,
        ...)
    


    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vfscanf_l((__acrt_iob_func(0)), _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    

      __declspec(deprecated("This function or variable may be unsafe. Consider using " "scanf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl scanf(
            char const* const _Format,
        ...)
    


    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vfscanf_l((__acrt_iob_func(0)), _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    

    
    __inline int __cdecl _scanf_s_l(
            char const* const _Format,
                                          _locale_t   const _Locale,
        ...)
    


    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vfscanf_s_l((__acrt_iob_func(0)), _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    

    

        
        __inline int __cdecl scanf_s(
                char const* const _Format,
            ...)
    


        {
            int _Result;
            va_list _ArgList;
            ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
            _Result = _vfscanf_s_l((__acrt_iob_func(0)), _Format, 0, _ArgList);
            ((void)(_ArgList = (va_list)0));
            return _Result;
        }
    

    



    //-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    //
    // Narrow Character Formatted Output Functions (String)
    //
    //-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     
    __declspec(dllimport) int __cdecl __stdio_common_vsprintf(
                                             unsigned __int64 _Options,
                 char*            _Buffer,
                                             size_t           _BufferCount,
            char const*      _Format,
                                         _locale_t        _Locale,
                                                va_list          _ArgList
        );

     
    __declspec(dllimport) int __cdecl __stdio_common_vsprintf_s(
                                             unsigned __int64 _Options,
                     char*            _Buffer,
                                             size_t           _BufferCount,
            char const*      _Format,
                                         _locale_t        _Locale,
                                                va_list          _ArgList
        );

     
    __declspec(dllimport) int __cdecl __stdio_common_vsnprintf_s(
                                             unsigned __int64 _Options,
                 char*            _Buffer,
                                             size_t           _BufferCount,
                                             size_t           _MaxCount,
            char const*      _Format,
                                         _locale_t        _Locale,
                                                va_list          _ArgList
        );

     
    __declspec(dllimport) int __cdecl __stdio_common_vsprintf_p(
                                             unsigned __int64 _Options,
                     char*            _Buffer,
                                             size_t           _BufferCount,
            char const*      _Format,
                                         _locale_t        _Locale,
                                                va_list          _ArgList
        );

     
     __declspec(deprecated("This function or variable may be unsafe. Consider using " "_vsnprintf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl _vsnprintf_l(
            char*       const _Buffer,
                                                  size_t      const _BufferCount,
                 char const* const _Format,
                                              _locale_t   const _Locale,
                                                     va_list           _ArgList
        )
    


    {
        int const _Result = __stdio_common_vsprintf(
            (*__local_stdio_printf_options()) | (1ULL << 0),
            _Buffer, _BufferCount, _Format, _Locale, _ArgList);

        return _Result < 0 ? -1 : _Result;
    }
    

     
    
    __inline int __cdecl _vsnprintf(
            char*       const _Buffer,
                                                 size_t      const _BufferCount,
                          char const* const _Format,
                                                    va_list           _ArgList
        )
    


    {
        #pragma warning(push)
        #pragma warning(disable: 4996) 
        return _vsnprintf_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
        #pragma warning(pop)
    }
    

    










     
    
    __inline int __cdecl vsnprintf(
           char*       const _Buffer,
                                                       size_t      const _BufferCount,
                                char const* const _Format,
                                                          va_list           _ArgList
        )
    


    {
        int const _Result = __stdio_common_vsprintf(
            (*__local_stdio_printf_options()) | (1ULL << 1),
            _Buffer, _BufferCount, _Format, 0, _ArgList);

        return _Result < 0 ? -1 : _Result;
    }
    

     
     __declspec(deprecated("This function or variable may be unsafe. Consider using " "_vsprintf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl _vsprintf_l(
           char*       const _Buffer,
                                    char const* const _Format,
                                  _locale_t   const _Locale,
                                         va_list           _ArgList
        )
    


    {
        #pragma warning(push)
        #pragma warning(disable: 4996) 
        return _vsnprintf_l(_Buffer, (size_t)-1, _Format, _Locale, _ArgList);
        #pragma warning(pop)
    }
    

     
     __declspec(deprecated("This function or variable may be unsafe. Consider using " "vsprintf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl vsprintf(
           char*       const _Buffer,
               char const* const _Format,
                                         va_list           _ArgList
        )
    


    {
        #pragma warning(push)
        #pragma warning(disable: 4996) 
        return _vsnprintf_l(_Buffer, (size_t)-1, _Format, 0, _ArgList);
        #pragma warning(pop)
    }
    

     
    
    __inline int __cdecl _vsprintf_s_l(
           char*       const _Buffer,
                                                   size_t      const _BufferCount,
                  char const* const _Format,
                                               _locale_t   const _Locale,
                                                      va_list           _ArgList
        )
    


    {
        int const _Result = __stdio_common_vsprintf_s(
            (*__local_stdio_printf_options()),
            _Buffer, _BufferCount, _Format, _Locale, _ArgList);

        return _Result < 0 ? -1 : _Result;
    }
    

    

         
        
        __inline int __cdecl vsprintf_s(
               char*       const _Buffer,
                                                       size_t      const _BufferCount,
                                char const* const _Format,
                                                          va_list           _ArgList
            )
    


        {
            return _vsprintf_s_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
        }
    

        extern "C++" { template <size_t _Size> inline   int __cdecl vsprintf_s( char (&_Buffer)[_Size],     char const* _Format, va_list _ArgList) throw() { return vsprintf_s(_Buffer, _Size, _Format, _ArgList); } }

    

     
    
    __inline int __cdecl _vsprintf_p_l(
           char*       const _Buffer,
                                                   size_t      const _BufferCount,
                  char const* const _Format,
                                               _locale_t   const _Locale,
                                                      va_list           _ArgList
        )
    


    {
        int const _Result = __stdio_common_vsprintf_p(
            (*__local_stdio_printf_options()),
            _Buffer, _BufferCount, _Format, _Locale, _ArgList);

        return _Result < 0 ? -1 : _Result;
    }
    

     
    
    __inline int __cdecl _vsprintf_p(
           char*       const _Buffer,
                                                   size_t      const _BufferCount,
                            char const* const _Format,
                                                      va_list           _ArgList
        )
    


    {
        return _vsprintf_p_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
    }
    

     
    
    __inline int __cdecl _vsnprintf_s_l(
           char*       const _Buffer,
                                                       size_t      const _BufferCount,
                                                       size_t      const _MaxCount,
                      char const* const _Format,
                                                   _locale_t   const _Locale,
                                                          va_list          _ArgList
        )
    


    {
        int const _Result = __stdio_common_vsnprintf_s(
            (*__local_stdio_printf_options()),
            _Buffer, _BufferCount, _MaxCount, _Format, _Locale, _ArgList);

        return _Result < 0 ? -1 : _Result;
    }
    

     
    
    __inline int __cdecl _vsnprintf_s(
           char*       const _Buffer,
                                                       size_t      const _BufferCount,
                                                       size_t      const _MaxCount,
                                char const* const _Format,
                                                          va_list           _ArgList
        )
    


    {
        return _vsnprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, 0, _ArgList);
    }
    

    extern "C++" { template <size_t _Size> inline   int __cdecl _vsnprintf_s( char (&_Buffer)[_Size],   size_t _BufferCount,     char const* _Format, va_list _ArgList) throw() { return _vsnprintf_s(_Buffer, _Size, _BufferCount, _Format, _ArgList); } }

    

         
        
        __inline int __cdecl vsnprintf_s(
               char*       const _Buffer,
                                                           size_t      const _BufferCount,
                                                           size_t      const _MaxCount,
                                    char const* const _Format,
                                                              va_list           _ArgList
            )
    


        {
            return _vsnprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, 0, _ArgList);
        }
    

        extern "C++" { template <size_t _Size> inline   int __cdecl vsnprintf_s( char (&_Buffer)[_Size],   size_t _BufferCount,     char const* _Format, va_list _ArgList) throw() { return vsnprintf_s(_Buffer, _Size, _BufferCount, _Format, _ArgList); } }

    

    
    __inline int __cdecl _vscprintf_l(
            char const* const _Format,
                                         _locale_t   const _Locale,
                                                va_list           _ArgList
        )
    


    {
        int const _Result = __stdio_common_vsprintf(
            (*__local_stdio_printf_options()) | (1ULL << 1),
            0, 0, _Format, _Locale, _ArgList);

        return _Result < 0 ? -1 : _Result;
    }
    

     
    __inline int __cdecl _vscprintf(
            char const* const _Format,
                                      va_list           _ArgList
        )
    


    {
        return _vscprintf_l(_Format, 0, _ArgList);
    }
    

    
    __inline int __cdecl _vscprintf_p_l(
            char const* const _Format,
                                         _locale_t   const _Locale,
                                                va_list           _ArgList
        )
    


    {
        int const _Result = __stdio_common_vsprintf_p(
            (*__local_stdio_printf_options()) | (1ULL << 1),
            0, 0, _Format, _Locale, _ArgList);

        return _Result < 0 ? -1 : _Result;
    }
    

     
    __inline int __cdecl _vscprintf_p(
            char const* const _Format,
                                      va_list           _ArgList
        )
    


    {
        return _vscprintf_p_l(_Format, 0, _ArgList);
    }
    

    
    __inline int __cdecl _vsnprintf_c_l(
                   char*       const _Buffer,
                                             size_t      const _BufferCount,
            char const* const _Format,
                                         _locale_t   const _Locale,
                                                va_list           _ArgList
        )
    


    {
        int const _Result = __stdio_common_vsprintf(
            (*__local_stdio_printf_options()),
            _Buffer, _BufferCount, _Format, _Locale, _ArgList);

        return _Result < 0 ? -1 : _Result;
    }
    

     
    
    __inline int __cdecl _vsnprintf_c(
          char*       const _Buffer,
                                    size_t      const _BufferCount,
             char const* const _Format,
                                       va_list           _ArgList
        )
    


    {
        return _vsnprintf_c_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
    }
    

     
     __declspec(deprecated("This function or variable may be unsafe. Consider using " "_sprintf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl _sprintf_l(
                  char*       const _Buffer,
            char const* const _Format,
                                         _locale_t   const _Locale,
        ...)
    


    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));

        #pragma warning(push)
        #pragma warning(disable: 4996) 
        _Result = _vsprintf_l(_Buffer, _Format, _Locale, _ArgList);
        #pragma warning(pop)

        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    

     
    
    __inline int __cdecl sprintf(
           char*       const _Buffer,
               char const* const _Format,
        ...)
    


    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));

        #pragma warning(push)
        #pragma warning(disable: 4996) 
        _Result = _vsprintf_l(_Buffer, _Format, 0, _ArgList);
        #pragma warning(pop)

        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    

    #pragma warning(push)
    #pragma warning(disable: 4996)
    #pragma warning(disable: 28719) 
    #pragma warning(disable: 28726) 
    __declspec(deprecated("This function or variable may be unsafe. Consider using " "sprintf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))   int __cdecl sprintf(  char *_Buffer,  char const* _Format, ...); __declspec(deprecated("This function or variable may be unsafe. Consider using " "vsprintf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))   int __cdecl vsprintf(  char *_Buffer,  char const* _Format, va_list _Args);
    #pragma warning(pop)

     
    
    __inline int __cdecl _sprintf_s_l(
           char*       const _Buffer,
                                                   size_t      const _BufferCount,
                  char const* const _Format,
                                               _locale_t   const _Locale,
        ...)
    


    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vsprintf_s_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    

    

         
        
        __inline int __cdecl sprintf_s(
               char*       const _Buffer,
                                                       size_t      const _BufferCount,
                                char const* const _Format,
            ...)
    


        {
            int _Result;
            va_list _ArgList;
            ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
            _Result = _vsprintf_s_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
            ((void)(_ArgList = (va_list)0));
            return _Result;
        }
    

    

    extern "C++" { __pragma(warning(push)); __pragma(warning(disable: 4793)); template <size_t _Size> inline   int __cdecl sprintf_s( char (&_Buffer)[_Size],     char const* _Format, ...) throw() { va_list _ArgList; ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format))))); return vsprintf_s(_Buffer, _Size, _Format, _ArgList); } __pragma(warning(pop)); }

     
    
    __inline int __cdecl _sprintf_p_l(
           char*       const _Buffer,
                                                   size_t      const _BufferCount,
                  char const* const _Format,
                                               _locale_t   const _Locale,
        ...)
    


    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vsprintf_p_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    

     
    
    __inline int __cdecl _sprintf_p(
           char*       const _Buffer,
                                                   size_t      const _BufferCount,
                            char const* const _Format,
        ...)
    


    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vsprintf_p_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    

     
     __declspec(deprecated("This function or variable may be unsafe. Consider using " "_snprintf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl _snprintf_l(
            char*       const _Buffer,
                                                  size_t      const _BufferCount,
                 char const* const _Format,
                                              _locale_t   const _Locale,
        ...)
    


    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));

        #pragma warning(push)
        #pragma warning(disable: 4996) 
        _Result = _vsnprintf_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
        #pragma warning(pop)

        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    

    










     
    
    __inline int __cdecl snprintf(
           char*       const _Buffer,
                                                       size_t      const _BufferCount,
                                char const* const _Format,
        ...)
    


    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
    #pragma warning(suppress:28719)    
        _Result = vsnprintf(_Buffer, _BufferCount, _Format, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    

     
    
    __inline int __cdecl _snprintf(
            char*       const _Buffer,
                                                  size_t      const _BufferCount,
                           char const* const _Format,
        ...)
    


    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
    #pragma warning(suppress:28719)    
        _Result = _vsnprintf(_Buffer, _BufferCount, _Format, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    

    __declspec(deprecated("This function or variable may be unsafe. Consider using " "_snprintf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))    int __cdecl _snprintf(    char *_Buffer,   size_t _BufferCount,     char const* _Format, ...); __declspec(deprecated("This function or variable may be unsafe. Consider using " "_vsnprintf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))    int __cdecl _vsnprintf(    char *_Buffer,   size_t _BufferCount,     char const* _Format, va_list _Args);

     
    
    __inline int __cdecl _snprintf_c_l(
                   char*       const _Buffer,
                                             size_t      const _BufferCount,
            char const* const _Format,
                                         _locale_t   const _Locale,
        ...)
    


    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vsnprintf_c_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    

     
    
    __inline int __cdecl _snprintf_c(
          char*       const _Buffer,
                                    size_t      const _BufferCount,
             char const* const _Format,
        ...)
    


    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vsnprintf_c_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    

     
    
    __inline int __cdecl _snprintf_s_l(
           char*       const _Buffer,
                                                       size_t      const _BufferCount,
                                                       size_t      const _MaxCount,
                      char const* const _Format,
                                                   _locale_t   const _Locale,
        ...)
    


    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vsnprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    

     
    
    __inline int __cdecl _snprintf_s(
           char*       const _Buffer,
                                                       size_t      const _BufferCount,
                                                       size_t      const _MaxCount,
                                char const* const _Format,
        ...)
    


    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vsnprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    

    extern "C++" { __pragma(warning(push)); __pragma(warning(disable: 4793)); template <size_t _Size> inline   int __cdecl _snprintf_s( char (&_Buffer)[_Size],   size_t _BufferCount,     char const* _Format, ...) throw() { va_list _ArgList; ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format))))); return _vsnprintf_s(_Buffer, _Size, _BufferCount, _Format, _ArgList); } __pragma(warning(pop)); }

    
    __inline int __cdecl _scprintf_l(
            char const* const _Format,
                                         _locale_t   const _Locale,
        ...)
    


    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vscprintf_l(_Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    

     
    __inline int __cdecl _scprintf(
            char const* const _Format,
        ...)
    


    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vscprintf_l(_Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    

    
    __inline int __cdecl _scprintf_p_l(
            char const* const _Format,
                                         _locale_t   const _Locale,
        ...)
    


    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vscprintf_p_l(_Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    

     
    __inline int __cdecl _scprintf_p(
            char const* const _Format,
        ...)
    


    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vscprintf_p(_Format, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    

    //-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    //
    // Narrow Character Formatted Input Functions (String)
    //
    //-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    __declspec(dllimport) int __cdecl __stdio_common_vsscanf(
                                            unsigned __int64 _Options,
                  char const*      _Buffer,
                                            size_t           _BufferCount,
            char const*      _Format,
                                        _locale_t        _Locale,
                                               va_list          _ArgList
        );

    
    __inline int __cdecl _vsscanf_l(
                                 char const* const _Buffer,
            char const* const _Format,
                               _locale_t   const _Locale,
                                      va_list           _ArgList
        )
    


    {
        return __stdio_common_vsscanf(
            (*__local_stdio_scanf_options ()),
            _Buffer, (size_t)-1, _Format, _Locale, _ArgList);
    }
    

    
    __inline int __cdecl vsscanf(
                                 char const* const _Buffer,
            char const* const _Format,
                                      va_list           _ArgList
        )
    


    {
        return _vsscanf_l(_Buffer, _Format, 0, _ArgList);
    }
    

    
    __inline int __cdecl _vsscanf_s_l(
                                 char const* const _Buffer,
            char const* const _Format,
                               _locale_t   const _Locale,
                                      va_list           _ArgList
        )
    


    {
        return __stdio_common_vsscanf(
            (*__local_stdio_scanf_options ()) | (1ULL << 0),
            _Buffer, (size_t)-1, _Format, _Locale, _ArgList);
    }
    

    

        #pragma warning(push)
        #pragma warning(disable:6530)

        
        __inline int __cdecl vsscanf_s(
                                     char const* const _Buffer,
                char const* const _Format,
                                          va_list           _ArgList
            )
    


        {
            return _vsscanf_s_l(_Buffer, _Format, 0, _ArgList);
        }
    

        extern "C++" { template <size_t _Size> inline int __cdecl vsscanf_s(  char const (&_Buffer)[_Size],     char const* _Format, va_list _ArgList) throw() { return vsscanf_s(_Buffer, _Size, _Format, _ArgList); } }

        #pragma warning(pop)

    

     __declspec(deprecated("This function or variable may be unsafe. Consider using " "_sscanf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl _sscanf_l(
                                          char const* const _Buffer,
            char const* const _Format,
                                        _locale_t   const _Locale,
        ...)
    


    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vsscanf_l(_Buffer, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    

      __declspec(deprecated("This function or variable may be unsafe. Consider using " "sscanf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl sscanf(
                                char const* const _Buffer,
            char const* const _Format,
        ...)
    


    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vsscanf_l(_Buffer, _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    

    
    __inline int __cdecl _sscanf_s_l(
                                            char const* const _Buffer,
            char const* const _Format,
                                          _locale_t   const _Locale,
        ...)
    


    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vsscanf_s_l(_Buffer, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    

    

        
        __inline int __cdecl sscanf_s(
                                      char const* const _Buffer,
                char const* const _Format,
            ...)
    


        {
            int _Result;
            va_list _ArgList;
            ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));

            #pragma warning(push)
            #pragma warning(disable: 4996) 
            _Result = vsscanf_s(_Buffer, _Format, _ArgList);
            #pragma warning(pop)

            ((void)(_ArgList = (va_list)0));
            return _Result;
        }
    

    

    #pragma warning(push)
    #pragma warning(disable:6530)

     __declspec(deprecated("This function or variable may be unsafe. Consider using " "_snscanf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl _snscanf_l(
            char const* const _Buffer,
                                            size_t      const _BufferCount,
            char const* const _Format,
                                        _locale_t   const _Locale,
        ...)
    


    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));

        _Result = __stdio_common_vsscanf(
            (*__local_stdio_scanf_options ()),
            _Buffer, _BufferCount, _Format, _Locale, _ArgList);

        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    

     __declspec(deprecated("This function or variable may be unsafe. Consider using " "_snscanf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl _snscanf(
            char const* const _Buffer,
                                            size_t      const _BufferCount,
                      char const* const _Format,
        ...)
    


    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));

        _Result = __stdio_common_vsscanf(
            (*__local_stdio_scanf_options ()),
            _Buffer, _BufferCount, _Format, 0, _ArgList);

        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    


    
    __inline int __cdecl _snscanf_s_l(
              char const* const _Buffer,
                                              size_t      const _BufferCount,
            char const* const _Format,
                                          _locale_t   const _Locale,
        ...)
    


    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));

        _Result = __stdio_common_vsscanf(
            (*__local_stdio_scanf_options ()) | (1ULL << 0),
            _Buffer, _BufferCount, _Format, _Locale, _ArgList);

        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    

    
    __inline int __cdecl _snscanf_s(
            char const* const _Buffer,
                                            size_t      const _BufferCount,
                    char const* const _Format,
        ...)
    


    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));

        _Result = __stdio_common_vsscanf(
            (*__local_stdio_scanf_options ()) | (1ULL << 0),
            _Buffer, _BufferCount, _Format, 0, _ArgList);

        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    

    #pragma warning(pop)

    





    //-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    //
    // Non-ANSI Names for Compatibility
    //
    //-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    

        

        




        __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_tempnam" ". See online help for details."))
        __declspec(dllimport) char* __cdecl tempnam(
              char const* _Directory,
              char const* _FilePrefix
            );

        



         __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_fcloseall" ". See online help for details.")) __declspec(dllimport) int   __cdecl fcloseall(void);
              __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_fdopen" ". See online help for details."))    __declspec(dllimport) FILE* __cdecl fdopen(  int _FileHandle,   char const* _Format);
         __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_fgetchar" ". See online help for details."))  __declspec(dllimport) int   __cdecl fgetchar(void);
              __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_fileno" ". See online help for details."))    __declspec(dllimport) int   __cdecl fileno(  FILE* _Stream);
         __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_flushall" ". See online help for details."))  __declspec(dllimport) int   __cdecl flushall(void);
         __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_fputchar" ". See online help for details."))  __declspec(dllimport) int   __cdecl fputchar(  int _Ch);
              __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_getw" ". See online help for details."))      __declspec(dllimport) int   __cdecl getw(  FILE* _Stream);
         __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_putw" ". See online help for details."))      __declspec(dllimport) int   __cdecl putw(  int _Ch,   FILE* _Stream);
              __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_rmtmp" ". See online help for details."))     __declspec(dllimport) int   __cdecl rmtmp(void);

    




} __pragma(pack(pop))



#pragma pack(push,8)
#pragma warning(push,3)
#pragma warning(disable: 4455 4494  4619 4643 4702 4984 4988 )




// undef common macro overrides
 
 
 
 
 
 
 

// TRANSITION: Boost nonconformingly uses this macro


namespace std {
#pragma warning(push)
#pragma warning(disable: 4995) 

using :: FILE; using :: _Mbstatet;

using :: size_t; using :: fpos_t; using :: FILE;
using :: clearerr; using :: fclose; using :: feof;
using :: ferror; using :: fflush; using :: fgetc;
using :: fgetpos; using :: fgets; using :: fopen;
using :: fprintf; using :: fputc; using :: fputs;
using :: fread; using :: freopen; using :: fscanf;
using :: fseek; using :: fsetpos; using :: ftell;
using :: fwrite; using :: getc; using :: getchar;
using :: perror;
using :: putc; using :: putchar;
using :: printf; using :: puts; using :: remove;
using :: rename; using :: rewind; using :: scanf;
using :: setbuf; using :: setvbuf; using :: sprintf;
using :: sscanf; using :: tmpfile; using :: tmpnam;
using :: ungetc; using :: vfprintf; using :: vprintf;
using :: vsprintf;

using :: snprintf; using :: vsnprintf;
using :: vfscanf; using :: vscanf; using :: vsscanf;

#pragma warning(pop)
}



#pragma warning(pop)
#pragma pack(pop)




/*
 * Copyright (c) by P.J. Plauger. All rights reserved.
 * Consult your license regarding permissions and restrictions.
V6.50:0009 */



// streambuf standard header
#pragma once




// xiosbase internal header (from <ios>)
#pragma once




// xlocale internal header (from <locale>)
#pragma once





// cstring standard header
#pragma once






//
// string.h
//
//      Copyright (c) Microsoft Corporation. All rights reserved.
//
// The C Standard Library <string.h> header.
//
#pragma once





//
// corecrt_memory.h
//
//      Copyright (c) Microsoft Corporation. All rights reserved.
//
// The buffer (memory) manipulation library.  These declarations are split out
// so that they may be included by both <string.h> and <memory.h>.  <string.h>
// does not include <memory.h> to avoid introducing conflicts with other user
// headers named <memory.h>.
//
#pragma once



//
// corecrt_memcpy_s.h
//
//      Copyright (c) Microsoft Corporation. All rights reserved.
//
// Inline definitions of memcpy_s and memmove_s
//
#pragma once



//
// errno.h
//
//      Copyright (c) Microsoft Corporation. All rights reserved.
//
// System error numbers for use with errno and errno_t.
//
#pragma once





__pragma(pack(push, 8)) extern "C" {




    __declspec(dllimport) int* __cdecl _errno(void);
    

    __declspec(dllimport) errno_t __cdecl _set_errno(  int _Value);
    __declspec(dllimport) errno_t __cdecl _get_errno(  int* _Value);

    __declspec(dllimport) unsigned long* __cdecl __doserrno(void);
    

    __declspec(dllimport) errno_t __cdecl _set_doserrno(  unsigned long _Value);
    __declspec(dllimport) errno_t __cdecl _get_doserrno(  unsigned long * _Value);




// Error codes




































// Error codes used in the Secure CRT functions

    
    
    
    
    


// Support EDEADLOCK for compatibility with older Microsoft C versions


// POSIX Supplement

    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    




} __pragma(pack(pop))



//
// vcruntime_string.h
//
//      Copyright (c) Microsoft Corporation. All rights reserved.
//
// <string.h> functionality that is implemented in the VCRuntime.
//
#pragma once





__pragma(pack(push, 8)) extern "C" {



 
 void const* __cdecl memchr(
      void const* _Buf,
                                 int         _Val,
                                 size_t      _MaxCount
    );

 
int __cdecl memcmp(
      void const* _Buf1,
      void const* _Buf2,
                         size_t      _Size
    );


 

void* __cdecl memcpy(
      void* _Dst,
            void const* _Src,
                               size_t      _Size
    );


 void* __cdecl memmove(
      void*       _Dst,
            void const* _Src,
                                   size_t      _Size
    );

 

void* __cdecl memset(
      void*  _Dst,
                               int    _Val,
                               size_t _Size
    );

 
 char const* __cdecl strchr(
      char const* _Str,
        int         _Val
    );

 
 char const* __cdecl strrchr(
      char const* _Str,
        int         _Ch
    );

   
 char const* __cdecl strstr(
      char const* _Str,
      char const* _SubStr
    );

 

 wchar_t const* __cdecl wcschr(
      wchar_t const* _Str,
        wchar_t        _Ch
    );

 
 wchar_t const* __cdecl wcsrchr(
      wchar_t const* _Str,
        wchar_t        _Ch
    );

   

 wchar_t const* __cdecl wcsstr(
      wchar_t const* _Str,
      wchar_t const* _SubStr
    );



} __pragma(pack(pop))




__pragma(pack(push, 8)) extern "C" {


    















     
    
    static __inline errno_t __cdecl memcpy_s(
          void*       const _Destination,
                                                              rsize_t     const _DestinationSize,
                                 void const* const _Source,
                                                              rsize_t     const _SourceSize
        )
    {
        if (_SourceSize == 0)
        {
            return 0;
        }

        { int _Expr_val=!!(_Destination != 0); if (!(_Expr_val)) { (*_errno()) = 22; _invalid_parameter_noinfo(); return 22; } };
        if (_Source == 0 || _DestinationSize < _SourceSize)
        {
            memset(_Destination, 0, _DestinationSize);

            { int _Expr_val=!!(_Source != 0); if (!(_Expr_val)) { (*_errno()) = 22; _invalid_parameter_noinfo(); return 22; } };
            { int _Expr_val=!!(_DestinationSize >= _SourceSize); if (!(_Expr_val)) { (*_errno()) = 34; _invalid_parameter_noinfo(); return 34; } };

            // Unreachable, but required to suppress /analyze warnings:
            return 22;
        }
#pragma warning(suppress:4996) 
        memcpy(_Destination, _Source, _SourceSize);
        return 0;
    }

    
    static __inline errno_t __cdecl memmove_s(
          void*       const _Destination,
                                                              rsize_t     const _DestinationSize,
                                 void const* const _Source,
                                                              rsize_t     const _SourceSize
        )
    {
        if (_SourceSize == 0)
        {
            return 0;
        }

        { int _Expr_val=!!(_Destination != 0); if (!(_Expr_val)) { (*_errno()) = 22; _invalid_parameter_noinfo(); return 22; } };
        { int _Expr_val=!!(_Source != 0); if (!(_Expr_val)) { (*_errno()) = 22; _invalid_parameter_noinfo(); return 22; } };
        { int _Expr_val=!!(_DestinationSize >= _SourceSize); if (!(_Expr_val)) { (*_errno()) = 34; _invalid_parameter_noinfo(); return 34; } };

#pragma warning(suppress:4996) 
        memmove(_Destination, _Source, _SourceSize);
        return 0;
    }





} __pragma(pack(pop))





__pragma(pack(push, 8)) extern "C" {



 
__declspec(dllimport) int __cdecl _memicmp(
      void const* _Buf1,
      void const* _Buf2,
                             size_t      _Size
    );

 
__declspec(dllimport) int __cdecl _memicmp_l(
      void const* _Buf1,
      void const* _Buf2,
                             size_t      _Size,
                         _locale_t   _Locale
    );





    














    




















    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_memccpy" ". See online help for details."))
    __declspec(dllimport) void* __cdecl memccpy(
          void*       _Dst,
            void const* _Src,
                                   int         _Val,
                                   size_t      _Size
        );

      __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_memicmp" ". See online help for details."))
    __declspec(dllimport) int __cdecl memicmp(
          void const* _Buf1,
          void const* _Buf2,
                                 size_t      _Size
        );







    extern "C++"  
    inline void* __cdecl memchr(
          void*  _Pv,
                              int    _C,
                              size_t _N
        )
    {
        void const* const _Pvc = _Pv;
        return const_cast<void*>(memchr(_Pvc, _C, _N));
    }





} __pragma(pack(pop))




//
// corecrt_wstring.h
//
//      Copyright (c) Microsoft Corporation. All rights reserved.
//
// This file declares the wide character (wchar_t) string functionality, shared
// by <string.h> and <wchar.h>.
//
#pragma once






__pragma(pack(push, 8)) extern "C" {



//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// Secure Alternatives
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+


    
    __declspec(dllimport) errno_t __cdecl wcscat_s(
          wchar_t* _Destination,
          rsize_t _SizeInWords,
          wchar_t const* _Source
        );

    
    __declspec(dllimport) errno_t __cdecl wcscpy_s(
          wchar_t* _Destination,
          rsize_t _SizeInWords,
          wchar_t const* _Source
        );

    
    __declspec(dllimport) errno_t __cdecl wcsncat_s(
          wchar_t*       _Destination,
                                     rsize_t        _SizeInWords,
               wchar_t const* _Source,
                                     rsize_t        _MaxCount
        );

    
    __declspec(dllimport) errno_t __cdecl wcsncpy_s(
          wchar_t*       _Destination,
                                  rsize_t        _SizeInWords,
            wchar_t const* _Source,
                                  rsize_t        _MaxCount
        );

     
    __declspec(dllimport) wchar_t* __cdecl wcstok_s(
                          wchar_t*       _String,
                                 wchar_t const* _Delimiter,
            wchar_t**      _Context
        );





//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// Wide-Character <string.h> Functions
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+





 
__declspec(dllimport) __declspec(allocator) wchar_t* __cdecl _wcsdup(
      wchar_t const* _String
    );







extern "C++" { template <size_t _Size> inline errno_t __cdecl wcscat_s(wchar_t (&_Destination)[_Size],   wchar_t const* _Source) throw() { return wcscat_s(_Destination, _Size, _Source); } }



#pragma warning(push)
#pragma warning(disable: 28719) 
#pragma warning(disable: 28726) 
    __declspec(deprecated("This function or variable may be unsafe. Consider using " "wcscat_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) wchar_t* __cdecl wcscat( wchar_t *_Destination,  wchar_t const* _Source);
#pragma warning(pop)


 
__declspec(dllimport) int __cdecl wcscmp(
      wchar_t const* _String1,
      wchar_t const* _String2
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl wcscpy_s(wchar_t (&_Destination)[_Size],   wchar_t const* _Source) throw() { return wcscpy_s(_Destination, _Size, _Source); } }

#pragma warning(push)
#pragma warning(disable: 28719) 
#pragma warning(disable: 28726) 
__declspec(deprecated("This function or variable may be unsafe. Consider using " "wcscpy_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) wchar_t* __cdecl wcscpy( wchar_t *_Destination,  wchar_t const* _Source);
#pragma warning(pop)

 
__declspec(dllimport) size_t __cdecl wcscspn(
      wchar_t const* _String,
      wchar_t const* _Control
    );

 
__declspec(dllimport) size_t __cdecl wcslen(
      wchar_t const* _String
    );

 


__declspec(dllimport) size_t __cdecl wcsnlen(
      wchar_t const* _Source,
                            size_t         _MaxCount
    );



     
    
    
    static __inline size_t __cdecl wcsnlen_s(
          wchar_t const* _Source,
                                size_t         _MaxCount
        )
    {
        return (_Source == 0) ? 0 : wcsnlen(_Source, _MaxCount);
    }



extern "C++" { template <size_t _Size> inline errno_t __cdecl wcsncat_s(  wchar_t (&_Destination)[_Size],   wchar_t const* _Source,   size_t _Count) throw() { return wcsncat_s(_Destination, _Size, _Source, _Count); } }

__declspec(deprecated("This function or variable may be unsafe. Consider using " "wcsncat_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) wchar_t* __cdecl wcsncat(  wchar_t *_Destination,   wchar_t const* _Source,   size_t _Count);

 
__declspec(dllimport) int __cdecl wcsncmp(
      wchar_t const* _String1,
      wchar_t const* _String2,
                            size_t         _MaxCount
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl wcsncpy_s(wchar_t (&_Destination)[_Size],   wchar_t const* _Source,   size_t _Count) throw() { return wcsncpy_s(_Destination, _Size, _Source, _Count); } }

__declspec(deprecated("This function or variable may be unsafe. Consider using " "wcsncpy_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) wchar_t* __cdecl wcsncpy(    wchar_t *_Destination,   wchar_t const* _Source,   size_t _Count);

 
__declspec(dllimport) wchar_t const* __cdecl wcspbrk(
      wchar_t const* _String,
      wchar_t const* _Control
    );

 
__declspec(dllimport) size_t __cdecl wcsspn(
      wchar_t const* _String,
      wchar_t const* _Control
    );

  __declspec(deprecated("This function or variable may be unsafe. Consider using " "wcstok_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__declspec(dllimport) wchar_t* __cdecl wcstok(
                          wchar_t*       _String,
                                 wchar_t const* _Delimiter,
        wchar_t**      _Context
    );



    


        



    

    #pragma warning(push)
    #pragma warning(disable: 4141 4996) 
    #pragma warning(disable: 28719 28726 28727) 
      __declspec(deprecated("This function or variable may be unsafe. Consider using " "wcstok_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    static __inline wchar_t* __cdecl _wcstok(
          wchar_t*       const _String,
                 wchar_t const* const _Delimiter
        )
    {
        return wcstok(_String, _Delimiter, 0);
    }

    



    
        extern "C++"   __declspec(deprecated("wcstok has been changed to conform with the ISO C standard, " "adding an extra context parameter. To use the legacy Microsoft " "wcstok, define _CRT_NON_CONFORMING_WCSTOK."))
        inline wchar_t* __cdecl wcstok(
              wchar_t*       _String,
                     wchar_t const* _Delimiter
            ) throw()
        {
            return wcstok(_String, _Delimiter, 0);
        }
    

    #pragma warning(pop)





 
  __declspec(deprecated("This function or variable may be unsafe. Consider using " "_wcserror_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__declspec(dllimport) wchar_t* __cdecl _wcserror(
      int _ErrorNumber
    );


__declspec(dllimport) errno_t __cdecl _wcserror_s(
      wchar_t* _Buffer,
                                  size_t   _SizeInWords,
                                  int      _ErrorNumber
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _wcserror_s(wchar_t (&_Buffer)[_Size],   int _Error) throw() { return _wcserror_s(_Buffer, _Size, _Error); } }

 
 
  __declspec(deprecated("This function or variable may be unsafe. Consider using " "__wcserror_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__declspec(dllimport) wchar_t* __cdecl __wcserror(
      wchar_t const* _String
    );

 __declspec(dllimport) errno_t __cdecl __wcserror_s(
      wchar_t*       _Buffer,
                                  size_t         _SizeInWords,
                                wchar_t const* _ErrorMessage
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl __wcserror_s(wchar_t (&_Buffer)[_Size],   wchar_t const* _ErrorMessage) throw() { return __wcserror_s(_Buffer, _Size, _ErrorMessage); } }

  __declspec(dllimport) int __cdecl _wcsicmp(
      wchar_t const* _String1,
      wchar_t const* _String2
    );

  __declspec(dllimport) int __cdecl _wcsicmp_l(
        wchar_t const* _String1,
        wchar_t const* _String2,
      _locale_t      _Locale
    );

  __declspec(dllimport) int __cdecl _wcsnicmp(
      wchar_t const* _String1,
      wchar_t const* _String2,
                            size_t         _MaxCount
    );

  __declspec(dllimport) int __cdecl _wcsnicmp_l(
      wchar_t const* _String1,
      wchar_t const* _String2,
                            size_t         _MaxCount,
                        _locale_t      _Locale
    );

 __declspec(dllimport) errno_t __cdecl _wcsnset_s(
      wchar_t* _Destination,
                                 size_t   _SizeInWords,
                                 wchar_t  _Value,
                                 size_t   _MaxCount
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _wcsnset_s(  wchar_t (&_Destination)[_Size],   wchar_t _Value,   size_t _MaxCount) throw() { return _wcsnset_s(_Destination, _Size, _Value, _MaxCount); } }

__declspec(deprecated("This function or variable may be unsafe. Consider using " "_wcsnset_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) wchar_t* __cdecl _wcsnset(  wchar_t *_String,   wchar_t _Value,   size_t _MaxCount);

__declspec(dllimport) wchar_t* __cdecl _wcsrev(
      wchar_t* _String
    );

 __declspec(dllimport) errno_t __cdecl _wcsset_s(
      wchar_t* _Destination,
                                 size_t   _SizeInWords,
                                 wchar_t  _Value
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _wcsset_s(  wchar_t (&_String)[_Size],   wchar_t _Value) throw() { return _wcsset_s(_String, _Size, _Value); } }

__declspec(deprecated("This function or variable may be unsafe. Consider using " "_wcsset_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) wchar_t* __cdecl _wcsset(  wchar_t *_String,   wchar_t _Value);

 __declspec(dllimport) errno_t __cdecl _wcslwr_s(
      wchar_t* _String,
                                 size_t   _SizeInWords
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _wcslwr_s(  wchar_t (&_String)[_Size]) throw() { return _wcslwr_s(_String, _Size); } }

__declspec(deprecated("This function or variable may be unsafe. Consider using " "_wcslwr_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) wchar_t* __cdecl _wcslwr( wchar_t *_String);


__declspec(dllimport) errno_t __cdecl _wcslwr_s_l(
      wchar_t*  _String,
                                 size_t    _SizeInWords,
                             _locale_t _Locale
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _wcslwr_s_l(  wchar_t (&_String)[_Size],   _locale_t _Locale) throw() { return _wcslwr_s_l(_String, _Size, _Locale); } }

__declspec(deprecated("This function or variable may be unsafe. Consider using " "_wcslwr_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) wchar_t* __cdecl _wcslwr_l(  wchar_t *_String,   _locale_t _Locale);


__declspec(dllimport) errno_t __cdecl _wcsupr_s(
      wchar_t* _String,
                          size_t   _Size
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _wcsupr_s(  wchar_t (&_String)[_Size]) throw() { return _wcsupr_s(_String, _Size); } }

__declspec(deprecated("This function or variable may be unsafe. Consider using " "_wcsupr_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) wchar_t* __cdecl _wcsupr( wchar_t *_String);


__declspec(dllimport) errno_t __cdecl _wcsupr_s_l(
      wchar_t*  _String,
                          size_t    _Size,
                      _locale_t _Locale
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _wcsupr_s_l(  wchar_t (&_String)[_Size],   _locale_t _Locale) throw() { return _wcsupr_s_l(_String, _Size, _Locale); } }

__declspec(deprecated("This function or variable may be unsafe. Consider using " "_wcsupr_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) wchar_t* __cdecl _wcsupr_l(  wchar_t *_String,   _locale_t _Locale);

 

__declspec(dllimport) size_t __cdecl wcsxfrm(
        wchar_t*       _Destination,
                                         wchar_t const* _Source,
                size_t         _MaxCount
    );

 

__declspec(dllimport) size_t __cdecl _wcsxfrm_l(
        wchar_t*       _Destination,
                                         wchar_t const* _Source,
                size_t         _MaxCount,
                                       _locale_t      _Locale
    );

 
__declspec(dllimport) int __cdecl wcscoll(
      wchar_t const* _String1,
      wchar_t const* _String2
    );

 
__declspec(dllimport) int __cdecl _wcscoll_l(
        wchar_t const* _String1,
        wchar_t const* _String2,
      _locale_t      _Locale
    );

 
__declspec(dllimport) int __cdecl _wcsicoll(
      wchar_t const* _String1,
      wchar_t const* _String2
    );

 
__declspec(dllimport) int __cdecl _wcsicoll_l(
        wchar_t const* _String1,
        wchar_t const* _String2,
      _locale_t      _Locale
    );

 
__declspec(dllimport) int __cdecl _wcsncoll(
      wchar_t const* _String1,
      wchar_t const* _String2,
                            size_t         _MaxCount
    );

 
__declspec(dllimport) int __cdecl _wcsncoll_l(
      wchar_t const* _String1,
      wchar_t const* _String2,
                            size_t         _MaxCount,
                        _locale_t      _Locale
    );

 
__declspec(dllimport) int __cdecl _wcsnicoll(
      wchar_t const* _String1,
      wchar_t const* _String2,
                            size_t         _MaxCount
    );

 
__declspec(dllimport) int __cdecl _wcsnicoll_l(
      wchar_t const* _String1,
      wchar_t const* _String2,
                            size_t         _MaxCount,
                        _locale_t      _Locale
    );



//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// Inline C++ Overloads
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

extern "C++" {

     
    
    inline wchar_t* __cdecl wcschr(  wchar_t* _String, wchar_t _C)
    {
        return const_cast<wchar_t*>(wcschr(static_cast<wchar_t const*>(_String), _C));
    }

     
    inline wchar_t* __cdecl wcspbrk(  wchar_t* _String,   wchar_t const* _Control)
    {
        return const_cast<wchar_t*>(wcspbrk(static_cast<wchar_t const*>(_String), _Control));
    }

     
    inline wchar_t* __cdecl wcsrchr(  wchar_t* _String,   wchar_t _C)
    {
        return const_cast<wchar_t*>(wcsrchr(static_cast<wchar_t const*>(_String), _C));
    }

       
    
    inline wchar_t* __cdecl wcsstr(  wchar_t* _String,   wchar_t const*_SubStr)
    {
        return const_cast<wchar_t*>(wcsstr(static_cast<wchar_t const*>(_String), _SubStr));
    }

}




//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// Non-Standard Names
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

    




      __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_wcsdup" ". See online help for details."))
    __declspec(dllimport) wchar_t* __cdecl wcsdup(
          wchar_t const* _String
        );

    



    // Declarations of functions defined in oldnames.lib:
    

      __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_wcsicmp" ". See online help for details."))
    __declspec(dllimport) int __cdecl wcsicmp(
          wchar_t const* _String1,
          wchar_t const* _String2
        );

      __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_wcsnicmp" ". See online help for details."))
    __declspec(dllimport) int __cdecl wcsnicmp(
          wchar_t const* _String1,
          wchar_t const* _String2,
                                size_t         _MaxCount
        );

    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_wcsnset" ". See online help for details."))
     
    __declspec(dllimport) wchar_t* __cdecl wcsnset(
          wchar_t* _String,
                                  wchar_t  _Value,
                                  size_t   _MaxCount
        );

    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_wcsrev" ". See online help for details."))
     
    __declspec(dllimport) wchar_t* __cdecl wcsrev(
          wchar_t* _String
        );

    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_wcsset" ". See online help for details."))
     
    __declspec(dllimport) wchar_t* __cdecl wcsset(
          wchar_t* _String,
               wchar_t  _Value
        );

    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_wcslwr" ". See online help for details."))
     
    __declspec(dllimport) wchar_t* __cdecl wcslwr(
          wchar_t* _String
        );

    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_wcsupr" ". See online help for details."))
     
    __declspec(dllimport) wchar_t* __cdecl wcsupr(
          wchar_t* _String
        );

      __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_wcsicoll" ". See online help for details."))
    __declspec(dllimport) int __cdecl wcsicoll(
          wchar_t const* _String1,
          wchar_t const* _String2
        );





} __pragma(pack(pop))







__pragma(pack(push, 8)) extern "C" {







    
    __declspec(dllimport) errno_t __cdecl strcpy_s(
          char*       _Destination,
                                  rsize_t     _SizeInBytes,
                                char const* _Source
        );

    
    __declspec(dllimport) errno_t __cdecl strcat_s(
          char*       _Destination,
                                     rsize_t     _SizeInBytes,
                                   char const* _Source
        );

    
    __declspec(dllimport) errno_t __cdecl strerror_s(
          char*  _Buffer,
                                  size_t _SizeInBytes,
                                  int    _ErrorNumber);

    
    __declspec(dllimport) errno_t __cdecl strncat_s(
          char*       _Destination,
                                     rsize_t     _SizeInBytes,
               char const* _Source,
                                     rsize_t     _MaxCount
        );

    
    __declspec(dllimport) errno_t __cdecl strncpy_s(
          char*       _Destination,
                                  rsize_t     _SizeInBytes,
            char const* _Source,
                                  rsize_t     _MaxCount
        );

     
    __declspec(dllimport) char*  __cdecl strtok_s(
                          char*       _String,
                                 char const* _Delimiter,
            char**      _Context
        );



__declspec(dllimport) void* __cdecl _memccpy(
      void*       _Dst,
                                   void const* _Src,
                                   int         _Val,
                                   size_t      _MaxCount
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl strcat_s(char (&_Destination)[_Size],   char const* _Source) throw() { return strcat_s(_Destination, _Size, _Source); } }



#pragma warning(push)
#pragma warning(disable: 28719) 
#pragma warning(disable: 28726) 
    __declspec(deprecated("This function or variable may be unsafe. Consider using " "strcat_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))  char* __cdecl strcat( char *_Destination,  char const* _Source);
#pragma warning(pop)



 
int __cdecl strcmp(
      char const* _Str1,
      char const* _Str2
    );

 
__declspec(dllimport) int __cdecl _strcmpi(
      char const* _String1,
      char const* _String2
    );

 
__declspec(dllimport) int __cdecl strcoll(
      char const* _String1,
      char const* _String2
    );

 
__declspec(dllimport) int __cdecl _strcoll_l(
        char const* _String1,
        char const* _String2,
      _locale_t   _Locale
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl strcpy_s(  char (&_Destination)[_Size],   char const* _Source) throw() { return strcpy_s(_Destination, _Size, _Source); } }

#pragma warning(push)
#pragma warning(disable: 28719) 
#pragma warning(disable: 28726) 
__declspec(deprecated("This function or variable may be unsafe. Consider using " "strcpy_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))  char* __cdecl strcpy( char *_Destination,  char const* _Source);
#pragma warning(pop)

 
__declspec(dllimport) size_t __cdecl strcspn(
      char const* _Str,
      char const* _Control
    );






 
__declspec(dllimport) __declspec(allocator) char* __cdecl _strdup(
      char const* _Source
    );





 
 
  __declspec(deprecated("This function or variable may be unsafe. Consider using " "_strerror_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__declspec(dllimport) char*  __cdecl _strerror(
      char const* _ErrorMessage
    );


__declspec(dllimport) errno_t __cdecl _strerror_s(
      char*       _Buffer,
                              size_t      _SizeInBytes,
                        char const* _ErrorMessage
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _strerror_s(char (&_Buffer)[_Size],   char const* _ErrorMessage) throw() { return _strerror_s(_Buffer, _Size, _ErrorMessage); } }

 
  __declspec(deprecated("This function or variable may be unsafe. Consider using " "strerror_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__declspec(dllimport) char* __cdecl strerror(
      int _ErrorMessage
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl strerror_s(char (&_Buffer)[_Size],   int _ErrorMessage) throw() { return strerror_s(_Buffer, _Size, _ErrorMessage); } }

 
__declspec(dllimport) int __cdecl _stricmp(
      char const* _String1,
      char const* _String2
    );

 
__declspec(dllimport) int __cdecl _stricoll(
      char const* _String1,
      char const* _String2
    );

 
__declspec(dllimport) int __cdecl _stricoll_l(
        char const* _String1,
        char const* _String2,
      _locale_t   _Locale
    );

 
__declspec(dllimport) int __cdecl _stricmp_l(
        char const* _String1,
        char const* _String2,
      _locale_t   _Locale
    );

 
size_t __cdecl strlen(
      char const* _Str
    );


__declspec(dllimport) errno_t __cdecl _strlwr_s(
      char*  _String,
                          size_t _Size
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _strlwr_s(  char (&_String)[_Size]) throw() { return _strlwr_s(_String, _Size); } }

__declspec(deprecated("This function or variable may be unsafe. Consider using " "_strlwr_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) char* __cdecl _strlwr( char *_String);


__declspec(dllimport) errno_t __cdecl _strlwr_s_l(
      char*     _String,
                          size_t    _Size,
                      _locale_t _Locale
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _strlwr_s_l(  char (&_String)[_Size],   _locale_t _Locale) throw() { return _strlwr_s_l(_String, _Size, _Locale); } }

__declspec(deprecated("This function or variable may be unsafe. Consider using " "_strlwr_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) char* __cdecl _strlwr_l(  char *_String,   _locale_t _Locale);

extern "C++" { template <size_t _Size> inline errno_t __cdecl strncat_s(  char (&_Destination)[_Size],   char const* _Source,   size_t _Count) throw() { return strncat_s(_Destination, _Size, _Source, _Count); } }

__declspec(deprecated("This function or variable may be unsafe. Consider using " "strncat_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) char* __cdecl strncat(  char *_Destination,   char const* _Source,   size_t _Count);

 
__declspec(dllimport) int __cdecl strncmp(
      char const* _Str1,
      char const* _Str2,
                            size_t      _MaxCount
    );

 
__declspec(dllimport) int __cdecl _strnicmp(
      char const* _String1,
      char const* _String2,
                            size_t      _MaxCount
    );

 
__declspec(dllimport) int __cdecl _strnicmp_l(
      char const* _String1,
      char const* _String2,
                            size_t      _MaxCount,
                        _locale_t   _Locale
    );

 
__declspec(dllimport) int __cdecl _strnicoll(
      char const* _String1,
      char const* _String2,
                            size_t      _MaxCount
    );

 
__declspec(dllimport) int __cdecl _strnicoll_l(
      char const* _String1,
      char const* _String2,
                            size_t      _MaxCount,
                        _locale_t   _Locale
    );

 
__declspec(dllimport) int __cdecl _strncoll(
      char const* _String1,
      char const* _String2,
                            size_t      _MaxCount
    );

 
__declspec(dllimport) int __cdecl _strncoll_l(
      char const* _String1,
      char const* _String2,
                            size_t      _MaxCount,
                        _locale_t   _Locale
    );

__declspec(dllimport) size_t __cdecl __strncnt(
      char const* _String,
                         size_t      _Count
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl strncpy_s(char (&_Destination)[_Size],   char const* _Source,   size_t _Count) throw() { return strncpy_s(_Destination, _Size, _Source, _Count); } }

__declspec(deprecated("This function or variable may be unsafe. Consider using " "strncpy_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) char* __cdecl strncpy(    char *_Destination,   char const* _Source,   size_t _Count);

 


__declspec(dllimport) size_t __cdecl strnlen(
      char const* _String,
                            size_t      _MaxCount
    );



     
    
    
    static __inline size_t __cdecl strnlen_s(
          char const* _String,
                                size_t      _MaxCount
        )
    {
        return _String == 0 ? 0 : strnlen(_String, _MaxCount);
    }




__declspec(dllimport) errno_t __cdecl _strnset_s(
      char*  _String,
                                 size_t _SizeInBytes,
                                 int    _Value,
                                 size_t _MaxCount
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _strnset_s(  char (&_Destination)[_Size],   int _Value,   size_t _Count) throw() { return _strnset_s(_Destination, _Size, _Value, _Count); } }

__declspec(deprecated("This function or variable may be unsafe. Consider using " "_strnset_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) char* __cdecl _strnset(  char *_Destination,   int _Value,   size_t _Count);

 
__declspec(dllimport) char const* __cdecl strpbrk(
      char const* _Str,
      char const* _Control
    );

__declspec(dllimport) char* __cdecl _strrev(
      char* _Str
    );


__declspec(dllimport) errno_t __cdecl _strset_s(
      char*  _Destination,
                                     size_t _DestinationSize,
                                     int    _Value
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _strset_s(  char (&_Destination)[_Size],   int _Value) throw() { return _strset_s(_Destination, _Size, _Value); } }

__declspec(deprecated("This function or variable may be unsafe. Consider using " "_strset_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))  char* __cdecl _strset( char *_Destination,  int _Value);

 
__declspec(dllimport) size_t __cdecl strspn(
      char const* _Str,
      char const* _Control
    );

  __declspec(deprecated("This function or variable may be unsafe. Consider using " "strtok_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__declspec(dllimport) char* __cdecl strtok(
      char*       _String,
             char const* _Delimiter
    );


__declspec(dllimport) errno_t __cdecl _strupr_s(
      char*  _String,
                          size_t _Size
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _strupr_s(  char (&_String)[_Size]) throw() { return _strupr_s(_String, _Size); } }

__declspec(deprecated("This function or variable may be unsafe. Consider using " "_strupr_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) char* __cdecl _strupr( char *_String);


__declspec(dllimport) errno_t __cdecl _strupr_s_l(
      char*     _String,
                          size_t    _Size,
                      _locale_t _Locale
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _strupr_s_l(  char (&_String)[_Size],   _locale_t _Locale) throw() { return _strupr_s_l(_String, _Size, _Locale); } }

__declspec(deprecated("This function or variable may be unsafe. Consider using " "_strupr_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) char* __cdecl _strupr_l(  char *_String,   _locale_t _Locale);

 

__declspec(dllimport) size_t __cdecl strxfrm(
        char*       _Destination,
                                         char const* _Source,
                 size_t      _MaxCount
    );

 

__declspec(dllimport) size_t __cdecl _strxfrm_l(
        char*       _Destination,
                                         char const* _Source,
                 size_t      _MaxCount,
                                       _locale_t   _Locale
    );




extern "C++"
{
     
    inline char* __cdecl strchr(  char* const _String,   int const _Ch)
    {
        return const_cast<char*>(strchr(static_cast<char const*>(_String), _Ch));
    }

     
    inline char* __cdecl strpbrk(  char* const _String,   char const* const _Control)
    {
        return const_cast<char*>(strpbrk(static_cast<char const*>(_String), _Control));
    }

     
    inline char* __cdecl strrchr(  char* const _String,   int const _Ch)
    {
        return const_cast<char*>(strrchr(static_cast<char const*>(_String), _Ch));
    }

       
    inline char* __cdecl strstr(  char* const _String,   char const* const _SubString)
    {
        return const_cast<char*>(strstr(static_cast<char const*>(_String), _SubString));
    }
}






    
    
      __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_strdup" ". See online help for details."))
    __declspec(dllimport) char* __cdecl strdup(
          char const* _String
        );
    

    // Declarations of functions defined in oldnames.lib:
      __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_strcmpi" ". See online help for details."))
    __declspec(dllimport) int __cdecl strcmpi(
          char const* _String1,
          char const* _String2
        );

      __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_stricmp" ". See online help for details."))
    __declspec(dllimport) int __cdecl stricmp(
          char const* _String1,
          char const* _String2
        );

    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_strlwr" ". See online help for details."))
    __declspec(dllimport) char* __cdecl strlwr(
          char* _String
        );

      __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_strnicmp" ". See online help for details."))
    __declspec(dllimport) int __cdecl strnicmp(
          char const* _String1,
          char const* _String2,
                                size_t      _MaxCount
        );

    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_strnset" ". See online help for details."))
    __declspec(dllimport) char* __cdecl strnset(
          char*  _String,
                                  int    _Value,
                                  size_t _MaxCount
        );

    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_strrev" ". See online help for details."))
    __declspec(dllimport) char* __cdecl strrev(
          char* _String
        );

    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_strset" ". See online help for details."))
    char* __cdecl strset(
          char* _String,
               int   _Value);

    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_strupr" ". See online help for details."))
    __declspec(dllimport) char* __cdecl strupr(
          char* _String
        );





} __pragma(pack(pop))





#pragma pack(push,8)
#pragma warning(push,3)
#pragma warning(disable: 4455 4494  4619 4643 4702 4984 4988 )




namespace std {
#pragma warning(push)
#pragma warning(disable: 4995) 

using :: size_t; using :: memchr; using :: memcmp;
using :: memcpy; using :: memmove; using :: memset;
using :: strcat; using :: strchr; using :: strcmp;
using :: strcoll; using :: strcpy; using :: strcspn;
using :: strerror; using :: strlen; using :: strncat;
using :: strncmp; using :: strncpy; using :: strpbrk;
using :: strrchr; using :: strspn; using :: strstr;
using :: strtok; using :: strxfrm;

#pragma warning(pop)
}



#pragma warning(pop)
#pragma pack(pop)




/*
 * Copyright (c) by P.J. Plauger. All rights reserved.
 * Consult your license regarding permissions and restrictions.
V6.50:0009 */


// stdexcept standard header
#pragma once




// exception standard header
#pragma once






// type_traits standard header (core)
#pragma once




// xstddef internal header (core)
#pragma once




// cstddef standard header (core)
#pragma once







#pragma pack(push,8)
#pragma warning(push,3)
#pragma warning(disable: 4455 4494  4619 4643 4702 4984 4988 )




namespace std {
using :: ptrdiff_t; using :: size_t;
typedef double max_align_t;	// most aligned type















































































}

using ::std:: max_align_t;	// intentional, for historical reasons



#pragma warning(pop)
#pragma pack(pop)




/*
 * Copyright (c) by P.J. Plauger. All rights reserved.
 * Consult your license regarding permissions and restrictions.
V6.50:0009 */



// initializer_list standard header (core)
#pragma once





 #pragma pack(push,8)
 #pragma warning(push,3)
 #pragma warning(disable: 4455 4494  4619 4643 4702 4984 4988 )
 
 
 

namespace std {
		// CLASS TEMPLATE initializer_list
template<class _Elem>
	class initializer_list
	{	// list of pointers to elements
public:
	typedef _Elem value_type;
	typedef const _Elem& reference;
	typedef const _Elem& const_reference;
	typedef size_t size_type;

	typedef const _Elem* iterator;
	typedef const _Elem* const_iterator;

	constexpr initializer_list() noexcept
		: _First(nullptr), _Last(nullptr)
		{	// empty list
		}

	constexpr initializer_list(const _Elem *_First_arg,
		const _Elem *_Last_arg) noexcept
		: _First(_First_arg), _Last(_Last_arg)
		{	// construct with pointers
		}

	 constexpr const _Elem * begin() const noexcept
		{	// get beginning of list
		return (_First);
		}

	 constexpr const _Elem * end() const noexcept
		{	// get end of list
		return (_Last);
		}

	 constexpr size_t size() const noexcept
		{	// get length of list
		return (static_cast<size_t>(_Last - _First));
		}

private:
	const _Elem *_First;
	const _Elem *_Last;
	};

		// FUNCTION TEMPLATE begin
template<class _Elem>
	 constexpr const _Elem * begin(initializer_list<_Elem> _Ilist) noexcept
	{	// get beginning of sequence
	return (_Ilist.begin());
	}

		// FUNCTION TEMPLATE end
template<class _Elem>
	 constexpr const _Elem * end(initializer_list<_Elem> _Ilist) noexcept
	{	// get end of sequence
	return (_Ilist.end());
	}
}
 
 
 #pragma warning(pop)
 #pragma pack(pop)



/*
 * Copyright (c) by P.J. Plauger. All rights reserved.
 * Consult your license regarding permissions and restrictions.
V6.50:0009 */



 #pragma pack(push,8)
 #pragma warning(push,3)
 #pragma warning(disable: 4455 4494  4619 4643 4702 4984 4988 )
 
 
 

namespace std {
		// TYPE DEFINITIONS
template<class>
	// false value attached to a dependent name (for static_assert)
	 constexpr bool _Always_false = false;

		// FUNCTIONAL STUFF (from <functional>)
 
		// STRUCT TEMPLATE unary_function
template<class _Arg,
	class _Result>
	struct unary_function
	{	// base class for unary functions
	typedef _Arg argument_type;
	typedef _Result result_type;
	};

		// STRUCT TEMPLATE binary_function
template<class _Arg1,
	class _Arg2,
	class _Result>
	struct binary_function
	{	// base class for binary functions
	typedef _Arg1 first_argument_type;
	typedef _Arg2 second_argument_type;
	typedef _Result result_type;
	};
 

		// STRUCT TEMPLATE plus
template<class _Ty = void>
	struct plus
	{	// functor for operator+
	 typedef _Ty first_argument_type;
	 typedef _Ty second_argument_type;
	 typedef _Ty result_type;

	constexpr _Ty operator()(const _Ty& _Left, const _Ty& _Right) const
		{	// apply operator+ to operands
		return (_Left + _Right);
		}
	};

		// STRUCT TEMPLATE minus
template<class _Ty = void>
	struct minus
	{	// functor for operator-
	 typedef _Ty first_argument_type;
	 typedef _Ty second_argument_type;
	 typedef _Ty result_type;

	constexpr _Ty operator()(const _Ty& _Left, const _Ty& _Right) const
		{	// apply operator- to operands
		return (_Left - _Right);
		}
	};

		// STRUCT TEMPLATE multiplies
template<class _Ty = void>
	struct multiplies
	{	// functor for operator*
	 typedef _Ty first_argument_type;
	 typedef _Ty second_argument_type;
	 typedef _Ty result_type;

	constexpr _Ty operator()(const _Ty& _Left, const _Ty& _Right) const
		{	// apply operator* to operands
		return (_Left * _Right);
		}
	};

		// STRUCT TEMPLATE equal_to
template<class _Ty = void>
	struct equal_to
	{	// functor for operator==
	 typedef _Ty first_argument_type;
	 typedef _Ty second_argument_type;
	 typedef bool result_type;

	constexpr bool operator()(const _Ty& _Left, const _Ty& _Right) const
		{	// apply operator== to operands
		return (_Left == _Right);
		}
	};

		// STRUCT TEMPLATE not_equal_to
template<class _Ty = void>
	struct not_equal_to
	{	// functor for operator!=
	 typedef _Ty first_argument_type;
	 typedef _Ty second_argument_type;
	 typedef bool result_type;

	constexpr bool operator()(const _Ty& _Left, const _Ty& _Right) const
		{	// apply operator!= to operands
		return (_Left != _Right);
		}
	};

		// STRUCT TEMPLATE greater
template<class _Ty = void>
	struct greater
	{	// functor for operator>
	 typedef _Ty first_argument_type;
	 typedef _Ty second_argument_type;
	 typedef bool result_type;

	constexpr bool operator()(const _Ty& _Left, const _Ty& _Right) const
		{	// apply operator> to operands
		return (_Left > _Right);
		}
	};

		// STRUCT TEMPLATE less
template<class _Ty = void>
	struct less
	{	// functor for operator<
	 typedef _Ty first_argument_type;
	 typedef _Ty second_argument_type;
	 typedef bool result_type;

	constexpr bool operator()(const _Ty& _Left, const _Ty& _Right) const
		{	// apply operator< to operands
		return (_Left < _Right);
		}
	};

		// STRUCT TEMPLATE greater_equal
template<class _Ty = void>
	struct greater_equal
	{	// functor for operator>=
	 typedef _Ty first_argument_type;
	 typedef _Ty second_argument_type;
	 typedef bool result_type;

	constexpr bool operator()(const _Ty& _Left, const _Ty& _Right) const
		{	// apply operator>= to operands
		return (_Left >= _Right);
		}
	};

		// STRUCT TEMPLATE less_equal
template<class _Ty = void>
	struct less_equal
	{	// functor for operator<=
	 typedef _Ty first_argument_type;
	 typedef _Ty second_argument_type;
	 typedef bool result_type;

	constexpr bool operator()(const _Ty& _Left, const _Ty& _Right) const
		{	// apply operator<= to operands
		return (_Left <= _Right);
		}
	};

		// STRUCT TEMPLATE SPECIALIZATION plus
template<>
	struct plus<void>
	{	// transparent functor for operator+
	typedef int is_transparent;

	template<class _Ty1,
		class _Ty2>
		constexpr auto operator()(_Ty1&& _Left, _Ty2&& _Right) const
		-> decltype(static_cast<_Ty1&&>(_Left)
			+ static_cast<_Ty2&&>(_Right))
		{	// transparently apply operator+ to operands
		return (static_cast<_Ty1&&>(_Left)
			+ static_cast<_Ty2&&>(_Right));
		}
	};

		// STRUCT TEMPLATE SPECIALIZATION minus
template<>
	struct minus<void>
	{	// transparent functor for operator-
	typedef int is_transparent;

	template<class _Ty1,
		class _Ty2>
		constexpr auto operator()(_Ty1&& _Left, _Ty2&& _Right) const
		-> decltype(static_cast<_Ty1&&>(_Left)
			- static_cast<_Ty2&&>(_Right))
		{	// transparently apply operator- to operands
		return (static_cast<_Ty1&&>(_Left)
			- static_cast<_Ty2&&>(_Right));
		}
	};

		// STRUCT TEMPLATE SPECIALIZATION multiplies
template<>
	struct multiplies<void>
	{	// transparent functor for operator*
	typedef int is_transparent;

	template<class _Ty1,
		class _Ty2>
		constexpr auto operator()(_Ty1&& _Left, _Ty2&& _Right) const
		-> decltype(static_cast<_Ty1&&>(_Left)
			* static_cast<_Ty2&&>(_Right))
		{	// transparently apply operator* to operands
		return (static_cast<_Ty1&&>(_Left)
			* static_cast<_Ty2&&>(_Right));
		}
	};

		// STRUCT TEMPLATE SPECIALIZATION equal_to
template<>
	struct equal_to<void>
	{	// transparent functor for operator==
	typedef int is_transparent;

	template<class _Ty1,
		class _Ty2>
		constexpr auto operator()(_Ty1&& _Left, _Ty2&& _Right) const
		-> decltype(static_cast<_Ty1&&>(_Left)
			== static_cast<_Ty2&&>(_Right))
		{	// transparently apply operator== to operands
		return (static_cast<_Ty1&&>(_Left)
			== static_cast<_Ty2&&>(_Right));
		}
	};

		// STRUCT TEMPLATE SPECIALIZATION not_equal_to
template<>
	struct not_equal_to<void>
	{	// transparent functor for operator!=
	typedef int is_transparent;

	template<class _Ty1,
		class _Ty2>
		constexpr auto operator()(_Ty1&& _Left, _Ty2&& _Right) const
		-> decltype(static_cast<_Ty1&&>(_Left)
			!= static_cast<_Ty2&&>(_Right))
		{	// transparently apply operator!= to operands
		return (static_cast<_Ty1&&>(_Left)
			!= static_cast<_Ty2&&>(_Right));
		}
	};

		// STRUCT TEMPLATE SPECIALIZATION greater
template<>
	struct greater<void>
	{	// transparent functor for operator>
	typedef int is_transparent;

	template<class _Ty1,
		class _Ty2>
		constexpr auto operator()(_Ty1&& _Left, _Ty2&& _Right) const
		-> decltype(static_cast<_Ty1&&>(_Left)
			> static_cast<_Ty2&&>(_Right))
		{	// transparently apply operator> to operands
		return (static_cast<_Ty1&&>(_Left)
			> static_cast<_Ty2&&>(_Right));
		}
	};

		// STRUCT TEMPLATE SPECIALIZATION less
template<>
	struct less<void>
	{	// transparent functor for operator<
	typedef int is_transparent;

	template<class _Ty1,
		class _Ty2>
		constexpr auto operator()(_Ty1&& _Left, _Ty2&& _Right) const
		-> decltype(static_cast<_Ty1&&>(_Left)
			< static_cast<_Ty2&&>(_Right))
		{	// transparently apply operator< to operands
		return (static_cast<_Ty1&&>(_Left)
			< static_cast<_Ty2&&>(_Right));
		}
	};

		// STRUCT TEMPLATE SPECIALIZATION greater_equal
template<>
	struct greater_equal<void>
	{	// transparent functor for operator>=
	typedef int is_transparent;

	template<class _Ty1,
		class _Ty2>
		constexpr auto operator()(_Ty1&& _Left, _Ty2&& _Right) const
		-> decltype(static_cast<_Ty1&&>(_Left)
			>= static_cast<_Ty2&&>(_Right))
		{	// transparently apply operator>= to operands
		return (static_cast<_Ty1&&>(_Left)
			>= static_cast<_Ty2&&>(_Right));
		}
	};

		// STRUCT TEMPLATE SPECIALIZATION less_equal
template<>
	struct less_equal<void>
	{	// transparent functor for operator<=
	typedef int is_transparent;

	template<class _Ty1,
		class _Ty2>
		constexpr auto operator()(_Ty1&& _Left, _Ty2&& _Right) const
		-> decltype(static_cast<_Ty1&&>(_Left)
			<= static_cast<_Ty2&&>(_Right))
		{	// transparently apply operator<= to operands
		return (static_cast<_Ty1&&>(_Left)
			<= static_cast<_Ty2&&>(_Right));
		}
	};

		// FUNCTION TEMPLATE addressof
template<class _Ty>
	 constexpr _Ty * addressof(_Ty& _Val) noexcept
	{	// return address of _Val
	return (__builtin_addressof(_Val));
	}

template<class _Ty>
	const _Ty * addressof(const _Ty&&) = delete;

		// FUNCTION TEMPLATE _Unfancy
template<class _Ptrty> inline
	auto _Unfancy(_Ptrty _Ptr)
	{	// converts from a fancy pointer to a plain pointer
	return (::std:: addressof(*_Ptr));
	}

template<class _Ty> inline
	_Ty * _Unfancy(_Ty * _Ptr)
	{	// do nothing for plain pointers
	return (_Ptr);
	}
}




 





 

 





 

 








 

 



 


























 



























 








































 














 
 
 #pragma warning(pop)
 #pragma pack(pop)



/*
 * Copyright (c) by P.J. Plauger. All rights reserved.
 * Consult your license regarding permissions and restrictions.
V6.50:0009 */


 #pragma pack(push,8)
 #pragma warning(push,3)
 #pragma warning(disable: 4455 4494  4619 4643 4702 4984 4988 )
 
 
 

 #pragma warning(disable: 4180)	

namespace std {
	// STRUCT TEMPLATE integer_sequence
template<class _Ty,
	_Ty... _Vals>
	struct integer_sequence
	{	// sequence of integer parameters
	static_assert(is_integral_v<_Ty>,
		"integer_sequence<T, I...> requires T to be an integral type.");

	using value_type = _Ty;

	 static constexpr size_t size() noexcept
		{	// get length of parameter list
		return (sizeof...(_Vals));
		}
	};

	// ALIAS TEMPLATE make_integer_sequence
template<class _Ty,
	_Ty _Size>
	using make_integer_sequence = __make_integer_seq<integer_sequence, _Ty, _Size>;

template<size_t... _Vals>
	using index_sequence = integer_sequence<size_t, _Vals...>;

template<size_t _Size>
	using make_index_sequence = make_integer_sequence<size_t, _Size>;

template<class... _Types>
	using index_sequence_for = make_index_sequence<sizeof...(_Types)>;

	// STRUCT TEMPLATE conjunction
template<bool _First_value,
	class _First,
	class... _Rest>
	struct _Conjunction
	{	// handle false trait or last trait
	using type = _First;
	};

template<class _True,
	class _Next,
	class... _Rest>
	struct _Conjunction<true, _True, _Next, _Rest...>
	{	// the first trait is true, try the next one
	using type = typename _Conjunction<_Next::value, _Next, _Rest...>::type;
	};

template<class... _Traits>
	struct conjunction
		: true_type
	{	// If _Traits is empty, true_type
	};

template<class _First,
	class... _Rest>
	struct conjunction<_First, _Rest...>
		: _Conjunction<_First::value, _First, _Rest...>::type
	{	// Otherwise, if any of _Traits are false, the first false trait
		// Otherwise, the last trait in _Traits
	};

template<class... _Traits>
	 constexpr bool conjunction_v = conjunction<_Traits...>::value;

	// STRUCT TEMPLATE disjunction
template<bool _First_value,
	class _First,
	class... _Rest>
	struct _Disjunction
	{	// handle true trait or last trait
	using type = _First;
	};

template<class _False,
	class _Next,
	class... _Rest>
	struct _Disjunction<false, _False, _Next, _Rest...>
	{	// first trait is false, try the next trait
	using type = typename _Disjunction<_Next::value, _Next, _Rest...>::type;
	};

template<class... _Traits>
	struct disjunction
		: false_type
	{	// If _Traits is empty, false_type
	};

template<class _First,
	class... _Rest>
	struct disjunction<_First, _Rest...>
		: _Disjunction<_First::value, _First, _Rest...>::type
	{	// Otherwise, if any of _Traits are true, the first true trait
		// Otherwise, the last trait in _Traits
	};

template<class... _Traits>
	 constexpr bool disjunction_v = disjunction<_Traits...>::value;

	// STRUCT TEMPLATE negation
template<class _Trait>
	struct negation
		: bool_constant<!static_cast<bool>(_Trait::value)>
	{	// The negated result of _Trait
	};

template<class _Trait>
	 constexpr bool negation_v = negation<_Trait>::value;

	// VARIABLE TEMPLATE _Is_any_of_v
template<class _Ty,
	class... _Types>
	 constexpr bool _Is_any_of_v = disjunction_v<is_same<_Ty, _Types>...>;

	// STRUCT TEMPLATE _Arg_types
template<class... _Types>
	struct _Arg_types
	{	// provide argument_type, etc. (sometimes)
	};

template<class _Ty1>
	struct _Arg_types<_Ty1>
	{	// provide argument_type, etc. (sometimes)
	 typedef _Ty1 argument_type;
	};

template<class _Ty1,
	class _Ty2>
	struct _Arg_types<_Ty1, _Ty2>
	{	// provide argument_type, etc. (sometimes)
	 typedef _Ty1 first_argument_type;
	 typedef _Ty2 second_argument_type;
	};

	// STRUCT TEMPLATE is_function
template<class _Ty>
	struct _Is_function
	{	// determine whether _Ty is a function
	using _Bool_type = false_type;
	};











template<class _Ret, class... _Types> struct _Is_function<_Ret __cdecl (_Types...)   > : _Arg_types<_Types...> { using _Bool_type = true_type;  typedef _Ret result_type; };    template<class _Ret, class... _Types> struct _Is_function<_Ret __vectorcall (_Types...)   > : _Arg_types<_Types...> { using _Bool_type = true_type;  typedef _Ret result_type; }; template<class _Ret, class... _Types> struct _Is_function<_Ret __cdecl (_Types...) const  > : _Arg_types<_Types...> { using _Bool_type = true_type;  typedef _Ret result_type; };    template<class _Ret, class... _Types> struct _Is_function<_Ret __vectorcall (_Types...) const  > : _Arg_types<_Types...> { using _Bool_type = true_type;  typedef _Ret result_type; }; template<class _Ret, class... _Types> struct _Is_function<_Ret __cdecl (_Types...) volatile  > : _Arg_types<_Types...> { using _Bool_type = true_type;  typedef _Ret result_type; };    template<class _Ret, class... _Types> struct _Is_function<_Ret __vectorcall (_Types...) volatile  > : _Arg_types<_Types...> { using _Bool_type = true_type;  typedef _Ret result_type; }; template<class _Ret, class... _Types> struct _Is_function<_Ret __cdecl (_Types...) const volatile  > : _Arg_types<_Types...> { using _Bool_type = true_type;  typedef _Ret result_type; };    template<class _Ret, class... _Types> struct _Is_function<_Ret __vectorcall (_Types...) const volatile  > : _Arg_types<_Types...> { using _Bool_type = true_type;  typedef _Ret result_type; }; template<class _Ret, class... _Types> struct _Is_function<_Ret __cdecl (_Types...)  & > : _Arg_types<_Types...> { using _Bool_type = true_type;  typedef _Ret result_type; };    template<class _Ret, class... _Types> struct _Is_function<_Ret __vectorcall (_Types...)  & > : _Arg_types<_Types...> { using _Bool_type = true_type;  typedef _Ret result_type; }; template<class _Ret, class... _Types> struct _Is_function<_Ret __cdecl (_Types...) const & > : _Arg_types<_Types...> { using _Bool_type = true_type;  typedef _Ret result_type; };    template<class _Ret, class... _Types> struct _Is_function<_Ret __vectorcall (_Types...) const & > : _Arg_types<_Types...> { using _Bool_type = true_type;  typedef _Ret result_type; }; template<class _Ret, class... _Types> struct _Is_function<_Ret __cdecl (_Types...) volatile & > : _Arg_types<_Types...> { using _Bool_type = true_type;  typedef _Ret result_type; };    template<class _Ret, class... _Types> struct _Is_function<_Ret __vectorcall (_Types...) volatile & > : _Arg_types<_Types...> { using _Bool_type = true_type;  typedef _Ret result_type; }; template<class _Ret, class... _Types> struct _Is_function<_Ret __cdecl (_Types...) const volatile & > : _Arg_types<_Types...> { using _Bool_type = true_type;  typedef _Ret result_type; };    template<class _Ret, class... _Types> struct _Is_function<_Ret __vectorcall (_Types...) const volatile & > : _Arg_types<_Types...> { using _Bool_type = true_type;  typedef _Ret result_type; }; template<class _Ret, class... _Types> struct _Is_function<_Ret __cdecl (_Types...)  && > : _Arg_types<_Types...> { using _Bool_type = true_type;  typedef _Ret result_type; };    template<class _Ret, class... _Types> struct _Is_function<_Ret __vectorcall (_Types...)  && > : _Arg_types<_Types...> { using _Bool_type = true_type;  typedef _Ret result_type; }; template<class _Ret, class... _Types> struct _Is_function<_Ret __cdecl (_Types...) const && > : _Arg_types<_Types...> { using _Bool_type = true_type;  typedef _Ret result_type; };    template<class _Ret, class... _Types> struct _Is_function<_Ret __vectorcall (_Types...) const && > : _Arg_types<_Types...> { using _Bool_type = true_type;  typedef _Ret result_type; }; template<class _Ret, class... _Types> struct _Is_function<_Ret __cdecl (_Types...) volatile && > : _Arg_types<_Types...> { using _Bool_type = true_type;  typedef _Ret result_type; };    template<class _Ret, class... _Types> struct _Is_function<_Ret __vectorcall (_Types...) volatile && > : _Arg_types<_Types...> { using _Bool_type = true_type;  typedef _Ret result_type; }; template<class _Ret, class... _Types> struct _Is_function<_Ret __cdecl (_Types...) const volatile && > : _Arg_types<_Types...> { using _Bool_type = true_type;  typedef _Ret result_type; };    template<class _Ret, class... _Types> struct _Is_function<_Ret __vectorcall (_Types...) const volatile && > : _Arg_types<_Types...> { using _Bool_type = true_type;  typedef _Ret result_type; };











template<class _Ret, class... _Types> struct _Is_function<_Ret (_Types..., ...) > { using _Bool_type = true_type;  typedef _Ret result_type; }; template<class _Ret, class... _Types> struct _Is_function<_Ret (_Types..., ...) const> { using _Bool_type = true_type;  typedef _Ret result_type; }; template<class _Ret, class... _Types> struct _Is_function<_Ret (_Types..., ...) volatile> { using _Bool_type = true_type;  typedef _Ret result_type; }; template<class _Ret, class... _Types> struct _Is_function<_Ret (_Types..., ...) const volatile> { using _Bool_type = true_type;  typedef _Ret result_type; }; template<class _Ret, class... _Types> struct _Is_function<_Ret (_Types..., ...) &> { using _Bool_type = true_type;  typedef _Ret result_type; }; template<class _Ret, class... _Types> struct _Is_function<_Ret (_Types..., ...) const &> { using _Bool_type = true_type;  typedef _Ret result_type; }; template<class _Ret, class... _Types> struct _Is_function<_Ret (_Types..., ...) volatile &> { using _Bool_type = true_type;  typedef _Ret result_type; }; template<class _Ret, class... _Types> struct _Is_function<_Ret (_Types..., ...) const volatile &> { using _Bool_type = true_type;  typedef _Ret result_type; }; template<class _Ret, class... _Types> struct _Is_function<_Ret (_Types..., ...) &&> { using _Bool_type = true_type;  typedef _Ret result_type; }; template<class _Ret, class... _Types> struct _Is_function<_Ret (_Types..., ...) const &&> { using _Bool_type = true_type;  typedef _Ret result_type; }; template<class _Ret, class... _Types> struct _Is_function<_Ret (_Types..., ...) volatile &&> { using _Bool_type = true_type;  typedef _Ret result_type; }; template<class _Ret, class... _Types> struct _Is_function<_Ret (_Types..., ...) const volatile &&> { using _Bool_type = true_type;  typedef _Ret result_type; };


template<class _Ty>
	struct is_function
		: _Is_function<_Ty>::_Bool_type
	{	// determine whether _Ty is a function
	};

template<class _Ty>
	 constexpr bool is_function_v = is_function<_Ty>::value;


template<class _Ty>
	struct _Is_memfunptr
	{	// base class for member function pointer predicates
	using _Bool_type = false_type;
	};














template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...)   > : _Arg_types< _Arg0 *, _Types...> { using _Bool_type = true_type;  typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int , int&&>, _Ret (_Types...)>; };     template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__vectorcall _Arg0::*)(_Types...)   > : _Arg_types< _Arg0 *, _Types...> { using _Bool_type = true_type;  typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int , int&&>, _Ret (_Types...)>; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...) const  > : _Arg_types<const _Arg0 *, _Types...> { using _Bool_type = true_type;  typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int , int&&>, _Ret (_Types...)>; };     template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__vectorcall _Arg0::*)(_Types...) const  > : _Arg_types<const _Arg0 *, _Types...> { using _Bool_type = true_type;  typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int , int&&>, _Ret (_Types...)>; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...) volatile  > : _Arg_types<volatile _Arg0 *, _Types...> { using _Bool_type = true_type;  typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int , int&&>, _Ret (_Types...)>; };     template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__vectorcall _Arg0::*)(_Types...) volatile  > : _Arg_types<volatile _Arg0 *, _Types...> { using _Bool_type = true_type;  typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int , int&&>, _Ret (_Types...)>; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...) const volatile  > : _Arg_types<const volatile _Arg0 *, _Types...> { using _Bool_type = true_type;  typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int , int&&>, _Ret (_Types...)>; };     template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__vectorcall _Arg0::*)(_Types...) const volatile  > : _Arg_types<const volatile _Arg0 *, _Types...> { using _Bool_type = true_type;  typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int , int&&>, _Ret (_Types...)>; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...)  & > : _Arg_types< _Arg0 *, _Types...> { using _Bool_type = true_type;  typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int &, int&&>, _Ret (_Types...)>; };     template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__vectorcall _Arg0::*)(_Types...)  & > : _Arg_types< _Arg0 *, _Types...> { using _Bool_type = true_type;  typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int &, int&&>, _Ret (_Types...)>; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...) const & > : _Arg_types<const _Arg0 *, _Types...> { using _Bool_type = true_type;  typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int &, int&&>, _Ret (_Types...)>; };     template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__vectorcall _Arg0::*)(_Types...) const & > : _Arg_types<const _Arg0 *, _Types...> { using _Bool_type = true_type;  typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int &, int&&>, _Ret (_Types...)>; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...) volatile & > : _Arg_types<volatile _Arg0 *, _Types...> { using _Bool_type = true_type;  typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int &, int&&>, _Ret (_Types...)>; };     template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__vectorcall _Arg0::*)(_Types...) volatile & > : _Arg_types<volatile _Arg0 *, _Types...> { using _Bool_type = true_type;  typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int &, int&&>, _Ret (_Types...)>; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...) const volatile & > : _Arg_types<const volatile _Arg0 *, _Types...> { using _Bool_type = true_type;  typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int &, int&&>, _Ret (_Types...)>; };     template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__vectorcall _Arg0::*)(_Types...) const volatile & > : _Arg_types<const volatile _Arg0 *, _Types...> { using _Bool_type = true_type;  typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int &, int&&>, _Ret (_Types...)>; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...)  && > : _Arg_types< _Arg0 *, _Types...> { using _Bool_type = true_type;  typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int &&, int&&>, _Ret (_Types...)>; };     template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__vectorcall _Arg0::*)(_Types...)  && > : _Arg_types< _Arg0 *, _Types...> { using _Bool_type = true_type;  typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int &&, int&&>, _Ret (_Types...)>; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...) const && > : _Arg_types<const _Arg0 *, _Types...> { using _Bool_type = true_type;  typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int &&, int&&>, _Ret (_Types...)>; };     template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__vectorcall _Arg0::*)(_Types...) const && > : _Arg_types<const _Arg0 *, _Types...> { using _Bool_type = true_type;  typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int &&, int&&>, _Ret (_Types...)>; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...) volatile && > : _Arg_types<volatile _Arg0 *, _Types...> { using _Bool_type = true_type;  typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int &&, int&&>, _Ret (_Types...)>; };     template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__vectorcall _Arg0::*)(_Types...) volatile && > : _Arg_types<volatile _Arg0 *, _Types...> { using _Bool_type = true_type;  typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int &&, int&&>, _Ret (_Types...)>; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...) const volatile && > : _Arg_types<const volatile _Arg0 *, _Types...> { using _Bool_type = true_type;  typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int &&, int&&>, _Ret (_Types...)>; };     template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__vectorcall _Arg0::*)(_Types...) const volatile && > : _Arg_types<const volatile _Arg0 *, _Types...> { using _Bool_type = true_type;  typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int &&, int&&>, _Ret (_Types...)>; };














template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) > { using _Bool_type = true_type;  typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<false>; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) const> { using _Bool_type = true_type;  typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<false>; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) volatile> { using _Bool_type = true_type;  typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<false>; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) const volatile> { using _Bool_type = true_type;  typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<false>; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) &> { using _Bool_type = true_type;  typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<false>; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) const &> { using _Bool_type = true_type;  typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<false>; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) volatile &> { using _Bool_type = true_type;  typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<false>; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) const volatile &> { using _Bool_type = true_type;  typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<false>; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) &&> { using _Bool_type = true_type;  typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<false>; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) const &&> { using _Bool_type = true_type;  typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<false>; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) volatile &&> { using _Bool_type = true_type;  typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<false>; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) const volatile &&> { using _Bool_type = true_type;  typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if<false>; };


	// STRUCT TEMPLATE is_void
template<class _Ty>
	struct is_void
		: false_type
	{	// determine whether _Ty is void
	};








template<> struct is_void< void> : true_type { }; template<> struct is_void<const void> : true_type { }; template<> struct is_void<volatile void> : true_type { }; template<> struct is_void<const volatile void> : true_type { };


template<class _Ty>
	 constexpr bool is_void_v = is_void<_Ty>::value;

	// ALIAS TEMPLATE void_t
template<class... _Types>
	using void_t = void;

	// Type modifiers
	// STRUCT TEMPLATE add_const
template<class _Ty>
	struct add_const
	{	// add top level const qualifier
	using type = const _Ty;
	};

template<class _Ty>
	using add_const_t = const _Ty;

	// STRUCT TEMPLATE add_volatile
template<class _Ty>
	struct add_volatile
	{	// add top level volatile qualifier
	using type = volatile _Ty;
	};

template<class _Ty>
	using add_volatile_t = volatile _Ty;

	// STRUCT TEMPLATE add_cv
template<class _Ty>
	struct add_cv
	{	// add top level const and volatile qualifiers
	using type = const volatile _Ty;
	};

template<class _Ty>
	using add_cv_t = const volatile _Ty;

	// STRUCT TEMPLATE _Add_reference
template<class _Ty,
	class = void>
	struct _Add_reference
	{	// add reference
	using _Lvalue = _Ty;
	using _Rvalue = _Ty;
	};

template<class _Ty>
	struct _Add_reference<_Ty, void_t<_Ty&>>
	{	// add reference
	using _Lvalue = _Ty&;
	using _Rvalue = _Ty&&;
	};

	// STRUCT TEMPLATE add_lvalue_reference
template<class _Ty>
	struct add_lvalue_reference
	{	// add lvalue reference
	using type = typename _Add_reference<_Ty>::_Lvalue;
	};

template<class _Ty>
	using add_lvalue_reference_t = typename _Add_reference<_Ty>::_Lvalue;

	// STRUCT TEMPLATE add_rvalue_reference
template<class _Ty>
	struct add_rvalue_reference
	{	// add rvalue reference
	using type = typename _Add_reference<_Ty>::_Rvalue;
	};

template<class _Ty>
	using add_rvalue_reference_t = typename _Add_reference<_Ty>::_Rvalue;

	// FUNCTION TEMPLATE declval
template<class _Ty>
	add_rvalue_reference_t<_Ty> declval() noexcept;

	// STRUCT TEMPLATE remove_extent
template<class _Ty>
	struct remove_extent
	{	// remove array extent
	using type = _Ty;
	};

template<class _Ty, size_t _Ix>
	struct remove_extent<_Ty[_Ix]>
	{	// remove array extent
	using type = _Ty;
	};

template<class _Ty>
	struct remove_extent<_Ty[]>
	{	// remove array extent
	using type = _Ty;
	};

template<class _Ty>
	using remove_extent_t = typename remove_extent<_Ty>::type;

	// STRUCT TEMPLATE remove_all_extents
template<class _Ty>
	struct remove_all_extents
	{	// remove all array extents
	using type = _Ty;
	};

template<class _Ty, size_t _Ix>
	struct remove_all_extents<_Ty[_Ix]>
	{	// remove all array extents
	using type = typename remove_all_extents<_Ty>::type;
	};

template<class _Ty>
	struct remove_all_extents<_Ty[]>
	{	// remove all array extents
	using type = typename remove_all_extents<_Ty>::type;
	};

template<class _Ty>
	using remove_all_extents_t = typename remove_all_extents<_Ty>::type;

	// STRUCT TEMPLATE remove_pointer
template<class _Ty>
	struct remove_pointer
	{	// remove pointer
	using type = _Ty;
	};








template<class _Ty> struct remove_pointer<_Ty * > { using type = _Ty; }; template<class _Ty> struct remove_pointer<_Ty * const> { using type = _Ty; }; template<class _Ty> struct remove_pointer<_Ty * volatile> { using type = _Ty; }; template<class _Ty> struct remove_pointer<_Ty * const volatile> { using type = _Ty; };


template<class _Ty>
	using remove_pointer_t = typename remove_pointer<_Ty>::type;

	// STRUCT TEMPLATE add_pointer
template<class _Ty,
	class = void>
	struct _Add_pointer
	{	// add pointer
	using type = _Ty;
	};

template<class _Ty>
	struct _Add_pointer<_Ty, void_t<remove_reference_t<_Ty> *>>
	{	// add pointer
	using type = remove_reference_t<_Ty> *;
	};

template<class _Ty>
	struct add_pointer
	{	// add pointer
	using type = typename _Add_pointer<_Ty>::type;
	};

template<class _Ty>
	using add_pointer_t = typename _Add_pointer<_Ty>::type;

	// TYPE PREDICATES
	// STRUCT TEMPLATE is_array
template<class _Ty>
	struct is_array
		: false_type
	{	// determine whether _Ty is an array
	};

template<class _Ty, size_t _Nx>
	struct is_array<_Ty[_Nx]>
		: true_type
	{	// determine whether _Ty is an array
	};

template<class _Ty>
	struct is_array<_Ty[]>
		: true_type
	{	// determine whether _Ty is an array
	};

template<class _Ty>
	 constexpr bool is_array_v = is_array<_Ty>::value;

	// STRUCT TEMPLATE is_lvalue_reference
template<class _Ty>
	struct is_lvalue_reference
		: false_type
	{	// determine whether _Ty is an lvalue reference
	};

template<class _Ty>
	struct is_lvalue_reference<_Ty&>
		: true_type
	{	// determine whether _Ty is an lvalue reference
	};

template<class _Ty>
	 constexpr bool is_lvalue_reference_v = is_lvalue_reference<_Ty>::value;

	// STRUCT TEMPLATE is_rvalue_reference
template<class _Ty>
	struct is_rvalue_reference
		: false_type
	{	// determine whether _Ty is an rvalue reference
	};

template<class _Ty>
	struct is_rvalue_reference<_Ty&&>
		: true_type
	{	// determine whether _Ty is an rvalue reference
	};

template<class _Ty>
	 constexpr bool is_rvalue_reference_v = is_rvalue_reference<_Ty>::value;

	// STRUCT TEMPLATE is_reference
template<class _Ty>
	struct is_reference
		: false_type
	{	// determine whether _Ty is a reference
	};

template<class _Ty>
	struct is_reference<_Ty&>
		: true_type
	{	// determine whether _Ty is a reference
	};

template<class _Ty>
	struct is_reference<_Ty&&>
		: true_type
	{	// determine whether _Ty is a reference
	};

template<class _Ty>
	 constexpr bool is_reference_v = is_reference<_Ty>::value;

	// STRUCT TEMPLATE is_member_object_pointer
template<class _Ty,
	bool _Pmf = _Is_memfunptr<_Ty>::_Bool_type::value>
	struct _Is_member_object_pointer
		: false_type
	{	// determine whether _Ty is a pointer to member object
	};

template<class _Ty1,
	class _Ty2>
	struct _Is_member_object_pointer<_Ty1 _Ty2::*, false>
		: true_type
	{	// determine whether _Ty is a pointer to member object
	using _Class_type = _Ty2;
	};

template<class _Ty>
	struct is_member_object_pointer
		: _Is_member_object_pointer<remove_cv_t<_Ty>>::type
	{	// determine whether _Ty is a pointer to member object
	};

template<class _Ty>
	 constexpr bool is_member_object_pointer_v = is_member_object_pointer<_Ty>::value;

	// STRUCT TEMPLATE is_member_function_pointer
template<class _Ty>
	struct is_member_function_pointer
		: _Is_memfunptr<remove_cv_t<_Ty>>::_Bool_type
	{	// determine whether _Ty is a pointer to member function
	};

template<class _Ty>
	 constexpr bool is_member_function_pointer_v = is_member_function_pointer<_Ty>::value;

	// STRUCT TEMPLATE is_pointer
template<class _Ty>
	struct is_pointer
		: false_type
	{	// determine whether _Ty is a pointer
	};

template<class _Ty>
	struct is_pointer<_Ty *>
		: true_type
	{	// determine whether _Ty is a pointer
	};

template<class _Ty>
	struct is_pointer<_Ty * const>
		: true_type
	{	// determine whether _Ty is a pointer
	};

template<class _Ty>
	struct is_pointer<_Ty * volatile>
		: true_type
	{	// determine whether _Ty is a pointer
	};

template<class _Ty>
	struct is_pointer<_Ty * const volatile>
		: true_type
	{	// determine whether _Ty is a pointer
	};

template<class _Ty>
	 constexpr bool is_pointer_v = is_pointer<_Ty>::value;

	// STRUCT TEMPLATE is_null_pointer
template<class _Ty>
	struct is_null_pointer
		: bool_constant<is_same_v<remove_cv_t<_Ty>, nullptr_t>>
	{	// determine whether _Ty is nullptr_t
	};

template<class _Ty>
	 constexpr bool is_null_pointer_v = is_same_v<remove_cv_t<_Ty>, nullptr_t>;

	// STRUCT TEMPLATE is_union
template<class _Ty>
	struct is_union
		: bool_constant<__is_union(_Ty)>
	{	// determine whether _Ty is a union
	};

template<class _Ty>
	 constexpr bool is_union_v = __is_union(_Ty);

	// STRUCT TEMPLATE is_class
template<class _Ty>
	struct is_class
		: bool_constant<__is_class(_Ty)>
	{	// determine whether _Ty is a class
	};

template<class _Ty>
	 constexpr bool is_class_v = __is_class(_Ty);

	// STRUCT TEMPLATE is_fundamental
template<class _Ty>
	struct is_fundamental
		: bool_constant<is_arithmetic_v<_Ty>
		|| is_void_v<_Ty>
		|| is_null_pointer_v<_Ty>>
	{	// determine whether _Ty is a fundamental type
	};

template<class _Ty>
	 constexpr bool is_fundamental_v = is_fundamental<_Ty>::value;

	// STRUCT TEMPLATE is_object
template<class _Ty>
	struct is_object
		: bool_constant<!is_function_v<_Ty>
		&& !is_reference_v<_Ty>
		&& !is_void_v<_Ty>>
	{	// determine whether _Ty is an object type
	};

template<class _Ty>
	 constexpr bool is_object_v = is_object<_Ty>::value;

	// STRUCT TEMPLATE is_convertible
template<class _From,
	class _To>
	struct is_convertible
		: bool_constant<__is_convertible_to(_From, _To)>
	{	// determine whether _From is convertible to _To
	};

template<class _From,
	class _To>
	 constexpr bool is_convertible_v = __is_convertible_to(_From, _To);

	// STRUCT TEMPLATE is_enum
template<class _Ty>
	struct is_enum
		: bool_constant<__is_enum(_Ty)>
	{	// determine whether _Ty is an enumerated type
	};

template<class _Ty>
	 constexpr bool is_enum_v = __is_enum(_Ty);

	// STRUCT TEMPLATE is_compound
template<class _Ty>
	struct is_compound
		: bool_constant<!is_fundamental_v<_Ty>>
	{	// determine whether _Ty is a compound type
	};

template<class _Ty>
	 constexpr bool is_compound_v = is_compound<_Ty>::value;

	// STRUCT TEMPLATE is_member_pointer
template<class _Ty>
	struct is_member_pointer
		: bool_constant<is_member_object_pointer_v<_Ty>
		|| is_member_function_pointer_v<_Ty>>
	{	// determine whether _Ty is a pointer to member
	};

template<class _Ty>
	 constexpr bool is_member_pointer_v = is_member_pointer<_Ty>::value;

	// STRUCT TEMPLATE is_scalar
template<class _Ty>
	struct is_scalar
		: bool_constant<is_arithmetic_v<_Ty>
		|| is_enum_v<_Ty>
		|| is_pointer_v<_Ty>
		|| is_member_pointer_v<_Ty>
		|| is_null_pointer_v<_Ty>>
	{	// determine whether _Ty is a scalar type
	};

template<class _Ty>
	 constexpr bool is_scalar_v = is_scalar<_Ty>::value;

	// STRUCT TEMPLATE is_const
template<class _Ty>
	struct is_const
		: false_type
	{	// determine whether _Ty is const qualified
	};

template<class _Ty>
	struct is_const<const _Ty>
		: true_type
	{	// determine whether _Ty is const qualified
	};

template<class _Ty>
	 constexpr bool is_const_v = is_const<_Ty>::value;

	// STRUCT TEMPLATE is_volatile
template<class _Ty>
	struct is_volatile
		: false_type
	{	// determine whether _Ty is volatile qualified
	};

template<class _Ty>
	struct is_volatile<volatile _Ty>
		: true_type
	{	// determine whether _Ty is volatile qualified
	};

template<class _Ty>
	 constexpr bool is_volatile_v = is_volatile<_Ty>::value;

	// STRUCT TEMPLATE is_pod
template<class _Ty>
	struct is_pod
		: bool_constant<__is_pod(_Ty)>
	{	// determine whether _Ty is a POD type
	};

template<class _Ty>
	 constexpr bool is_pod_v = __is_pod(_Ty);

	// STRUCT TEMPLATE is_empty
template<class _Ty>
	struct is_empty
		: bool_constant<__is_empty(_Ty)>
	{	// determine whether _Ty is an empty class
	};

template<class _Ty>
	 constexpr bool is_empty_v = __is_empty(_Ty);

	// STRUCT TEMPLATE is_polymorphic
template<class _Ty>
	struct is_polymorphic
		: bool_constant<__is_polymorphic(_Ty)>
	{	// determine whether _Ty is a polymorphic type
	};

template<class _Ty>
	 constexpr bool is_polymorphic_v = __is_polymorphic(_Ty);

	// STRUCT TEMPLATE is_abstract
template<class _Ty>
	struct is_abstract
		: bool_constant<__is_abstract(_Ty)>
	{	// determine whether _Ty is an abstract class
	};

template<class _Ty>
	 constexpr bool is_abstract_v = __is_abstract(_Ty);

	// STRUCT TEMPLATE is_final
template<class _Ty>
	struct is_final
		: bool_constant<__is_final(_Ty)>
	{	// determine whether _Ty is a final class
	};

template<class _Ty>
	 constexpr bool is_final_v = __is_final(_Ty);

	// STRUCT TEMPLATE is_standard_layout
template<class _Ty>
	struct is_standard_layout
		: bool_constant<__is_standard_layout(_Ty)>
	{	// determine whether _Ty is standard layout
	};

template<class _Ty>
	 constexpr bool is_standard_layout_v = __is_standard_layout(_Ty);

	// STRUCT TEMPLATE is_literal_type
template<class _Ty>
	struct  is_literal_type
		: bool_constant<__is_literal_type(_Ty)>
	{	// determine whether _Ty is a literal type
	};

#pragma warning(push)
#pragma warning(disable: 4996)	
template<class _Ty>
	  constexpr bool is_literal_type_v = __is_literal_type(_Ty);
#pragma warning(pop)

	// STRUCT TEMPLATE is_trivial
template<class _Ty>
	struct is_trivial
		: bool_constant<__is_trivial(_Ty)>
	{	// determine whether _Ty is trivial
	};

template<class _Ty>
	 constexpr bool is_trivial_v = __is_trivial(_Ty);

	// STRUCT TEMPLATE is_trivially_copyable
template<class _Ty>
	struct is_trivially_copyable
		: bool_constant<__is_trivially_copyable(_Ty)>
	{	// determine whether _Ty is trivially copyable
	};

template<class _Ty>
	 constexpr bool is_trivially_copyable_v = __is_trivially_copyable(_Ty);

	// STRUCT TEMPLATE has_virtual_destructor
template<class _Ty>
	struct has_virtual_destructor
		: bool_constant<__has_virtual_destructor(_Ty)>
	{	// determine whether _Ty has a virtual destructor
	};

template<class _Ty>
	 constexpr bool has_virtual_destructor_v = __has_virtual_destructor(_Ty);























		// CONSTRUCTIBLE/ASSIGNABLE TRAITS
	// STRUCT TEMPLATE is_constructible
template<class _Ty,
	class... _Args>
	struct is_constructible
		: bool_constant<__is_constructible(_Ty, _Args...)>
	{	// determine whether _Ty(_Args...) is constructible
	};

template<class _Ty,
	class... _Args>
	 constexpr bool is_constructible_v = __is_constructible(_Ty, _Args...);

	// STRUCT TEMPLATE is_copy_constructible
template<class _Ty>
	struct is_copy_constructible
		: bool_constant<__is_constructible(_Ty, add_lvalue_reference_t<const _Ty>)>
	{	// determine whether _Ty has a copy constructor
	};

template<class _Ty>
	 constexpr bool is_copy_constructible_v = __is_constructible(_Ty, add_lvalue_reference_t<const _Ty>);

	// STRUCT TEMPLATE is_default_constructible
template<class _Ty>
	struct is_default_constructible
		: bool_constant<__is_constructible(_Ty)>
	{	// determine whether _Ty has a default constructor
	};

template<class _Ty>
	 constexpr bool is_default_constructible_v = __is_constructible(_Ty);

	// STRUCT TEMPLATE _Is_implicitly_default_constructible
template<class _Ty,
	class = void>
	struct _Is_implicitly_default_constructible
		: false_type
	{	// determine whether _Ty is implicitly default constructible
	};

template<class _Ty>
	void _Implicitly_default_construct(const _Ty&);

template<class _Ty>
	struct _Is_implicitly_default_constructible<_Ty, void_t<decltype(_Implicitly_default_construct<_Ty>({}))>>
		: true_type
	{	// determine whether _Ty is implicitly default constructible
	};

	// STRUCT TEMPLATE is_move_constructible
template<class _Ty>
	struct is_move_constructible
		: bool_constant<__is_constructible(_Ty, _Ty)>
	{	// determine whether _Ty has a move constructor
	};

template<class _Ty>
	 constexpr bool is_move_constructible_v = __is_constructible(_Ty, _Ty);

	// STRUCT TEMPLATE is_assignable
template<class _To,
	class _From>
	struct is_assignable
		: bool_constant<__is_assignable(_To, _From)>
	{	// determine whether _From can be assigned to _To
	};

template<class _To,
	class _From>
	 constexpr bool is_assignable_v = __is_assignable(_To, _From);

	// STRUCT TEMPLATE is_copy_assignable
template<class _Ty>
	struct is_copy_assignable
		: bool_constant<__is_assignable(add_lvalue_reference_t<_Ty>, add_lvalue_reference_t<const _Ty>)>
	{	// determine whether _Ty has a copy assignment operator
	};

template<class _Ty>
	 constexpr bool is_copy_assignable_v =
		__is_assignable(add_lvalue_reference_t<_Ty>, add_lvalue_reference_t<const _Ty>);

	// STRUCT TEMPLATE is_move_assignable
template<class _Ty>
	struct is_move_assignable
		: bool_constant<__is_assignable(add_lvalue_reference_t<_Ty>, _Ty)>
	{	// determine whether _Ty has a move assignment operator
	};

template<class _Ty>
	 constexpr bool is_move_assignable_v = __is_assignable(add_lvalue_reference_t<_Ty>, _Ty);

	// STRUCT TEMPLATE is_destructible
template<class _Ty>
	struct is_destructible
		: bool_constant<__is_destructible(_Ty)>
	{	// determine whether _Ty has a destructor
	};

template<class _Ty>
	 constexpr bool is_destructible_v = __is_destructible(_Ty);

		// TRIVIAL TRAITS
	// STRUCT TEMPLATE is_trivially_constructible
template<class _Ty,
	class... _Args>
	struct is_trivially_constructible
		: bool_constant<__is_trivially_constructible(_Ty, _Args...)>
	{	// determine whether _Ty(_Args...) is trivially constructible
	};

template<class _Ty,
	class... _Args>
	 constexpr bool is_trivially_constructible_v = __is_trivially_constructible(_Ty, _Args...);

	// STRUCT TEMPLATE is_trivially_copy_constructible
template<class _Ty>
	struct is_trivially_copy_constructible
		: bool_constant<__is_trivially_constructible(_Ty, add_lvalue_reference_t<const _Ty>)>
	{	// determine whether _Ty has a trivial copy constructor
	};

template<class _Ty>
	 constexpr bool is_trivially_copy_constructible_v =
		__is_trivially_constructible(_Ty, add_lvalue_reference_t<const _Ty>);

	// STRUCT TEMPLATE is_trivially_default_constructible
template<class _Ty>
	struct is_trivially_default_constructible
		: bool_constant<__is_trivially_constructible(_Ty)>
	{	// determine whether _Ty has a trivial default constructor
	};

template<class _Ty>
	 constexpr bool is_trivially_default_constructible_v = __is_trivially_constructible(_Ty);

	// STRUCT TEMPLATE is_trivially_move_constructible
template<class _Ty>
	struct is_trivially_move_constructible
		: bool_constant<__is_trivially_constructible(_Ty, _Ty)>
	{	// determine whether _Ty has a trivial move constructor
	};

template<class _Ty>
	 constexpr bool is_trivially_move_constructible_v = __is_trivially_constructible(_Ty, _Ty);

	// STRUCT TEMPLATE is_trivially_assignable
template<class _To,
	class _From>
	struct is_trivially_assignable
		: bool_constant<__is_trivially_assignable(_To, _From)>
	{	// determine whether _From can be assigned to _To, trivially
	};

template<class _To,
	class _From>
	 constexpr bool is_trivially_assignable_v = __is_trivially_assignable(_To, _From);

	// STRUCT TEMPLATE is_trivially_copy_assignable
template<class _Ty>
	struct is_trivially_copy_assignable
		: bool_constant<__is_trivially_assignable(add_lvalue_reference_t<_Ty>, add_lvalue_reference_t<const _Ty>)>
	{	// determine whether _Ty has a trivial copy assignment operator
	};

template<class _Ty>
	 constexpr bool is_trivially_copy_assignable_v =
		__is_trivially_assignable(add_lvalue_reference_t<_Ty>, add_lvalue_reference_t<const _Ty>);

	// STRUCT TEMPLATE is_trivially_move_assignable
template<class _Ty>
	struct is_trivially_move_assignable
		: bool_constant<__is_trivially_assignable(add_lvalue_reference_t<_Ty>, _Ty)>
	{	// determine whether _Ty has a trivial move assignment operator
	};

template<class _Ty>
	 constexpr bool is_trivially_move_assignable_v =
		__is_trivially_assignable(add_lvalue_reference_t<_Ty>, _Ty);

	// STRUCT TEMPLATE is_trivially_destructible
template<class _Ty>
	struct is_trivially_destructible
		: bool_constant<__is_trivially_destructible(_Ty)>
	{	// determine whether _Ty has a trivial destructor
	};

template<class _Ty>
	 constexpr bool is_trivially_destructible_v = __is_trivially_destructible(_Ty);

		// NOTHROW TRAITS
	// STRUCT TEMPLATE is_nothrow_constructible
template<class _Ty,
	class... _Args>
	struct is_nothrow_constructible
		: bool_constant<__is_nothrow_constructible(_Ty, _Args...)>
	{	// determine whether _Ty(_Args...) is nothrow constructible
	};

template<class _Ty,
	class... _Args>
	 constexpr bool is_nothrow_constructible_v = __is_nothrow_constructible(_Ty, _Args...);

	// STRUCT TEMPLATE is_nothrow_copy_constructible
template<class _Ty>
	struct is_nothrow_copy_constructible
		: bool_constant<__is_nothrow_constructible(_Ty, add_lvalue_reference_t<const _Ty>)>
	{	// determine whether _Ty has a nothrow copy constructor
	};

template<class _Ty>
	 constexpr bool is_nothrow_copy_constructible_v =
		__is_nothrow_constructible(_Ty, add_lvalue_reference_t<const _Ty>);

	// STRUCT TEMPLATE is_nothrow_default_constructible
template<class _Ty>
	struct is_nothrow_default_constructible
		: bool_constant<__is_nothrow_constructible(_Ty)>
	{	// determine whether _Ty has a nothrow default constructor
	};

template<class _Ty>
	 constexpr bool is_nothrow_default_constructible_v = __is_nothrow_constructible(_Ty);

	// STRUCT TEMPLATE is_nothrow_move_constructible
template<class _Ty>
	struct is_nothrow_move_constructible
		: bool_constant<__is_nothrow_constructible(_Ty, _Ty)>
	{	// determine whether _Ty has a nothrow move constructor
	};

template<class _Ty>
	 constexpr bool is_nothrow_move_constructible_v = __is_nothrow_constructible(_Ty, _Ty);

	// STRUCT TEMPLATE is_nothrow_assignable
template<class _To,
	class _From>
	struct is_nothrow_assignable
		: bool_constant<__is_nothrow_assignable(_To, _From)>
	{	// determine whether _From can be assigned to _To, nothrow
	};

template<class _To,
	class _From>
	 constexpr bool is_nothrow_assignable_v = __is_nothrow_assignable(_To, _From);

	// STRUCT TEMPLATE is_nothrow_copy_assignable
template<class _Ty>
	struct is_nothrow_copy_assignable
		: bool_constant<__is_nothrow_assignable(add_lvalue_reference_t<_Ty>, add_lvalue_reference_t<const _Ty>)>
	{	// determine whether _Ty has a nothrow copy assignment operator
	};

template<class _Ty>
	 constexpr bool is_nothrow_copy_assignable_v =
		__is_nothrow_assignable(add_lvalue_reference_t<_Ty>, add_lvalue_reference_t<const _Ty>);

	// STRUCT TEMPLATE is_nothrow_move_assignable
template<class _Ty>
	struct is_nothrow_move_assignable
		: bool_constant<__is_nothrow_assignable(add_lvalue_reference_t<_Ty>, _Ty)>
	{	// determine whether _Ty has a nothrow move assignment operator
	};

template<class _Ty>
	 constexpr bool is_nothrow_move_assignable_v = __is_nothrow_assignable(add_lvalue_reference_t<_Ty>, _Ty);

	// STRUCT TEMPLATE is_nothrow_destructible
template<class _Ty>
	struct is_nothrow_destructible
		: bool_constant<__is_nothrow_destructible(_Ty)>
	{	// determine whether _Ty has a nothrow destructor
	};

template<class _Ty>
	 constexpr bool is_nothrow_destructible_v = __is_nothrow_destructible(_Ty);

	// STRUCT TEMPLATE is_signed
#pragma warning(push)
#pragma warning(disable: 4296)	
template<class _Ty,
	bool = is_integral_v<_Ty>>
	struct _Sign_base
	{	// determine whether integral _Ty is a signed or unsigned type
	using _Uty = remove_cv_t<_Ty>;
	using _Signed = bool_constant<_Uty(-1) < _Uty(0)>;
	using _Unsigned = bool_constant<_Uty(0) < _Uty(-1)>;
	};
#pragma warning(pop)

template<class _Ty>
	struct _Sign_base<_Ty, false>
	{	// floating-point _Ty is signed
		// non-arithmetic _Ty is neither signed nor unsigned
	using _Signed = typename is_floating_point<_Ty>::type;
	using _Unsigned = false_type;
	};

template<class _Ty>
	struct is_signed
		: _Sign_base<_Ty>::_Signed
	{	// determine whether _Ty is a signed type
	};

template<class _Ty>
	 constexpr bool is_signed_v = is_signed<_Ty>::value;

	// STRUCT TEMPLATE is_unsigned
template<class _Ty>
	struct is_unsigned
		: _Sign_base<_Ty>::_Unsigned
	{	// determine whether _Ty is an unsigned type
	};

template<class _Ty>
	 constexpr bool is_unsigned_v = is_unsigned<_Ty>::value;

	// ALIAS TEMPLATE _Is_nonbool_integral
template<class _Ty>
	using _Is_nonbool_integral =
		bool_constant<is_integral_v<_Ty>
			&& !is_same_v<remove_cv_t<_Ty>, bool>>;

	// STRUCT TEMPLATE _Change_sign
template<class _Ty>
	struct _Change_sign
	{	// signed/unsigned partners to _Ty
	static_assert(_Is_nonbool_integral<_Ty>::value || is_enum_v<_Ty>,
		"make_signed<T>/make_unsigned<T> require that T shall be a (possibly "
		"cv-qualified) integral type or enumeration but not a bool type.");

	using _Signed =
		conditional_t<_Is_any_of_v<_Ty, long, unsigned long>, long,
		conditional_t<sizeof(_Ty) == 1, signed char,
		conditional_t<sizeof(_Ty) == 2, short,
		conditional_t<sizeof(_Ty) == 4, int,
			long long
		>>>>;

	using _Unsigned =
		conditional_t<_Is_any_of_v<_Ty, long, unsigned long>, unsigned long,
		conditional_t<sizeof(_Ty) == 1, unsigned char,
		conditional_t<sizeof(_Ty) == 2, unsigned short,
		conditional_t<sizeof(_Ty) == 4, unsigned int,
			unsigned long long
		>>>>;
	};

template<class _Ty>
	struct _Change_sign<const _Ty>
	{	// signed/unsigned partners to _Ty
	using _Signed = const typename _Change_sign<_Ty>::_Signed;
	using _Unsigned = const typename _Change_sign<_Ty>::_Unsigned;
	};

template<class _Ty>
	struct _Change_sign<volatile _Ty>
	{	// signed/unsigned partners to _Ty
	using _Signed = volatile typename _Change_sign<_Ty>::_Signed;
	using _Unsigned = volatile typename _Change_sign<_Ty>::_Unsigned;
	};

template<class _Ty>
	struct _Change_sign<const volatile _Ty>
	{	// signed/unsigned partners to _Ty
	using _Signed = const volatile typename _Change_sign<_Ty>::_Signed;
	using _Unsigned = const volatile typename _Change_sign<_Ty>::_Unsigned;
	};

	// STRUCT TEMPLATE make_signed
template<class _Ty>
	struct make_signed
	{	// signed partner to _Ty
	using type = typename _Change_sign<_Ty>::_Signed;
	};

template<class _Ty>
	using make_signed_t = typename make_signed<_Ty>::type;

	// STRUCT TEMPLATE make_unsigned
template<class _Ty>
	struct make_unsigned
	{	// unsigned partner to _Ty
	using type = typename _Change_sign<_Ty>::_Unsigned;
	};

template<class _Ty>
	using make_unsigned_t = typename make_unsigned<_Ty>::type;

	// FUNCTION TEMPLATE _Unsigned_value
template<class _Rep>
	constexpr make_unsigned_t<_Rep> _Unsigned_value(_Rep _Val)
	{	// makes _Val unsigned
	return (static_cast<make_unsigned_t<_Rep>>(_Val));
	}

	// STRUCT TEMPLATE alignment_of
template<class _Ty>
	struct alignment_of
		: integral_constant<size_t, alignof(_Ty)>
	{	// determine alignment of _Ty
	};

template<class _Ty>
	 constexpr size_t alignment_of_v = alignof(_Ty);

	// STRUCT TEMPLATE aligned_storage




template<class _Ty,
	size_t _Len>
	union _Align_type
	{	// union with size _Len bytes and alignment of _Ty
	_Ty _Val;
	char _Pad[_Len];
	};

template<size_t _Len,
	size_t _Align,
	class _Ty,
	bool _Ok>
	struct _Aligned;

template<size_t _Len,
	size_t _Align,
	class _Ty>
	struct _Aligned<_Len, _Align, _Ty, true>
	{	// define type with size _Len and alignment _Ty
	using type = _Align_type<_Ty, _Len>;
	};

template<size_t _Len,
	size_t _Align>
	struct _Aligned<_Len, _Align, double, false>
	{	// define type with size _Len and alignment _Ty
 





  
	static_assert(_Always_false<_Aligned>,
		"You've instantiated std::aligned_storage<Len, Align> with an extended alignment (in other "
		"words, Align > alignof(max_align_t)). Before VS 2017 15.8, the member type would "
		"non-conformingly have an alignment of only alignof(max_align_t). VS 2017 15.8 was fixed to "
		"handle this correctly, but the fix inherently changes layout and breaks binary compatibility "
		"(*only* for uses of aligned_storage with extended alignments). "
		"Please define either "
		"(1) _ENABLE_EXTENDED_ALIGNED_STORAGE to acknowledge that you understand this message and "
		"that you actually want a type with an extended alignment, or "
		"(2) _DISABLE_EXTENDED_ALIGNED_STORAGE to silence this message and get the old non-conformant "
		"behavior.");
  
	using type = _Align_type<max_align_t, _Len>;
 
	};

template<size_t _Len,
	size_t _Align>
	struct _Aligned<_Len, _Align, int, false>
	{	// define type with size _Len and alignment _Ty
	using type = typename _Aligned<_Len, _Align, double, _Align <= alignof(double)>::type;
	};

template<size_t _Len,
	size_t _Align>
	struct _Aligned<_Len, _Align, short, false>
	{	// define type with size _Len and alignment _Ty
	using type = typename _Aligned<_Len, _Align, int, _Align <= alignof(int)>::type;
	};

template<size_t _Len,
	size_t _Align>
	struct _Aligned<_Len, _Align, char, false>
	{	// define type with size _Len and alignment _Ty
	using type = typename _Aligned<_Len, _Align, short, _Align <= alignof(short)>::type;
	};

template<size_t _Len,
	size_t _Align = alignof(max_align_t)>
	struct aligned_storage
	{	// define type with size _Len and alignment _Align
	using type = typename _Aligned<_Len, _Align, char, _Align <= alignof(char)>::type;
	};




template<size_t _Len,
	size_t _Align = alignof(max_align_t)>
	using aligned_storage_t = typename aligned_storage<_Len, _Align>::type;

	// STRUCT TEMPLATE aligned_union
template<size_t... _Vals>
	struct _Maximum;

template<>
	struct _Maximum<>
		: integral_constant<size_t, 0>
	{	// maximum of nothing is 0
	};

template<size_t _Val>
	struct _Maximum<_Val>
		: integral_constant<size_t, _Val>
	{	// maximum of _Val is _Val
	};

template<size_t _First,
	size_t _Second,
	size_t... _Rest>
	struct _Maximum<_First, _Second, _Rest...>
		: _Maximum<(_First < _Second ? _Second : _First), _Rest...>::type
	{	// find maximum value in _First, _Second, _Rest...
	};

template<size_t _Len,
	class... _Types>
	struct aligned_union
	{	// define type with size at least _Len, for storing anything in _Types
	static constexpr size_t _Max_len = _Maximum<_Len, sizeof(_Types)...>::value;	// NOT sizeof...(_Types)
	static constexpr size_t alignment_value = _Maximum<alignof(_Types)...>::value;
	using type = aligned_storage_t<_Max_len, alignment_value>;
	};

template<size_t _Len,
	class... _Types>
	using aligned_union_t = typename aligned_union<_Len, _Types...>::type;

	// STRUCT TEMPLATE underlying_type
template<class _Ty>
	struct underlying_type
	{	// determine type underlying type for enum
	using type = __underlying_type(_Ty);
	};

template<class _Ty>
	using underlying_type_t = typename underlying_type<_Ty>::type;

	// STRUCT TEMPLATE rank
template<class _Ty>
	struct rank
		: integral_constant<size_t, 0>
	{	// determine number of dimensions of array _Ty
	};

template<class _Ty, size_t _Ix>
	struct rank<_Ty[_Ix]>
		: integral_constant<size_t, rank<_Ty>::value + 1>
	{	// determine number of dimensions of array _Ty
	};

template<class _Ty>
	struct rank<_Ty[]>
		: integral_constant<size_t, rank<_Ty>::value + 1>
	{	// determine number of dimensions of array _Ty
	};

template<class _Ty>
	 constexpr size_t rank_v = rank<_Ty>::value;

	// STRUCT TEMPLATE extent
template<class _Ty, unsigned int _Nx>
	struct _Extent
		: integral_constant<size_t, 0>
	{	// determine extent of dimension _Nx of array _Ty
	};

template<class _Ty, size_t _Ix>
	struct _Extent<_Ty[_Ix], 0>
		: integral_constant<size_t, _Ix>
	{	// determine extent of dimension _Nx of array _Ty
	};

template<class _Ty, unsigned int _Nx, size_t _Ix>
	struct _Extent<_Ty[_Ix], _Nx>
		: _Extent<_Ty, _Nx - 1>
	{	// determine extent of dimension _Nx of array _Ty
	};

template<class _Ty, unsigned int _Nx>
	struct _Extent<_Ty[], _Nx>
		: _Extent<_Ty, _Nx - 1>
	{	// determine extent of dimension _Nx of array _Ty
	};

template<class _Ty, unsigned int _Nx = 0>
	struct extent
		: _Extent<_Ty, _Nx>
	{	// determine extent of dimension _Nx of array _Ty
	};

template<class _Ty,
	unsigned int _Ix = 0>
	 constexpr size_t extent_v = extent<_Ty, _Ix>::value;

	// STRUCT TEMPLATE is_base_of
template<class _Base,
	class _Derived>
	struct is_base_of
		: bool_constant<__is_base_of(_Base, _Derived)>
	{	// determine whether _Base is a base of or the same as _Derived
	};

template<class _Base,
	class _Derived>
	 constexpr bool is_base_of_v = __is_base_of(_Base, _Derived);

	// STRUCT TEMPLATE decay
template<class _Ty>
	struct decay
	{	// determines decayed version of _Ty
	using _Ty1 = remove_reference_t<_Ty>;

	using type = conditional_t<is_array_v<_Ty1>,
		add_pointer_t<remove_extent_t<_Ty1>>,
		conditional_t<is_function_v<_Ty1>,
			add_pointer_t<_Ty1>,
			remove_cv_t<_Ty1>>>;
	};

template<class _Ty>
	using decay_t = typename decay<_Ty>::type;

		// STRUCT TEMPLATE common_type
template<class _Ty1,
	class _Ty2,
	class = void>
	struct _Decayed_cond_oper
	{
	};

template<class _Ty1,
	class _Ty2>
	struct _Decayed_cond_oper<_Ty1, _Ty2, void_t<decltype(false ? ::std:: declval<_Ty1>() : ::std:: declval<_Ty2>())>>
	{
	using type = decay_t<decltype(false ? ::std:: declval<_Ty1>() : ::std:: declval<_Ty2>())>;
	};

template<class... _Ty>
	struct common_type;

template<class... _Ty>
	using common_type_t = typename common_type<_Ty...>::type;

template<>
	struct common_type<>
	{
	};

template<class _Ty1>
	struct common_type<_Ty1>
		: common_type<_Ty1, _Ty1>
	{
	};

template<class _Ty1,
	class _Ty2,
	class _Decayed1 = decay_t<_Ty1>,
	class _Decayed2 = decay_t<_Ty2>>
	struct _Common_type2
		: common_type<_Decayed1, _Decayed2>
	{
	};

template<class _Ty1,
	class _Ty2>
	struct _Common_type2<_Ty1, _Ty2, _Ty1, _Ty2>
		: _Decayed_cond_oper<_Ty1, _Ty2>
	{
	};

template<class _Ty1,
	class _Ty2>
	struct common_type<_Ty1, _Ty2>
		: _Common_type2<_Ty1, _Ty2>
	{
	};

template<class _Void,
	class _Ty1,
	class _Ty2,
	class... _Rest>
	struct _Common_type3
	{
	};

template<class _Ty1,
	class _Ty2,
	class... _Rest>
	struct _Common_type3<void_t<common_type_t<_Ty1, _Ty2>>, _Ty1, _Ty2, _Rest...>
		: common_type<common_type_t<_Ty1, _Ty2>, _Rest...>
	{
	};

template<class _Ty1,
	class _Ty2,
	class... _Rest>
	struct common_type<_Ty1, _Ty2, _Rest...>
		: _Common_type3<void, _Ty1, _Ty2, _Rest...>
	{
	};


	// STRUCT TEMPLATE identity
template<class _Ty>
	struct [[deprecated("warning STL4003: " "The non-Standard std::identity struct is deprecated and will be REMOVED. You can " "define _SILENCE_IDENTITY_STRUCT_DEPRECATION_WARNING to acknowledge that you have received this warning.")]] identity
	{	// map _Ty to type unchanged
	using type = _Ty;

	const _Ty& operator()(const _Ty& _Left) const
		{	// apply identity operator to operand
		return (_Left);
		}
	};


	// STRUCT TEMPLATE _Identity
template<class _Ty>
	struct _Identity
	{	// the identity transformation trait
	using type = _Ty;
	};
template<class _Ty>
	using _Identity_t = typename _Identity<_Ty>::type;

	// TRAIT _Is_specialization: TRUE IFF _Type IS A SPECIALIZATION OF _Template
template<class _Type,
	template <class...> class _Template>
	 constexpr bool _Is_specialization_v = false;
template<template <class...> class _Template,
	class... _Types>
	 constexpr bool _Is_specialization_v<_Template<_Types...>, _Template> = true;

template<class _Type,
	template <class...> class _Template>
	struct _Is_specialization
		: bool_constant<_Is_specialization_v<_Type, _Template>>
	{};

	// FUNCTION TEMPLATE forward
template<class _Ty>
	 constexpr _Ty&& forward(remove_reference_t<_Ty>& _Arg) noexcept
	{	// forward an lvalue as either an lvalue or an rvalue
	return (static_cast<_Ty&&>(_Arg));
	}

template<class _Ty>
	 constexpr _Ty&& forward(remove_reference_t<_Ty>&& _Arg) noexcept
	{	// forward an rvalue as an rvalue
	static_assert(!is_lvalue_reference_v<_Ty>, "bad forward call");
	return (static_cast<_Ty&&>(_Arg));
	}

		// FUNCTION TEMPLATE move
template<class _Ty>
	 constexpr remove_reference_t<_Ty>&&
		move(_Ty&& _Arg) noexcept
	{	// forward _Arg as movable
	return (static_cast<remove_reference_t<_Ty>&&>(_Arg));
	}

		// FUNCTION TEMPLATE move_if_noexcept
template<class _Ty>
	 constexpr conditional_t<!is_nothrow_move_constructible_v<_Ty> && is_copy_constructible_v<_Ty>,
		const _Ty&, _Ty&&>
	move_if_noexcept(_Ty& _Arg) noexcept
	{	// forward _Arg as movable, sometimes
	return (::std:: move(_Arg));
	}

template<class _Ty>
	class reference_wrapper;








































































































































































template<class _Callable,
	class... _Types>
	struct _Invoker;

template<class _Callable,
	class... _Types> inline
	auto invoke(_Callable&& _Obj, _Types&&... _Args)
	noexcept(noexcept(_Invoker<_Callable, _Types...>::_Call( ::std:: forward<_Callable>(_Obj), ::std:: forward<_Types>(_Args)...)))
	-> decltype(_Invoker<_Callable, _Types...>::_Call(
		::std:: forward<_Callable>(_Obj), ::std:: forward<_Types>(_Args)...));

struct _Unforced
	{	// tag to distinguish bind() from bind<R>()
	};

	// TYPE TRAITS FOR invoke()
template<class _To>
	void _Implicitly_convert_to(_To) noexcept;

template<class _From,
	class _To,
	bool = is_convertible_v<_From, _To>>
	struct _Is_nothrow_convertible
		: bool_constant<noexcept(_Implicitly_convert_to<_To>(::std:: declval<_From>()))>
	{	// determine whether _From is nothrow-convertible to _To
	};

template<class _From,
	class _To>
	struct _Is_nothrow_convertible<_From, _To, false>
		: false_type
	{	// determine whether _From is nothrow-convertible to _To
	};

template<class _Void,
	class... _Types>
	struct _Invoke_traits
	{	// selected when _Callable isn't callable with _Args
	using _Is_invocable = false_type;
	using _Is_nothrow_invocable = false_type;
	template<class _Rx>
		using _Is_invocable_r = false_type;
	template<class _Rx>
		using _Is_nothrow_invocable_r = false_type;
	};

template<class... _Types>
	struct _Invoke_traits<void_t<decltype(::std:: invoke(::std:: declval<_Types>()...))>, _Types...>
	{	// selected when _Callable is callable with _Args
	using type = decltype(::std:: invoke(::std:: declval<_Types>()...));
	using _Is_invocable = true_type;
	using _Is_nothrow_invocable = bool_constant<noexcept(::std:: invoke(::std:: declval<_Types>()...))>;
	template<class _Rx>
		using _Is_invocable_r = bool_constant<disjunction_v<is_void<_Rx>, is_convertible<type, _Rx>>>;
	template<class _Rx>
		using _Is_nothrow_invocable_r = bool_constant<conjunction_v<
			_Is_nothrow_invocable,
			disjunction<is_void<_Rx>, _Is_nothrow_convertible<type, _Rx>>>>;
	};

	// STRUCT TEMPLATE result_of
template<class _Fty>
	struct  result_of
	{	// explain usage
	static_assert(_Always_false<_Fty>,
		"result_of<CallableType> is invalid; use "
		"result_of<CallableType(zero or more argument types)> instead.");
	};









template<class _Callable, class... _Args> struct  result_of<_Callable __cdecl (_Args...)> : _Invoke_traits<void, _Callable, _Args...> { };    template<class _Callable, class... _Args> struct  result_of<_Callable __vectorcall (_Args...)> : _Invoke_traits<void, _Callable, _Args...> { };


#pragma warning(push)
#pragma warning(disable: 4996)	
template<class _Ty>
	using result_of_t  = typename result_of<_Ty>::type;
#pragma warning(pop)

template<class _Callable,
	class... _Args>
	using _Invoke_result_t = typename _Invoke_traits<void, _Callable, _Args...>::type;

template<class _Rx,
	class _Callable,
	class... _Args>
	using _Is_invocable_r_ = typename _Invoke_traits<void, _Callable, _Args...>::template _Is_invocable_r<_Rx>;

template<class _Rx,
	class _Callable,
	class... _Args>
	struct _Is_invocable_r
		: _Is_invocable_r_<_Rx, _Callable, _Args...>
	{	// determines whether _Callable is callable with _Args and return type _Rx
	};






































































	// STRUCT TEMPLATE _Weak_types
template<class _Ty,
	class = void>
	struct _Weak_result_type
	{	// default definition
	};

#pragma warning(push)
#pragma warning(disable: 4996)	
template<class _Ty>
	struct _Weak_result_type<_Ty, void_t<
		typename _Ty::result_type>>
	{	// defined if _Ty::result_type exists
	 typedef typename _Ty::result_type result_type;
	};
#pragma warning(pop)

template<class _Ty,
	class = void>
	struct _Weak_argument_type
		: _Weak_result_type<_Ty>
	{	// default definition
	};

#pragma warning(push)
#pragma warning(disable: 4996)	
template<class _Ty>
	struct _Weak_argument_type<_Ty, void_t<
		typename _Ty::argument_type>>
		: _Weak_result_type<_Ty>
	{	// defined if _Ty::argument_type exists
	 typedef typename _Ty::argument_type argument_type;
	};
#pragma warning(pop)

template<class _Ty,
	class = void>
	struct _Weak_binary_args
		: _Weak_argument_type<_Ty>
	{	// default definition
	};

#pragma warning(push)
#pragma warning(disable: 4996)	
template<class _Ty>
	struct _Weak_binary_args<_Ty, void_t<
		typename _Ty::first_argument_type,
		typename _Ty::second_argument_type>>
		: _Weak_argument_type<_Ty>
	{	// defined if both types exist
	 typedef typename _Ty::first_argument_type first_argument_type;
	 typedef typename _Ty::second_argument_type second_argument_type;
	};
#pragma warning(pop)

template<class _Ty>
	struct _Weak_types
	{	// provide nested types (sometimes)
	using _Is_f_or_pf = _Is_function<remove_pointer_t<_Ty>>;
	using _Is_pmf = _Is_memfunptr<remove_cv_t<_Ty>>;
	using type = conditional_t<_Is_f_or_pf::_Bool_type::value, _Is_f_or_pf,
		conditional_t<_Is_pmf::_Bool_type::value, _Is_pmf,
		_Weak_binary_args<_Ty>>>;
	};

	// CLASS TEMPLATE reference_wrapper
template<class _Ty>
	void _Refwrap_ctor_fun(_Identity_t<_Ty&>) noexcept;
template<class _Ty>
	void _Refwrap_ctor_fun(_Identity_t<_Ty&&>) = delete;

struct _Unique_tag_refwrap_has_ctor_from
	{	// TRANSITION, VSO#606027
	};

template<class _Ty,
	class _Uty,
	class = void>
	struct _Refwrap_has_ctor_from
		: false_type
	{
	};

template<class _Ty,
	class _Uty>
	struct _Refwrap_has_ctor_from<_Ty, _Uty, void_t<
		_Unique_tag_refwrap_has_ctor_from,	// TRANSITION, VSO#606027
		decltype(_Refwrap_ctor_fun<_Ty>(::std:: declval<_Uty>()))>>
		: true_type
	{
	};

template<class _Ty>
	class reference_wrapper
		: public _Weak_types<_Ty>::type
	{	// stand-in for an assignable reference
public:
	static_assert(is_object_v<_Ty> || is_function_v<_Ty>,
		"reference_wrapper<T> requires T to be an object type or a function type.");

	using type = _Ty;

	template<class _Uty,
		enable_if_t<conjunction_v<
			negation<is_same<remove_cv_t<remove_reference_t<_Uty>>, reference_wrapper>>,
			_Refwrap_has_ctor_from<_Ty, _Uty>>, int> = 0>
		reference_wrapper(_Uty&& _Val)
			noexcept(noexcept(_Refwrap_ctor_fun<_Ty>(::std:: declval<_Uty>())))
			{	// construct
			_Ty& _Ref = ::std:: forward<_Uty>(_Val);
			_Ptr = ::std:: addressof(_Ref);
			}

	operator _Ty&() const noexcept
		{	// return reference
		return (*_Ptr);
		}

	 _Ty& get() const noexcept
		{	// return reference
		return (*_Ptr);
		}

	template<class... _Types>
		auto operator()(_Types&&... _Args) const
		-> decltype(::std:: invoke(get(), ::std:: forward<_Types>(_Args)...))
		{	// invoke object/function
		return (::std:: invoke(get(), ::std:: forward<_Types>(_Args)...));
		}

private:
	_Ty * _Ptr;
	};







	// FUNCTION TEMPLATES ref AND cref
template<class _Ty>
	 inline reference_wrapper<_Ty> ref(_Ty& _Val) noexcept
	{	// create reference_wrapper<_Ty> object
	return (reference_wrapper<_Ty>(_Val));
	}

template<class _Ty>
	void ref(const _Ty&&) = delete;

template<class _Ty>
	 inline reference_wrapper<_Ty> ref(reference_wrapper<_Ty> _Val) noexcept
	{	// create reference_wrapper<_Ty> object
	return (::std:: ref(_Val.get()));
	}

template<class _Ty>
	 inline reference_wrapper<const _Ty> cref(const _Ty& _Val) noexcept
	{	// create reference_wrapper<const _Ty> object
	return (reference_wrapper<const _Ty>(_Val));
	}

template<class _Ty>
	void cref(const _Ty&&) = delete;

template<class _Ty>
	 inline reference_wrapper<const _Ty> cref(reference_wrapper<_Ty> _Val) noexcept
	{	// create reference_wrapper<const _Ty> object
	return (::std:: cref(_Val.get()));
	}

		// STRUCT TEMPLATE _Is_swappable
template<class _Ty>
	struct _Is_swappable;

		// STRUCT TEMPLATE _Is_nothrow_swappable
template<class _Ty>
	struct _Is_nothrow_swappable;

		// FUNCTION TEMPLATE swap





template<class _Ty,
	class = void> inline

	void swap(_Ty&, _Ty&)
		noexcept(is_nothrow_move_constructible_v<_Ty> && is_nothrow_move_assignable_v<_Ty>);

template<class _Ty,
	size_t _Size,
	class = enable_if_t<_Is_swappable<_Ty>::value>> inline
	void swap(_Ty (&)[_Size], _Ty (&)[_Size])
		noexcept(_Is_nothrow_swappable<_Ty>::value);

		// STRUCT TEMPLATE _Swappable_with_helper
template<class _Ty1,
	class _Ty2,
	class = void>
	struct _Swappable_with_helper
		: false_type
	{	// swap(declval<_Ty1>(), declval<_Ty2>()) is not valid
	};

template<class _Ty1,
	class _Ty2>
	struct _Swappable_with_helper<_Ty1, _Ty2, void_t<decltype(swap(::std:: declval<_Ty1>(), ::std:: declval<_Ty2>()))>>
		: true_type
	{	// swap(declval<_Ty1>(), declval<_Ty2>()) is valid
	};

		// STRUCT TEMPLATE _Is_swappable_with
template<class _Ty1,
	class _Ty2>
	struct _Is_swappable_with
		: bool_constant<conjunction_v<
			_Swappable_with_helper<_Ty1, _Ty2>,
			_Swappable_with_helper<_Ty2, _Ty1>>>
	{	// Determine if expressions with type and value category _Ty1 and _Ty2
		// can be swapped (and vice versa)
	};

		// STRUCT TEMPLATE _Is_swappable
template<class _Ty>
	struct _Is_swappable
		: _Is_swappable_with<
			add_lvalue_reference_t<_Ty>,
			add_lvalue_reference_t<_Ty>>::type
	{	// Determine if _Ty lvalues satisfy is_swappable_with
	};

		// STRUCT TEMPLATE _Swap_cannot_throw
template<class _Ty1,
	class _Ty2>
	struct _Swap_cannot_throw
		: bool_constant<noexcept(swap(::std:: declval<_Ty1>(), ::std:: declval<_Ty2>()))
					&& noexcept(swap(::std:: declval<_Ty2>(), ::std:: declval<_Ty1>()))>
	{	// Determine if expressions with type and value category _Ty1 and _Ty2
		// (presumed to satisfy is_swappable_with) can be swapped without
		// emitting exceptions
	};

		// STRUCT TEMPLATE _Is_nothrow_swappable_with
template<class _Ty1,
	class _Ty2>
	struct _Is_nothrow_swappable_with
		: bool_constant<conjunction_v<
			_Is_swappable_with<_Ty1, _Ty2>,
			_Swap_cannot_throw<_Ty1, _Ty2>>>
	{	// Determine if expressions with type and value category _Ty1 and _Ty2
		// satisfy is_swappable_with, and can be swapped without emitting exceptions
	};

		// STRUCT TEMPLATE _Is_nothrow_swappable
template<class _Ty>
	struct _Is_nothrow_swappable
		: _Is_nothrow_swappable_with<
			add_lvalue_reference_t<_Ty>,
			add_lvalue_reference_t<_Ty>>::type
	{	// Determine if _Ty lvalues satisfy is_nothrow_swappable_with
	};

















































	// TYPE TRAIT _Is_trivially_swappable
namespace _Has_ADL_swap_detail {
	void swap(); // undefined (deliberate shadowing)

	template<class,
		class = void>
		struct _Has_ADL_swap
			: false_type
		{};
	template<class _Ty>
		struct _Has_ADL_swap<_Ty, void_t<decltype(swap(::std:: declval<_Ty&>(), ::std:: declval<_Ty&>()))>>
			: true_type
		{};
} // namespace _Has_ADL_swap_detail
using _Has_ADL_swap_detail::_Has_ADL_swap;

template<class _Ty>
	struct _Is_trivially_swappable
		: bool_constant<conjunction_v<
			is_trivially_destructible<_Ty>,
			is_trivially_move_constructible<_Ty>,
			is_trivially_move_assignable<_Ty>,
			negation<_Has_ADL_swap<_Ty>>>>
	{	// true_type if it is valid to swap two _Ty lvalues by exchanging
		// object representations.
	};

template<class _Ty>
	 constexpr bool _Is_trivially_swappable_v = _Is_trivially_swappable<_Ty>::value;

		// BITMASK OPERATIONS
 


















































	// FNV-1a UTILITIES
	// These functions are extremely performance sensitive, check examples like
	// that in VSO#653642 before making changes.

 constexpr size_t _FNV_offset_basis = 14695981039346656037ULL;
 constexpr size_t _FNV_prime = 1099511628211ULL;





 inline size_t _Fnv1a_append_bytes(size_t _Val,
	const unsigned char * const _First, const size_t _Count) noexcept
	{	// accumulate range [_First, _First + _Count) into partial FNV-1a hash _Val
	for (size_t _Idx = 0; _Idx < _Count; ++_Idx)
		{
		_Val ^= static_cast<size_t>(_First[_Idx]);
		_Val *= _FNV_prime;
		}

	return (_Val);
	}

template<class _Ty>
	 inline size_t _Fnv1a_append_range(const size_t _Val,
		const _Ty * const _First, const _Ty * const _Last) noexcept
	{	// accumulate range [_First, _Last) into partial FNV-1a hash _Val
	static_assert(is_trivial_v<_Ty>, "Only trivial types can be directly hashed.");
	const auto _Firstb = reinterpret_cast<const unsigned char *>(_First);
	const auto _Lastb = reinterpret_cast<const unsigned char *>(_Last);
	return (_Fnv1a_append_bytes(_Val, _Firstb, static_cast<size_t>(_Lastb - _Firstb)));
	}

template<class _Kty>
	 inline size_t _Fnv1a_append_value(const size_t _Val, const _Kty& _Keyval) noexcept
	{	// accumulate _Keyval into partial FNV-1a hash _Val
	static_assert(is_trivial_v<_Kty>, "Only trivial types can be directly hashed.");
	return (_Fnv1a_append_bytes(_Val,
		&reinterpret_cast<const unsigned char&>(_Keyval), sizeof(_Kty)));
	}

	// FUNCTION TEMPLATE _Hash_representation
template<class _Kty>
	 inline size_t _Hash_representation(const _Kty& _Keyval) noexcept
	{	// bitwise hashes the representation of a key
	return (_Fnv1a_append_value(_FNV_offset_basis, _Keyval));
	}

	// FUNCTION TEMPLATE _Hash_array_representation
template<class _Kty>
	 inline size_t _Hash_array_representation(
		const _Kty * const _First, const size_t _Count) noexcept
	{	// bitwise hashes the representation of an array
	static_assert(is_trivial_v<_Kty>, "Only trivial types can be directly hashed.");
	return (_Fnv1a_append_bytes(_FNV_offset_basis,
		reinterpret_cast<const unsigned char *>(_First), _Count * sizeof(_Kty)));
	}

	// STRUCT TEMPLATE _Conditionally_enabled_hash
template<class _Kty>
	struct hash;

template<class _Kty,
	bool _Enabled>
	struct _Conditionally_enabled_hash
	{	// conditionally enabled hash base
	 typedef _Kty argument_type;
	 typedef size_t result_type;

	 size_t operator()(const _Kty& _Keyval) const
		noexcept(noexcept(hash<_Kty>::_Do_hash(_Keyval)))
		{	// hash _Keyval to size_t value by pseudorandomizing transform
		return (hash<_Kty>::_Do_hash(_Keyval));
		}
	};

template<class _Kty>
	struct _Conditionally_enabled_hash<_Kty, false>
	{	// conditionally disabled hash base
	_Conditionally_enabled_hash() = delete;
	_Conditionally_enabled_hash(const _Conditionally_enabled_hash&) = delete;
	_Conditionally_enabled_hash(_Conditionally_enabled_hash&&) = delete;
	_Conditionally_enabled_hash& operator=(const _Conditionally_enabled_hash&) = delete;
	_Conditionally_enabled_hash& operator=(_Conditionally_enabled_hash&&) = delete;
	};

	// STRUCT TEMPLATE hash
template<class _Kty>
	struct hash
		: _Conditionally_enabled_hash<_Kty, !is_const_v<_Kty> && !is_volatile_v<_Kty>
			&& (is_enum_v<_Kty> || is_integral_v<_Kty> || is_pointer_v<_Kty>)>
	{	// hash functor primary template (handles enums, integrals, and pointers)
	static size_t _Do_hash(const _Kty& _Keyval) noexcept
		{	// hash _Keyval to size_t value by pseudorandomizing transform
		return (_Hash_representation(_Keyval));
		}
	};

template<>
	struct hash<float>
	{	// hash functor for float
	 typedef float argument_type;
	 typedef size_t result_type;
	 size_t operator()(const float _Keyval) const noexcept
		{	// hash _Keyval to size_t value by pseudorandomizing transform
		return (_Hash_representation(_Keyval == 0.0F ? 0.0F : _Keyval));	// map -0 to 0
		}
	};

template<>
	struct hash<double>
	{	// hash functor for double
	 typedef double argument_type;
	 typedef size_t result_type;
	 size_t operator()(const double _Keyval) const noexcept
		{	// hash _Keyval to size_t value by pseudorandomizing transform
		return (_Hash_representation(_Keyval == 0.0 ? 0.0 : _Keyval));	// map -0 to 0
		}
	};

template<>
	struct hash<long double>
	{	// hash functor for long double
	 typedef long double argument_type;
	 typedef size_t result_type;
	 size_t operator()(const long double _Keyval) const noexcept
		{	// hash _Keyval to size_t value by pseudorandomizing transform
		return (_Hash_representation(_Keyval == 0.0L ? 0.0L : _Keyval));	// map -0 to 0
		}
	};

template<>
	struct hash<nullptr_t>
	{	// hash functor for nullptr_t
	 typedef nullptr_t argument_type;
	 typedef size_t result_type;
	 size_t operator()(nullptr_t) const noexcept
		{	// hash nullptr_t to size_t value by pseudorandomizing transform
		void * _Null{};
		return (_Hash_representation(_Null));
		}
	};

		// STRUCT TEMPLATE _Is_nothrow_hashable
template<class _Kty,
	class = void>
	struct _Is_nothrow_hashable
		: false_type
	{	// tests if std::hash can hash _Kty with noexcept
	};

template<class _Kty>
	struct _Is_nothrow_hashable<_Kty, void_t<decltype(hash<_Kty>{}(::std:: declval<const _Kty&>()))>>
		: bool_constant<noexcept(hash<_Kty>{}(::std:: declval<const _Kty&>()))>
	{	// tests if std::hash can hash _Kty with noexcept
	};


#pragma warning(push)
#pragma warning(disable: 4996)	
namespace [[deprecated("warning STL4002: " "The non-Standard std::tr1 namespace and TR1-only machinery are deprecated and will be REMOVED. You can " "define _SILENCE_TR1_NAMESPACE_DEPRECATION_WARNING to acknowledge that you have received this warning.")]] tr1 {
using ::std:: add_const;
using ::std:: add_cv;
using ::std:: add_pointer;
using ::std:: add_volatile;
using ::std:: aligned_storage;
using ::std:: alignment_of;
using ::std:: conditional;
using ::std:: decay;
using ::std:: enable_if;
using ::std:: extent;
using ::std:: false_type;
using ::std:: has_virtual_destructor;
using ::std:: integral_constant;
using ::std:: is_abstract;
using ::std:: is_arithmetic;
using ::std:: is_array;
using ::std:: is_base_of;
using ::std:: is_class;
using ::std:: is_compound;
using ::std:: is_const;
using ::std:: is_convertible;
using ::std:: is_empty;
using ::std:: is_enum;
using ::std:: is_floating_point;
using ::std:: is_function;
using ::std:: is_fundamental;
using ::std:: is_integral;
using ::std:: is_member_function_pointer;
using ::std:: is_member_object_pointer;
using ::std:: is_member_pointer;
using ::std:: is_object;
using ::std:: is_pod;
using ::std:: is_pointer;
using ::std:: is_polymorphic;
using ::std:: is_reference;
using ::std:: is_same;
using ::std:: is_scalar;
using ::std:: is_signed;
using ::std:: is_union;
using ::std:: is_unsigned;
using ::std:: is_void;
using ::std:: is_volatile;
using ::std:: make_signed;
using ::std:: make_unsigned;
using ::std:: rank;
using ::std:: remove_all_extents;
using ::std:: remove_const;
using ::std:: remove_cv;
using ::std:: remove_extent;
using ::std:: remove_pointer;
using ::std:: remove_reference;
using ::std:: remove_volatile;
using ::std:: true_type;
using ::std:: cref;
using ::std:: ref;
using ::std:: reference_wrapper;
using ::std:: result_of;
using ::std:: hash;
}
#pragma warning(pop)



// EVERYTHING BELOW WILL HAVE STRANGE LINE NUMBERS





 

struct _Invoker_pmf_object { template<class _Decayed, class _Ty1, class... _Types2> static inline auto _Call(_Decayed _Pmf, _Ty1&& _Arg1, _Types2&&... _Args2) noexcept(noexcept((::std:: forward<_Ty1>(_Arg1).*_Pmf)(::std:: forward<_Types2>(_Args2)...))) -> decltype((::std:: forward<_Ty1>(_Arg1).*_Pmf)(::std:: forward<_Types2>(_Args2)...)) { return ((::std:: forward<_Ty1>(_Arg1).*_Pmf)(::std:: forward<_Types2>(_Args2)...)); } }; struct _Invoker_pmf_refwrap { template<class _Decayed, class _Ty1, class... _Types2> static inline auto _Call(_Decayed _Pmf, _Ty1&& _Arg1, _Types2&&... _Args2) noexcept(noexcept((::std:: forward<_Ty1>(_Arg1).get().*_Pmf)(::std:: forward<_Types2>(_Args2)...))) -> decltype((::std:: forward<_Ty1>(_Arg1).get().*_Pmf)(::std:: forward<_Types2>(_Args2)...)) { return ((::std:: forward<_Ty1>(_Arg1).get().*_Pmf)(::std:: forward<_Types2>(_Args2)...)); } }; struct _Invoker_pmf_pointer { template<class _Decayed, class _Ty1, class... _Types2> static inline auto _Call(_Decayed _Pmf, _Ty1&& _Arg1, _Types2&&... _Args2) noexcept(noexcept(((*::std:: forward<_Ty1>(_Arg1)).*_Pmf)(::std:: forward<_Types2>(_Args2)...))) -> decltype(((*::std:: forward<_Ty1>(_Arg1)).*_Pmf)(::std:: forward<_Types2>(_Args2)...)) { return (((*::std:: forward<_Ty1>(_Arg1)).*_Pmf)(::std:: forward<_Types2>(_Args2)...)); } }; struct _Invoker_pmd_object { template<class _Decayed, class _Ty1> static inline auto _Call(_Decayed _Pmd, _Ty1&& _Arg1) noexcept(noexcept(::std:: forward<_Ty1>(_Arg1).*_Pmd)) -> decltype(::std:: forward<_Ty1>(_Arg1).*_Pmd) { return (::std:: forward<_Ty1>(_Arg1).*_Pmd); } }; struct _Invoker_pmd_refwrap { template<class _Decayed, class _Ty1> static inline auto _Call(_Decayed _Pmd, _Ty1&& _Arg1) noexcept(noexcept(::std:: forward<_Ty1>(_Arg1).get().*_Pmd)) -> decltype(::std:: forward<_Ty1>(_Arg1).get().*_Pmd) { return (::std:: forward<_Ty1>(_Arg1).get().*_Pmd); } }; struct _Invoker_pmd_pointer { template<class _Decayed, class _Ty1> static inline auto _Call(_Decayed _Pmd, _Ty1&& _Arg1) noexcept(noexcept((*::std:: forward<_Ty1>(_Arg1)).*_Pmd)) -> decltype((*::std:: forward<_Ty1>(_Arg1)).*_Pmd) { return ((*::std:: forward<_Ty1>(_Arg1)).*_Pmd); } }; struct _Invoker_functor { template<class _Callable, class... _Types> static inline auto _Call(_Callable&& _Obj, _Types&&... _Args) noexcept(noexcept(::std:: forward<_Callable>(_Obj)(::std:: forward<_Types>(_Args)...))) -> decltype(::std:: forward<_Callable>(_Obj)(::std:: forward<_Types>(_Args)...)) { return (::std:: forward<_Callable>(_Obj)(::std:: forward<_Types>(_Args)...)); } }; template<class _Callable, class _Ty1, class _Removed_cvref = remove_cv_t<remove_reference_t<_Callable>>, bool _Is_pmf = is_member_function_pointer_v<_Removed_cvref>, bool _Is_pmd = is_member_object_pointer_v<_Removed_cvref>> struct _Invoker1; template<class _Callable, class _Ty1, class _Removed_cvref> struct _Invoker1<_Callable, _Ty1, _Removed_cvref, true, false> : conditional_t<is_base_of_v< typename _Is_memfunptr<_Removed_cvref>::_Class_type, remove_reference_t<_Ty1>>, _Invoker_pmf_object, conditional_t<_Is_specialization_v<remove_cv_t<remove_reference_t<_Ty1>>, reference_wrapper>, _Invoker_pmf_refwrap, _Invoker_pmf_pointer >> { }; template<class _Callable, class _Ty1, class _Removed_cvref> struct _Invoker1<_Callable, _Ty1, _Removed_cvref, false, true> : conditional_t<is_base_of_v< typename _Is_member_object_pointer<_Removed_cvref>::_Class_type, remove_reference_t<_Ty1>>, _Invoker_pmd_object, conditional_t<_Is_specialization_v<remove_cv_t<remove_reference_t<_Ty1>>, reference_wrapper>, _Invoker_pmd_refwrap, _Invoker_pmd_pointer >> { }; template<class _Callable, class _Ty1, class _Removed_cvref> struct _Invoker1<_Callable, _Ty1, _Removed_cvref, false, false> : _Invoker_functor { }; template<class _Callable, class... _Types> struct _Invoker; template<class _Callable> struct _Invoker<_Callable> : _Invoker_functor { }; template<class _Callable, class _Ty1, class... _Types2> struct _Invoker<_Callable, _Ty1, _Types2...> : _Invoker1<_Callable, _Ty1> { }; template<class _Callable, class... _Types> inline auto invoke(_Callable&& _Obj, _Types&&... _Args) noexcept(noexcept(_Invoker<_Callable, _Types...>::_Call( ::std:: forward<_Callable>(_Obj), ::std:: forward<_Types>(_Args)...))) -> decltype(_Invoker<_Callable, _Types...>::_Call( ::std:: forward<_Callable>(_Obj), ::std:: forward<_Types>(_Args)...)) { return (_Invoker<_Callable, _Types...>::_Call( ::std:: forward<_Callable>(_Obj), ::std:: forward<_Types>(_Args)...)); }











template<class _Rx,
	bool = is_void_v<_Rx>>
	struct _Invoker_ret
	{	// helper to give INVOKE an explicit return type; avoids undesirable Expression SFINAE
	};

template<class _Cv_void>
	struct _Invoker_ret<_Cv_void, true>
	{	// selected for _Rx being cv void
	template<class... _Valtys>
		static void _Call(_Valtys&&... _Vals)



		{	// INVOKE, "implicitly" converted to void



		::std:: invoke(::std:: forward<_Valtys>(_Vals)...);



		}
	};

template<class _Rx>
	struct _Invoker_ret<_Rx, false>
	{	// selected for all _Rx other than cv void and _Unforced
	template<class... _Valtys>
		static _Rx _Call(_Valtys&&... _Vals)



		{	// INVOKE, implicitly converted to _Rx



		return (::std:: invoke(::std:: forward<_Valtys>(_Vals)...));



		}
	};

template<>
	struct _Invoker_ret<_Unforced, false>
	{	// selected for _Rx being _Unforced
	template<class... _Valtys>
		static auto _Call(_Valtys&&... _Vals)
		-> decltype(::std:: invoke(::std:: forward<_Valtys>(_Vals)...))



		{	// INVOKE, unchanged



		return (::std:: invoke(::std:: forward<_Valtys>(_Vals)...));



		}
	};

}

 
 
 #pragma warning(pop)
 #pragma pack(pop)



/*
 * Copyright (c) by P.J. Plauger. All rights reserved.
 * Consult your license regarding permissions and restrictions.
V6.50:0009 */


 #pragma pack(push,8)
 #pragma warning(push,3)
 #pragma warning(disable: 4455 4494  4619 4643 4702 4984 4988 )
 
 
 

namespace std {

  bool __cdecl uncaught_exception() noexcept;
 int __cdecl uncaught_exceptions() noexcept;

}

 


//
// malloc.h
//
//      Copyright (c) Microsoft Corporation. All rights reserved.
//
// The memory allocation library.
//
#pragma once






__pragma(pack(push, 8)) extern "C" {



// Maximum heap request the heap manager will attempt

    






// Constants for _heapchk and _heapwalk routines











typedef struct _heapinfo
{
    int* _pentry;
    size_t _size;
    int _useflag;
} _HEAPINFO;








   
void* __cdecl _alloca(  size_t _Size);





    __declspec(dllimport) intptr_t __cdecl _get_heap_handle(void);

     
    __declspec(dllimport) int __cdecl _heapmin(void);

    
        __declspec(dllimport) int __cdecl _heapwalk(  _HEAPINFO* _EntryInfo);
    

    
          __declspec(dllimport) int __cdecl _heapchk(void);
    

    __declspec(dllimport) int __cdecl _resetstkoflw(void);

    
    
    

    
        
    



    typedef char __static_assert_t[(sizeof(unsigned int) <= 16) != 0];


    #pragma warning(push)
    #pragma warning(disable:6540)

    __inline void* _MarkAllocaS(   void* _Ptr, unsigned int _Marker)
    {
        if (_Ptr)
        {
            *((unsigned int*)_Ptr) = _Marker;
            _Ptr = (char*)_Ptr + 16;
        }
        return _Ptr;
    }

    __inline size_t _MallocaComputeSize(size_t _Size)
    {
        size_t _MarkedSize = _Size + 16;
        return _MarkedSize > _Size ? _MarkedSize : 0;
    }

    #pragma warning(pop)







    
        
        




    




















    

    #pragma warning(push)
    #pragma warning(disable: 6014)
    __inline void __cdecl _freea(    void* _Memory)
    {
        unsigned int _Marker;
        if (_Memory)
        {
            _Memory = (char*)_Memory - 16;
            _Marker = *(unsigned int*)_Memory;
            if (_Marker == 0xDDDD)
            {
                free(_Memory);
            }
            
            else if (_Marker != 0xCCCC)
            {
                (void)( (!!((("Corrupted pointer passed to _freea" && 0)))) || (1 != _CrtDbgReportW(2, L"c:\\windows kits\\10\\include\\10.0.17763.0\\ucrt\\malloc.h", 162, 0, L"%ls", L"(\"Corrupted pointer passed to _freea\" && 0)")) || (__debugbreak(), 0) );
            }
            
        }
    }
    #pragma warning(pop)






    




} __pragma(pack(pop))



//
// vcruntime_exception.h
//
//      Copyright (c) Microsoft Corporation. All rights reserved.
//
// <exception> functionality that is implemented in the VCRuntime.
//
#pragma once


//
// eh.h
//
//      Copyright (c) Microsoft Corporation. All rights reserved.
//
// User-includable header for exception handling.
//
#pragma once



//
// corecrt_terminate.h
//
//      Copyright (c) Microsoft Corporation. All rights reserved.
//
// The terminate handler
//
#pragma once





__pragma(pack(push, 8)) extern "C" {

// terminate_handler is the standard name; terminate_function is defined for
// source compatibility.
typedef void (__cdecl* terminate_handler )();
typedef void (__cdecl* terminate_function)();








    __declspec(dllimport) __declspec(noreturn) void __cdecl abort();
    __declspec(dllimport) __declspec(noreturn) void __cdecl terminate() throw();

    

        __declspec(dllimport) terminate_handler __cdecl set_terminate(
              terminate_handler _NewTerminateHandler
            ) throw();

        __declspec(dllimport) terminate_handler __cdecl _get_terminate();

    



} __pragma(pack(pop))






__pragma(pack(push, 8)) extern "C" {

// unexpected_handler is the standard name; unexpected_function is defined for
// source compatibility.
typedef void (__cdecl* unexpected_handler )();
typedef void (__cdecl* unexpected_function)();






struct _EXCEPTION_POINTERS;



     __declspec(noreturn) void __cdecl unexpected() noexcept(false);

    

         unexpected_handler __cdecl set_unexpected(
              unexpected_handler _NewUnexpectedHandler
            ) noexcept;

         unexpected_handler __cdecl _get_unexpected() noexcept;

        typedef void (__cdecl* _se_translator_function)(unsigned int, struct _EXCEPTION_POINTERS*);

         _se_translator_function __cdecl _set_se_translator(
              _se_translator_function _NewSETranslator
            );

    

    class type_info;

     int __cdecl _is_exception_typeof(
          type_info const&     _Type,
          _EXCEPTION_POINTERS* _ExceptionPtr
        );

     bool __cdecl __uncaught_exception();
     int  __cdecl __uncaught_exceptions();



} __pragma(pack(pop))








#pragma pack(push, 8)


__pragma(pack(push, 8)) extern "C" {

struct __std_exception_data
{
    char const* _What;
    bool        _DoFree;
};

 void __cdecl __std_exception_copy(
       __std_exception_data const* _From,
      __std_exception_data*       _To
    );

 void __cdecl __std_exception_destroy(
      __std_exception_data* _Data
    );

} __pragma(pack(pop))



namespace std {

#pragma warning(push)
#pragma warning(disable: 4577) 
class exception
{
public:

    exception() noexcept
        : _Data()
    {
    }

    explicit exception(char const* const _Message) noexcept
        : _Data()
    {
        __std_exception_data _InitData = { _Message, true };
        __std_exception_copy(&_InitData, &_Data);
    }

    exception(char const* const _Message, int) noexcept
        : _Data()
    {
        _Data._What = _Message;
    }

    exception(exception const& _Other) noexcept
        : _Data()
    {
        __std_exception_copy(&_Other._Data, &_Data);
    }

    exception& operator=(exception const& _Other) noexcept
    {
        if (this == &_Other)
        {
            return *this;
        }

        __std_exception_destroy(&_Data);
        __std_exception_copy(&_Other._Data, &_Data);
        return *this;
    }

    virtual ~exception() noexcept
    {
        __std_exception_destroy(&_Data);
    }

    virtual char const* what() const
    {
        return _Data._What ? _Data._What : "Unknown exception";
    }

private:

    __std_exception_data _Data;
};

class bad_exception
    : public exception
{
public:

    bad_exception() noexcept
        : exception("bad exception", 1)
    {
    }
};

class bad_alloc
    : public exception
{
public:

    bad_alloc() noexcept
        : exception("bad allocation", 1)
    {
    }

private:

    friend class bad_array_new_length;

    bad_alloc(char const* const _Message) noexcept
        : exception(_Message, 1)
    {
    }
};

class bad_array_new_length
    : public bad_alloc
{
public:

    bad_array_new_length() noexcept
        : bad_alloc("bad array new length")
    {
    }
};

#pragma warning(pop)

} // namespace std


#pragma pack(pop)

/*
 * Copyright (c) 1992-2012 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
  V6.00:0009 */


namespace std {

using ::terminate;


using ::set_terminate;
using ::terminate_handler;

 inline terminate_handler __cdecl get_terminate() noexcept
	{	// get current terminate handler
	return (_get_terminate());
	}



using ::unexpected;

 
using ::set_unexpected;
using ::unexpected_handler;

 inline unexpected_handler __cdecl get_unexpected() noexcept
	{	// get current unexpected handler
	return (_get_unexpected());
	}
 


}

 





































































































































































 void __cdecl __ExceptionPtrCreate(  void*);
 void __cdecl __ExceptionPtrDestroy(  void*);
 void __cdecl __ExceptionPtrCopy(  void*,   const void*);
 void __cdecl __ExceptionPtrAssign(  void*,   const void*);
 bool __cdecl __ExceptionPtrCompare(  const void*,   const void*);
 bool __cdecl __ExceptionPtrToBool(  const void*);
 void __cdecl __ExceptionPtrSwap(  void*,   void*);
 void __cdecl __ExceptionPtrCurrentException(  void*);
[[noreturn]]  void __cdecl __ExceptionPtrRethrow(  const void*);
 void __cdecl __ExceptionPtrCopyException(
	  void*,   const void*,   const void*);

namespace std {

class exception_ptr
	{
public:
	exception_ptr() noexcept
		{
		__ExceptionPtrCreate(this);
		}

	exception_ptr(nullptr_t) noexcept
		{
		__ExceptionPtrCreate(this);
		}

	~exception_ptr() noexcept
		{
		__ExceptionPtrDestroy(this);
		}

	exception_ptr(const exception_ptr& _Rhs) noexcept
		{
		__ExceptionPtrCopy(this, &_Rhs);
		}

	exception_ptr& operator=(const exception_ptr& _Rhs) noexcept
		{
		__ExceptionPtrAssign(this, &_Rhs);
		return *this;
		}

	exception_ptr& operator=(nullptr_t) noexcept
		{
		exception_ptr _Ptr;
		__ExceptionPtrAssign(this, &_Ptr);
		return *this;
		}

	explicit operator bool() const noexcept
		{
		return __ExceptionPtrToBool(this);
		}

	[[noreturn]] void _RethrowException() const
		{
		__ExceptionPtrRethrow(this);
		}

	static exception_ptr _Current_exception() noexcept
		{
		exception_ptr _Retval;
		__ExceptionPtrCurrentException(&_Retval);
		return _Retval;
		}

	static exception_ptr _Copy_exception(  void* _Except,   const void* _Ptr)
		{
		exception_ptr _Retval;
		if (!_Ptr)
			{
			// unsupported exceptions
			return _Retval;
			}
		__ExceptionPtrCopyException(&_Retval, _Except, _Ptr);
		return _Retval;
		}

private:




	void* _Data1;
	void* _Data2;



	};

inline void swap(exception_ptr& _Lhs, exception_ptr& _Rhs) noexcept
	{
	__ExceptionPtrSwap(&_Lhs, &_Rhs);
	}

 inline bool operator==(const exception_ptr& _Lhs, const exception_ptr& _Rhs) noexcept
	{
	return __ExceptionPtrCompare(&_Lhs, &_Rhs);
	}

 inline bool operator==(nullptr_t, const exception_ptr& _Rhs) noexcept
	{
	return !_Rhs;
	}

 inline bool operator==(const exception_ptr& _Lhs, nullptr_t) noexcept
	{
	return !_Lhs;
	}

 inline bool operator!=(const exception_ptr& _Lhs, const exception_ptr& _Rhs) noexcept
	{
	return !(_Lhs == _Rhs);
	}

 inline bool operator!=(nullptr_t _Lhs, const exception_ptr& _Rhs) noexcept
	{
	return !(_Lhs == _Rhs);
	}

 inline bool operator!=(const exception_ptr& _Lhs, nullptr_t _Rhs) noexcept
	{
	return !(_Lhs == _Rhs);
	}

 inline exception_ptr current_exception() noexcept
	{
	return exception_ptr::_Current_exception();
	}

[[noreturn]] inline void rethrow_exception(  exception_ptr _Ptr)
	{
	_Ptr._RethrowException();
	}

template<class _Ex> void *__GetExceptionInfo(_Ex);

template<class _Ex>  exception_ptr make_exception_ptr(_Ex _Except) noexcept
	{
	return exception_ptr::_Copy_exception(::std:: addressof(_Except), __GetExceptionInfo(_Except));
	}

	// CLASS nested_exception
class nested_exception
	{	// wrap an exception_ptr
public:
	nested_exception() noexcept
		: _Exc(::std:: current_exception())
		{	// default construct
		}

	nested_exception(const nested_exception&) noexcept = default;
	nested_exception& operator=(const nested_exception&) noexcept = default;
	virtual ~nested_exception() noexcept
		{
		}

	[[noreturn]] void rethrow_nested() const
		{	// throw wrapped exception_ptr
		if (_Exc)
			::std:: rethrow_exception(_Exc);
		else
			::std:: terminate();
		}

	 exception_ptr nested_ptr() const noexcept
		{	// return wrapped exception_ptr
		return (_Exc);
		}

private:
	exception_ptr _Exc;
	};

	// FUNCTION TEMPLATE throw_with_nested
template<class _Ty,
	class _Uty>
	struct _With_nested
		: _Uty, nested_exception
	{	// glue user exception to nested_exception
	explicit _With_nested(_Ty&& _Arg)
		: _Uty(::std:: forward<_Ty>(_Arg)), nested_exception()
		{	// store user exception and current_exception()
		}
	};

template<class _Ty>
	[[noreturn]] inline void _Throw_with_nested(_Ty&& _Arg, true_type)
	{	// throw user exception glued to nested_exception
	using _Uty = decay_t<_Ty>;
	using _Glued = _With_nested<_Ty, _Uty>;

	throw _Glued(::std:: forward<_Ty>(_Arg));
	}

template<class _Ty>
	[[noreturn]] inline void _Throw_with_nested(_Ty&& _Arg, false_type)
	{	// throw user exception by itself
	throw ::std:: forward<_Ty>(_Arg);
	}

template<class _Ty>
	[[noreturn]] inline void throw_with_nested(_Ty&& _Arg)
	{	// throw user exception, glued to nested_exception if possible
	typedef decay_t<_Ty> _Uty;

	bool_constant<
		is_class_v<_Uty>
		&& !is_base_of_v<nested_exception, _Uty>
		&& !is_final_v<_Uty>> _Tag;

	_Throw_with_nested(::std:: forward<_Ty>(_Arg), _Tag);
	}


	// FUNCTION TEMPLATE rethrow_if_nested
template<class _Ty> inline
	void _Rethrow_if_nested(const _Ty *_Ptr, true_type)
	{	// use dynamic_cast
	const auto _Nested = dynamic_cast<const nested_exception *>(_Ptr);

	if (_Nested)
		_Nested->rethrow_nested();
	}

template<class _Ty> inline
	void _Rethrow_if_nested(const _Ty *, false_type)
	{	// can't use dynamic_cast
	}

template<class _Ty> inline
	void rethrow_if_nested(const _Ty& _Arg)
	{	// detect nested_exception inheritance
	bool_constant<is_polymorphic_v<_Ty> && (!is_base_of_v<nested_exception, _Ty>
		|| is_convertible_v<_Ty *, nested_exception *>)> _Tag;

	_Rethrow_if_nested(::std:: addressof(_Arg), _Tag);
	}





}

 
 
 #pragma warning(pop)
 #pragma pack(pop)




/*
 * Copyright (c) by P.J. Plauger. All rights reserved.
 * Consult your license regarding permissions and restrictions.
V6.50:0009 */


// xstring internal header (from <string>)
#pragma once




// xmemory0 internal header
#pragma once




// cstdint standard header
#pragma once






//
// stdint.h
//
//      Copyright (c) Microsoft Corporation. All rights reserved.
//
// The C Standard Library <stdint.h> header.
//
#pragma once








typedef signed char        int8_t;
typedef short              int16_t;
typedef int                int32_t;
typedef long long          int64_t;
typedef unsigned char      uint8_t;
typedef unsigned short     uint16_t;
typedef unsigned int       uint32_t;
typedef unsigned long long uint64_t;

typedef signed char        int_least8_t;
typedef short              int_least16_t;
typedef int                int_least32_t;
typedef long long          int_least64_t;
typedef unsigned char      uint_least8_t;
typedef unsigned short     uint_least16_t;
typedef unsigned int       uint_least32_t;
typedef unsigned long long uint_least64_t;

typedef signed char        int_fast8_t;
typedef int                int_fast16_t;
typedef int                int_fast32_t;
typedef long long          int_fast64_t;
typedef unsigned char      uint_fast8_t;
typedef unsigned int       uint_fast16_t;
typedef unsigned int       uint_fast32_t;
typedef unsigned long long uint_fast64_t;

typedef long long          intmax_t;
typedef unsigned long long uintmax_t;

// These macros must exactly match those in the Windows SDK's intsafe.h.








































    
    
    











































/*
 * Copyright (c) 1992-2012 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
V6.00:0009 */


#pragma pack(push,8)
#pragma warning(push,3)
#pragma warning(disable: 4455 4494  4619 4643 4702 4984 4988 )




namespace std {
using :: int8_t; using :: int16_t;
using :: int32_t; using :: int64_t;
using :: uint8_t; using :: uint16_t;
using :: uint32_t; using :: uint64_t;

using :: int_least8_t; using :: int_least16_t;
using :: int_least32_t; using :: int_least64_t;
using :: uint_least8_t; using :: uint_least16_t;
using :: uint_least32_t; using :: uint_least64_t;

using :: int_fast8_t; using :: int_fast16_t;
using :: int_fast32_t; using :: int_fast64_t;
using :: uint_fast8_t; using :: uint_fast16_t;
using :: uint_fast32_t; using :: uint_fast64_t;

using :: intmax_t; using :: intptr_t;
using :: uintmax_t; using :: uintptr_t;


namespace [[deprecated("warning STL4002: " "The non-Standard std::tr1 namespace and TR1-only machinery are deprecated and will be REMOVED. You can " "define _SILENCE_TR1_NAMESPACE_DEPRECATION_WARNING to acknowledge that you have received this warning.")]] tr1 {
using :: int8_t; using :: int16_t;
using :: int32_t; using :: int64_t;
using :: uint8_t; using :: uint16_t;
using :: uint32_t; using :: uint64_t;

using :: int_least8_t; using :: int_least16_t;
using :: int_least32_t; using :: int_least64_t;
using :: uint_least8_t; using :: uint_least16_t;
using :: uint_least32_t; using :: uint_least64_t;

using :: int_fast8_t; using :: int_fast16_t;
using :: int_fast32_t; using :: int_fast64_t;
using :: uint_fast8_t; using :: uint_fast16_t;
using :: uint_fast32_t; using :: uint_fast64_t;

using :: intmax_t; using :: intptr_t;
using :: uintmax_t; using :: uintptr_t;
}

}



#pragma warning(pop)
#pragma pack(pop)




/*
 * Copyright (c) by P.J. Plauger. All rights reserved.
 * Consult your license regarding permissions and restrictions.
V6.50:0009 */



// limits standard header
#pragma once




/* ymath.h internal header */
#pragma once




 #pragma pack(push,8)
 #pragma warning(push,3)
 #pragma warning(disable: 4455 4494  4619 4643 4702 4984 4988 )
 
 
 

 
 
extern "C" {
 
 

		/* MACROS FOR _Dtest RETURN (0 => ZERO) */





		/* MACROS FOR _Feraise ARGUMENT */






void __cdecl _Feraise(int);

typedef union
	{	/* pun float types as integer array */
	unsigned short _Word[8];
	float _Float;
	double _Double;
	long double _Long_double;
	} _Dconst;

		/* double DECLARATIONS */
 double __cdecl _Cosh(double, double);
 short __cdecl _Dtest(double *);
 double __cdecl _Sinh(double, double);

 short __cdecl _Exp(double *, double, short);
extern __declspec(dllimport) /* const */ _Dconst _Denorm, _Hugeval, _Inf,
	_Nan, _Snan;

		/* float DECLARATIONS */
 float __cdecl _FCosh(float, float);
 short __cdecl _FDtest(float *);
 float __cdecl _FSinh(float, float);

 short __cdecl _FExp(float *, float, short);
extern __declspec(dllimport) /* const */ _Dconst _FDenorm, _FInf, _FNan, _FSnan;

		/* long double DECLARATIONS */
 long double __cdecl _LCosh(long double, long double);
 short __cdecl _LDtest(long double *);
 long double __cdecl _LSinh(long double, long double);

 short __cdecl _LExp(long double *, long double, short);
extern __declspec(dllimport) /* const */ _Dconst _LDenorm, _LInf, _LNan, _LSnan;

 
 
}
 
 

 
 
 #pragma warning(pop)
 #pragma pack(pop)



/*
 * Copyright (c) by P.J. Plauger. All rights reserved.
 * Consult your license regarding permissions and restrictions.
V6.50:0009 */


// cfloat standard header
#pragma once





//
// float.h
//
//      Copyright (c) Microsoft Corporation. All rights reserved.
//
// Implementation-defined values commonly used by sophisticated numerical
// (floating point) programs.
//
#pragma once





__pragma(pack(push, 8)) extern "C" {




    


        


            
        
    



// Define the floating point precision used.
//
// For x86, results are in double precision (unless /arch:sse2 is used, in which
// case results are in source precision.
//
// For x64 and ARM, results are in source precision.
//
// If the compiler is invoked with /fp:fast, the compiler is allowed to use the
// fastest precision and even mix within a single function, so precision is
// indeterminable.
//
// Note that manipulating the floating point behavior using the float_control/
// fenv_access/fp_contract #pragmas may alter the actual floating point evaluation
// method, which may in turn invalidate the value of FLT_EVAL_METHOD.



    






        
    




//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// Constants
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+















































//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// Flags
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+







// New Control Bit that specifies the ambiguity in control word.



// Abstract User Control Word Mask and bit definitions














// i386 specific definitions









// RISC specific definitions








// Invalid subconditions (_SW_INVALID also set)







// Floating point error signals and return codes














// On x86 with arch:SSE2, the OS returns these exceptions


















// Initial Control Word value






    





//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// State Manipulation
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
// Note that reading or writing the floating point control or status words is
// not supported in managed code.

__declspec(dllimport) unsigned int __cdecl _clearfp(void);

#pragma warning(push)
#pragma warning(disable: 4141)

 __declspec(deprecated("This function or variable may be unsafe. Consider using " "_controlfp_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__declspec(dllimport) unsigned int __cdecl _controlfp(
      unsigned int _NewValue,
      unsigned int _Mask
    );

#pragma warning(pop)


__declspec(dllimport) void __cdecl _set_controlfp(
      unsigned int _NewValue,
      unsigned int _Mask
    );


__declspec(dllimport) errno_t __cdecl _controlfp_s(
      unsigned int* _CurrentState,
           unsigned int  _NewValue,
           unsigned int  _Mask
    );


__declspec(dllimport) unsigned int __cdecl _statusfp(void);


__declspec(dllimport) void __cdecl _fpreset(void);















__declspec(dllimport) unsigned int __cdecl _control87(
      unsigned int _NewValue,
      unsigned int _Mask
    );











// Global variable holding floating point error code
 
__declspec(dllimport) int* __cdecl __fpecode(void);



 
__declspec(dllimport) int __cdecl __fpe_flt_rounds(void);







//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// IEEE Recommended Functions
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  __declspec(dllimport) double __cdecl _copysign(  double _Number,   double _Sign);
  __declspec(dllimport) double __cdecl _chgsign(  double _X);
  __declspec(dllimport) double __cdecl _scalb(  double _X,   long _Y);
  __declspec(dllimport) double __cdecl _logb(  double _X);
  __declspec(dllimport) double __cdecl _nextafter(  double _X,   double _Y);
  __declspec(dllimport) int    __cdecl _finite(  double _X);
  __declspec(dllimport) int    __cdecl _isnan(  double _X);
  __declspec(dllimport) int    __cdecl _fpclass(  double _X);


      __declspec(dllimport) float __cdecl _scalbf(  float _X,   long _Y);




//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// Nonstandard Names for Compatibility
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+


    
    
    

    
    __declspec(dllimport) void __cdecl fpreset(void);

    
    

    
    

    // For backwards compatibility with the old spelling
    
    

    
    
    
    
    
    
    

    
    
    

    
    
    
    
    

    
    
    
    

    

    
    
    
    
    
    

    
    
    
    

    
    
    
    
    
    

    
    
    
    

    





} __pragma(pack(pop))




/*
 * Copyright (c) by P.J. Plauger. All rights reserved.
 * Consult your license regarding permissions and restrictions.
V6.50:0009 */




// cwchar standard header
#pragma once






//
// wchar.h
//
//      Copyright (c) Microsoft Corporation. All rights reserved.
//
// All of the types, macros, and function declarations for all wide-character
// related functionality.  Most of the functionality is in the #included
// <corecrt_wxxxx.h> headers, which are also #included by other public headers.
//
#pragma once






//
// corecrt_wconio.h
//
//      Copyright (c) Microsoft Corporation. All rights reserved.
//
// This file declares the wide character (wchar_t) console I/O functionality,
// shared by both <conio.h> and <wchar.h>
//
#pragma once




__pragma(pack(push, 8)) extern "C" {









    
     
    __declspec(dllimport) errno_t __cdecl _cgetws_s(
          wchar_t* _Buffer,
                                               size_t   _BufferCount,
                                              size_t*  _SizeRead
        );

    extern "C++" { template <size_t _Size> inline   errno_t __cdecl _cgetws_s(  wchar_t (&_Buffer)[_Size],   size_t* _SizeRead) throw() { return _cgetws_s(_Buffer, _Size, _SizeRead); } }

    
    __declspec(dllimport) int __cdecl _cputws(
          wchar_t const* _Buffer
        );

          __declspec(dllimport) wint_t __cdecl _getwch  (void);
          __declspec(dllimport) wint_t __cdecl _getwche (void);
     __declspec(dllimport) wint_t __cdecl _putwch  (  wchar_t _Character);
     __declspec(dllimport) wint_t __cdecl _ungetwch(  wint_t  _Character);

          __declspec(dllimport) wint_t __cdecl _getwch_nolock  (void);
          __declspec(dllimport) wint_t __cdecl _getwche_nolock (void);
     __declspec(dllimport) wint_t __cdecl _putwch_nolock  (  wchar_t _Character);
     __declspec(dllimport) wint_t __cdecl _ungetwch_nolock(  wint_t  _Character);



    //-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    //
    // Wide Character Formatted Output Functions (Console)
    //
    //-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    
    __declspec(dllimport) int __cdecl __conio_common_vcwprintf(
                                             unsigned __int64 _Options,
            wchar_t const*   _Format,
                                         _locale_t        _Locale,
                                                va_list          _ArgList
        );

    
    __declspec(dllimport) int __cdecl __conio_common_vcwprintf_s(
                                             unsigned __int64 _Options,
            wchar_t const*   _Format,
                                         _locale_t        _Locale,
                                                va_list          _ArgList
        );

    
    __declspec(dllimport) int __cdecl __conio_common_vcwprintf_p(
                                             unsigned __int64 _Options,
            wchar_t const*   _Format,
                                         _locale_t        _Locale,
                                                va_list          _ArgList
        );

    
    __inline int __cdecl _vcwprintf_l(
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
                                                va_list              _ArgList
        )



    {
        return __conio_common_vcwprintf((*__local_stdio_printf_options()), _Format, _Locale, _ArgList);
    }


    
    __inline int __cdecl _vcwprintf(
            wchar_t const* const _Format,
                                      va_list              _ArgList
        )



    {
        return _vcwprintf_l(_Format, 0, _ArgList);
    }


    
    __inline int __cdecl _vcwprintf_s_l(
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
                                                va_list              _ArgList
        )



    {
        return __conio_common_vcwprintf_s((*__local_stdio_printf_options()), _Format, _Locale, _ArgList);
    }


    
    __inline int __cdecl _vcwprintf_s(
            wchar_t const* const _Format,
                                      va_list              _ArgList
        )



    {
        return _vcwprintf_s_l(_Format, 0, _ArgList);
    }


    
    __inline int __cdecl _vcwprintf_p_l(
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
                                                va_list              _ArgList
        )



    {
        return __conio_common_vcwprintf_p((*__local_stdio_printf_options()), _Format, _Locale, _ArgList);
    }


    
    __inline int __cdecl _vcwprintf_p(
            const wchar_t* const _Format,
                                      va_list              _ArgList
        )



    {
        return _vcwprintf_p_l(_Format, 0, _ArgList);
    }


    
    __inline int __cdecl _cwprintf_l(
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
        ...)



    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vcwprintf_l(_Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }


    
    __inline int __cdecl _cwprintf(
            wchar_t const* const _Format,
        ...)



    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vcwprintf_l(_Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }


    
    __inline int __cdecl _cwprintf_s_l(
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
        ...)



    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vcwprintf_s_l(_Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }


    
    __inline int __cdecl _cwprintf_s(
            wchar_t const* const _Format,
        ...)



    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vcwprintf_s_l(_Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }


    
    __inline int __cdecl _cwprintf_p_l(
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
        ...)



    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vcwprintf_p_l(_Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }


    
    __inline int __cdecl _cwprintf_p(
            wchar_t const* const _Format,
        ...)



    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vcwprintf_p_l(_Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }




    //-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    //
    // Wide Character Formatted Input Functions (Console)
    //
    //-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    
    __declspec(dllimport) int __cdecl __conio_common_vcwscanf(
                                            unsigned __int64 _Options,
            wchar_t const*   _Format,
                                        _locale_t        _Locale,
                                               va_list          _ArgList
        );

     __declspec(deprecated("This function or variable may be unsafe. Consider using " "_vcwscanf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl _vcwscanf_l(
            wchar_t const* const _Format,
                                        _locale_t      const _Locale,
                                               va_list              _ArgList
        )



    {
        return __conio_common_vcwscanf(
            (*__local_stdio_scanf_options ()),
            _Format, _Locale, _ArgList);
    }


     __declspec(deprecated("This function or variable may be unsafe. Consider using " "_vcwscanf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl _vcwscanf(
            wchar_t const* const _Format,
                                               va_list              _ArgList
        )



    {
        #pragma warning(push)
        #pragma warning(disable: 4996) 
        return _vcwscanf_l(_Format, 0, _ArgList);
        #pragma warning(pop)
    }


    
    __inline int __cdecl _vcwscanf_s_l(
            wchar_t const* const _Format,
                                        _locale_t      const _Locale,
                                               va_list              _ArgList
        )



    {
        return __conio_common_vcwscanf(
            (*__local_stdio_scanf_options ()) | (1ULL << 0),
            _Format, _Locale, _ArgList);
    }


    
    __inline int __cdecl _vcwscanf_s(
            wchar_t const* const _Format,
                                               va_list              _ArgList
        )



    {
        return _vcwscanf_s_l(_Format, 0, _ArgList);
    }


     __declspec(deprecated("This function or variable may be unsafe. Consider using " "_cwscanf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl _cwscanf_l(
            wchar_t const* const _Format,
                                        _locale_t      const _Locale,
        ...)



    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));

        #pragma warning(push)
        #pragma warning(disable: 4996) 
        _Result = _vcwscanf_l(_Format, _Locale, _ArgList);
        #pragma warning(pop)

        ((void)(_ArgList = (va_list)0));
        return _Result;
    }


     __declspec(deprecated("This function or variable may be unsafe. Consider using " "_cwscanf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl _cwscanf(
            wchar_t const* const _Format,
        ...)



    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));

        #pragma warning(push)
        #pragma warning(disable: 4996) 
        _Result = _vcwscanf_l(_Format, 0, _ArgList);
        #pragma warning(pop)

        ((void)(_ArgList = (va_list)0));
        return _Result;
    }


    
    __inline int __cdecl _cwscanf_s_l(
            wchar_t const* const _Format,
                                        _locale_t      const _Locale,
        ...)



    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vcwscanf_s_l(_Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }


    
    __inline int __cdecl _cwscanf_s(
            wchar_t const* const _Format,
        ...)



    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vcwscanf_s_l(_Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }






} __pragma(pack(pop))


//
// corecrt_wctype.h
//
//      Copyright (c) Microsoft Corporation. All rights reserved.
//
// This file declares the wide character (wchar_t) classification functionality,
// shared by <ctype.h>, <wchar.h>, and <wctype.h>.
//
#pragma once



__pragma(pack(push, 8)) extern "C" {







// This declaration allows the user access to the ctype look-up
// array _ctype defined in ctype.obj by simply including ctype.h


    


        
    

    __declspec(dllimport) const unsigned short* __cdecl __pctype_func(void);
    __declspec(dllimport) const wctype_t*       __cdecl __pwctype_func(void);

    



        
        
    


// Bit masks for the possible character types














//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// Wide Character Classification and Conversion Functions
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  __declspec(dllimport) int __cdecl iswalnum  (  wint_t _C);
  __declspec(dllimport) int __cdecl iswalpha  (  wint_t _C);
  __declspec(dllimport) int __cdecl iswascii  (  wint_t _C);
  __declspec(dllimport) int __cdecl iswblank  (  wint_t _C);
  __declspec(dllimport) int __cdecl iswcntrl  (  wint_t _C);


  __declspec(dllimport) int __cdecl iswdigit  (  wint_t _C);

  __declspec(dllimport) int __cdecl iswgraph  (  wint_t _C);
  __declspec(dllimport) int __cdecl iswlower  (  wint_t _C);
  __declspec(dllimport) int __cdecl iswprint  (  wint_t _C);
  __declspec(dllimport) int __cdecl iswpunct  (  wint_t _C);
  __declspec(dllimport) int __cdecl iswspace  (  wint_t _C);
  __declspec(dllimport) int __cdecl iswupper  (  wint_t _C);
  __declspec(dllimport) int __cdecl iswxdigit (  wint_t _C);
  __declspec(dllimport) int __cdecl __iswcsymf(  wint_t _C);
  __declspec(dllimport) int __cdecl __iswcsym (  wint_t _C);

  __declspec(dllimport) int __cdecl _iswalnum_l (  wint_t _C,   _locale_t _Locale);
  __declspec(dllimport) int __cdecl _iswalpha_l (  wint_t _C,   _locale_t _Locale);
  __declspec(dllimport) int __cdecl _iswblank_l (  wint_t _C,   _locale_t _Locale);
  __declspec(dllimport) int __cdecl _iswcntrl_l (  wint_t _C,   _locale_t _Locale);
  __declspec(dllimport) int __cdecl _iswdigit_l (  wint_t _C,   _locale_t _Locale);
  __declspec(dllimport) int __cdecl _iswgraph_l (  wint_t _C,   _locale_t _Locale);
  __declspec(dllimport) int __cdecl _iswlower_l (  wint_t _C,   _locale_t _Locale);
  __declspec(dllimport) int __cdecl _iswprint_l (  wint_t _C,   _locale_t _Locale);
  __declspec(dllimport) int __cdecl _iswpunct_l (  wint_t _C,   _locale_t _Locale);
  __declspec(dllimport) int __cdecl _iswspace_l (  wint_t _C,   _locale_t _Locale);
  __declspec(dllimport) int __cdecl _iswupper_l (  wint_t _C,   _locale_t _Locale);
  __declspec(dllimport) int __cdecl _iswxdigit_l(  wint_t _C,   _locale_t _Locale);
  __declspec(dllimport) int __cdecl _iswcsymf_l (  wint_t _C,   _locale_t _Locale);
  __declspec(dllimport) int __cdecl _iswcsym_l  (  wint_t _C,   _locale_t _Locale);


  __declspec(dllimport) wint_t __cdecl towupper(  wint_t _C);
  __declspec(dllimport) wint_t __cdecl towlower(  wint_t _C);
  __declspec(dllimport) int    __cdecl iswctype(  wint_t _C,   wctype_t _Type);

  __declspec(dllimport) wint_t __cdecl _towupper_l(  wint_t _C,   _locale_t _Locale);
  __declspec(dllimport) wint_t __cdecl _towlower_l(  wint_t _C,   _locale_t _Locale);
  __declspec(dllimport) int    __cdecl _iswctype_l(  wint_t _C,   wctype_t _Type,   _locale_t _Locale);



      __declspec(dllimport) int __cdecl isleadbyte(  int _C);
      __declspec(dllimport) int __cdecl _isleadbyte_l(  int _C,   _locale_t _Locale);

    __declspec(deprecated("This function or variable has been superceded by newer library " "or operating system functionality. Consider using " "iswctype" " " "instead. See online help for details.")) __declspec(dllimport) int __cdecl is_wctype(  wint_t _C,   wctype_t _Type);




//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// Macro and Inline Definitions
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+














































































} __pragma(pack(pop))


//
// corecrt_wdirect.h
//
//      Copyright (c) Microsoft Corporation. All rights reserved.
//
// This file declares the wide character (wchar_t) directory functionality, shared
// by <direct.h> and <wchar.h>.
//
#pragma once



__pragma(pack(push, 8)) extern "C" {






 
   
__declspec(dllimport) __declspec(allocator) wchar_t* __cdecl _wgetcwd(
      wchar_t* _DstBuf,
                                  int      _SizeInWords
    );

 
   
__declspec(dllimport) __declspec(allocator) wchar_t* __cdecl _wgetdcwd(
                                  int      _Drive,
      wchar_t* _DstBuf,
                                  int      _SizeInWords
    );






 
__declspec(dllimport) int __cdecl _wchdir(
      wchar_t const* _Path
    );

 
__declspec(dllimport) int __cdecl _wmkdir(
      wchar_t const* _Path
    );

 
__declspec(dllimport) int __cdecl _wrmdir(
      wchar_t const* _Path
    );



} __pragma(pack(pop))


//
// corecrt_wio.h
//
//      Copyright (c) Microsoft Corporation. All rights reserved.
//
// This file declares the wide character (wchar_t) I/O functionality, shared by
// <io.h> and <wchar.h>.
//
#pragma once



//
// corecrt_share.h
//
//      Copyright (c) Microsoft Corporation. All rights reserved.
//
// Defines the file sharing modes for the sopen() family of functions.  These
// declarations are split out to support the Windows build.
//
#pragma once












    
    
    
    



__pragma(pack(push, 8)) extern "C" {


#pragma warning(push)
#pragma warning(disable:4820) 


//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// Types
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+




    
    


typedef unsigned long _fsize_t;

struct _wfinddata32_t
{
    unsigned   attrib;
    __time32_t time_create;    // -1 for FAT file systems
    __time32_t time_access;    // -1 for FAT file systems
    __time32_t time_write;
    _fsize_t   size;
    wchar_t    name[260];
};

struct _wfinddata32i64_t
{
    unsigned   attrib;
    __time32_t time_create;    // -1 for FAT file systems
    __time32_t time_access;    // -1 for FAT file systems
    __time32_t time_write;
    __int64    size;
    wchar_t    name[260];
};

struct _wfinddata64i32_t
{
    unsigned   attrib;
    __time64_t time_create;    // -1 for FAT file systems
    __time64_t time_access;    // -1 for FAT file systems
    __time64_t time_write;
    _fsize_t   size;
    wchar_t    name[260];
};

struct _wfinddata64_t
{
    unsigned   attrib;
    __time64_t time_create;    // -1 for FAT file systems
    __time64_t time_access;    // -1 for FAT file systems
    __time64_t time_write;
    __int64    size;
    wchar_t    name[260];
};



//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// Functions
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+






    
    
    
    


 
__declspec(dllimport) int __cdecl _waccess(
      wchar_t const* _FileName,
        int            _AccessMode
    );


__declspec(dllimport) errno_t __cdecl _waccess_s(
      wchar_t const* _FileName,
        int            _AccessMode
    );

 
__declspec(dllimport) int __cdecl _wchmod(
      wchar_t const* _FileName,
        int            _Mode
    );

  __declspec(deprecated("This function or variable may be unsafe. Consider using " "_wsopen_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__declspec(dllimport) int __cdecl _wcreat(
      wchar_t const* _FileName,
        int            _PermissionMode
    );

 
 
__declspec(dllimport) intptr_t __cdecl _wfindfirst32(
      wchar_t const*         _FileName,
       struct _wfinddata32_t* _FindData
    );

 
 
__declspec(dllimport) int __cdecl _wfindnext32(
       intptr_t               _FindHandle,
      struct _wfinddata32_t* _FindData
    );

__declspec(dllimport) int __cdecl _wunlink(
      wchar_t const* _FileName
    );

 
__declspec(dllimport) int __cdecl _wrename(
      wchar_t const* _OldFileName,
      wchar_t const* _NewFileName
    );

__declspec(dllimport) errno_t __cdecl _wmktemp_s(
      wchar_t* _TemplateName,
                                 size_t   _SizeInWords
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _wmktemp_s(wchar_t (&_TemplateName)[_Size]) throw() { return _wmktemp_s(_TemplateName, _Size); } }

 
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_wmktemp_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) wchar_t* __cdecl _wmktemp( wchar_t *_TemplateName);

 
 
__declspec(dllimport) intptr_t __cdecl _wfindfirst32i64(
      wchar_t const*            _FileName,
       struct _wfinddata32i64_t* _FindData
    );

 
 
__declspec(dllimport) intptr_t __cdecl _wfindfirst64i32(
      wchar_t const*            _FileName,
       struct _wfinddata64i32_t* _FindData
    );

 
 
__declspec(dllimport) intptr_t __cdecl _wfindfirst64(
      wchar_t const*         _FileName,
       struct _wfinddata64_t* _FindData
    );

 
 
__declspec(dllimport) int __cdecl _wfindnext32i64(
       intptr_t                  _FindHandle,
      struct _wfinddata32i64_t* _FindData
    );

 
 
__declspec(dllimport) int __cdecl _wfindnext64i32(
       intptr_t                  _FindHandle,
      struct _wfinddata64i32_t* _FindData
    );

 
 
__declspec(dllimport) int __cdecl _wfindnext64(
       intptr_t               _FindHandle,
      struct _wfinddata64_t* _FindData
    );


__declspec(dllimport) errno_t __cdecl _wsopen_s(
       int*           _FileHandle,
      wchar_t const* _FileName,
        int            _OpenFlag,
        int            _ShareFlag,
        int            _PermissionFlag
    );

__declspec(dllimport) errno_t __cdecl _wsopen_dispatch(
      wchar_t const* _FileName,
        int            _OFlag,
        int            _ShFlag,
        int            _PMode,
       int*           _PFileHandle,
        int            _BSecure
    );





    // These functions do not validate pmode; use _wsopen_s instead.
    extern "C++"   __declspec(deprecated("This function or variable may be unsafe. Consider using " "_wsopen_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    inline int __cdecl _wopen(
          wchar_t const* _FileName,
            int            _OFlag,
            int            _PMode = 0
        )
    {
        int _FileHandle;
        // Last parameter passed as 0 because we don't want to validate pmode from _open
        errno_t const _Result = _wsopen_dispatch(_FileName, _OFlag, 0x40, _PMode, &_FileHandle, 0);
        return _Result ? -1 : _FileHandle;
    }

    extern "C++"   __declspec(deprecated("This function or variable may be unsafe. Consider using " "_wsopen_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    inline int __cdecl _wsopen(
          wchar_t const* _FileName,
            int            _OFlag,
            int            _ShFlag,
            int            _PMode = 0
        )
    {
        int _FileHandle;
        // Last parameter passed as 0 because we don't want to validate pmode from _sopen
        errno_t const _Result = _wsopen_dispatch(_FileName, _OFlag, _ShFlag, _PMode, &_FileHandle, 0);
        return _Result ? -1 : _FileHandle;
    }




















#pragma warning(pop)


} __pragma(pack(pop))


//
// corecrt_wprocess.h
//
//      Copyright (c) Microsoft Corporation. All rights reserved.
//
// This file declares the wide character (wchar_t) process functionality, shared
// by <process.h> and <wchar.h>.
//
#pragma once



__pragma(pack(push, 8)) extern "C" {




    

        __declspec(dllimport) intptr_t __cdecl _wexecl(
              wchar_t const* _FileName,
              wchar_t const* _ArgList,
            ...);

        __declspec(dllimport) intptr_t __cdecl _wexecle(
              wchar_t const* _FileName,
              wchar_t const* _ArgList,
            ...);

        __declspec(dllimport) intptr_t __cdecl _wexeclp(
              wchar_t const* _FileName,
              wchar_t const* _ArgList,
            ...);

        __declspec(dllimport) intptr_t __cdecl _wexeclpe(
              wchar_t const* _FileName,
              wchar_t const* _ArgList,
            ...);

        __declspec(dllimport) intptr_t __cdecl _wexecv(
              wchar_t const*        _FileName,
              wchar_t const* const* _ArgList
            );

        __declspec(dllimport) intptr_t __cdecl _wexecve(
                  wchar_t const*        _FileName,
                  wchar_t const* const* _ArgList,
              wchar_t const* const* _Env
            );

        __declspec(dllimport) intptr_t __cdecl _wexecvp(
              wchar_t const*        _FileName,
              wchar_t const* const* _ArgList
            );

        __declspec(dllimport) intptr_t __cdecl _wexecvpe(
                  wchar_t const*        _FileName,
                  wchar_t const* const* _ArgList,
              wchar_t const* const* _Env
            );

        __declspec(dllimport) intptr_t __cdecl _wspawnl(
                int            _Mode,
              wchar_t const* _FileName,
              wchar_t const* _ArgList,
            ...);

        __declspec(dllimport) intptr_t __cdecl _wspawnle(
                int            _Mode,
              wchar_t const* _FileName,
              wchar_t const* _ArgList,
            ...);

        __declspec(dllimport) intptr_t __cdecl _wspawnlp(
                int            _Mode,
              wchar_t const* _FileName,
              wchar_t const* _ArgList,
            ...);

        __declspec(dllimport) intptr_t __cdecl _wspawnlpe(
                int            _Mode,
              wchar_t const* _FileName,
              wchar_t const* _ArgList,
            ...);

        __declspec(dllimport) intptr_t __cdecl _wspawnv(
                int                   _Mode,
              wchar_t const*        _FileName,
              wchar_t const* const* _ArgList
            );

        __declspec(dllimport) intptr_t __cdecl _wspawnve(
                    int                   _Mode,
                  wchar_t const*        _FileName,
                  wchar_t const* const* _ArgList,
              wchar_t const* const* _Env
            );

        __declspec(dllimport) intptr_t __cdecl _wspawnvp(
                int                   _Mode,
              wchar_t const*        _FileName,
              wchar_t const* const* _ArgList
            );

        __declspec(dllimport) intptr_t __cdecl _wspawnvpe(
                    int                   _Mode,
                  wchar_t const*        _FileName,
                  wchar_t const* const* _ArgList,
              wchar_t const* const* _Env
            );

        __declspec(dllimport) int __cdecl _wsystem(
              wchar_t const* _Command
            );

    




} __pragma(pack(pop))





//
// corecrt_wtime.h
//
//      Copyright (c) Microsoft Corporation. All rights reserved.
//
// This file declares the wide character (wchar_t) time functionality, shared
// by <time.h> and <wchar.h>.
//
#pragma once



__pragma(pack(push, 8)) extern "C" {



//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// Types
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
struct tm
{
    int tm_sec;   // seconds after the minute - [0, 60] including leap second
    int tm_min;   // minutes after the hour - [0, 59]
    int tm_hour;  // hours since midnight - [0, 23]
    int tm_mday;  // day of the month - [1, 31]
    int tm_mon;   // months since January - [0, 11]
    int tm_year;  // years since 1900
    int tm_wday;  // days since Sunday - [0, 6]
    int tm_yday;  // days since January 1 - [0, 365]
    int tm_isdst; // daylight savings time flag
};


//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// Wide String Time Functions
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  __declspec(deprecated("This function or variable may be unsafe. Consider using " "_wasctime_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
 
 
__declspec(dllimport) wchar_t* __cdecl _wasctime(
      struct tm const* _Tm
    );

 

__declspec(dllimport) errno_t __cdecl _wasctime_s(
        wchar_t*         _Buffer,
                                          size_t           _SizeInWords,
                                                       struct tm const* _Tm
    );

extern "C++" { template <size_t _Size> inline   errno_t __cdecl _wasctime_s(  wchar_t (&_Buffer)[_Size],   struct tm const* _Time) throw() { return _wasctime_s(_Buffer, _Size, _Time); } }

 

__declspec(dllimport) size_t __cdecl wcsftime(
       wchar_t*         _Buffer,
                               size_t           _SizeInWords,
                             wchar_t const*   _Format,
                               struct tm const* _Tm
    );

 

__declspec(dllimport) size_t __cdecl _wcsftime_l(
       wchar_t*         _Buffer,
                               size_t           _SizeInWords,
                             wchar_t const*   _Format,
                               struct tm const* _Tm,
                           _locale_t        _Locale
    );

 
  __declspec(deprecated("This function or variable may be unsafe. Consider using " "_wctime32_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__declspec(dllimport) wchar_t* __cdecl _wctime32(
      __time32_t const* _Time
    );


__declspec(dllimport) errno_t __cdecl _wctime32_s(
        wchar_t*          _Buffer,
                                      size_t            _SizeInWords,
                                                       __time32_t const* _Time
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _wctime32_s(  wchar_t (&_Buffer)[_Size],   __time32_t const* _Time) throw() { return _wctime32_s(_Buffer, _Size, _Time); } }

 
 
  __declspec(deprecated("This function or variable may be unsafe. Consider using " "_wctime64_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__declspec(dllimport) wchar_t* __cdecl _wctime64(
      __time64_t const* _Time
    );


__declspec(dllimport) errno_t __cdecl _wctime64_s(
        wchar_t*          _Buffer,
                                      size_t            _SizeInWords,
                                                       __time64_t const* _Time);

extern "C++" { template <size_t _Size> inline errno_t __cdecl _wctime64_s(  wchar_t (&_Buffer)[_Size],   __time64_t const* _Time) throw() { return _wctime64_s(_Buffer, _Size, _Time); } }


__declspec(dllimport) errno_t __cdecl _wstrdate_s(
       wchar_t* _Buffer,
                                                                                size_t   _SizeInWords
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _wstrdate_s(  wchar_t (&_Buffer)[_Size]) throw() { return _wstrdate_s(_Buffer, _Size); } }

__declspec(deprecated("This function or variable may be unsafe. Consider using " "_wstrdate_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport)  wchar_t* __cdecl _wstrdate( wchar_t *_Buffer);


__declspec(dllimport) errno_t __cdecl _wstrtime_s(
       wchar_t* _Buffer,
                                                                                size_t   _SizeInWords
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _wstrtime_s(  wchar_t (&_Buffer)[_Size]) throw() { return _wstrtime_s(_Buffer, _Size); } }

__declspec(deprecated("This function or variable may be unsafe. Consider using " "_wstrtime_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport)  wchar_t* __cdecl _wstrtime( wchar_t *_Buffer);



//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// Inline Definitions
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

    #pragma warning(push)
    #pragma warning(disable: 4996)

    




















         
        static __inline wchar_t * __cdecl _wctime(
              time_t const* const _Time)
        {
            return _wctime64(_Time);
        }

        
        static __inline errno_t __cdecl _wctime_s(
                  wchar_t*      const _Buffer,
                                                             size_t        const _SizeInWords,
                                                             time_t const* const _Time
            )
        {
            return _wctime64_s(_Buffer, _SizeInWords, _Time);
        }

    

    #pragma warning(pop)




} __pragma(pack(pop))


//
// sys/stat.h
//
//      Copyright (c) Microsoft Corporation. All rights reserved.
//
// The _stat() and _fstat() families of functions.
//
#pragma once



//
// sys/types.h
//
//      Copyright (c) Microsoft Corporation. All rights reserved.
//
// Types used for returning file status and time information.
//
#pragma once




    

    typedef unsigned short _ino_t; // inode number (unused on Windows)

    
        typedef _ino_t ino_t;
    





    

    typedef unsigned int _dev_t; // device code

    
        typedef _dev_t dev_t;
    





    

    typedef long _off_t; // file offset value

    
        typedef _off_t off_t;
    



__pragma(pack(push, 8)) extern "C" {


#pragma warning(push)
#pragma warning(disable: 4820) 


//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// Types
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
struct _stat32
{
    _dev_t         st_dev;
    _ino_t         st_ino;
    unsigned short st_mode;
    short          st_nlink;
    short          st_uid;
    short          st_gid;
    _dev_t         st_rdev;
    _off_t         st_size;
    __time32_t     st_atime;
    __time32_t     st_mtime;
    __time32_t     st_ctime;
};

struct _stat32i64
{
    _dev_t         st_dev;
    _ino_t         st_ino;
    unsigned short st_mode;
    short          st_nlink;
    short          st_uid;
    short          st_gid;
    _dev_t         st_rdev;
    __int64        st_size;
    __time32_t     st_atime;
    __time32_t     st_mtime;
    __time32_t     st_ctime;
};

struct _stat64i32
{
    _dev_t         st_dev;
    _ino_t         st_ino;
    unsigned short st_mode;
    short          st_nlink;
    short          st_uid;
    short          st_gid;
    _dev_t         st_rdev;
    _off_t         st_size;
    __time64_t     st_atime;
    __time64_t     st_mtime;
    __time64_t     st_ctime;
};

struct _stat64
{
    _dev_t         st_dev;
    _ino_t         st_ino;
    unsigned short st_mode;
    short          st_nlink;
    short          st_uid;
    short          st_gid;
    _dev_t         st_rdev;
    __int64        st_size;
    __time64_t     st_atime;
    __time64_t     st_mtime;
    __time64_t     st_ctime;
};




    struct stat
    {
        _dev_t         st_dev;
        _ino_t         st_ino;
        unsigned short st_mode;
        short          st_nlink;
        short          st_uid;
        short          st_gid;
        _dev_t         st_rdev;
        _off_t         st_size;
        time_t         st_atime;
        time_t         st_mtime;
        time_t         st_ctime;
    };




//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// Flags
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+










    
    
    
    
    
    
    




//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// Functions
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+








    
    
    
    
    
    




__declspec(dllimport) int __cdecl _fstat32(
       int             _FileHandle,
      struct _stat32* _Stat
    );

__declspec(dllimport) int __cdecl _fstat32i64(
       int                _FileHandle,
      struct _stat32i64* _Stat
    );

__declspec(dllimport) int __cdecl _fstat64i32(
       int                _FileHandle,
      struct _stat64i32* _Stat
    );

__declspec(dllimport) int __cdecl _fstat64(
       int             _FileHandle,
      struct _stat64* _Stat
    );

__declspec(dllimport) int __cdecl _stat32(
      char const*     _FileName,
       struct _stat32* _Stat
    );

__declspec(dllimport) int __cdecl _stat32i64(
      char const*        _FileName,
       struct _stat32i64* _Stat
    );

__declspec(dllimport) int __cdecl _stat64i32(
      char const*        _FileName,
       struct _stat64i32* _Stat
    );

__declspec(dllimport) int __cdecl _stat64(
      char const*     _FileName,
       struct _stat64* _Stat
    );

__declspec(dllimport) int __cdecl _wstat32(
      wchar_t const*  _FileName,
       struct _stat32* _Stat
    );

__declspec(dllimport) int __cdecl _wstat32i64(
      wchar_t const*     _FileName,
       struct _stat32i64* _Stat
    );

__declspec(dllimport) int __cdecl _wstat64i32(
      wchar_t const*     _FileName,
       struct _stat64i32* _Stat
    );

__declspec(dllimport) int __cdecl _wstat64(
      wchar_t const*  _FileName,
       struct _stat64* _Stat
    );




    















        static __inline int __cdecl fstat(int const _FileHandle, struct stat* const _Stat)
        {
            typedef char __static_assert_t[(sizeof(struct stat) == sizeof(struct _stat64i32)) != 0];
            return _fstat64i32(_FileHandle, (struct _stat64i32*)_Stat);
        }
        static __inline int __cdecl stat(char const* const _FileName, struct stat* const _Stat)
        {
            typedef char __static_assert_t[(sizeof(struct stat) == sizeof(struct _stat64i32)) != 0];
            return _stat64i32(_FileName, (struct _stat64i32*)_Stat);
        }

    



#pragma warning(pop)


} __pragma(pack(pop))




__pragma(pack(push, 8)) extern "C" {








typedef wchar_t _Wint_t;





        
    __declspec(dllimport) wchar_t* __cdecl _wsetlocale(
                int            _Category,
          wchar_t const* _Locale
        );

    
    __declspec(dllimport) _locale_t __cdecl _wcreate_locale(
            int            _Category,
          wchar_t const* _Locale
        );



    __declspec(dllimport) wint_t __cdecl btowc(
          int _Ch
        );

    __declspec(dllimport) size_t __cdecl mbrlen(
            char const* _Ch,
                                                    size_t      _SizeInBytes,
                                                 mbstate_t*  _State
        );

    __declspec(dllimport) size_t __cdecl mbrtowc(
                                  wchar_t*    _DstCh,
            char const* _SrcCh,
                                                    size_t      _SizeInBytes,
                                                 mbstate_t*  _State
        );

     
    __declspec(dllimport) errno_t __cdecl mbsrtowcs_s(
                                  size_t*      _Retval,
                  wchar_t*     _Dst,
                                       size_t       _Size,
                          char const** _PSrc,
                                       size_t       _N,
                                    mbstate_t*   _State
        );

    extern "C++" { template <size_t _Size> inline   errno_t __cdecl mbsrtowcs_s(  size_t* _Retval,   wchar_t (&_Dest)[_Size],     char const** _PSource,   size_t _Count,   mbstate_t* _State) throw() { return mbsrtowcs_s(_Retval, _Dest, _Size, _PSource, _Count, _State); } }

    __declspec(deprecated("This function or variable may be unsafe. Consider using " "mbsrtowcs_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))  __declspec(dllimport) size_t __cdecl mbsrtowcs( wchar_t *_Dest,  char const** _PSrc,  size_t _Count,  mbstate_t* _State);

     
    __declspec(dllimport) errno_t __cdecl wcrtomb_s(
                                 size_t*    _Retval,
          char*      _Dst,
                                      size_t     _SizeInBytes,
                                      wchar_t    _Ch,
                               mbstate_t* _State
        );

    extern "C++" { template <size_t _Size> inline   errno_t __cdecl wcrtomb_s(  size_t* _Retval,   char (&_Dest)[_Size],   wchar_t _Source,   mbstate_t* _State) throw() { return wcrtomb_s(_Retval, _Dest, _Size, _Source, _State); } }

    __declspec(deprecated("This function or variable may be unsafe. Consider using " "wcrtomb_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) size_t __cdecl wcrtomb(  char *_Dest,  wchar_t _Source,  mbstate_t* _State);

     
    __declspec(dllimport) errno_t __cdecl wcsrtombs_s(
                                                  size_t*         _Retval,
          char*           _Dst,
                                                       size_t          _SizeInBytes,
                                    wchar_t const** _Src,
                                                       size_t          _Size,
                                                mbstate_t*      _State
        );

    extern "C++" { template <size_t _Size> inline   errno_t __cdecl wcsrtombs_s(  size_t* _Retval,   char (&_Dest)[_Size],     wchar_t const** _PSrc,   size_t _Count,   mbstate_t* _State) throw() { return wcsrtombs_s(_Retval, _Dest, _Size, _PSrc, _Count, _State); } }

    __declspec(deprecated("This function or variable may be unsafe. Consider using " "wcsrtombs_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) size_t __cdecl wcsrtombs(  char *_Dest,  wchar_t const** _PSource,  size_t _Count,  mbstate_t* _State);

    __declspec(dllimport) int __cdecl wctob(
          wint_t _WCh
        );

    

         
        errno_t __cdecl wmemcpy_s(
              wchar_t*       _S1,
                                      rsize_t        _N1,
                        wchar_t const* _S2,
                                      rsize_t        _N
            );

         
        errno_t __cdecl wmemmove_s(
              wchar_t*       _S1,
                                      rsize_t        _N1,
                        wchar_t const* _S2,
                                      rsize_t        _N
            );

    

    __inline int __cdecl fwide(
          FILE* _F,
              int   _M
        )
    {
        (void)_F;
        return (_M);
    }

    __inline int __cdecl mbsinit(
          mbstate_t const* _P
        )
    {
        return _P == 0 || _P->_Wchar == 0;
    }

    __inline wchar_t const* __cdecl wmemchr(
          wchar_t const* _S,
                    wchar_t        _C,
                    size_t         _N
        )
    {
        for (; 0 < _N; ++_S, --_N)
            if (*_S == _C)
                return (wchar_t const*)_S;

        return 0;
    }

    __inline int __cdecl wmemcmp(
          wchar_t const* _S1,
          wchar_t const* _S2,
                    size_t         _N
        )
    {
        for (; 0 < _N; ++_S1, ++_S2, --_N)
            if (*_S1 != *_S2)
                return *_S1 < *_S2 ? -1 : 1;

        return 0;
    }

     
    
    __inline 
    wchar_t* __cdecl wmemcpy(
          wchar_t*       _S1,
                wchar_t const* _S2,
                          size_t         _N
        )
    {
        #pragma warning(push)
        #pragma warning(disable : 4995 4996 6386)
        return (wchar_t*)memcpy(_S1, _S2, _N*sizeof(wchar_t));
        #pragma warning(pop)
    }

    __inline 
    wchar_t* __cdecl wmemmove(
          wchar_t*       _S1,
                wchar_t const* _S2,
                              size_t         _N
        )
    {
        #pragma warning(push)
        #pragma warning(disable : 4996 6386)
        return (wchar_t*)memmove(_S1, _S2, _N*sizeof(wchar_t));
        #pragma warning(pop)
    }

     
    
    __inline wchar_t* __cdecl wmemset(
          wchar_t* _S,
                          wchar_t  _C,
                          size_t   _N
        )
    {
        wchar_t *_Su = _S;
        for (; 0 < _N; ++_Su, --_N)
        {
            *_Su = _C;
        }
        return _S;
    }

    

        extern "C++" inline wchar_t* __cdecl wmemchr(
              wchar_t* _S,
                        wchar_t  _C,
                        size_t   _N
            )
        {
            wchar_t const* const _SC = _S;
            return const_cast<wchar_t*>(wmemchr(_SC, _C, _N));
        }

    





} __pragma(pack(pop))



#pragma pack(push,8)
#pragma warning(push,3)
#pragma warning(disable: 4455 4494  4619 4643 4702 4984 4988 )




typedef mbstate_t _Mbstatet;

namespace std {
#pragma warning(push)
#pragma warning(disable: 4995) 

using :: _Mbstatet;

using :: mbstate_t; using :: size_t; using :: tm; using :: wint_t;

using :: btowc; using :: fgetwc; using :: fgetws; using :: fputwc;
using :: fputws; using :: fwide; using :: fwprintf;
using :: fwscanf; using :: getwc; using :: getwchar;
using :: mbrlen; using :: mbrtowc; using :: mbsrtowcs;
using :: mbsinit; using :: putwc; using :: putwchar;
using :: swprintf; using :: swscanf; using :: ungetwc;
using :: vfwprintf; using :: vswprintf; using :: vwprintf;
using :: wcrtomb; using :: wprintf; using :: wscanf;
using :: wcsrtombs; using :: wcstol; using :: wcscat;
using :: wcschr; using :: wcscmp; using :: wcscoll;
using :: wcscpy; using :: wcscspn; using :: wcslen;
using :: wcsncat; using :: wcsncmp; using :: wcsncpy;
using :: wcspbrk; using :: wcsrchr; using :: wcsspn;
using :: wcstod; using :: wcstoul; using :: wcsstr;
using :: wcstok; using :: wcsxfrm; using :: wctob;
using :: wmemchr; using :: wmemcmp; using :: wmemcpy;
using :: wmemmove; using :: wmemset; using :: wcsftime;

using :: vfwscanf; using :: vswscanf; using :: vwscanf;
using :: wcstof; using :: wcstold;
using :: wcstoll; using :: wcstoull;

#pragma warning(pop)
}



#pragma warning(pop)
#pragma pack(pop)




/*
 * Copyright (c) by P.J. Plauger. All rights reserved.
 * Consult your license regarding permissions and restrictions.
V6.50:0009 */



 #pragma pack(push,8)
 #pragma warning(push,3)
 #pragma warning(disable: 4455 4494  4619 4643 4702 4984 4988 )
 
 
 

namespace std {
		// ENUM float_denorm_style
enum float_denorm_style
	{	// constants for different IEEE float denormalization styles
	denorm_indeterminate = -1,
	denorm_absent = 0,
	denorm_present = 1
	};

		// ENUM float_round_style
enum float_round_style
	{	// constants for different IEEE rounding styles
	round_indeterminate = -1,
	round_toward_zero = 0,
	round_to_nearest = 1,
	round_toward_infinity = 2,
	round_toward_neg_infinity = 3
	};

		// STRUCT _Num_base
struct _Num_base
	{	// base for all types, with common defaults
	static constexpr float_denorm_style has_denorm = denorm_absent;
	static constexpr bool has_denorm_loss = false;
	static constexpr bool has_infinity = false;
	static constexpr bool has_quiet_NaN = false;
	static constexpr bool has_signaling_NaN = false;
	static constexpr bool is_bounded = false;
	static constexpr bool is_exact = false;
	static constexpr bool is_iec559 = false;
	static constexpr bool is_integer = false;
	static constexpr bool is_modulo = false;
	static constexpr bool is_signed = false;
	static constexpr bool is_specialized = false;
	static constexpr bool tinyness_before = false;
	static constexpr bool traps = false;
	static constexpr float_round_style round_style = round_toward_zero;
	static constexpr int digits = 0;
	static constexpr int digits10 = 0;
	static constexpr int max_digits10 = 0;
	static constexpr int max_exponent = 0;
	static constexpr int max_exponent10 = 0;
	static constexpr int min_exponent = 0;
	static constexpr int min_exponent10 = 0;
	static constexpr int radix = 0;
	};

		// CLASS TEMPLATE numeric_limits
template<class _Ty>
	class numeric_limits
		: public _Num_base
	{	// numeric limits for arbitrary type _Ty (say little or nothing)
public:
	 static constexpr _Ty (min)() noexcept
		{	// return minimum value
		return (_Ty());
		}

	 static constexpr _Ty (max)() noexcept
		{	// return maximum value
		return (_Ty());
		}

	 static constexpr _Ty lowest() noexcept
		{	// return most negative value
		return (_Ty());
		}

	 static constexpr _Ty epsilon() noexcept
		{	// return smallest effective increment from 1.0
		return (_Ty());
		}

	 static constexpr _Ty round_error() noexcept
		{	// return largest rounding error
		return (_Ty());
		}

	 static constexpr _Ty denorm_min() noexcept
		{	// return minimum denormalized value
		return (_Ty());
		}

	 static constexpr _Ty infinity() noexcept
		{	// return positive infinity
		return (_Ty());
		}

	 static constexpr _Ty quiet_NaN() noexcept
		{	// return non-signaling NaN
		return (_Ty());
		}

	 static constexpr _Ty signaling_NaN() noexcept
		{	// return signaling NaN
		return (_Ty());
		}
	};

template<class _Ty>
	class numeric_limits<const _Ty>
		: public numeric_limits<_Ty>
	{	// numeric limits for const types
	};

template<class _Ty>
	class numeric_limits<volatile _Ty>
		: public numeric_limits<_Ty>
	{	// numeric limits for volatile types
	};

template<class _Ty>
	class numeric_limits<const volatile _Ty>
		: public numeric_limits<_Ty>
	{	// numeric limits for const volatile types
	};

		// STRUCT _Num_int_base
struct _Num_int_base
	: _Num_base
	{	// base for integer types
	static constexpr bool is_bounded = true;
	static constexpr bool is_exact = true;
	static constexpr bool is_integer = true;
	static constexpr bool is_specialized = true;
	static constexpr int radix = 2;
	};

		// STRUCT _Num_float_base
struct _Num_float_base
	: _Num_base
	{	// base for floating-point types
	static constexpr float_denorm_style has_denorm = denorm_present;
	static constexpr bool has_infinity = true;
	static constexpr bool has_quiet_NaN = true;
	static constexpr bool has_signaling_NaN = true;
	static constexpr bool is_bounded = true;
	static constexpr bool is_iec559 = true;
	static constexpr bool is_signed = true;
	static constexpr bool is_specialized = true;
	static constexpr float_round_style round_style = round_to_nearest;
	static constexpr int radix = 2;
	};

		// CLASS numeric_limits<char>
template<> class numeric_limits<char>
	: public _Num_int_base
	{	// limits for type char
public:
	 static constexpr char (min)() noexcept
		{	// return minimum value
		return ((-128));
		}

	 static constexpr char (max)() noexcept
		{	// return maximum value
		return (127);
		}

	 static constexpr char lowest() noexcept
		{	// return most negative value
		return ((min)());
		}

	 static constexpr char epsilon() noexcept
		{	// return smallest effective increment from 1.0
		return (0);
		}

	 static constexpr char round_error() noexcept
		{	// return largest rounding error
		return (0);
		}

	 static constexpr char denorm_min() noexcept
		{	// return minimum denormalized value
		return (0);
		}

	 static constexpr char infinity() noexcept
		{	// return positive infinity
		return (0);
		}

	 static constexpr char quiet_NaN() noexcept
		{	// return non-signaling NaN
		return (0);
		}

	 static constexpr char signaling_NaN() noexcept
		{	// return signaling NaN
		return (0);
		}

	static constexpr bool is_signed = (-128) != 0;
	static constexpr bool is_modulo = (-128) == 0;
	static constexpr int digits = 8 - ((-128) != 0);
	static constexpr int digits10 = 2;
	};

		// CLASS numeric_limits<wchar_t>
template<> class numeric_limits<wchar_t>
	: public _Num_int_base
	{	// limits for type wchar_t
public:
	 static constexpr wchar_t (min)() noexcept
		{	// return minimum value
		return (0x0000);
		}

	 static constexpr wchar_t (max)() noexcept
		{	// return maximum value
		return (0xffff);
		}

	 static constexpr wchar_t lowest() noexcept
		{	// return most negative value
		return ((min)());
		}

	 static constexpr wchar_t epsilon() noexcept
		{	// return smallest effective increment from 1.0
		return (0);
		}

	 static constexpr wchar_t round_error() noexcept
		{	// return largest rounding error
		return (0);
		}

	 static constexpr wchar_t denorm_min() noexcept
		{	// return minimum denormalized value
		return (0);
		}

	 static constexpr wchar_t infinity() noexcept
		{	// return positive infinity
		return (0);
		}

	 static constexpr wchar_t quiet_NaN() noexcept
		{	// return non-signaling NaN
		return (0);
		}

	 static constexpr wchar_t signaling_NaN() noexcept
		{	// return signaling NaN
		return (0);
		}

	static constexpr bool is_modulo = true;
	static constexpr int digits = 16;
	static constexpr int digits10 = 4;
	};

		// CLASS numeric_limits<bool>
template<> class numeric_limits<bool>
	: public _Num_int_base
	{	// limits for type bool
public:
	 static constexpr bool (min)() noexcept
		{	// return minimum value
		return (false);
		}

	 static constexpr bool (max)() noexcept
		{	// return maximum value
		return (true);
		}

	 static constexpr bool lowest() noexcept
		{	// return most negative value
		return ((min)());
		}

	 static constexpr bool epsilon() noexcept
		{	// return smallest effective increment from 1.0
		return (0);
		}

	 static constexpr bool round_error() noexcept
		{	// return largest rounding error
		return (0);
		}

	 static constexpr bool denorm_min() noexcept
		{	// return minimum denormalized value
		return (0);
		}

	 static constexpr bool infinity() noexcept
		{	// return positive infinity
		return (0);
		}

	 static constexpr bool quiet_NaN() noexcept
		{	// return non-signaling NaN
		return (0);
		}

	 static constexpr bool signaling_NaN() noexcept
		{	// return signaling NaN
		return (0);
		}

	static constexpr int digits = 1;
	};

		// CLASS numeric_limits<signed char>
template<> class numeric_limits<signed char>
	: public _Num_int_base
	{	// limits for type signed char
public:
	 static constexpr signed char (min)() noexcept
		{	// return minimum value
		return ((-128));
		}

	 static constexpr signed char (max)() noexcept
		{	// return maximum value
		return (127);
		}

	 static constexpr signed char lowest() noexcept
		{	// return most negative value
		return ((min)());
		}

	 static constexpr signed char epsilon() noexcept
		{	// return smallest effective increment from 1.0
		return (0);
		}

	 static constexpr signed char round_error() noexcept
		{	// return largest rounding error
		return (0);
		}

	 static constexpr signed char denorm_min() noexcept
		{	// return minimum denormalized value
		return (0);
		}

	 static constexpr signed char infinity() noexcept
		{	// return positive infinity
		return (0);
		}

	 static constexpr signed char quiet_NaN() noexcept
		{	// return non-signaling NaN
		return (0);
		}

	 static constexpr signed char signaling_NaN() noexcept
		{	// return signaling NaN
		return (0);
		}

	static constexpr bool is_signed = true;
	static constexpr int digits = 7;
	static constexpr int digits10 = 2;
	};

		// CLASS numeric_limits<unsigned char>
template<> class numeric_limits<unsigned char>
	: public _Num_int_base
	{	// limits for type unsigned char
public:
	 static constexpr unsigned char (min)() noexcept
		{	// return minimum value
		return (0);
		}

	 static constexpr unsigned char (max)() noexcept
		{	// return maximum value
		return (0xff);
		}

	 static constexpr unsigned char lowest() noexcept
		{	// return most negative value
		return ((min)());
		}

	 static constexpr unsigned char epsilon() noexcept
		{	// return smallest effective increment from 1.0
		return (0);
		}

	 static constexpr unsigned char round_error() noexcept
		{	// return largest rounding error
		return (0);
		}

	 static constexpr unsigned char denorm_min() noexcept
		{	// return minimum denormalized value
		return (0);
		}

	 static constexpr unsigned char infinity() noexcept
		{	// return positive infinity
		return (0);
		}

	 static constexpr unsigned char quiet_NaN() noexcept
		{	// return non-signaling NaN
		return (0);
		}

	 static constexpr unsigned char signaling_NaN() noexcept
		{	// return signaling NaN
		return (0);
		}

	static constexpr bool is_modulo = true;
	static constexpr int digits = 8;
	static constexpr int digits10 = 2;
	};

		// CLASS numeric_limits<short>
template<> class numeric_limits<short>
	: public _Num_int_base
	{	// limits for type short
public:
	 static constexpr short (min)() noexcept
		{	// return minimum value
		return ((-32768));
		}

	 static constexpr short (max)() noexcept
		{	// return maximum value
		return (32767);
		}

	 static constexpr short lowest() noexcept
		{	// return most negative value
		return ((min)());
		}

	 static constexpr short epsilon() noexcept
		{	// return smallest effective increment from 1.0
		return (0);
		}

	 static constexpr short round_error() noexcept
		{	// return largest rounding error
		return (0);
		}

	 static constexpr short denorm_min() noexcept
		{	// return minimum denormalized value
		return (0);
		}

	 static constexpr short infinity() noexcept
		{	// return positive infinity
		return (0);
		}

	 static constexpr short quiet_NaN() noexcept
		{	// return non-signaling NaN
		return (0);
		}

	 static constexpr short signaling_NaN() noexcept
		{	// return signaling NaN
		return (0);
		}

	static constexpr bool is_signed = true;
	static constexpr int digits = 15;
	static constexpr int digits10 = 4;
	};

 
		// CLASS numeric_limits<unsigned short>
template<> class numeric_limits<unsigned short>
	: public _Num_int_base
	{	// limits for type unsigned short
public:
	 static constexpr unsigned short (min)() noexcept
		{	// return minimum value
		return (0);
		}

	 static constexpr unsigned short (max)() noexcept
		{	// return maximum value
		return (0xffff);
		}

	 static constexpr unsigned short lowest() noexcept
		{	// return most negative value
		return ((min)());
		}

	 static constexpr unsigned short epsilon() noexcept
		{	// return smallest effective increment from 1.0
		return (0);
		}

	 static constexpr unsigned short round_error() noexcept
		{	// return largest rounding error
		return (0);
		}

	 static constexpr unsigned short denorm_min() noexcept
		{	// return minimum denormalized value
		return (0);
		}

	 static constexpr unsigned short infinity() noexcept
		{	// return positive infinity
		return (0);
		}

	 static constexpr unsigned short quiet_NaN() noexcept
		{	// return non-signaling NaN
		return (0);
		}

	 static constexpr unsigned short signaling_NaN() noexcept
		{	// return signaling NaN
		return (0);
		}

	static constexpr bool is_modulo = true;
	static constexpr int digits = 16;
	static constexpr int digits10 = 4;
	};
 

		// CLASS numeric_limits<char16_t>
template<> class numeric_limits<char16_t>
	: public _Num_int_base
	{	// limits for type char16_t
public:
	 static constexpr char16_t (min)() noexcept
		{	// return minimum value
		return (0);
		}

	 static constexpr char16_t (max)() noexcept
		{	// return maximum value
		return (0xffff);
		}

	 static constexpr char16_t lowest() noexcept
		{	// return most negative value
		return ((min)());
		}

	 static constexpr char16_t epsilon() noexcept
		{	// return smallest effective increment from 1.0
		return (0);
		}

	 static constexpr char16_t round_error() noexcept
		{	// return largest rounding error
		return (0);
		}

	 static constexpr char16_t denorm_min() noexcept
		{	// return minimum denormalized value
		return (0);
		}

	 static constexpr char16_t infinity() noexcept
		{	// return positive infinity
		return (0);
		}

	 static constexpr char16_t quiet_NaN() noexcept
		{	// return non-signaling NaN
		return (0);
		}

	 static constexpr char16_t signaling_NaN() noexcept
		{	// return signaling NaN
		return (0);
		}

	static constexpr bool is_modulo = true;
	static constexpr int digits = 16;
	static constexpr int digits10 = 4;
	};

		// CLASS numeric_limits<int>
template<> class numeric_limits<int>
	: public _Num_int_base
	{	// limits for type int
public:
	 static constexpr int (min)() noexcept
		{	// return minimum value
		return ((-2147483647 - 1));
		}

	 static constexpr int (max)() noexcept
		{	// return maximum value
		return (2147483647);
		}

	 static constexpr int lowest() noexcept
		{	// return most negative value
		return ((min)());
		}

	 static constexpr int epsilon() noexcept
		{	// return smallest effective increment from 1.0
		return (0);
		}

	 static constexpr int round_error() noexcept
		{	// return largest rounding error
		return (0);
		}

	 static constexpr int denorm_min() noexcept
		{	// return minimum denormalized value
		return (0);
		}

	 static constexpr int infinity() noexcept
		{	// return positive infinity
		return (0);
		}

	 static constexpr int quiet_NaN() noexcept
		{	// return non-signaling NaN
		return (0);
		}

	 static constexpr int signaling_NaN() noexcept
		{	// return signaling NaN
		return (0);
		}

	static constexpr bool is_signed = true;
	static constexpr int digits = 31;
	static constexpr int digits10 = 9;
	};

		// CLASS numeric_limits<unsigned int>
template<> class numeric_limits<unsigned int>
	: public _Num_int_base
	{	// limits for type unsigned int
public:
	 static constexpr unsigned int (min)() noexcept
		{	// return minimum value
		return (0);
		}

	 static constexpr unsigned int (max)() noexcept
		{	// return maximum value
		return (0xffffffff);
		}

	 static constexpr unsigned int lowest() noexcept
		{	// return most negative value
		return ((min)());
		}

	 static constexpr unsigned int epsilon() noexcept
		{	// return smallest effective increment from 1.0
		return (0);
		}

	 static constexpr unsigned int round_error() noexcept
		{	// return largest rounding error
		return (0);
		}

	 static constexpr unsigned int denorm_min() noexcept
		{	// return minimum denormalized value
		return (0);
		}

	 static constexpr unsigned int infinity() noexcept
		{	// return positive infinity
		return (0);
		}

	 static constexpr unsigned int quiet_NaN() noexcept
		{	// return non-signaling NaN
		return (0);
		}

	 static constexpr unsigned int signaling_NaN() noexcept
		{	// return signaling NaN
		return (0);
		}

	static constexpr bool is_modulo = true;
	static constexpr int digits = 32;
	static constexpr int digits10 = 9;
	};

		// CLASS numeric_limits<long>
template<> class numeric_limits<long>
	: public _Num_int_base
	{	// limits for type long
public:
	 static constexpr long (min)() noexcept
		{	// return minimum value
		return ((-2147483647L - 1));
		}

	 static constexpr long (max)() noexcept
		{	// return maximum value
		return (2147483647L);
		}

	 static constexpr long lowest() noexcept
		{	// return most negative value
		return ((min)());
		}

	 static constexpr long epsilon() noexcept
		{	// return smallest effective increment from 1.0
		return (0);
		}

	 static constexpr long round_error() noexcept
		{	// return largest rounding error
		return (0);
		}

	 static constexpr long denorm_min() noexcept
		{	// return minimum denormalized value
		return (0);
		}

	 static constexpr long infinity() noexcept
		{	// return positive infinity
		return (0);
		}

	 static constexpr long quiet_NaN() noexcept
		{	// return non-signaling NaN
		return (0);
		}

	 static constexpr long signaling_NaN() noexcept
		{	// return signaling NaN
		return (0);
		}

	static_assert(sizeof(int) == sizeof(long), "LLP64 assumption");
	static constexpr bool is_signed = true;
	static constexpr int digits = 31;
	static constexpr int digits10 = 9;
	};

		// CLASS numeric_limits<unsigned long>
template<> class numeric_limits<unsigned long>
	: public _Num_int_base
	{	// limits for type unsigned long
public:
	 static constexpr unsigned long (min)() noexcept
		{	// return minimum value
		return (0);
		}

	 static constexpr unsigned long (max)() noexcept
		{	// return maximum value
		return (0xffffffffUL);
		}

	 static constexpr unsigned long lowest() noexcept
		{	// return most negative value
		return ((min)());
		}

	 static constexpr unsigned long epsilon() noexcept
		{	// return smallest effective increment from 1.0
		return (0);
		}

	 static constexpr unsigned long round_error() noexcept
		{	// return largest rounding error
		return (0);
		}

	 static constexpr unsigned long denorm_min() noexcept
		{	// return minimum denormalized value
		return (0);
		}

	 static constexpr unsigned long infinity() noexcept
		{	// return positive infinity
		return (0);
		}

	 static constexpr unsigned long quiet_NaN() noexcept
		{	// return non-signaling NaN
		return (0);
		}

	 static constexpr unsigned long signaling_NaN() noexcept
		{	// return signaling NaN
		return (0);
		}

	static_assert(sizeof(unsigned int) == sizeof(unsigned long), "LLP64 assumption");
	static constexpr bool is_modulo = true;
	static constexpr int digits = 32;
	static constexpr int digits10 = 9;
	};

		// CLASS numeric_limits<char32_t>
template<> class numeric_limits<char32_t>
	: public _Num_int_base
	{	// limits for type char32_t
public:
	 static constexpr char32_t (min)() noexcept
		{	// return minimum value
		return (0);
		}

	 static constexpr char32_t (max)() noexcept
		{	// return maximum value
		return (0xffffffff);
		}

	 static constexpr char32_t lowest() noexcept
		{	// return most negative value
		return ((min)());
		}

	 static constexpr char32_t epsilon() noexcept
		{	// return smallest effective increment from 1.0
		return (0);
		}

	 static constexpr char32_t round_error() noexcept
		{	// return largest rounding error
		return (0);
		}

	 static constexpr char32_t denorm_min() noexcept
		{	// return minimum denormalized value
		return (0);
		}

	 static constexpr char32_t infinity() noexcept
		{	// return positive infinity
		return (0);
		}

	 static constexpr char32_t quiet_NaN() noexcept
		{	// return non-signaling NaN
		return (0);
		}

	 static constexpr char32_t signaling_NaN() noexcept
		{	// return signaling NaN
		return (0);
		}

	static constexpr bool is_modulo = true;
	static constexpr int digits = 32;
	static constexpr int digits10 = 9;
	};

		// CLASS numeric_limits<long long>
template<> class numeric_limits<long long>
	: public _Num_int_base
	{	// limits for type long long
public:
	 static constexpr long long (min)() noexcept
		{	// return minimum value
		return ((-9223372036854775807i64 - 1));
		}

	 static constexpr long long (max)() noexcept
		{	// return maximum value
		return (9223372036854775807i64);
		}

	 static constexpr long long lowest() noexcept
		{	// return most negative value
		return ((min)());
		}

	 static constexpr long long epsilon() noexcept
		{	// return smallest effective increment from 1.0
		return (0);
		}

	 static constexpr long long round_error() noexcept
		{	// return largest rounding error
		return (0);
		}

	 static constexpr long long denorm_min() noexcept
		{	// return minimum denormalized value
		return (0);
		}

	 static constexpr long long infinity() noexcept
		{	// return positive infinity
		return (0);
		}

	 static constexpr long long quiet_NaN() noexcept
		{	// return non-signaling NaN
		return (0);
		}

	 static constexpr long long signaling_NaN() noexcept
		{	// return signaling NaN
		return (0);
		}

	static constexpr bool is_signed = true;
	static constexpr int digits = 63;
	static constexpr int digits10 = 18;
	};

		// CLASS numeric_limits<unsigned long long>
template<> class numeric_limits<unsigned long long>
	: public _Num_int_base
	{	// limits for type unsigned long long
public:
	 static constexpr unsigned long long (min)() noexcept
		{	// return minimum value
		return (0);
		}

	 static constexpr unsigned long long (max)() noexcept
		{	// return maximum value
		return (0xffffffffffffffffui64);
		}

	 static constexpr unsigned long long lowest() noexcept
		{	// return most negative value
		return ((min)());
		}

	 static constexpr unsigned long long epsilon() noexcept
		{	// return smallest effective increment from 1.0
		return (0);
		}

	 static constexpr unsigned long long round_error() noexcept
		{	// return largest rounding error
		return (0);
		}

	 static constexpr unsigned long long denorm_min() noexcept
		{	// return minimum denormalized value
		return (0);
		}

	 static constexpr unsigned long long infinity() noexcept
		{	// return positive infinity
		return (0);
		}

	 static constexpr unsigned long long quiet_NaN() noexcept
		{	// return non-signaling NaN
		return (0);
		}

	 static constexpr unsigned long long signaling_NaN() noexcept
		{	// return signaling NaN
		return (0);
		}

	static constexpr bool is_modulo = true;
	static constexpr int digits = 64;
	static constexpr int digits10 = 19;
	};

		// CLASS numeric_limits<float>
template<> class numeric_limits<float>
	: public _Num_float_base
	{	// limits for type float
public:
	 static constexpr float (min)() noexcept
		{	// return minimum value
		return (1.175494351e-38F);
		}

	 static constexpr float (max)() noexcept
		{	// return maximum value
		return (3.402823466e+38F);
		}

	 static constexpr float lowest() noexcept
		{	// return most negative value
		return (-(max)());
		}

	 static constexpr float epsilon() noexcept
		{	// return smallest effective increment from 1.0
		return (1.192092896e-07F);
		}

	 static constexpr float round_error() noexcept
		{	// return largest rounding error
		return (0.5F);
		}

	 static constexpr float denorm_min() noexcept
		{	// return minimum denormalized value
		return (1.401298464e-45F);
		}

	 static constexpr float infinity() noexcept
		{	// return positive infinity
		return (__builtin_huge_valf());
		}

	 static constexpr float quiet_NaN() noexcept
		{	// return non-signaling NaN
		return (__builtin_nanf("0"));
		}

	 static constexpr float signaling_NaN() noexcept
		{	// return signaling NaN
		return (__builtin_nansf("1"));
		}

	static constexpr int digits = 24;
	static constexpr int digits10 = 6;
	static constexpr int max_digits10 = 9;
	static constexpr int max_exponent = 128;
	static constexpr int max_exponent10 = 38;
	static constexpr int min_exponent = (-125);
	static constexpr int min_exponent10 = (-37);
	};

		// CLASS numeric_limits<double>
template<> class numeric_limits<double>
	: public _Num_float_base
	{	// limits for type double
public:
	 static constexpr double (min)() noexcept
		{	// return minimum value
		return (2.2250738585072014e-308);
		}

	 static constexpr double (max)() noexcept
		{	// return maximum value
		return (1.7976931348623158e+308);
		}

	 static constexpr double lowest() noexcept
		{	// return most negative value
		return (-(max)());
		}

	 static constexpr double epsilon() noexcept
		{	// return smallest effective increment from 1.0
		return (2.2204460492503131e-016);
		}

	 static constexpr double round_error() noexcept
		{	// return largest rounding error
		return (0.5);
		}

	 static constexpr double denorm_min() noexcept
		{	// return minimum denormalized value
		return (4.9406564584124654e-324);
		}

	 static constexpr double infinity() noexcept
		{	// return positive infinity
		return (__builtin_huge_val());
		}

	 static constexpr double quiet_NaN() noexcept
		{	// return non-signaling NaN
		return (__builtin_nan("0"));
		}

	 static constexpr double signaling_NaN() noexcept
		{	// return signaling NaN
		return (__builtin_nans("1"));
		}

	static constexpr int digits = 53;
	static constexpr int digits10 = 15;
	static constexpr int max_digits10 = 17;
	static constexpr int max_exponent = 1024;
	static constexpr int max_exponent10 = 308;
	static constexpr int min_exponent = (-1021);
	static constexpr int min_exponent10 = (-307);
	};

		// CLASS numeric_limits<long double>
template<> class numeric_limits<long double>
	: public _Num_float_base
	{	// limits for type long double
public:
	 static constexpr long double (min)() noexcept
		{	// return minimum value
		return (2.2250738585072014e-308);
		}

	 static constexpr long double (max)() noexcept
		{	// return maximum value
		return (1.7976931348623158e+308);
		}

	 static constexpr long double lowest() noexcept
		{	// return most negative value
		return (-(max)());
		}

	 static constexpr long double epsilon() noexcept
		{	// return smallest effective increment from 1.0
		return (2.2204460492503131e-016);
		}

	 static constexpr long double round_error() noexcept
		{	// return largest rounding error
		return (0.5L);
		}

	 static constexpr long double denorm_min() noexcept
		{	// return minimum denormalized value
		return (4.9406564584124654e-324);
		}

	 static constexpr long double infinity() noexcept
		{	// return positive infinity
		return (__builtin_huge_val());
		}

	 static constexpr long double quiet_NaN() noexcept
		{	// return non-signaling NaN
		return (__builtin_nan("0"));
		}

	 static constexpr long double signaling_NaN() noexcept
		{	// return signaling NaN
		return (__builtin_nans("1"));
		}

	static constexpr int digits = 53;
	static constexpr int digits10 = 15;
	static constexpr int max_digits10 = 17;
	static constexpr int max_exponent = 1024;
	static constexpr int max_exponent10 = 308;
	static constexpr int min_exponent = (-1021);
	static constexpr int min_exponent10 = (-307);
	};
}
 
 
 #pragma warning(pop)
 #pragma pack(pop)



/*
 * Copyright (c) by P.J. Plauger. All rights reserved.
 * Consult your license regarding permissions and restrictions.
V6.50:0009 */


// new standard header
#pragma once






#pragma pack(push,8)
#pragma warning(push,3)
#pragma warning(disable: 4455 4494  4619 4643 4702 4984 4988 )




namespace std {























		// SUPPORT TYPES

// handler for operator new failures
typedef void (__cdecl * new_handler) ();


		// FUNCTION AND OBJECT DECLARATIONS
 new_handler __cdecl set_new_handler(  new_handler) noexcept;
  new_handler __cdecl get_new_handler() noexcept;
}



#pragma warning(pop)
#pragma pack(pop)




/*
 * Copyright (c) by P.J. Plauger. All rights reserved.
 * Consult your license regarding permissions and restrictions.
V6.50:0009 */


// xutility internal header
#pragma once






// utility standard header
#pragma once





// iosfwd standard header
#pragma once











 #pragma pack(push,8)
 #pragma warning(push,3)
 #pragma warning(disable: 4455 4494  4619 4643 4702 4984 4988 )
 
 
 

namespace std {
		// STREAM POSITIONING TYPES (from <streambuf>)
using streamoff = long long;
using streamsize = long long;

		// CLASS TEMPLATE fpos (from <streambuf>)
template<class _Statetype>
	class fpos
	{	// store arbitrary file position
public:
	/* implicit */ fpos(streamoff _Off = 0)
		: _Myoff(_Off), _Fpos(0), _Mystate()
		{	// construct with stream offset
		}

	fpos(_Statetype _State, fpos_t _Fileposition)
		: _Myoff(_Fileposition), _Fpos(0), _Mystate(_State)
		{	// construct with conversion state and C file position
		}

	 _Statetype state() const
		{	// return conversion state
		return (_Mystate);
		}

	void state(_Statetype _State)
		{	// set conversion state
		_Mystate = _State;
		}

	operator streamoff() const
		{	// return offset
			// TRANSITION, ABI: We currently always set _Fpos to 0 but older .objs containing old basic_filebuf
			// would set _Fpos.
		return (_Myoff + _Fpos);
		}


	[[deprecated("warning STL4019: " "The member std::fpos::seekpos() is non-Standard, and is preserved only for compatibility with " "workarounds for old versions of Visual C++. It will be removed in a future release, and in this " "release always returns 0. Please use standards-conforming mechanisms to manipulate fpos, such as " "conversions to and from streamoff, or an integral type, instead. If you are receiving this message " "while compiling Boost.IOStreams, a fix has been submitted upstream to make Boost use " "standards-conforming mechanisms, as it does for other compilers. You can define " "_SILENCE_FPOS_SEEKPOS_DEPRECATION_WARNING to acknowledge that you have received this warning, " "or define _REMOVE_FPOS_SEEKPOS to remove std::fpos::seekpos entirely.")]] fpos_t seekpos() const noexcept
		{
		return {};
		}


	 streamoff operator-(const fpos& _Right) const
		{	// return difference of file positions as an offset
		return (static_cast<streamoff>(*this) - static_cast<streamoff>(_Right));
		}

	fpos& operator+=(streamoff _Off)
		{	// add offset
		_Myoff += _Off;
		return (*this);
		}

	fpos& operator-=(streamoff _Off)
		{	// subtract offset
		_Myoff -= _Off;
		return (*this);
		}

	 fpos operator+(streamoff _Off) const
		{	// return this + offset
		fpos _Tmp = *this;
		_Tmp += _Off;
		return (_Tmp);
		}

	 fpos operator-(streamoff _Off) const
		{	// return this - offset
		fpos _Tmp = *this;
		_Tmp -= _Off;
		return (_Tmp);
		}

	 bool operator==(const fpos& _Right) const
		{
		return (static_cast<streamoff>(*this) == static_cast<streamoff>(_Right));
		}

	template<class _Int,
		enable_if_t<is_integral_v<_Int>, int> = 0>
		 friend bool operator==(const fpos& _Left, const _Int _Right)
		{
		return (static_cast<streamoff>(_Left) == _Right);
		}

	template<class _Int,
		enable_if_t<is_integral_v<_Int>, int> = 0>
		 friend bool operator==(const _Int _Left, const fpos& _Right)
		{
		return (_Left == static_cast<streamoff>(_Right));
		}

	 bool operator!=(const fpos& _Right) const
		{
		return (static_cast<streamoff>(*this) != static_cast<streamoff>(_Right));
		}

	template<class _Int,
		enable_if_t<is_integral_v<_Int>, int> = 0>
		 friend bool operator!=(const fpos& _Left, const _Int _Right)
		{
		return (static_cast<streamoff>(_Left) != _Right);
		}

	template<class _Int,
		enable_if_t<is_integral_v<_Int>, int> = 0>
		 friend bool operator!=(const _Int _Left, const fpos& _Right)
		{
		return (_Left != static_cast<streamoff>(_Right));
		}

private:
	streamoff _Myoff;	// stream offset
	fpos_t _Fpos;	// TRANSITION, ABI. C file position, not currently used
	_Statetype _Mystate;	// current conversion state
	};

using streampos = fpos<_Mbstatet>;
using wstreampos = streampos;

		// STRUCT TEMPLATE _Char_traits (FROM <string>)
template<class _Elem,
	class _Int_type>
	struct _Char_traits
	{	// properties of a string or stream element
	using char_type = _Elem;
	using int_type = _Int_type;
	using pos_type = streampos;
	using off_type = streamoff;
	using state_type = _Mbstatet;

	 static inline int compare(  const _Elem * _First1,
		  const _Elem * _First2, size_t _Count) noexcept // strengthened
		{	// compare [_First1, _First1 + _Count) with [_First2, ...)
		for (; 0 < _Count; --_Count, ++_First1, ++_First2)
			{
			if (*_First1 != *_First2)
				{
				return (*_First1 < *_First2 ? -1 : +1);
				}
			}

		return (0);
		}

	 static inline size_t length(  const _Elem * _First) noexcept // strengthened
		{	// find length of null-terminated sequence
		size_t _Count = 0;
		while (*_First != _Elem())
			{
			++_Count;
			++_First;
			}

		return (_Count);
		}

	static _Elem * copy(  _Elem * const _First1,
		  const _Elem * _First2, size_t _Count) noexcept // strengthened
		{	// copy [_First2, _First2 + _Count) to [_First1, ...)
		return (static_cast<_Elem *>(:: memcpy(_First1, _First2, _Count * sizeof(_Elem))));
		}

	  static _Elem * _Copy_s(
		  _Elem * const _First1, const size_t _Dest_size,
		  const _Elem * const _First2, const size_t _Count) noexcept
		{	// copy [_First2, _First2 + _Count) to [_First1, _First1 + _Dest_size)
		do { if (_Count <= _Dest_size) { } else { do { (void) ((1 != _CrtDbgReport(2, "c:\\visual studio\\vc\\tools\\msvc\\14.16.27023\\include\\iosfwd", 190, 0, "%s", "invalid argument")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"invalid argument\"", __LPREFIX( __FUNCTION__), L"c:\\visual studio\\vc\\tools\\msvc\\14.16.27023\\include\\iosfwd", 190, 0); } while (false); } ; } while (false);
		return (copy(_First1, _First2, _Count));
		}

	 static inline const _Elem * find(  const _Elem * _First,
		size_t _Count, const _Elem& _Ch) noexcept // strengthened
		{	// look for _Ch in [_First, _First + _Count)
		for (; 0 < _Count; --_Count, ++_First)
			{
			if (*_First == _Ch)
				{
				return (_First);
				}
			}

		return (nullptr);
		}

	static _Elem * move(  _Elem * const _First1,
		  const _Elem * _First2, size_t _Count) noexcept // strengthened
		{	// copy [_First2, _First2 + _Count) to [_First1, ...), allowing overlap
		return (static_cast<_Elem *>(:: memmove(_First1, _First2, _Count * sizeof(_Elem))));
		}

	static _Elem * assign(  _Elem * const _First,
		size_t _Count, const _Elem _Ch) noexcept // strengthened
		{	// assign _Count * _Ch to [_First, ...)
		_Elem * _Next = _First;
		for (; 0 < _Count; --_Count, ++_Next)
			{
			*_Next = _Ch;
			}

		return (_First);
		}

	static inline void assign(_Elem& _Left, const _Elem& _Right) noexcept
		{	// assign an element
		_Left = _Right;
		}

	 static constexpr bool eq(const _Elem& _Left, const _Elem& _Right) noexcept
		{	// test for element equality
		return (_Left == _Right);
		}

	 static constexpr bool lt(const _Elem& _Left, const _Elem& _Right) noexcept
		{	// test if _Left precedes _Right
		return (_Left < _Right);
		}

	 static constexpr _Elem to_char_type(const int_type& _Meta) noexcept
		{	// convert metacharacter to character
		return (static_cast<_Elem>(_Meta));
		}

	 static constexpr int_type to_int_type(const _Elem& _Ch) noexcept
		{	// convert character to metacharacter
		return (static_cast<int_type>(_Ch));
		}

	 static constexpr bool eq_int_type(const int_type& _Left, const int_type& _Right) noexcept
		{	// test for metacharacter equality
		return (_Left == _Right);
		}

	 static constexpr int_type not_eof(const int_type& _Meta) noexcept
		{	// return anything but EOF
		return (_Meta != eof() ? _Meta : !eof());
		}

	 static constexpr int_type eof() noexcept
		{	// return end-of-file metacharacter
		return (static_cast<int_type>((-1)));
		}
	};

		// STRUCT TEMPLATE _WChar_traits
template<class _Elem>
	struct _WChar_traits
	{	// char_traits for the char16_t-likes: char16_t, wchar_t, unsigned short
	using char_type = _Elem;
	using int_type = unsigned short;
	using pos_type = streampos;
	using off_type = streamoff;
	using state_type = _Mbstatet;

	 static inline int compare(  const _Elem * const _First1,
			  const _Elem * const _First2, const size_t _Count) noexcept // strengthened
		{	// compare [_First1, _First1 + _Count) with [_First2, ...)










		return (:: wmemcmp(reinterpret_cast<const wchar_t *>(_First1),
			reinterpret_cast<const wchar_t *>(_First2), _Count));

		}

	 static inline size_t length(  const _Elem * _First) noexcept // strengthened
		{	// find length of null-terminated sequence










		return (:: wcslen(reinterpret_cast<const wchar_t *>(_First)));

		}

	static _Elem * copy(  _Elem * const _First1,
			  const _Elem * const _First2, const size_t _Count) noexcept // strengthened
		{	// copy [_First2, _First2 + _Count) to [_First1, ...)
		return (reinterpret_cast<_Elem *>(:: wmemcpy(reinterpret_cast<wchar_t *>(_First1),
			reinterpret_cast<const wchar_t *>(_First2), _Count)));
		}

	  static _Elem * _Copy_s(
			  _Elem * const _First1, const size_t _Size_in_words,
			  const _Elem * const _First2, const size_t _Count) noexcept
		{	// copy [_First2, _First2 + _Count) to [_First1, ...)
		do { if (_Count <= _Size_in_words) { } else { do { (void) ((1 != _CrtDbgReport(2, "c:\\visual studio\\vc\\tools\\msvc\\14.16.27023\\include\\iosfwd", 322, 0, "%s", "invalid argument")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"invalid argument\"", __LPREFIX( __FUNCTION__), L"c:\\visual studio\\vc\\tools\\msvc\\14.16.27023\\include\\iosfwd", 322, 0); } while (false); } ; } while (false);
		return (copy(_First1, _First2, _Count));
		}

	 static inline const _Elem * find(  const _Elem * _First,
			const size_t _Count, const _Elem& _Ch) noexcept // strengthened
		{	// look for _Ch in [_First, _First + _Count)










		return (reinterpret_cast<const _Elem *>(:: wmemchr(
			reinterpret_cast<const wchar_t *>(_First), _Ch, _Count)));

		}

	static _Elem * move(  _Elem * const _First1,
			  const _Elem * const _First2, const size_t _Count) noexcept // strengthened
		{	// copy [_First2, _First2 + _Count) to [_First1, ...)
		return (reinterpret_cast<_Elem *>(:: wmemmove(reinterpret_cast<wchar_t *>(_First1),
			reinterpret_cast<const wchar_t *>(_First2), _Count)));
		}

	static _Elem * assign(  _Elem * const _First, size_t _Count, _Elem _Ch)
			noexcept // strengthened
		{	// assign _Count * _Ch to [_First, ...)
		return (reinterpret_cast<_Elem *>(:: wmemset(reinterpret_cast<wchar_t *>(_First), _Ch, _Count)));
		}

	static inline void assign(_Elem& _Left, const _Elem& _Right) noexcept
		{	// assign an element
		_Left = _Right;
		}

	 static constexpr bool eq(const _Elem& _Left, const _Elem& _Right) noexcept
		{	// test for element equality
		return (_Left == _Right);
		}

	 static constexpr bool lt(const _Elem& _Left, const _Elem& _Right) noexcept
		{	// test if _Left precedes _Right
		return (_Left < _Right);
		}

	 static constexpr _Elem to_char_type(const int_type& _Meta) noexcept
		{	// convert metacharacter to character
		return (_Meta);
		}

	 static constexpr int_type to_int_type(const _Elem& _Ch) noexcept
		{	// convert character to metacharacter
		return (_Ch);
		}

	 static constexpr bool eq_int_type(const int_type& _Left, const int_type& _Right) noexcept
		{	// test for metacharacter equality
		return (_Left == _Right);
		}

	 static constexpr int_type not_eof(const int_type& _Meta) noexcept
		{	// return anything but EOF
		return (_Meta != eof() ? _Meta : static_cast<int_type>(!eof()));
		}

	 static constexpr int_type eof() noexcept
		{	// return end-of-file metacharacter
		return (((wint_t)(0xFFFF)));
		}
	};

		// STRUCT TEMPLATE char_traits
template<class _Elem>
	struct char_traits
		: _Char_traits<_Elem, long>
	{	// properties of a string or stream unknown element
	};

		// STRUCT char_traits<char16_t>
template<>
	struct char_traits<char16_t>
		: _WChar_traits<char16_t>
	{	// properties of a string or stream char16_t element
	};

using u16streampos = streampos;

		// STRUCT char_traits<char32_t>
template<>
	struct char_traits<char32_t>
		: _Char_traits<char32_t, unsigned int>
	{	// properties of a string or stream char32_t element
	};

using u32streampos = streampos;

		// STRUCT char_traits<wchar_t>
template<>
	struct char_traits<wchar_t>
		: _WChar_traits<wchar_t>
	{	// properties of a string or stream wchar_t element
	};

 
		// STRUCT char_traits<unsigned short>
template<>
	struct char_traits<unsigned short>
		: _WChar_traits<unsigned short>
	{	// properties of a string or stream unsigned short element
	};
 

		// STRUCT char_traits<char> (FROM <string>)
template<>
	struct char_traits<char>
	{	// properties of a string or stream char element
	using char_type = char;
	using int_type = int;
	using pos_type = streampos;
	using off_type = streamoff;
	using state_type = _Mbstatet;

	 static inline int compare(  const char * const _First1,
		  const char * const _First2, const size_t _Count) noexcept // strengthened
		{	// compare [_First1, _First1 + _Count) with [_First2, ...)



		return (:: memcmp(_First1, _First2, _Count));

		}

	 static inline size_t length(  const char * const _First) noexcept // strengthened
		{	// find length of null-terminated string



		return (:: strlen(_First));

		}

	static char * copy(  char * const _First1,
		  const char * const _First2, const size_t _Count) noexcept // strengthened
		{	// copy [_First2, _First2 + _Count) to [_First1, ...)
		return (static_cast<char *>(:: memcpy(_First1, _First2, _Count)));
		}

	  static char * _Copy_s(
		  char * const _First1, const size_t _Size_in_bytes,
		  const char * const _First2, const size_t _Count) noexcept
		{	// copy [_First2, _First2 + _Count) to [_First1, ...)
		do { if (_Count <= _Size_in_bytes) { } else { do { (void) ((1 != _CrtDbgReport(2, "c:\\visual studio\\vc\\tools\\msvc\\14.16.27023\\include\\iosfwd", 478, 0, "%s", "invalid argument")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"invalid argument\"", __LPREFIX( __FUNCTION__), L"c:\\visual studio\\vc\\tools\\msvc\\14.16.27023\\include\\iosfwd", 478, 0); } while (false); } ; } while (false);
		return (copy(_First1, _First2, _Count));
		}

	 static inline const char * find(  const char * const _First,
		const size_t _Count, const char& _Ch) noexcept // strengthened
		{	// look for _Ch in [_First, _First + _Count)



		return (static_cast<const char *>(:: memchr(_First, _Ch, _Count)));

		}

	static char * move(  char * const _First1,
		  const char * const _First2, const size_t _Count) noexcept // strengthened
		{	// copy [_First2, _First2 + _Count) to [_First1, ...)
		return (static_cast<char *>(:: memmove(_First1, _First2, _Count)));
		}

	static char * assign(  char * const _First,
		const size_t _Count, const char _Ch) noexcept // strengthened
		{	// assign _Count * _Ch to [_First, ...)
		return (static_cast<char *>(:: memset(_First, _Ch, _Count)));
		}

	static inline void assign(char& _Left, const char& _Right) noexcept
		{	// assign an element
		_Left = _Right;
		}

	 static constexpr bool eq(const char& _Left, const char& _Right) noexcept
		{	// test for element equality
		return (_Left == _Right);
		}

	 static constexpr bool lt(const char& _Left, const char& _Right) noexcept
		{	// test if _Left precedes _Right
		return (static_cast<unsigned char>(_Left) < static_cast<unsigned char>(_Right));
		}

	 static constexpr char to_char_type(const int_type& _Meta) noexcept
		{	// convert metacharacter to character
		return (static_cast<char>(_Meta));
		}

	 static constexpr int_type to_int_type(const char& _Ch) noexcept
		{	// convert character to metacharacter
		return (static_cast<unsigned char>(_Ch));
		}

	 static constexpr bool eq_int_type(const int_type& _Left, const int_type& _Right) noexcept
		{	// test for metacharacter equality
		return (_Left == _Right);
		}

	 static constexpr int_type not_eof(const int_type& _Meta) noexcept
		{	// return anything but EOF
		return (_Meta != eof() ? _Meta : !eof());
		}

	 static constexpr int_type eof() noexcept
		{	// return end-of-file metacharacter
		return ((-1));
		}
	};

		// FORWARD REFERENCES
template<class _Ty>
	class allocator;
class ios_base;
template<class _Elem,
	class _Traits = char_traits<_Elem>>
	class basic_ios;
template<class _Elem,
	class _Traits = char_traits<_Elem>>
	class istreambuf_iterator;
template<class _Elem,
	class _Traits = char_traits<_Elem>>
	class ostreambuf_iterator;
template<class _Elem,
	class _Traits = char_traits<_Elem>>
	class basic_streambuf;

#pragma vtordisp(push, 2)	
template<class _Elem,
	class _Traits = char_traits<_Elem>>
	class basic_istream;
template<class _Elem,
	class _Traits = char_traits<_Elem>>
	class basic_ostream;
#pragma vtordisp(pop)	

template<class _Elem,
	class _Traits = char_traits<_Elem>>
	class basic_iostream;
template<class _Elem,
	class _Traits = char_traits<_Elem>,
	class _Alloc = allocator<_Elem>>
	class basic_stringbuf;
template<class _Elem,
	class _Traits = char_traits<_Elem>,
	class _Alloc = allocator<_Elem>>
	class basic_istringstream;
template<class _Elem,
	class _Traits = char_traits<_Elem>,
	class _Alloc = allocator<_Elem>>
	class basic_ostringstream;
template<class _Elem,
	class _Traits = char_traits<_Elem>,
	class _Alloc = allocator<_Elem>>
	class basic_stringstream;
template<class _Elem,
	class _Traits = char_traits<_Elem>>
	class basic_filebuf;
template<class _Elem,
	class _Traits = char_traits<_Elem>>
	class basic_ifstream;
template<class _Elem,
	class _Traits = char_traits<_Elem>>
	class basic_ofstream;
template<class _Elem,
	class _Traits = char_traits<_Elem>>
	class basic_fstream;

 
template<class _Elem,
	class _InIt >
	class num_get;
template<class _Elem,
	class _OutIt >
	class num_put;
template<class _Elem>
	class collate;
 

		// char TYPEDEFS
using ios = basic_ios<char, char_traits<char>>;
using streambuf = basic_streambuf<char, char_traits<char>>;
using istream = basic_istream<char, char_traits<char>>;
using ostream = basic_ostream<char, char_traits<char>>;
using iostream = basic_iostream<char, char_traits<char>>;
using stringbuf = basic_stringbuf<char, char_traits<char>, allocator<char>>;
using istringstream = basic_istringstream<char, char_traits<char>, allocator<char>>;
using ostringstream = basic_ostringstream<char, char_traits<char>, allocator<char>>;
using stringstream = basic_stringstream<char, char_traits<char>, allocator<char>>;
using filebuf = basic_filebuf<char, char_traits<char>>;
using ifstream = basic_ifstream<char, char_traits<char>>;
using ofstream = basic_ofstream<char, char_traits<char>>;
using fstream = basic_fstream<char, char_traits<char>>;

		// wchar_t TYPEDEFS
using wios = basic_ios<wchar_t, char_traits<wchar_t>>;
using wstreambuf = basic_streambuf<wchar_t, char_traits<wchar_t>>;
using wistream = basic_istream<wchar_t, char_traits<wchar_t>>;
using wostream = basic_ostream<wchar_t, char_traits<wchar_t>>;
using wiostream = basic_iostream<wchar_t, char_traits<wchar_t>>;
using wstringbuf = basic_stringbuf<wchar_t, char_traits<wchar_t>, allocator<wchar_t>>;
using wistringstream = basic_istringstream<wchar_t, char_traits<wchar_t>, allocator<wchar_t>>;
using wostringstream = basic_ostringstream<wchar_t, char_traits<wchar_t>, allocator<wchar_t>>;
using wstringstream = basic_stringstream<wchar_t, char_traits<wchar_t>, allocator<wchar_t>>;
using wfilebuf = basic_filebuf<wchar_t, char_traits<wchar_t>>;
using wifstream = basic_ifstream<wchar_t, char_traits<wchar_t>>;
using wofstream = basic_ofstream<wchar_t, char_traits<wchar_t>>;
using wfstream = basic_fstream<wchar_t, char_traits<wchar_t>>;

 





}

 
 
 #pragma warning(pop)
 #pragma pack(pop)



/*
 * Copyright (c) by P.J. Plauger. All rights reserved.
 * Consult your license regarding permissions and restrictions.
V6.50:0009 */



 #pragma pack(push,8)
 #pragma warning(push,3)
 #pragma warning(disable: 4455 4494  4619 4643 4702 4984 4988 )
 
 
 

namespace std {
		// FUNCTION TEMPLATE _Min_value
template<class _Ty>
	 
	constexpr const _Ty& _Min_value(const _Ty& _Left, const _Ty& _Right)
		noexcept(noexcept(_Right < _Left))
	{	// return smaller of _Left and _Right
	return (_Right < _Left ? _Right : _Left);
	}

		// FUNCTION TEMPLATE _Max_value
template<class _Ty>
	 
	constexpr const _Ty& _Max_value(const _Ty& _Left, const _Ty& _Right)
		noexcept(noexcept(_Left < _Right))
	{	// return larger of _Left and _Right
	return (_Left < _Right ? _Right : _Left);
	}

		// FUNCTION TEMPLATE iter_swap (from <algorithm>)
template<class _FwdIt1,
	class _FwdIt2> inline
	void iter_swap(_FwdIt1 _Left, _FwdIt2 _Right)
	{	// swap *_Left and *_Right
	swap(*_Left, *_Right);
	}

		// FUNCTION TEMPLATE swap
template<class _Ty,
	size_t _Size,
	class> inline
	void swap(_Ty (&_Left)[_Size], _Ty (&_Right)[_Size])
		noexcept(_Is_nothrow_swappable<_Ty>::value)
	{	// exchange arrays stored at _Left and _Right
	if (&_Left != &_Right)
		{	// worth swapping, swap ranges
		_Ty *_First1 = _Left;
		_Ty *_Last1 = _First1 + _Size;
		_Ty *_First2 = _Right;
		for (; _First1 != _Last1; ++_First1, ++_First2)
			::std:: iter_swap(_First1, _First2);
		}
	}

template<class _Ty,
	class> inline
	void swap(_Ty& _Left, _Ty& _Right)
		noexcept(is_nothrow_move_constructible_v<_Ty> && is_nothrow_move_assignable_v<_Ty>)
	{	// exchange values stored at _Left and _Right
	_Ty _Tmp = ::std:: move(_Left);
	_Left = ::std:: move(_Right);
	_Right = ::std:: move(_Tmp);
	}

		// FUNCTION TEMPLATE _Swap_adl
template<class _Ty> inline
	void _Swap_adl(_Ty& _Left, _Ty& _Right)
		noexcept(_Is_nothrow_swappable<_Ty>::value)
	{	// exchange values stored at _Left and _Right, using ADL
	swap(_Left, _Right);
	}

		// STRUCT piecewise_construct_t
struct piecewise_construct_t
	{	// tag type for pair tuple arguments
	explicit piecewise_construct_t() = default;
	};

 constexpr piecewise_construct_t piecewise_construct{};

		// STRUCT TEMPLATE pair
template<class...>
	class tuple;

template<class _Ty1,
	class _Ty2>
	struct pair
	{	// store a pair of values
	using first_type = _Ty1;
	using second_type = _Ty2;

	template<class _Uty1 = _Ty1,
		class _Uty2 = _Ty2,
		enable_if_t<conjunction_v<
			is_default_constructible<_Uty1>,
			is_default_constructible<_Uty2>,
			_Is_implicitly_default_constructible<_Uty1>,
			_Is_implicitly_default_constructible<_Uty2>
		>, int> = 0>
		constexpr pair()
			noexcept(is_nothrow_default_constructible_v<_Uty1> && is_nothrow_default_constructible_v<_Uty2>)	// strengthened
		: first(), second()
		{
		}

	template<class _Uty1 = _Ty1,
		class _Uty2 = _Ty2,
		enable_if_t<conjunction_v<
			is_default_constructible<_Uty1>,
			is_default_constructible<_Uty2>,
			negation<conjunction<
				_Is_implicitly_default_constructible<_Uty1>,
				_Is_implicitly_default_constructible<_Uty2>>>
		>, int> = 0>
		constexpr explicit pair()
			noexcept(is_nothrow_default_constructible_v<_Uty1> && is_nothrow_default_constructible_v<_Uty2>)	// strengthened
		: first(), second()
		{
		}

	template<class _Uty1 = _Ty1,
		class _Uty2 = _Ty2,
		enable_if_t<conjunction_v<
			is_copy_constructible<_Uty1>,
			is_copy_constructible<_Uty2>,
			is_convertible<const _Uty1&, _Uty1>,
			is_convertible<const _Uty2&, _Uty2>
		>, int> = 0>
		constexpr pair(const _Ty1& _Val1, const _Ty2& _Val2)
			noexcept(is_nothrow_copy_constructible_v<_Uty1> && is_nothrow_copy_constructible_v<_Uty2>)	// strengthened
		: first(_Val1), second(_Val2)
		{
		}

	template<class _Uty1 = _Ty1,
		class _Uty2 = _Ty2,
		enable_if_t<conjunction_v<
			is_copy_constructible<_Uty1>,
			is_copy_constructible<_Uty2>,
			negation<conjunction<
				is_convertible<const _Uty1&, _Uty1>,
				is_convertible<const _Uty2&, _Uty2>>>
		>, int> = 0>
		constexpr explicit pair(const _Ty1& _Val1, const _Ty2& _Val2)
			noexcept(is_nothrow_copy_constructible_v<_Uty1> && is_nothrow_copy_constructible_v<_Uty2>)	// strengthened
		: first(_Val1), second(_Val2)
		{
		}

	template<class _Other1,
		class _Other2,
		enable_if_t<conjunction_v<
			is_constructible<_Ty1, _Other1>,
			is_constructible<_Ty2, _Other2>,
			is_convertible<_Other1, _Ty1>,
			is_convertible<_Other2, _Ty2>
		>, int> = 0>
		constexpr pair(_Other1&& _Val1, _Other2&& _Val2)
			noexcept(is_nothrow_constructible_v<_Ty1, _Other1> && is_nothrow_constructible_v<_Ty2, _Other2>)	// strengthened
		: first(::std:: forward<_Other1>(_Val1)),
				second(::std:: forward<_Other2>(_Val2))
		{
		}

	template<class _Other1,
		class _Other2,
		enable_if_t<conjunction_v<
			is_constructible<_Ty1, _Other1>,
			is_constructible<_Ty2, _Other2>,
			negation<conjunction<
				is_convertible<_Other1, _Ty1>,
				is_convertible<_Other2, _Ty2>>>
		>, int> = 0>
		constexpr explicit pair(_Other1&& _Val1, _Other2&& _Val2)
			noexcept(is_nothrow_constructible_v<_Ty1, _Other1> && is_nothrow_constructible_v<_Ty2, _Other2>)	// strengthened
		: first(::std:: forward<_Other1>(_Val1)),
				second(::std:: forward<_Other2>(_Val2))
		{
		}

	pair(const pair&) = default;
	pair(pair&&) = default;

	template<class _Other1,
		class _Other2,
		enable_if_t<conjunction_v<
			is_constructible<_Ty1, const _Other1&>,
			is_constructible<_Ty2, const _Other2&>,
			is_convertible<const _Other1&, _Ty1>,
			is_convertible<const _Other2&, _Ty2>
		>, int> = 0>
		constexpr pair(const pair<_Other1, _Other2>& _Right)
			noexcept(is_nothrow_constructible_v<_Ty1, const _Other1&> && is_nothrow_constructible_v<_Ty2, const _Other2&>)	// strengthened
		: first(_Right.first), second(_Right.second)
		{
		}

	template<class _Other1,
		class _Other2,
		enable_if_t<conjunction_v<
			is_constructible<_Ty1, const _Other1&>,
			is_constructible<_Ty2, const _Other2&>,
			negation<conjunction<
				is_convertible<const _Other1&, _Ty1>,
				is_convertible<const _Other2&, _Ty2>>>
		>, int> = 0>
		constexpr explicit pair(const pair<_Other1, _Other2>& _Right)
			noexcept(is_nothrow_constructible_v<_Ty1, const _Other1&> && is_nothrow_constructible_v<_Ty2, const _Other2&>)	// strengthened
		: first(_Right.first), second(_Right.second)
		{
		}

	template<class _Other1,
		class _Other2,
		enable_if_t<conjunction_v<
			is_constructible<_Ty1, _Other1>,
			is_constructible<_Ty2, _Other2>,
			is_convertible<_Other1, _Ty1>,
			is_convertible<_Other2, _Ty2>
		>, int> = 0>
		constexpr pair(pair<_Other1, _Other2>&& _Right)
			noexcept(is_nothrow_constructible_v<_Ty1, _Other1> && is_nothrow_constructible_v<_Ty2, _Other2>)	// strengthened
		: first(::std:: forward<_Other1>(_Right.first)),
			second(::std:: forward<_Other2>(_Right.second))
		{
		}

	template<class _Other1,
		class _Other2,
		enable_if_t<conjunction_v<
			is_constructible<_Ty1, _Other1>,
			is_constructible<_Ty2, _Other2>,
			negation<conjunction<
				is_convertible<_Other1, _Ty1>,
				is_convertible<_Other2, _Ty2>>>
		>, int> = 0>
		constexpr explicit pair(pair<_Other1, _Other2>&& _Right)
			noexcept(is_nothrow_constructible_v<_Ty1, _Other1> && is_nothrow_constructible_v<_Ty2, _Other2>)	// strengthened
		: first(::std:: forward<_Other1>(_Right.first)),
			second(::std:: forward<_Other2>(_Right.second))
		{
		}

	template<class _Tuple1,
		class _Tuple2,
		size_t... _Indexes1,
		size_t... _Indexes2> inline
		pair(_Tuple1& _Val1,
			_Tuple2& _Val2,
			index_sequence<_Indexes1...>,
			index_sequence<_Indexes2...>);

	template<class... _Types1,
		class... _Types2> inline
		pair(piecewise_construct_t,
			tuple<_Types1...> _Val1,
			tuple<_Types2...> _Val2);

	pair& operator=(const volatile pair&) = delete;

	template<class _Other1 = _Ty1,
		class _Other2 = _Ty2,
		enable_if_t<conjunction_v<
			is_assignable<_Ty1&, const _Other1&>,
			is_assignable<_Ty2&, const _Other2&>
		>, int> = 0>
		pair& operator=(const pair<_Other1, _Other2>& _Right)
			noexcept(is_nothrow_assignable_v<_Ty1&, const _Other1&> && is_nothrow_assignable_v<_Ty2&, const _Other2&>)	// strengthened
		{
		first = _Right.first;
		second = _Right.second;
		return (*this);
		}

	template<class _Other1 = _Ty1,
		class _Other2 = _Ty2,
		enable_if_t<conjunction_v<
			is_assignable<_Ty1&, _Other1>,
			is_assignable<_Ty2&, _Other2>
		>, int> = 0>
		pair& operator=(pair<_Other1, _Other2>&& _Right)
			noexcept(is_nothrow_assignable_v<_Ty1&, _Other1> && is_nothrow_assignable_v<_Ty2&, _Other2>)	// strengthened
		{
		first = ::std:: forward<_Other1>(_Right.first);
		second = ::std:: forward<_Other2>(_Right.second);
		return (*this);
		}

	void swap(pair& _Right)
		noexcept(_Is_nothrow_swappable<_Ty1>::value && _Is_nothrow_swappable<_Ty2>::value)
		{
		if (this != ::std:: addressof(_Right))
			{	// different, worth swapping
			_Swap_adl(first, _Right.first);
			_Swap_adl(second, _Right.second);
			}
		}

	_Ty1 first;		// the first stored value
	_Ty2 second;	// the second stored value
	};







template<class _Ty1,
	class _Ty2,
	class = enable_if_t<_Is_swappable<_Ty1>::value && _Is_swappable<_Ty2>::value>> inline
	void swap(pair<_Ty1, _Ty2>& _Left, pair<_Ty1, _Ty2>& _Right)
		noexcept(noexcept(_Left.swap(_Right)))
	{	// swap _Left and _Right pairs
	_Left.swap(_Right);
	}

template<class _Ty1,
	class _Ty2>
	 constexpr bool operator==(const pair<_Ty1, _Ty2>& _Left, const pair<_Ty1, _Ty2>& _Right)
	{	// test for pair equality
	return (_Left.first == _Right.first && _Left.second == _Right.second);
	}

template<class _Ty1,
	class _Ty2>
	 constexpr bool operator!=(const pair<_Ty1, _Ty2>& _Left, const pair<_Ty1, _Ty2>& _Right)
	{	// test for pair inequality
	return (!(_Left == _Right));
	}

template<class _Ty1,
	class _Ty2>
	 constexpr bool operator<(const pair<_Ty1, _Ty2>& _Left, const pair<_Ty1, _Ty2>& _Right)
	{	// test if _Left < _Right for pairs
	return (_Left.first < _Right.first ||
		(!(_Right.first < _Left.first) && _Left.second < _Right.second));
	}

template<class _Ty1,
	class _Ty2>
	 constexpr bool operator>(const pair<_Ty1, _Ty2>& _Left, const pair<_Ty1, _Ty2>& _Right)
	{	// test if _Left > _Right for pairs
	return (_Right < _Left);
	}

template<class _Ty1,
	class _Ty2>
	 constexpr bool operator<=(const pair<_Ty1, _Ty2>& _Left, const pair<_Ty1, _Ty2>& _Right)
	{	// test if _Left <= _Right for pairs
	return (!(_Right < _Left));
	}

template<class _Ty1,
	class _Ty2>
	 constexpr bool operator>=(const pair<_Ty1, _Ty2>& _Left, const pair<_Ty1, _Ty2>& _Right)
	{	// test if _Left >= _Right for pairs
	return (!(_Left < _Right));
	}

	// ALIAS TEMPLATE _Unrefwrap_t
template<class _Ty>
	struct _Unrefwrap_helper
	{	// leave unchanged if not a reference_wrapper
	using type = _Ty;
	};

template<class _Ty>
	struct _Unrefwrap_helper<reference_wrapper<_Ty>>
	{	// make a reference from a reference_wrapper
	using type = _Ty&;
	};

	// decay, then unwrap a reference_wrapper
template<class _Ty>
	using _Unrefwrap_t = typename _Unrefwrap_helper<decay_t<_Ty>>::type;

	// FUNCTION TEMPLATE make_pair
template<class _Ty1,
	class _Ty2>
	 constexpr pair<_Unrefwrap_t<_Ty1>, _Unrefwrap_t<_Ty2>>
		make_pair(_Ty1&& _Val1, _Ty2&& _Val2)
	{	// return pair composed from arguments
	using _Mypair = pair<_Unrefwrap_t<_Ty1>, _Unrefwrap_t<_Ty2>>;
	return (_Mypair(::std:: forward<_Ty1>(_Val1), ::std:: forward<_Ty2>(_Val2)));
	}

	namespace rel_ops
		{	// nested namespace to hide relational operators from std
template<class _Ty>
	 inline bool operator!=(const _Ty& _Left, const _Ty& _Right)
	{	// test for inequality, in terms of equality
	return (!(_Left == _Right));
	}

template<class _Ty>
	 inline bool operator>(const _Ty& _Left, const _Ty& _Right)
	{	// test if _Left > _Right, in terms of operator<
	return (_Right < _Left);
	}

template<class _Ty>
	 inline bool operator<=(const _Ty& _Left, const _Ty& _Right)
	{	// test if _Left <= _Right, in terms of operator<
	return (!(_Right < _Left));
	}

template<class _Ty>
	 inline bool operator>=(const _Ty& _Left, const _Ty& _Right)
	{	// test if _Left >= _Right, in terms of operator<
	return (!(_Left < _Right));
	}
		}
}

namespace std {
	// STRUCTS FOR STRUCTURED BINDINGS tuple_size AND tuple_element
template<class _Tuple>
	struct tuple_size;

template<class _Tuple,
	class = void>
	struct _Tuple_size_sfinae
	{	// selected when tuple_size<_Tuple>::value isn't well-formed
	};

template<class _Tuple>
	struct _Tuple_size_sfinae<_Tuple, void_t<decltype(tuple_size<_Tuple>::value)>>
		: integral_constant<size_t, tuple_size<_Tuple>::value>
	{	// selected when tuple_size<_Tuple>::value is well-formed
	};

template<class _Tuple>
	struct tuple_size<const _Tuple>
	: _Tuple_size_sfinae<_Tuple>
	{	// size of const tuple
	};

template<class _Tuple>
	struct tuple_size<volatile _Tuple>
	: _Tuple_size_sfinae<_Tuple>
	{	// size of volatile tuple
	};

template<class _Tuple>
	struct tuple_size<const volatile _Tuple>
	: _Tuple_size_sfinae<_Tuple>
	{	// size of const volatile tuple
	};

template<class _Ty>
	 constexpr size_t tuple_size_v = tuple_size<_Ty>::value;

template<size_t _Index,
	class _Tuple>
	struct tuple_element;

template<size_t _Index,
	class _Tuple>
	struct tuple_element<_Index, const _Tuple>
		: public tuple_element<_Index, _Tuple>
	{	// tuple_element for const
	using _Mybase = tuple_element<_Index, _Tuple>;
	using type = add_const_t<typename _Mybase::type>;
	};

template<size_t _Index,
	class _Tuple>
	struct tuple_element<_Index, volatile _Tuple>
		: public tuple_element<_Index, _Tuple>
	{	// tuple_element for volatile
	using _Mybase = tuple_element<_Index, _Tuple>;
	using type = add_volatile_t<typename _Mybase::type>;
	};

template<size_t _Index,
	class _Tuple>
	struct tuple_element<_Index, const volatile _Tuple>
		: public tuple_element<_Index, _Tuple>
	{	// tuple_element for const volatile
	using _Mybase = tuple_element<_Index, _Tuple>;
	using type = add_cv_t<typename _Mybase::type>;
	};

template<size_t _Index,
	class _Tuple>
	using tuple_element_t = typename tuple_element<_Index, _Tuple>::type;

	// TUPLE INTERFACE TO array
template<class _Ty,
	size_t _Size>
	class array;

template<class _Ty,
	size_t _Size>
	struct tuple_size<array<_Ty, _Size> >
		: integral_constant<size_t, _Size>
	{	// struct to determine number of elements in array
	};

template<size_t _Idx,
	class _Ty,
	size_t _Size>
	struct tuple_element<_Idx, array<_Ty, _Size>>
	{	// struct to determine type of element _Idx in array
	static_assert(_Idx < _Size, "array index out of bounds");

	using type = _Ty;
	};


	// TUPLE INTERFACE TO tuple
template<class... _Types>
	struct tuple_size<tuple<_Types...>>
	: integral_constant<size_t, sizeof...(_Types)>
	{	// size of tuple
	};

template<size_t _Index>
	struct tuple_element<_Index, tuple<>>
	{	// enforce bounds checking
	static_assert(_Always_false<integral_constant<size_t, _Index>>,
		"tuple index out of bounds");
	};

template<class _This,
	class... _Rest>
	struct tuple_element<0, tuple<_This, _Rest...>>
	{	// select first element
	using type = _This;
	using _Ttype = tuple<_This, _Rest...>;
	};

template<size_t _Index,
	class _This,
	class... _Rest>
	struct tuple_element<_Index, tuple<_This, _Rest...>>
		: public tuple_element<_Index - 1, tuple<_Rest...>>
	{	// recursive tuple_element definition
	};

	// TUPLE INTERFACE TO pair
template<class _Ty1,
	class _Ty2>
	struct tuple_size<pair<_Ty1, _Ty2>>
	: integral_constant<size_t, 2>
	{	// size of pair
	};

template<size_t _Idx,
	class _Ty1,
	class _Ty2>
	struct tuple_element<_Idx, pair<_Ty1, _Ty2>>
	{	// struct to determine type of element _Idx in pair
	static_assert(_Idx < 2, "pair index out of bounds");

	using type = conditional_t<_Idx == 0, _Ty1, _Ty2>;
	};

template<class _Ret,
	class _Pair>
	constexpr _Ret _Pair_get(_Pair& _Pr,
		integral_constant<size_t, 0>) noexcept
	{	// get reference to element 0 in pair _Pr
	return (_Pr.first);
	}

template<class _Ret,
	class _Pair>
	constexpr _Ret _Pair_get(_Pair& _Pr,
		integral_constant<size_t, 1>) noexcept
	{	// get reference to element 1 in pair _Pr
	return (_Pr.second);
	}

template<size_t _Idx,
	class _Ty1,
	class _Ty2>
	 constexpr tuple_element_t<_Idx, pair<_Ty1, _Ty2>>&
		get(pair<_Ty1, _Ty2>& _Pr) noexcept
	{	// get reference to element at _Idx in pair _Pr
	using _Rtype = tuple_element_t<_Idx, pair<_Ty1, _Ty2>>&;
	return (_Pair_get<_Rtype>(_Pr, integral_constant<size_t, _Idx>()));
	}

template<class _Ty1,
	class _Ty2>
	 constexpr _Ty1& get(pair<_Ty1, _Ty2>& _Pr) noexcept
	{	// get reference to element _Ty1 in pair _Pr
	return (::std:: get<0>(_Pr));
	}

template<class _Ty2,
	class _Ty1>
	 constexpr _Ty2& get(pair<_Ty1, _Ty2>& _Pr) noexcept
	{	// get reference to element _Ty2 in pair _Pr
	return (::std:: get<1>(_Pr));
	}

template<size_t _Idx,
	class _Ty1,
	class _Ty2>
	 constexpr const tuple_element_t<_Idx, pair<_Ty1, _Ty2>>&
		get(const pair<_Ty1, _Ty2>& _Pr) noexcept
	{	// get const reference to element at _Idx in pair _Pr
	using _Ctype = const tuple_element_t<_Idx, pair<_Ty1, _Ty2>>&;
	return (_Pair_get<_Ctype>(_Pr, integral_constant<size_t, _Idx>()));
	}

template<class _Ty1,
	class _Ty2>
	 constexpr const _Ty1& get(const pair<_Ty1, _Ty2>& _Pr) noexcept
	{	// get const reference to element _Ty1 in pair _Pr
	return (::std:: get<0>(_Pr));
	}

template<class _Ty2,
	class _Ty1>
	 constexpr const _Ty2& get(const pair<_Ty1, _Ty2>& _Pr) noexcept
	{	// get const reference to element _Ty2 in pair _Pr
	return (::std:: get<1>(_Pr));
	}

template<size_t _Idx,
	class _Ty1,
	class _Ty2>
	 constexpr tuple_element_t<_Idx, pair<_Ty1, _Ty2>>&&
		get(pair<_Ty1, _Ty2>&& _Pr) noexcept
	{	// get rvalue reference to element at _Idx in pair _Pr
	using _RRtype = tuple_element_t<_Idx, pair<_Ty1, _Ty2>>&&;
	return (::std:: forward<_RRtype>(::std:: get<_Idx>(_Pr)));
	}

template<class _Ty1,
	class _Ty2>
	 constexpr _Ty1&& get(pair<_Ty1, _Ty2>&& _Pr) noexcept
	{	// get rvalue reference to element _Ty1 in pair _Pr
	return (::std:: get<0>(::std:: move(_Pr)));
	}

template<class _Ty2,
	class _Ty1>
	 constexpr _Ty2&& get(pair<_Ty1, _Ty2>&& _Pr) noexcept
	{	// get rvalue reference to element _Ty2 in pair _Pr
	return (::std:: get<1>(::std:: move(_Pr)));
	}

template<size_t _Idx,
	class _Ty1,
	class _Ty2>
	 constexpr const tuple_element_t<_Idx, pair<_Ty1, _Ty2>>&&
		get(const pair<_Ty1, _Ty2>&& _Pr) noexcept
	{	// get const rvalue reference to element at _Idx in pair _Pr
	using _RRtype = const tuple_element_t<_Idx, pair<_Ty1, _Ty2>>&&;
	return (::std:: forward<_RRtype>(::std:: get<_Idx>(_Pr)));
	}

template<class _Ty1,
	class _Ty2>
	 constexpr const _Ty1&& get(const pair<_Ty1, _Ty2>&& _Pr) noexcept
	{	// get const rvalue reference to element _Ty1 in pair _Pr
	return (::std:: get<0>(::std:: move(_Pr)));
	}

template<class _Ty2,
	class _Ty1>
	 constexpr const _Ty2&& get(const pair<_Ty1, _Ty2>&& _Pr) noexcept
	{	// get const rvalue reference to element _Ty2 in pair _Pr
	return (::std:: get<1>(::std:: move(_Pr)));
	}

	// FUNCTION TEMPLATE exchange
template<class _Ty,
	class _Other = _Ty> inline
	_Ty exchange(_Ty& _Val, _Other&& _New_val)
	{	// assign _New_val to _Val, return previous _Val
	_Ty _Old_val = ::std:: move(_Val);
	_Val = ::std:: forward<_Other>(_New_val);
	return (_Old_val);
	}

	// FUNCTION TEMPLATE as_const
template<class _Ty>
	 constexpr add_const_t<_Ty>& as_const(_Ty& _Val) noexcept
	{	// view _Val through const lenses
	return (_Val);
	}

template<class _Ty>
	void as_const(const _Ty&&) = delete;



























namespace [[deprecated("warning STL4002: " "The non-Standard std::tr1 namespace and TR1-only machinery are deprecated and will be REMOVED. You can " "define _SILENCE_TR1_NAMESPACE_DEPRECATION_WARNING to acknowledge that you have received this warning.")]] tr1 {
using ::std:: get;
using ::std:: tuple_element;
using ::std:: tuple_size;
}


}

 
 
 #pragma warning(pop)
 #pragma pack(pop)



/*
 * Copyright (c) by P.J. Plauger. All rights reserved.
 * Consult your license regarding permissions and restrictions.
V6.50:0009 */


 #pragma pack(push,8)
 #pragma warning(push,3)
 #pragma warning(disable: 4455 4494  4619 4643 4702 4984 4988 )
 
 
 


extern "C" {
// The "noalias" attribute tells the compiler optimizer that pointers going into these hand-vectorized algorithms
// won't be stored beyond the lifetime of the function, and that the function will only reference arrays denoted by
// those pointers. The optimizer also assumes in that case that a pointer parameter is not returned to the caller via
// the return value, so functions using "noalias" must usually return void. This attribute is valuable because these
// functions are in native code objects that the compiler cannot analyze. In the absence of the noalias attribute, the
// compiler has to assume that the denoted arrays are "globally address taken", and that any later calls to
// unanalyzable routines may modify those arrays.
__declspec(noalias) void __cdecl __std_reverse_trivially_swappable_1(void * _First, void * _Last) noexcept;
__declspec(noalias) void __cdecl __std_reverse_trivially_swappable_2(void * _First, void * _Last) noexcept;
__declspec(noalias) void __cdecl __std_reverse_trivially_swappable_4(void * _First, void * _Last) noexcept;
__declspec(noalias) void __cdecl __std_reverse_trivially_swappable_8(void * _First, void * _Last) noexcept;
}


namespace std {
		// CLASSES _Container_base*, _Iterator_base*
struct _Container_proxy;
struct _Container_base12;
struct _Iterator_base12;

struct _Container_base0
	{	// base of all containers
	void _Orphan_all() noexcept
		{	// orphan all iterators
		}

	void _Swap_all(_Container_base0&) noexcept
		{	// swap all iterators
		}
	};

struct _Iterator_base0
	{	// base of all iterators
	void _Adopt(const void *) noexcept
		{	// adopt this iterator by parent
		}

	const _Container_base0 *_Getcont() const noexcept
		{	// get owning container
		return (nullptr);
		}

	static constexpr bool _Unwrap_when_unverified = true;
	};

		// CLASS _Container_proxy
struct _Container_proxy
	{	// store head of iterator chain and back pointer
	_Container_proxy() noexcept
		: _Mycont(nullptr), _Myfirstiter(nullptr)
		{	// construct from pointers
		}

	const _Container_base12 *_Mycont;
	_Iterator_base12 *_Myfirstiter;
	};

struct _Container_base12
	{	// store pointer to _Container_proxy
public:
	_Container_base12()
		: _Myproxy(nullptr)
		{	// construct childless container
		}

	_Container_base12(const _Container_base12&) noexcept
		: _Myproxy(nullptr)
		{	// copy a container
		}

	_Container_base12& operator=(const _Container_base12&) noexcept
		{	// assign a container
		return (*this);
		}

	_Iterator_base12 **_Getpfirst() const noexcept
		{	// get address of iterator chain
		return (_Myproxy == nullptr ? nullptr : &_Myproxy->_Myfirstiter);
		}

	void _Orphan_all() noexcept;	// orphan all iterators
	void _Swap_all(_Container_base12&) noexcept;	// swap all iterators

	_Container_proxy *_Myproxy;
	};

struct _Iterator_base12
	{	// store links to container proxy, next iterator
	_Iterator_base12() noexcept
		: _Myproxy(nullptr), _Mynextiter(nullptr)
		{	// construct orphaned iterator
		}

	_Iterator_base12(const _Iterator_base12& _Right) noexcept
		: _Myproxy(nullptr), _Mynextiter(nullptr)
		{	// copy an iterator
		*this = _Right;
		}

	_Iterator_base12& operator=(const _Iterator_base12& _Right) noexcept
		{	// assign an iterator
		if (_Myproxy != _Right._Myproxy)
			{
			if (_Right._Myproxy == nullptr)
				{	// becoming invalid, disown current parent
 
				_Lockit _Lock(3);
				_Orphan_me();
 
				}
			else
				{
				_Adopt(_Right._Myproxy->_Mycont);
				}
			}

		return (*this);
		}

	~_Iterator_base12() noexcept
		{	// destroy the iterator
 
		_Lockit _Lock(3);
		_Orphan_me();
 
		}

	void _Adopt(const _Container_base12 *_Parent) noexcept
		{	// adopt this iterator by parent
		if (_Parent == nullptr)
			{	// no future parent, just disown current parent
 
			_Lockit _Lock(3);
			_Orphan_me();
 
			}
		else
			{	// have a parent, do adoption
			_Container_proxy *_Parent_proxy = _Parent->_Myproxy;

 
			if (_Myproxy != _Parent_proxy)
				{	// change parentage
				_Lockit _Lock(3);
				_Orphan_me();
				_Mynextiter = _Parent_proxy->_Myfirstiter;
				_Parent_proxy->_Myfirstiter = this;
				_Myproxy = _Parent_proxy;
				}

 


			}
		}

	void _Clrcont() noexcept
		{	// disown owning container
		_Myproxy = nullptr;
		}

	const _Container_base12 *_Getcont() const noexcept
		{	// get owning container
		return (_Myproxy == nullptr ? nullptr : _Myproxy->_Mycont);
		}

	_Iterator_base12 **_Getpnext() noexcept
		{	// get address of remaining iterator chain
		return (&_Mynextiter);
		}

	void _Orphan_me() noexcept
		{	// cut ties with parent
 
		if (_Myproxy != nullptr)
			{	// adopted, remove self from list
			_Iterator_base12 **_Pnext = &_Myproxy->_Myfirstiter;
			while (*_Pnext != nullptr && *_Pnext != this)
				_Pnext = &(*_Pnext)->_Mynextiter;

			do { if (*_Pnext) { } else { do { (void) ((1 != _CrtDbgReport(2, "c:\\visual studio\\vc\\tools\\msvc\\14.16.27023\\include\\xutility", 199, 0, "%s", "ITERATOR LIST CORRUPTED!")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"ITERATOR LIST CORRUPTED!\"", __LPREFIX( __FUNCTION__), L"c:\\visual studio\\vc\\tools\\msvc\\14.16.27023\\include\\xutility", 199, 0); } while (false); } ; } while (false);
			*_Pnext = _Mynextiter;
			_Myproxy = nullptr;
			}
 
		}

	static constexpr bool _Unwrap_when_unverified = 2 == 0;

	_Container_proxy *_Myproxy;
	_Iterator_base12 *_Mynextiter;
	};

		// MEMBER FUNCTIONS FOR _Container_base12
inline void _Container_base12::_Orphan_all() noexcept
	{	// orphan all iterators
 
	if (_Myproxy != nullptr)
		{	// proxy allocated, drain it
		_Lockit _Lock(3);

		for (_Iterator_base12 **_Pnext = &_Myproxy->_Myfirstiter;
			*_Pnext != nullptr; *_Pnext = (*_Pnext)->_Mynextiter)
			(*_Pnext)->_Myproxy = nullptr;
		_Myproxy->_Myfirstiter = nullptr;
		}
 
	}

inline void _Container_base12::_Swap_all(_Container_base12& _Right) noexcept
	{	// swap all iterators
 
	_Lockit _Lock(3);
 

	_Container_proxy *_Temp = _Myproxy;
	_Myproxy = _Right._Myproxy;
	_Right._Myproxy = _Temp;

	if (_Myproxy != nullptr)
		_Myproxy->_Mycont = (_Container_base12 *)this;
	if (_Right._Myproxy != nullptr)
		_Right._Myproxy->_Mycont = (_Container_base12 *)&_Right;
	}

 




using _Container_base = _Container_base12;
using _Iterator_base = _Iterator_base12;
 

	// CLASS TEMPLATE _Compressed_pair
struct _Zero_then_variadic_args_t
	{	// tag type for value-initializing first,
	};	// constructing second from remaining args

struct _One_then_variadic_args_t
	{	// tag type for constructing first from one arg,
	};	// constructing second from remaining args

template<class _Ty1,
	class _Ty2,
	bool = is_empty_v<_Ty1> && !is_final_v<_Ty1>>
	class _Compressed_pair final
		: private _Ty1
	{	// store a pair of values, deriving from empty first
private:
	_Ty2 _Myval2;

	using _Mybase = _Ty1;	// for visualization

public:
	template<class... _Other2>
		constexpr explicit _Compressed_pair(_Zero_then_variadic_args_t,
			_Other2&&... _Val2)
		: _Ty1(), _Myval2(::std:: forward<_Other2>(_Val2)...)
		{	// construct from forwarded values
		}

	template<class _Other1,
		class... _Other2>
		_Compressed_pair(_One_then_variadic_args_t,
			_Other1&& _Val1, _Other2&&... _Val2)
		: _Ty1(::std:: forward<_Other1>(_Val1)),
			_Myval2(::std:: forward<_Other2>(_Val2)...)
		{	// construct from forwarded values
		}

	_Ty1& _Get_first() noexcept
		{	// return reference to first
		return (*this);
		}

	const _Ty1& _Get_first() const noexcept
		{	// return const reference to first
		return (*this);
		}

	_Ty2& _Get_second() noexcept
		{	// return reference to second
		return (_Myval2);
		}

	const _Ty2& _Get_second() const noexcept
		{	// return const reference to second
		return (_Myval2);
		}
	};

template<class _Ty1,
	class _Ty2>
	class _Compressed_pair<_Ty1, _Ty2, false> final
	{	// store a pair of values, not deriving from first
private:
	_Ty1 _Myval1;
	_Ty2 _Myval2;

public:
	template<class... _Other2>
		constexpr explicit _Compressed_pair(_Zero_then_variadic_args_t,
			_Other2&&... _Val2)
		: _Myval1(), _Myval2(::std:: forward<_Other2>(_Val2)...)
		{	// construct from forwarded values
		}

	template<class _Other1,
		class... _Other2>
		_Compressed_pair(_One_then_variadic_args_t,
			_Other1&& _Val1, _Other2&&... _Val2)
		: _Myval1(::std:: forward<_Other1>(_Val1)),
			_Myval2(::std:: forward<_Other2>(_Val2)...)
		{	// construct from forwarded values
		}

	_Ty1& _Get_first() noexcept
		{	// return reference to first
		return (_Myval1);
		}

	const _Ty1& _Get_first() const noexcept
		{	// return const reference to first
		return (_Myval1);
		}

	_Ty2& _Get_second() noexcept
		{	// return reference to second
		return (_Myval2);
		}

	const _Ty2& _Get_second() const noexcept
		{	// return const reference to second
		return (_Myval2);
		}
	};

		// FUNCTION TEMPLATE _Pass_fn
		// TRANSITION, VSO#386225
template<class _Fx>
	struct _Ref_fn
	{	// pass function object by value as a reference
	template<class... _Args>
		constexpr decltype(auto) operator()(_Args&&... _Vals)
		{	// forward function call operator
		return (_Fn(::std:: forward<_Args>(_Vals)...));
		}

	_Fx& _Fn;
	};

template<class _Fn>
	 constexpr bool _Pass_functor_by_value_v = sizeof(_Fn) <= sizeof(void *)
		&& conjunction_v<
			is_trivially_copy_constructible<_Fn>,
			is_trivially_destructible<_Fn>>;

template<class _Fn,
	enable_if_t<_Pass_functor_by_value_v<_Fn>, int> = 0>
	constexpr _Fn _Pass_fn(_Fn _Val)
	{	// pass functor by value
	return (_Val);
	}

template<class _Fn,
	enable_if_t<!_Pass_functor_by_value_v<_Fn>, int> = 0>
	constexpr _Ref_fn<_Fn> _Pass_fn(_Fn& _Val)
	{	// pass functor by "reference"
	return {_Val};
	}

		// ITERATOR STUFF (from <iterator>)
		// ITERATOR TAGS (from <iterator>)
struct input_iterator_tag
	{	// identifying tag for input iterators
	};

struct output_iterator_tag
	{	// identifying tag for output iterators
	};

struct forward_iterator_tag
	: input_iterator_tag
	{	// identifying tag for forward iterators
	};

struct bidirectional_iterator_tag
	: forward_iterator_tag
	{	// identifying tag for bidirectional iterators
	};

struct random_access_iterator_tag
	: bidirectional_iterator_tag
	{	// identifying tag for random-access iterators
	};

		// POINTER ITERATOR TAGS
struct _General_ptr_iterator_tag
	{	// general case, no special optimizations
	};

struct _Trivially_copyable_ptr_iterator_tag
	: _General_ptr_iterator_tag
	{	// iterator is a pointer to a trivially copyable type
	};

struct _Really_trivial_ptr_iterator_tag
	: _Trivially_copyable_ptr_iterator_tag
	{	// iterator is a pointer to a trivial type
	};

		// STRUCT _Unused_parameter
struct _Unused_parameter
	{	// generic unused parameter struct
	constexpr _Unused_parameter() noexcept = default;
	template<class _Ty>
		constexpr _Unused_parameter(_Ty&&) noexcept {}
	};

		// ALIAS _Any_tag
using _Any_tag = _Unused_parameter; // generic fallback/default/"other" target for tag dispatch

		// ALIAS TEMPLATE _Algorithm_int_t
template<class _Ty>
	using _Algorithm_int_t = conditional_t<is_integral_v<_Ty>, _Ty, ptrdiff_t>;

		// STRUCT TEMPLATE iterator_traits
template<class,
	class = void>
	struct _Iterator_traits_base
	{	// empty for non-iterators
	};

template<class _Iter>
	struct _Iterator_traits_base<_Iter, void_t<
		typename _Iter::iterator_category,
		typename _Iter::value_type,
		typename _Iter::difference_type,
		typename _Iter::pointer,
		typename _Iter::reference
		>>
	{	// defined if _Iter::* types exist
	using iterator_category = typename _Iter::iterator_category;
	using value_type = typename _Iter::value_type;
	using difference_type = typename _Iter::difference_type;

	using pointer = typename _Iter::pointer;
	using reference = typename _Iter::reference;
	};

template<class _Ty,
	bool = is_object_v<_Ty>>
	struct _Iterator_traits_pointer_base
	{	// iterator properties for pointers to object
	using iterator_category = random_access_iterator_tag;
	using value_type = remove_cv_t<_Ty>;
	using difference_type = ptrdiff_t;

	using pointer = _Ty *;
	using reference = _Ty&;
	};

template<class _Ty>
	struct _Iterator_traits_pointer_base<_Ty, false>
	{	// iterator properties for pointers to non-object
		// not actually iterators, as no arithmetic is possible -> no members
	};

template<class _Iter>
	struct iterator_traits
		: _Iterator_traits_base<_Iter>
	{	// get traits from iterator _Iter, if possible
	};

template<class _Ty>
	struct iterator_traits<_Ty *>
		: _Iterator_traits_pointer_base<_Ty>
	{	// get traits from pointer, if possible
	};

		// ALIAS TEMPLATE _Iter_value_t
template<class _Iter>
	using _Iter_value_t = typename iterator_traits<_Iter>::value_type;

		// ALIAS TEMPLATE _Iter_diff_t
template<class _Iter>
	using _Iter_diff_t = typename iterator_traits<_Iter>::difference_type;

		// ALIAS TEMPLATE _Common_diff_t
template<class... _Iters>
	using _Common_diff_t = common_type_t<_Iter_diff_t<_Iters>...>;

		// ALIAS TEMPLATE _Iter_cat_t
template<class _Iter>
	using _Iter_cat_t = typename iterator_traits<_Iter>::iterator_category;

		// VARIABLE TEMPLATE _Is_iterator_v
template<class _Ty,
	class = void>
	 constexpr bool _Is_iterator_v = false;

template<class _Ty>
	 constexpr bool _Is_iterator_v<_Ty, void_t<_Iter_cat_t<_Ty>>> = true;

		// TRAIT _Is_iterator
template<class _Ty>
	struct _Is_iterator
		: bool_constant<_Is_iterator_v<_Ty>>
	{
	};

		// VARIABLE TEMPLATE _Is_input_iter_v
template<class _Iter>
	 constexpr bool _Is_input_iter_v = is_convertible_v<_Iter_cat_t<_Iter>, input_iterator_tag>;

		// VARIABLE TEMPLATE _Is_fwd_iter_v
template<class _Iter>
	 constexpr bool _Is_fwd_iter_v = is_convertible_v<_Iter_cat_t<_Iter>, forward_iterator_tag>;

		// VARIABLE TEMPLATE _Is_bidi_iter_v
template<class _Iter>
	 constexpr bool _Is_bidi_iter_v = is_convertible_v<_Iter_cat_t<_Iter>, bidirectional_iterator_tag>;

		// VARIABLE TEMPLATE _Is_random_iter_v
template<class _Iter>
	 constexpr bool _Is_random_iter_v = is_convertible_v<_Iter_cat_t<_Iter>, random_access_iterator_tag>;

		// STRUCT TEMPLATE _Is_checked_helper
template<class,
	class = void>
	struct _Is_checked_helper
	{	// default definition, no longer used, retained due to pseudo-documentation
	};

		// FUNCTION TEMPLATE _Adl_verify_range

template<class _Ty>
	constexpr void _Verify_range(const _Ty * const _First, const _Ty * const _Last) noexcept
	{	// special case range verification for pointers
	do { if (_First <= _Last) { } else { do { (void) ((1 != _CrtDbgReport(2, "c:\\visual studio\\vc\\tools\\msvc\\14.16.27023\\include\\xutility", 559, 0, "%s", "transposed pointer range")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"transposed pointer range\"", __LPREFIX( __FUNCTION__), L"c:\\visual studio\\vc\\tools\\msvc\\14.16.27023\\include\\xutility", 559, 0); } while (false); } ; } while (false);
	}


template<class _Iter,
	class _Sentinel = _Iter,
	class = void>
	struct _Range_verifiable
		: false_type
	{
	};

template<class _Iter,
	class _Sentinel>
	struct _Range_verifiable<_Iter, _Sentinel, void_t<
		decltype(_Verify_range(::std:: declval<const _Iter&>(), ::std:: declval<const _Sentinel&>()))>>
		: true_type
	{
	};

template<class _Iter,
	class _Sentinel = _Iter>
	 constexpr bool _Range_verifiable_v = _Range_verifiable<_Iter, _Sentinel>::value;

















template<class _Iter,
	class _Sentinel>
	constexpr void _Adl_verify_range1(const _Iter& _First, const _Sentinel& _Last, true_type)
	{	// check that [_First, _Last) forms an iterator range
	_Verify_range(_First, _Last);
	}

template<class _Iter,
	class _Sentinel>
	constexpr void _Adl_verify_range1(const _Iter&, const _Sentinel&, false_type)
	{	// (don't) check that [_First, _Last) forms an iterator range
	}

template<class _Iter,
	class _Sentinel>
	constexpr void _Adl_verify_range(const _Iter& _First, const _Sentinel& _Last)
	{	// check that [_First, _Last) forms an iterator range
	_Adl_verify_range1(_First, _Last, bool_constant<_Range_verifiable_v<_Iter, _Sentinel>>{});
	}



		// FUNCTION TEMPLATE _Get_unwrapped
template<class _Iter,
	class = void>
	struct _Unwrappable
		: false_type
	{
	};

template<class _Iter>
	struct _Unwrappable<_Iter, void_t<
		decltype(::std:: declval<_Iter&>()._Seek_to(::std:: declval<const _Iter&>()._Unwrapped()))>>
		: true_type
	{
	};

template<class _Iter>
	 constexpr bool _Unwrappable_v = _Unwrappable<_Iter>::value;

template<class _Iter,
	enable_if_t<_Unwrappable_v<_Iter>, int> = 0>
	 constexpr auto _Get_unwrapped(const _Iter& _It)
	{	// unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
	return (_It._Unwrapped());
	}

template<class _Iter,
	enable_if_t<!_Unwrappable_v<_Iter>, int> = 0>
	 constexpr const _Iter& _Get_unwrapped(const _Iter& _It)
	{	// (don't) unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
	return (_It);
	}

template<class _Iter,
	enable_if_t<!_Unwrappable_v<_Iter>, int> = 0>
	 constexpr const _Iter&& _Get_unwrapped(const _Iter&& _It)
	{	// (don't) unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
	return (static_cast<const _Iter&&>(_It));
	}

template<class _Ty>
	 constexpr _Ty * _Get_unwrapped(_Ty * const _Ptr)
	{	// special case already-unwrapped pointers
	return (_Ptr);
	}

template<class _Iter>
	using _Unwrapped_t = remove_cv_t<remove_reference_t<decltype(_Get_unwrapped(::std:: declval<const _Iter&>()))>>;

		// FUNCTION TEMPLATE _Get_unwrapped_unverified
template<class _Iter,
	class = bool>
	struct _Do_unwrap_when_unverified
		: false_type
	{
	};

template<class _Iter>
	struct _Do_unwrap_when_unverified<_Iter, decltype(static_cast<bool>(_Iter::_Unwrap_when_unverified))>
		: bool_constant<static_cast<bool>(_Iter::_Unwrap_when_unverified)>
	{
	};

template<class _Iter>
	 constexpr bool _Do_unwrap_when_unverified_v = _Do_unwrap_when_unverified<_Iter>::value;

template<class _Iter>
	 constexpr bool _Unwrappable_for_unverified_v = _Unwrappable_v<_Iter>
		&& _Do_unwrap_when_unverified_v<_Iter>;

template<class _Iter,
	enable_if_t<_Unwrappable_for_unverified_v<_Iter>, int> = 0>
	 constexpr auto _Get_unwrapped_unverified(const _Iter& _It)
	{	// unwrap an iterator not previously subjected to _Adl_verify_range
	return (_It._Unwrapped());
	}

template<class _Iter,
	enable_if_t<!_Unwrappable_for_unverified_v<_Iter>, int> = 0>
	 constexpr const _Iter& _Get_unwrapped_unverified(const _Iter& _It)
	{	// (don't) unwrap an iterator not previously subjected to _Adl_verify_range
	return (_It);
	}

template<class _Iter,
	enable_if_t<!_Unwrappable_for_unverified_v<_Iter>, int> = 0>
	 constexpr const _Iter&& _Get_unwrapped_unverified(const _Iter&& _It)
	{	// (don't) unwrap an iterator not previously subjected to _Adl_verify_range
	return (static_cast<const _Iter&&>(_It));
	}

template<class _Ty>
	 constexpr _Ty * _Get_unwrapped_unverified(_Ty * const _Ptr)
	{	// special case already-unwrapped pointers
	return (_Ptr);
	}

template<class _Iter>
	using _Unwrapped_unverified_t = remove_cv_t<remove_reference_t<
		decltype(_Get_unwrapped_unverified(::std:: declval<const _Iter&>()))>>;

		// FUNCTION TEMPLATE _Get_unwrapped_n
struct _Distance_unknown
	{
	constexpr _Distance_unknown operator-() const noexcept
		{
		return {};
		}
	};

template<class _Diff>
	 constexpr _Diff _Max_possible_v = static_cast<_Diff>(static_cast<make_unsigned_t<_Diff>>(-1) >> 1);

template<class _Diff>
	 constexpr _Diff _Min_possible_v = -_Max_possible_v<_Diff> - 1;

template<class _Iter,
	class = void>
	struct _Offset_verifiable
		: false_type
	{
	};

template<class _Iter>
	struct _Offset_verifiable<_Iter, void_t<decltype(
		::std:: declval<const _Iter&>()._Verify_offset(_Iter_diff_t<_Iter>{}))>>
		: true_type
	{
	};

template<class _Iter>
	 constexpr bool _Offset_verifiable_v = _Offset_verifiable<_Iter>::value;

template<class _Iter>
	 constexpr bool _Unwrappable_for_offset_v = _Unwrappable_v<_Iter> && _Offset_verifiable_v<_Iter>;

template<class _Iter,
	class _Diff,
	enable_if_t<_Unwrappable_for_offset_v<_Iter> && is_integral_v<_Diff>, int> = 0>
	 constexpr auto _Get_unwrapped_n(const _Iter& _It, const _Diff _Off)
	{	// ask an iterator to assert that the iterator moved _Off positions is valid, and unwrap
	using _IDiff = _Iter_diff_t<_Iter>;
	using _CDiff = common_type_t<_Diff, _IDiff>;
	const auto _COff = static_cast<_CDiff>(_Off);

	do { if (_COff <= static_cast<_CDiff>(_Max_possible_v<_IDiff>) && (is_unsigned_v<_Diff> || static_cast<_CDiff>(_Min_possible_v<_IDiff>) <= _COff)) { } else { do { (void) ((1 != _CrtDbgReport(2, "c:\\visual studio\\vc\\tools\\msvc\\14.16.27023\\include\\xutility", 767, 0, "%s", "integer overflow")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"integer overflow\"", __LPREFIX( __FUNCTION__), L"c:\\visual studio\\vc\\tools\\msvc\\14.16.27023\\include\\xutility", 767, 0); } while (false); } ; } while (false);
	(void) _COff;

	_It._Verify_offset(static_cast<_IDiff>(_Off));
	return (_It._Unwrapped());
	}

template<class _Iter,
	class _Diff,
	enable_if_t<_Unwrappable_for_unverified_v<_Iter>
		&& ((!_Unwrappable_for_offset_v<_Iter> && is_integral_v<_Diff>)
			|| is_same_v<_Diff, _Distance_unknown>), int> = 0>
	 constexpr auto _Get_unwrapped_n(const _Iter& _It, _Diff)
	{	// iterator doesn't support offset-based asserts, or offset unknown; defer to unverified unwrap
	return (_It._Unwrapped());
	}

template<class _Iter,
	class _Diff,
	enable_if_t<!_Unwrappable_for_unverified_v<_Iter>
		&& ((!_Unwrappable_for_offset_v<_Iter> && is_integral_v<_Diff>)
			|| is_same_v<_Diff, _Distance_unknown>), int> = 0>
	 constexpr const _Iter& _Get_unwrapped_n(const _Iter& _It, _Diff)
	{	// pass through lvalue iterator that doesn't participate in checking
	return (_It);
	}

template<class _Iter,
	class _Diff,
	enable_if_t<!_Unwrappable_for_unverified_v<_Iter>
		&& ((!_Unwrappable_for_offset_v<_Iter> && is_integral_v<_Diff>)
			|| is_same_v<_Diff, _Distance_unknown>), int> = 0>
	 constexpr const _Iter&& _Get_unwrapped_n(const _Iter&& _It, _Diff)
	{	// pass through rvalue iterator that doesn't participate in checking
	return (static_cast<const _Iter&&>(_It));
	}

template<class _Ty,
	class _Diff,
	enable_if_t<is_same_v<_Diff, _Distance_unknown> || is_integral_v<_Diff>, int> = 0>
	 constexpr _Ty * _Get_unwrapped_n(_Ty * const _Src, _Diff)
	{
	return (_Src);
	}

template<class _Iter>
	using _Unwrapped_n_t = remove_cv_t<remove_reference_t<
		decltype(_Get_unwrapped_n(::std:: declval<const _Iter&>(), _Iter_diff_t<_Iter>{}))>>;

		// FUNCTION TEMPLATE _Seek_wrapped
template<class _Iter,
	class _UIter,
	class = void>
	struct _Wrapped_seekable
		: false_type
	{
	};

template<class _Iter,
	class _UIter>
	struct _Wrapped_seekable<_Iter, _UIter, void_t<
		decltype(::std:: declval<_Iter&>()._Seek_to(::std:: declval<const _UIter&>()))>>
		: true_type
	{
	};

template<class _Iter,
	class _UIter>
	 constexpr bool _Wrapped_seekable_v = _Wrapped_seekable<_Iter, _UIter>::value;
















template<class _Iter,
	class _UIter,
	enable_if_t<_Wrapped_seekable_v<_Iter, _UIter>, int> = 0>
	constexpr void _Seek_wrapped(_Iter& _It, const _UIter& _UIt)
	{
	_It._Seek_to(_UIt);
	}

template<class _Iter,
	class _UIter,
	enable_if_t<!_Wrapped_seekable_v<_Iter, _UIter>, int> = 0>
	constexpr void _Seek_wrapped(_Iter& _It, const _UIter& _UIt)
	{
	_It = _UIt;
	}


template<class _Ty>
	constexpr void _Seek_wrapped(_Ty *& _It, _Ty * const _UIt)
	{
	_It = _UIt;
	}































		// STRUCT TEMPLATE _Priority_tag
template<size_t _Value>
	struct _Priority_tag
		: _Priority_tag<_Value - 1>
	{	// priority tag for tag dispatch
	};

template<>
	struct _Priority_tag<0>
	{	// base case priority tag for tag dispatch
	};























		// FUNCTION TEMPLATE _Idl_distance

















template<class _Checked,
	class _Iter> inline
	_Distance_unknown _Idl_distance1(const _Iter&, const _Iter&, input_iterator_tag)
	{	// _Idl_distance for non-random-access iterators
	return {};
	}

template<class _Checked,
	class _Iter> inline
	_Iter_diff_t<_Checked> _Idl_distance1(const _Iter& _First, const _Iter& _Last, random_access_iterator_tag)
	{	// _Idl_distance for random-access iterators
	return (static_cast<_Iter_diff_t<_Checked>>(_Last - _First));
	}

template<class _Checked,
	class _Iter> inline
	auto _Idl_distance(const _Iter& _First, const _Iter& _Last)
	{	// tries to get the distance between _First and _Last if they are random-access iterators
	return (_Idl_distance1<_Checked>(_First, _Last, _Iter_cat_t<_Iter>()));
	}


		// STRUCT TEMPLATE _Is_same_size
template<class _Ty1,
	class _Ty2>
	struct _Is_same_size
		: bool_constant<sizeof(_Ty1) == sizeof(_Ty2)>
	{	// determine whether two types have the same size
	};

		// STRUCT TEMPLATE _Unwrap_enum AND ALIAS
template<class _Elem,
	bool _Is_enum = is_enum_v<_Elem>>
	struct _Unwrap_enum
	{	// if _Elem is an enum, gets its underlying type; otherwise leaves _Elem unchanged
	using type = underlying_type_t<_Elem>;
	};

template<class _Elem>
	struct _Unwrap_enum<_Elem, false>
	{	// passthrough non-enum type
	using type = _Elem;
	};

template<class _Elem>
	using _Unwrap_enum_t = typename _Unwrap_enum<_Elem>::type;

		// STRUCT TEMPLATE _Both_or_neither_bool
template<class _Ty1,
	class _Ty2>
	struct _Both_or_neither_bool
		: bool_constant<is_same_v<bool, _Ty1> == is_same_v<bool, _Ty2>>
	{	// determines if both _Ty1 and _Ty2 are exactly bool, or neither are
	};

		// FUNCTION TEMPLATES _Ptr_copy_cat AND _Ptr_move_cat
template<class _Source,
	class _Dest>
	struct _Ptr_cat_helper
	{	// determines _Ptr_cat's result in the most general case
	using _USource = _Unwrap_enum_t<_Source>;
	using _UDest = _Unwrap_enum_t<_Dest>;
	using type = conditional_t<conjunction_v<
			_Is_same_size<_USource, _UDest>,
			is_integral<_USource>,
			is_integral<_UDest>,
			_Both_or_neither_bool<_USource, _UDest>
		>, _Really_trivial_ptr_iterator_tag, _General_ptr_iterator_tag>;
	};

template<class _Elem>
	struct _Ptr_cat_helper<_Elem, _Elem>
	{	// determines _Ptr_cat's result when the types are the same
	using type = conditional_t<
		is_trivially_copyable_v<_Elem>,
		conditional_t<is_trivial_v<_Elem>,
			_Really_trivial_ptr_iterator_tag,
			_Trivially_copyable_ptr_iterator_tag>,
		_General_ptr_iterator_tag>;
	};

template<class _Anything>
	struct _Ptr_cat_helper<_Anything *, const _Anything *>
	{	// determines _Ptr_cat's result when all we do is add const to a pointer
	using type = _Really_trivial_ptr_iterator_tag;
	};

template<class _Anything>
	struct _Ptr_cat_helper<_Anything *, volatile _Anything *>
	{	// determines _Ptr_cat's result when all we do is add volatile to a pointer
	using type = _Really_trivial_ptr_iterator_tag;
	};

template<class _Anything>
	struct _Ptr_cat_helper<_Anything *, const volatile _Anything *>
	{	// determines _Ptr_cat's result when all we do is add cv to a pointer
	using type = _Really_trivial_ptr_iterator_tag;
	};

template<class _Source,
	class _Dest> inline
	_General_ptr_iterator_tag _Ptr_copy_cat(const _Source&, const _Dest&)
	{	// return pointer copy optimization category for arbitrary iterators
	return {};
	}

template<class _Source,
	class _Dest> inline
	conditional_t<is_trivially_assignable_v<_Dest&, _Source&>,
		typename _Ptr_cat_helper<remove_cv_t<_Source>, remove_cv_t<_Dest>>::type,
		_General_ptr_iterator_tag>
		_Ptr_copy_cat(_Source * const&, _Dest * const&)
	{	// return pointer copy optimization category for pointers
	return {};
	}

template<class _Source,
	class _Dest> inline
	_General_ptr_iterator_tag _Ptr_move_cat(const _Source&, const _Dest&)
	{	// return pointer move optimization category for arbitrary iterators
	return {};
	}

template<class _Source,
	class _Dest> inline
	conditional_t<is_trivially_assignable_v<_Dest&, _Source>,
		typename _Ptr_cat_helper<remove_cv_t<_Source>, remove_cv_t<_Dest>>::type,
		_General_ptr_iterator_tag>
		_Ptr_move_cat(_Source * const&, _Dest * const&)
	{	// return pointer move optimization category for pointers
	return {};
	}

		// DEBUG TESTING MACROS

 





  
  
  


		// FUNCTION TEMPLATE _Debug_lt_pred
template<class _Pr,
	class _Ty1,
	class _Ty2>
	constexpr bool _Debug_lt_pred(_Pr&& _Pred, _Ty1&& _Left, _Ty2&& _Right)
		noexcept(noexcept(_Pred(_Left, _Right)) && noexcept(_Pred(_Right, _Left)))
	{	// test if _Pred(_Left, _Right) and _Pred is strict weak ordering
	const auto _Result = static_cast<bool>(_Pred(_Left, _Right));
	if (_Result)
		{
		do { if (!_Pred(_Right, _Left)) { } else { do { (void) ((1 != _CrtDbgReport(2, "c:\\visual studio\\vc\\tools\\msvc\\14.16.27023\\include\\xutility", 1113, 0, "%s", "invalid comparator")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"invalid comparator\"", __LPREFIX( __FUNCTION__), L"c:\\visual studio\\vc\\tools\\msvc\\14.16.27023\\include\\xutility", 1113, 0); } while (false); } ; } while (false);
		}

	return (_Result);
	}

		// FUNCTION TEMPLATE _Debug_order_unchecked
template<class _InIt,
	class _Sentinel,
	class _Pr> inline
	void _Debug_order_unchecked2(_InIt, _Sentinel, _Pr&, input_iterator_tag)
	{	// (don't) test if range is ordered by predicate, input iterators
	}

template<class _FwdIt,
	class _Sentinel,
	class _Pr> inline
	void _Debug_order_unchecked2(_FwdIt _First, _Sentinel _Last, _Pr& _Pred, forward_iterator_tag)
	{	// test if range is ordered by predicate, forward iterators
	if (_First != _Last)
		{
		for (_FwdIt _Next = _First; ++_Next != _Last; _First = _Next)
			{
			do { if (!_Debug_lt_pred(_Pred, *_Next, *_First)) { } else { do { (void) ((1 != _CrtDbgReport(2, "c:\\visual studio\\vc\\tools\\msvc\\14.16.27023\\include\\xutility", 1136, 0, "%s", "sequence not ordered")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"sequence not ordered\"", __LPREFIX( __FUNCTION__), L"c:\\visual studio\\vc\\tools\\msvc\\14.16.27023\\include\\xutility", 1136, 0); } while (false); } ; } while (false);
			}
		}
	}

template<class _InIt,
	class _Sentinel,
	class _Pr> inline
	void _Debug_order_unchecked(_InIt _First, _Sentinel _Last, _Pr&& _Pred)
	{	// test if range is ordered by predicate
	_Debug_order_unchecked2(_First, _Last, _Pred, _Iter_cat_t<_InIt>());
	}

		// FUNCTION TEMPLATE _Debug_order_set_unchecked
template<class _InIt,
	class _Pr> inline
	void _Debug_order_set_unchecked2(_InIt, _InIt, _Pr&, input_iterator_tag, _Priority_tag<0>)
	{	// (don't) test if range is ordered by predicate, input iterators or different types
	}

template<class _FwdIt,
	class _Pr> inline
	void _Debug_order_set_unchecked2(_FwdIt _First, _FwdIt _Last, _Pr& _Pred, forward_iterator_tag, _Priority_tag<1>)
	{	// test if range is ordered by predicate, forward iterators and same types
	_Debug_order_unchecked2(_First, _Last, _Pred, forward_iterator_tag{});
	}

template<class _OtherIt,
	class _InIt,
	class _Pr> inline
	void _Debug_order_set_unchecked(_InIt _First, _InIt _Last, _Pr&& _Pred)
	{	// test if range is ordered by predicate
	_Debug_order_set_unchecked2(_First, _Last, _Pred, _Iter_cat_t<_InIt>(),
		_Priority_tag<is_same<_Iter_value_t<_OtherIt>, _Iter_value_t<_InIt>>::value>());
	}
 

		// MORE ITERATOR STUFF (from <iterator>)
		// FUNCTION TEMPLATE advance
template<class _InIt,
	class _Diff>
	inline void _Advance1(_InIt& _Where, _Diff _Off, input_iterator_tag)
	{	// increment iterator by offset, input iterators
	do { if (_Off >= 0) { } else { do { (void) ((1 != _CrtDbgReport(2, "c:\\visual studio\\vc\\tools\\msvc\\14.16.27023\\include\\xutility", 1179, 0, "%s", "negative advance of non-bidirectional iterator")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"negative advance of non-bidirectional iterator\"", __LPREFIX( __FUNCTION__), L"c:\\visual studio\\vc\\tools\\msvc\\14.16.27023\\include\\xutility", 1179, 0); } while (false); } ; } while (false);
	for (; 0 < _Off; --_Off)
		{
		++_Where;
		}
	}

template<class _BidIt,
	class _Diff>
	inline void _Advance1(_BidIt& _Where, _Diff _Off, bidirectional_iterator_tag)
	{	// increment iterator by offset, bidirectional iterators
	for (; 0 < _Off; --_Off)
		{
		++_Where;
		}

	// the following warning is triggered if _Diff is unsigned
#pragma warning(suppress: 6294)	
								// Loop body not executed.
	for (; _Off < 0; ++_Off)
		{
		--_Where;
		}
	}

template<class _RanIt,
	class _Diff>
	inline void _Advance1(_RanIt& _Where, _Diff _Off, random_access_iterator_tag)
	{	// increment iterator by offset, random-access iterators
	_Where += _Off;
	}

template<class _InIt,
	class _Diff>
	inline void advance(_InIt& _Where, _Diff _Off)
	{	// increment iterator by offset, arbitrary iterators
		// we remove_const_t before _Iter_cat_t for better diagnostics if the user passes an iterator that is const
	_Advance1(_Where, _Off, _Iter_cat_t<remove_const_t<_InIt>>());
	}

		// FUNCTION TEMPLATE distance
template<class _InIt>
	inline _Iter_diff_t<_InIt> _Distance1(_InIt _First, _InIt _Last, input_iterator_tag)
	{	// return distance between iterators; input
	_Iter_diff_t<_InIt> _Off = 0;
	for (; _First != _Last; ++_First)
		{
		++_Off;
		}

	return (_Off);
	}

template<class _RanIt>
	inline _Iter_diff_t<_RanIt> _Distance1(_RanIt _First, _RanIt _Last, random_access_iterator_tag)
	{	// return distance between iterators; random-access
	return (_Last - _First);
	}

template<class _InIt>
	 inline _Iter_diff_t<_InIt> distance(_InIt _First, _InIt _Last)
	{	// return distance between iterators
	return (_Distance1(_First, _Last, _Iter_cat_t<_InIt>()));
	}

		// FUNCTION TEMPLATE _Next_iter
template<class _InIt>
	constexpr _InIt _Next_iter(_InIt _First)
	{	// increment iterator
	return (++_First);
	}

		// FUNCTION TEMPLATE next
template<class _InIt>
	 inline _InIt next(_InIt _First, _Iter_diff_t<_InIt> _Off = 1)
	{	// increment iterator
	static_assert(_Is_input_iter_v<_InIt>, "next requires input iterator");

	::std:: advance(_First, _Off);
	return (_First);
	}

		// FUNCTION TEMPLATE _Prev_iter
template<class _BidIt>
	constexpr _BidIt _Prev_iter(_BidIt _First)
	{	// decrement iterator
	return (--_First);
	}

		// FUNCTION TEMPLATE prev
template<class _BidIt>
	 inline _BidIt prev(_BidIt _First, _Iter_diff_t<_BidIt> _Off = 1)
	{	// decrement iterator
	static_assert(_Is_bidi_iter_v<_BidIt>, "prev requires bidirectional iterator");

	::std:: advance(_First, -_Off);
	return (_First);
	}

		// CLASS TEMPLATE reverse_iterator
template<class _Ty>
	struct pointer_traits;

template<class _Iterator>
	constexpr _Iterator _Operator_arrow(_Iterator _Target, true_type)
	{	// return operator-> where _Iterator is a pointer
	return (_Target);
	}

template<class _Iterator>
	constexpr decltype(auto) _Operator_arrow(_Iterator&& _Target, false_type)
	{	// return operator-> where _Iterator is a class type
	return (::std:: forward<_Iterator>(_Target).operator->());
	}

template<class _BidIt>
	class reverse_iterator
	{	// wrap iterator to run it backwards
public:
	using iterator_category = typename iterator_traits<_BidIt>::iterator_category;
	using value_type = typename iterator_traits<_BidIt>::value_type;
	using difference_type = typename iterator_traits<_BidIt>::difference_type;
	using pointer = typename iterator_traits<_BidIt>::pointer;
	using reference = typename iterator_traits<_BidIt>::reference;

	using iterator_type = _BidIt;

	inline reverse_iterator()
		: current()
		{	// construct with value-initialized wrapped iterator
		}

	inline explicit reverse_iterator(_BidIt _Right)
		: current(_Right)
		{	// construct wrapped iterator from _Right
		}

	template<class _Other>
		inline reverse_iterator(const reverse_iterator<_Other>& _Right)
		: current(_Right.base())
		{	// initialize with compatible base
		}

	template<class _Other>
		inline reverse_iterator& operator=(const reverse_iterator<_Other>& _Right)
		{	// assign from compatible base
		current = _Right.base();
		return (*this);
		}

	 inline _BidIt base() const
		{	// return wrapped iterator
		return (current);
		}

	 inline reference operator*() const
		{	// return designated value
		_BidIt _Tmp = current;
		return (*--_Tmp);
		}

	 inline pointer operator->() const
		{	// return pointer to class object
		_BidIt _Tmp = current;
		--_Tmp;
		return (_Operator_arrow(_Tmp, is_pointer<_BidIt>()));
		}

	inline reverse_iterator& operator++()
		{	// preincrement
		--current;
		return (*this);
		}

	inline reverse_iterator operator++(int)
		{	// postincrement
		reverse_iterator _Tmp = *this;
		--current;
		return (_Tmp);
		}

	inline reverse_iterator& operator--()
		{	// predecrement
		++current;
		return (*this);
		}

	inline reverse_iterator operator--(int)
		{	// postdecrement
		reverse_iterator _Tmp = *this;
		++current;
		return (_Tmp);
		}

// N.B. functions valid for random-access iterators only beyond this point

	inline reverse_iterator& operator+=(const difference_type _Off)
		{	// increment by integer
		current -= _Off;
		return (*this);
		}

	 inline reverse_iterator operator+(const difference_type _Off) const
		{	// return this + integer
		return (reverse_iterator(current - _Off));
		}

	inline reverse_iterator& operator-=(const difference_type _Off)
		{	// decrement by integer
		current += _Off;
		return (*this);
		}

	 inline reverse_iterator operator-(const difference_type _Off) const
		{	// return this - integer
		return (reverse_iterator(current + _Off));
		}

	 inline reference operator[](const difference_type _Off) const
		{	// subscript
		return (*(*this + _Off));
		}

	template<class _BidIt2 = _BidIt,
		enable_if_t<_Offset_verifiable_v<_BidIt2>, int> = 0>
		constexpr void _Verify_offset(const difference_type _Off) const
		{
		do { if (_Off != _Min_possible_v<difference_type>) { } else { do { (void) ((1 != _CrtDbgReport(2, "c:\\visual studio\\vc\\tools\\msvc\\14.16.27023\\include\\xutility", 1406, 0, "%s", "integer overflow")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"integer overflow\"", __LPREFIX( __FUNCTION__), L"c:\\visual studio\\vc\\tools\\msvc\\14.16.27023\\include\\xutility", 1406, 0); } while (false); } ; } while (false);
		current._Verify_offset(-_Off);
		}

	template<class _BidIt2 = _BidIt,
		enable_if_t<_Unwrappable_v<_BidIt2>, int> = 0>
		 constexpr reverse_iterator<_Unwrapped_t<_BidIt2>> _Unwrapped() const
		{
		return (static_cast<reverse_iterator<_Unwrapped_t<_BidIt2>>>(current._Unwrapped()));
		}

	static constexpr bool _Unwrap_when_unverified = _Do_unwrap_when_unverified_v<_BidIt>;

	template<class _Src,
		enable_if_t<_Wrapped_seekable_v<_BidIt, _Src>, int> = 0>
		constexpr void _Seek_to(const reverse_iterator<_Src>& _It)
		{
		current._Seek_to(_It.base());
		}
protected:
	_BidIt current;	// the wrapped iterator
	};

template<class _BidIt,
	class _BidIt2,
	enable_if_t<_Range_verifiable_v<_BidIt, _BidIt2>, int> = 0>
	constexpr void _Verify_range(const reverse_iterator<_BidIt>& _First, const reverse_iterator<_BidIt2>& _Last)
	{
	// TRANSITION, VSO#612785
	_Verify_range(_Last.base(), _First.base()); // note reversed parameters
	}

template<class _BidIt>
	 inline reverse_iterator<_BidIt> operator+(
		typename reverse_iterator<_BidIt>::difference_type _Off,
		const reverse_iterator<_BidIt>& _Right)
	{	// return reverse_iterator + integer
	return (_Right + _Off);
	}

template<class _BidIt1,
	class _BidIt2>
	 inline auto operator-(const reverse_iterator<_BidIt1>& _Left,
		const reverse_iterator<_BidIt2>& _Right)
			-> decltype(_Right.base() - _Left.base())
	{	// return difference of reverse_iterators
	return (_Right.base() - _Left.base());
	}

template<class _BidIt1,
	class _BidIt2>
	 inline bool operator==(const reverse_iterator<_BidIt1>& _Left,
		const reverse_iterator<_BidIt2>& _Right)
	{	// test for reverse_iterator equality
	return (_Left.base() == _Right.base());
	}

template<class _BidIt1,
	class _BidIt2>
	 inline bool operator!=(const reverse_iterator<_BidIt1>& _Left,
		const reverse_iterator<_BidIt2>& _Right)
	{	// test for reverse_iterator inequality
	return (!(_Left == _Right));
	}

template<class _BidIt1,
	class _BidIt2>
	 inline bool operator<(const reverse_iterator<_BidIt1>& _Left,
		const reverse_iterator<_BidIt2>& _Right)
	{	// test for reverse_iterator < reverse_iterator
	return (_Right.base() < _Left.base());
	}

template<class _BidIt1,
	class _BidIt2>
	 inline bool operator>(const reverse_iterator<_BidIt1>& _Left,
		const reverse_iterator<_BidIt2>& _Right)
	{	// test for reverse_iterator > reverse_iterator
	return (_Right < _Left);
	}

template<class _BidIt1,
	class _BidIt2>
	 inline bool operator<=(const reverse_iterator<_BidIt1>& _Left,
		const reverse_iterator<_BidIt2>& _Right)
	{	// test for reverse_iterator <= reverse_iterator
	return (!(_Right < _Left));
	}

template<class _BidIt1,
	class _BidIt2>
	 inline bool operator>=(const reverse_iterator<_BidIt1>& _Left,
		const reverse_iterator<_BidIt2>& _Right)
	{	// test for reverse_iterator >= reverse_iterator
	return (!(_Left < _Right));
	}

		// FUNCTION TEMPLATE make_reverse_iterator
template<class _BidIt>
	 inline reverse_iterator<_BidIt> make_reverse_iterator(_BidIt _Iter)
	{	// make reverse_iterator from iterator
	return (reverse_iterator<_BidIt>(_Iter));
	}

		// FUNCTION TEMPLATES begin AND end
template<class _Container>
	 inline auto begin(_Container& _Cont) -> decltype(_Cont.begin())
	{	// get beginning of sequence
	return (_Cont.begin());
	}

template<class _Container>
	 inline auto begin(const _Container& _Cont) -> decltype(_Cont.begin())
	{	// get beginning of sequence
	return (_Cont.begin());
	}

template<class _Container>
	 inline auto end(_Container& _Cont) -> decltype(_Cont.end())
	{	// get end of sequence
	return (_Cont.end());
	}

template<class _Container>
	 inline auto end(const _Container& _Cont) -> decltype(_Cont.end())
	{	// get end of sequence
	return (_Cont.end());
	}

template<class _Ty,
	size_t _Size>
	 constexpr _Ty *begin(_Ty (&_Array)[_Size]) noexcept
	{	// get beginning of array
	return (_Array);
	}

template<class _Ty,
	size_t _Size>
	 constexpr _Ty *end(_Ty (&_Array)[_Size]) noexcept
	{	// get end of array
	return (_Array + _Size);
	}

		// FUNCTION TEMPLATES cbegin AND cend
template<class _Container>
	 constexpr auto cbegin(const _Container& _Cont)
		noexcept(noexcept(::std:: begin(_Cont)))
		-> decltype(::std:: begin(_Cont))
	{	// get beginning of sequence
	return (::std:: begin(_Cont));
	}

template<class _Container>
	 constexpr auto cend(const _Container& _Cont)
		noexcept(noexcept(::std:: end(_Cont)))
		-> decltype(::std:: end(_Cont))
	{	// get end of sequence
	return (::std:: end(_Cont));
	}

		// FUNCTION TEMPLATES rbegin AND rend
template<class _Container>
	 inline auto rbegin(_Container& _Cont) -> decltype(_Cont.rbegin())
	{	// get beginning of reversed sequence
	return (_Cont.rbegin());
	}

template<class _Container>
	 inline auto rbegin(const _Container& _Cont) -> decltype(_Cont.rbegin())
	{	// get beginning of reversed sequence
	return (_Cont.rbegin());
	}

template<class _Container>
	 inline auto rend(_Container& _Cont) -> decltype(_Cont.rend())
	{	// get end of reversed sequence
	return (_Cont.rend());
	}

template<class _Container>
	 inline auto rend(const _Container& _Cont) -> decltype(_Cont.rend())
	{	// get end of reversed sequence
	return (_Cont.rend());
	}

template<class _Ty,
	size_t _Size>
	 inline reverse_iterator<_Ty *> rbegin(_Ty (&_Array)[_Size])
	{	// get beginning of reversed array
	return (reverse_iterator<_Ty *>(_Array + _Size));
	}

template<class _Ty,
	size_t _Size>
	 inline reverse_iterator<_Ty *> rend(_Ty (&_Array)[_Size])
	{	// get end of reversed array
	return (reverse_iterator<_Ty *>(_Array));
	}

template<class _Elem>
	 inline reverse_iterator<const _Elem *>
		rbegin(initializer_list<_Elem> _Ilist)
	{	// get beginning of reversed sequence
	return (reverse_iterator<const _Elem *>(_Ilist.end()));
	}

template<class _Elem>
	 inline reverse_iterator<const _Elem *>
		rend(initializer_list<_Elem> _Ilist)
	{	// get end of reversed sequence
	return (reverse_iterator<const _Elem *>(_Ilist.begin()));
	}

		// FUNCTION TEMPLATES crbegin AND crend
template<class _Container>
	 inline auto crbegin(const _Container& _Cont)
		-> decltype(::std:: rbegin(_Cont))
	{	// get beginning of reversed sequence
	return (::std:: rbegin(_Cont));
	}

template<class _Container>
	 inline auto crend(const _Container& _Cont)
		-> decltype(::std:: rend(_Cont))
	{	// get end of reversed sequence
	return (::std:: rend(_Cont));
	}


template<class _Container>
	 constexpr auto size(const _Container& _Cont)
		-> decltype(_Cont.size())
	{	// get size() for container
	return (_Cont.size());
	}

template<class _Ty,
	size_t _Size>
	 constexpr size_t size(const _Ty(&)[_Size]) noexcept
	{	// get dimension for array
	return (_Size);
	}

template<class _Container>
	 constexpr auto empty(const _Container& _Cont)
		-> decltype(_Cont.empty())
	{	// get empty() for container
	return (_Cont.empty());
	}

template<class _Ty,
	size_t _Size>
	 constexpr bool empty(const _Ty(&)[_Size]) noexcept
	{	// get dimension==0 for array (can't happen)
	return (false);
	}

template<class _Elem>
	 constexpr bool empty(
		initializer_list<_Elem> _Ilist) noexcept
	{	// get dimension==0 for initializer_list
	return (_Ilist.size() == 0);
	}

template<class _Container>
	 constexpr auto data(_Container& _Cont)
		-> decltype(_Cont.data())
	{	// get data() for container
	return (_Cont.data());
	}

template<class _Container>
	 constexpr auto data(const _Container& _Cont)
		-> decltype(_Cont.data())
	{	// get pointer to data of const container
	return (_Cont.data());
	}

template<class _Ty,
	size_t _Size>
	 constexpr _Ty *data(_Ty(&_Array)[_Size]) noexcept
	{	// get pointer to data of array
	return (_Array);
	}

template<class _Elem>
	 constexpr const _Elem *data(
		initializer_list<_Elem> _Ilist) noexcept
	{	// get pointer to data of initializer_list
	return (_Ilist.begin());
	}

		// MACRO _STL_VERIFY_ARRAY_SIZE




		// CLASS TEMPLATE _Array_const_iterator

struct _Iterator_base12_compatible
	{	// TRANSITION, for binary compatibility
	_Container_proxy * _Myproxy{};
	_Iterator_base12 * _Mynextiter{};
	};


template<class _Ty,
	size_t _Size>
	class _Array_const_iterator

		: private _Iterator_base12_compatible

	{	// iterator for nonmutable array
public:
	using iterator_category = random_access_iterator_tag;

	using value_type = _Ty;
	using difference_type = ptrdiff_t;
	using pointer = const _Ty *;
	using reference = const _Ty&;
	enum {_EEN_SIZE = _Size};	// helper for expression evaluator
 





























































































































	inline _Array_const_iterator()
		: _Ptr(),
		_Idx(0)
		{	// construct with null pointer
		}

	inline explicit _Array_const_iterator(pointer _Parg, size_t _Off = 0)
		: _Ptr(_Parg),
		_Idx(_Off)
		{	// construct with pointer and offset
		}

	 inline reference operator*() const
		{	// return designated object
		return (*operator->());
		}

	 inline pointer operator->() const
		{	// return pointer to class object
		do { if (_Ptr) { } else { do { (void) ((1 != _CrtDbgReport(2, "c:\\visual studio\\vc\\tools\\msvc\\14.16.27023\\include\\xutility", 1872, 0, "%s", "cannot dereference value-initialized array iterator")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"cannot dereference value-initialized array iterator\"", __LPREFIX( __FUNCTION__), L"c:\\visual studio\\vc\\tools\\msvc\\14.16.27023\\include\\xutility", 1872, 0); } while (false); } ; } while (false);
		do { if (_Idx < _Size) { } else { do { (void) ((1 != _CrtDbgReport(2, "c:\\visual studio\\vc\\tools\\msvc\\14.16.27023\\include\\xutility", 1873, 0, "%s", "cannot dereference out of range array iterator")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"cannot dereference out of range array iterator\"", __LPREFIX( __FUNCTION__), L"c:\\visual studio\\vc\\tools\\msvc\\14.16.27023\\include\\xutility", 1873, 0); } while (false); } ; } while (false);
		return (_Ptr + _Idx);
		}

	inline _Array_const_iterator& operator++()
		{	// preincrement
		do { if (_Ptr) { } else { do { (void) ((1 != _CrtDbgReport(2, "c:\\visual studio\\vc\\tools\\msvc\\14.16.27023\\include\\xutility", 1879, 0, "%s", "cannot increment value-initialized array iterator")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"cannot increment value-initialized array iterator\"", __LPREFIX( __FUNCTION__), L"c:\\visual studio\\vc\\tools\\msvc\\14.16.27023\\include\\xutility", 1879, 0); } while (false); } ; } while (false);
		do { if (_Idx < _Size) { } else { do { (void) ((1 != _CrtDbgReport(2, "c:\\visual studio\\vc\\tools\\msvc\\14.16.27023\\include\\xutility", 1880, 0, "%s", "cannot increment array iterator past end")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"cannot increment array iterator past end\"", __LPREFIX( __FUNCTION__), L"c:\\visual studio\\vc\\tools\\msvc\\14.16.27023\\include\\xutility", 1880, 0); } while (false); } ; } while (false);
		++_Idx;
		return (*this);
		}

	inline _Array_const_iterator operator++(int)
		{	// postincrement
		_Array_const_iterator _Tmp = *this;
		++*this;
		return (_Tmp);
		}

	inline _Array_const_iterator& operator--()
		{	// predecrement
		do { if (_Ptr) { } else { do { (void) ((1 != _CrtDbgReport(2, "c:\\visual studio\\vc\\tools\\msvc\\14.16.27023\\include\\xutility", 1894, 0, "%s", "cannot decrement value-initialized array iterator")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"cannot decrement value-initialized array iterator\"", __LPREFIX( __FUNCTION__), L"c:\\visual studio\\vc\\tools\\msvc\\14.16.27023\\include\\xutility", 1894, 0); } while (false); } ; } while (false);
		do { if (_Idx != 0) { } else { do { (void) ((1 != _CrtDbgReport(2, "c:\\visual studio\\vc\\tools\\msvc\\14.16.27023\\include\\xutility", 1895, 0, "%s", "cannot decrement array iterator before begin")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"cannot decrement array iterator before begin\"", __LPREFIX( __FUNCTION__), L"c:\\visual studio\\vc\\tools\\msvc\\14.16.27023\\include\\xutility", 1895, 0); } while (false); } ; } while (false);
		--_Idx;
		return (*this);
		}

	inline _Array_const_iterator operator--(int)
		{	// postdecrement
		_Array_const_iterator _Tmp = *this;
		--*this;
		return (_Tmp);
		}

	constexpr void _Verify_offset(const ptrdiff_t _Off) const noexcept
		{
		if (_Off != 0)
			{
			do { if (_Ptr) { } else { do { (void) ((1 != _CrtDbgReport(2, "c:\\visual studio\\vc\\tools\\msvc\\14.16.27023\\include\\xutility", 1911, 0, "%s", "cannot seek value-initialized array iterator")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"cannot seek value-initialized array iterator\"", __LPREFIX( __FUNCTION__), L"c:\\visual studio\\vc\\tools\\msvc\\14.16.27023\\include\\xutility", 1911, 0); } while (false); } ; } while (false);
			}

		if (_Off < 0)
			{
#pragma warning(suppress: 4146)	
			do { if (_Idx >= -static_cast<size_t>(_Off)) { } else { do { (void) ((1 != _CrtDbgReport(2, "c:\\visual studio\\vc\\tools\\msvc\\14.16.27023\\include\\xutility", 1918, 0, "%s", "cannot seek array iterator before begin")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"cannot seek array iterator before begin\"", __LPREFIX( __FUNCTION__), L"c:\\visual studio\\vc\\tools\\msvc\\14.16.27023\\include\\xutility", 1918, 0); } while (false); } ; } while (false);
			}

		if (_Off > 0)
			{
			do { if (_Size - _Idx >= static_cast<size_t>(_Off)) { } else { do { (void) ((1 != _CrtDbgReport(2, "c:\\visual studio\\vc\\tools\\msvc\\14.16.27023\\include\\xutility", 1924, 0, "%s", "cannot seek array iterator after end")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"cannot seek array iterator after end\"", __LPREFIX( __FUNCTION__), L"c:\\visual studio\\vc\\tools\\msvc\\14.16.27023\\include\\xutility", 1924, 0); } while (false); } ; } while (false);
			}
		}

	inline _Array_const_iterator& operator+=(const ptrdiff_t _Off)
		{	// increment by integer
		_Verify_offset(_Off);
		_Idx += _Off;
		return (*this);
		}

	 inline _Array_const_iterator operator+(const ptrdiff_t _Off) const
		{	// return this + integer
		_Array_const_iterator _Tmp = *this;
		return (_Tmp += _Off);
		}

	inline _Array_const_iterator& operator-=(const ptrdiff_t _Off)
		{	// decrement by integer
		return (*this += -_Off);
		}

	 inline _Array_const_iterator operator-(const ptrdiff_t _Off) const
		{	// return this - integer
		_Array_const_iterator _Tmp = *this;
		return (_Tmp -= _Off);
		}

	 inline ptrdiff_t operator-(const _Array_const_iterator& _Right) const
		{	// return difference of iterators
		_Compat(_Right);
		return (static_cast<ptrdiff_t>(_Idx - _Right._Idx));
		}

	 inline reference operator[](const ptrdiff_t _Off) const
		{	// subscript
		return (*(*this + _Off));
		}

	 inline bool operator==(const _Array_const_iterator& _Right) const
		{	// test for iterator equality
		_Compat(_Right);
		return (_Idx == _Right._Idx);
		}

	 inline bool operator!=(const _Array_const_iterator& _Right) const
		{	// test for iterator inequality
		return (!(*this == _Right));
		}

	 inline bool operator<(const _Array_const_iterator& _Right) const
		{	// test if this < _Right
		_Compat(_Right);
		return (_Idx < _Right._Idx);
		}

	 inline bool operator>(const _Array_const_iterator& _Right) const
		{	// test if this > _Right
		return (_Right < *this);
		}

	 inline bool operator<=(const _Array_const_iterator& _Right) const
		{	// test if this <= _Right
		return (!(_Right < *this));
		}

	 inline bool operator>=(const _Array_const_iterator& _Right) const
		{	// test if this >= _Right
		return (!(*this < _Right));
		}

	inline void _Compat(const _Array_const_iterator& _Right) const
		{	// test for compatible iterator pair
		do { if (_Ptr == _Right._Ptr) { } else { do { (void) ((1 != _CrtDbgReport(2, "c:\\visual studio\\vc\\tools\\msvc\\14.16.27023\\include\\xutility", 1997, 0, "%s", "array iterators incompatible")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"array iterators incompatible\"", __LPREFIX( __FUNCTION__), L"c:\\visual studio\\vc\\tools\\msvc\\14.16.27023\\include\\xutility", 1997, 0); } while (false); } ; } while (false);
		}

	 constexpr pointer _Unwrapped() const
		{
		return (_Ptr + _Idx);
		}

	constexpr void _Verify_with(const _Array_const_iterator& _Last) const noexcept
		{
		// note _Compat check inside operator<=
		do { if (*this <= _Last) { } else { do { (void) ((1 != _CrtDbgReport(2, "c:\\visual studio\\vc\\tools\\msvc\\14.16.27023\\include\\xutility", 2008, 0, "%s", "array iterator range transposed")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"array iterator range transposed\"", __LPREFIX( __FUNCTION__), L"c:\\visual studio\\vc\\tools\\msvc\\14.16.27023\\include\\xutility", 2008, 0); } while (false); } ; } while (false);
		}

	constexpr void _Seek_to(pointer _It)
		{
		_Idx = static_cast<size_t>(_It - _Ptr);
		}

private:
	pointer _Ptr;	// beginning of array
	size_t _Idx;	// offset into array
 
	};

 
template<class _Ty,
	size_t _Size>
	constexpr void _Verify_range(const _Array_const_iterator<_Ty, _Size>& _First,
		const _Array_const_iterator<_Ty, _Size>& _Last) noexcept
	{
	// TRANSITION, VSO#612785
	_First._Verify_with(_Last);
	}
 

template<class _Ty,
	size_t _Size>
	 inline _Array_const_iterator<_Ty, _Size> operator+(
		ptrdiff_t _Off,
		_Array_const_iterator<_Ty, _Size> _Next)
	{	// add offset to iterator
	return (_Next += _Off);
	}

		// CLASS TEMPLATE _Array_iterator
template<class _Ty,
	size_t _Size>
	class _Array_iterator
		: public _Array_const_iterator<_Ty, _Size>
	{	// iterator for mutable array
public:
	using _Mybase = _Array_const_iterator<_Ty, _Size>;
	using iterator_category = random_access_iterator_tag;

	using value_type = _Ty;
	using difference_type = ptrdiff_t;
	using pointer = _Ty *;
	using reference = _Ty&;

	inline _Array_iterator()
		{	// construct with null pointer
		}

	inline explicit _Array_iterator(pointer _Parg, size_t _Off = 0)
		: _Mybase(_Parg, _Off)
		{	// construct with pointer and offset
		}

	enum {_EEN_SIZE = _Size};	// helper for expression evaluator

	 inline reference operator*() const
		{	// return designated object
		return (const_cast<reference>(_Mybase::operator*()));
		}

	 inline pointer operator->() const
		{	// return pointer to class object
		return (const_cast<pointer>(_Mybase::operator->()));
		}

	inline _Array_iterator& operator++()
		{	// preincrement
		++*static_cast<_Mybase *>(this);
		return (*this);
		}

	inline _Array_iterator operator++(int)
		{	// postincrement
		_Array_iterator _Tmp = *this;
		++*this;
		return (_Tmp);
		}

	inline _Array_iterator& operator--()
		{	// predecrement
		--*static_cast<_Mybase *>(this);
		return (*this);
		}

	inline _Array_iterator operator--(int)
		{	// postdecrement
		_Array_iterator _Tmp = *this;
		--*this;
		return (_Tmp);
		}

	inline _Array_iterator& operator+=(const ptrdiff_t _Off)
		{	// increment by integer
		*static_cast<_Mybase *>(this) += _Off;
		return (*this);
		}

	 inline _Array_iterator operator+(const ptrdiff_t _Off) const
		{	// return this + integer
		_Array_iterator _Tmp = *this;
		return (_Tmp += _Off);
		}

	inline _Array_iterator& operator-=(const ptrdiff_t _Off)
		{	// decrement by integer
		return (*this += -_Off);
		}

	 inline _Array_iterator operator-(const ptrdiff_t _Off) const
		{	// return this - integer
		_Array_iterator _Tmp = *this;
		return (_Tmp -= _Off);
		}

	 inline ptrdiff_t operator-(const _Mybase& _Right) const
		{	// return difference of iterators
		return (*static_cast<const _Mybase *>(this) - _Right);
		}

	 inline reference operator[](const ptrdiff_t _Off) const
		{	// subscript
		return (*(*this + _Off));
		}

	 constexpr pointer _Unwrapped() const
		{
		return (const_cast<pointer>(_Mybase::_Unwrapped()));
		}
	};

template<class _Ty,
	size_t _Size>
	 inline _Array_iterator<_Ty, _Size> operator+(
		ptrdiff_t _Off,
		_Array_iterator<_Ty, _Size> _Next)
	{	// add offset to iterator
	return (_Next += _Off);
	}

		// CLASS TEMPLATE move_iterator
template<class _Iter>
	class move_iterator
	{	// wrap iterator to move rvalues
public:
	using iterator_category = typename iterator_traits<_Iter>::iterator_category;
	using value_type = typename iterator_traits<_Iter>::value_type;
	using difference_type = typename iterator_traits<_Iter>::difference_type;
	using pointer = _Iter;
	using _Ref0 = typename iterator_traits<_Iter>::reference;
	using reference = conditional_t<is_reference_v<_Ref0>, remove_reference_t<_Ref0>&&, _Ref0>;
	using iterator_type = _Iter;

	inline move_iterator()
		: current()
		{	// construct with value-initialized wrapped iterator
		}

	inline explicit move_iterator(iterator_type _Right)
		: current(_Right)
		{	// construct wrapped iterator from _Right
		}

	template<class _Iter2>
		inline move_iterator(const move_iterator<_Iter2>& _Right)
		: current(_Right.base())
		{	// initialize with compatible base
		}

	template<class _Iter2>
		inline move_iterator& operator=(const move_iterator<_Iter2>& _Right)
		{	// assign with compatible base
		current = _Right.base();
		return (*this);
		}

	 inline _Iter base() const
		{	// return wrapped iterator
		return (current);
		}

	 inline reference operator*() const
		{	// return designated value
		return (static_cast<reference>(*current));
		}

	 inline pointer operator->() const
		{	// return pointer to class object
		return (current);
		}

	inline move_iterator& operator++()
		{	// preincrement
		++current;
		return (*this);
		}

	inline move_iterator operator++(int)
		{	// postincrement
		move_iterator _Tmp = *this;
		++current;
		return (_Tmp);
		}

	inline move_iterator& operator--()
		{	// predecrement
		--current;
		return (*this);
		}

	inline move_iterator operator--(int)
		{	// postdecrement
		move_iterator _Tmp = *this;
		--current;
		return (_Tmp);
		}

// N.B. functions valid for random-access iterators only beyond this point

	inline move_iterator& operator+=(const difference_type _Off)
		{	// increment by integer
		current += _Off;
		return (*this);
		}

	 inline move_iterator operator+(const difference_type _Off) const
		{	// return this + integer
		return (move_iterator(current + _Off));
		}

	inline move_iterator& operator-=(const difference_type _Off)
		{	// decrement by integer
		current -= _Off;
		return (*this);
		}

	 inline move_iterator operator-(const difference_type _Off) const
		{	// return this - integer
		return (move_iterator(current - _Off));
		}

	 inline reference operator[](const difference_type _Off) const
		{	// subscript
		return (::std:: move(current[_Off]));
		}

	template<class _Iter2,
		enable_if_t<_Range_verifiable_v<_Iter, _Iter2>, int> = 0>
		friend constexpr void _Verify_range(const move_iterator& _First, const move_iterator<_Iter2>& _Last)
		{
		_Verify_range(_First.base(), _Last.base());
		}

	template<class _Iter2 = iterator_type,
		enable_if_t<_Offset_verifiable_v<_Iter2>, int> = 0>
		constexpr void _Verify_offset(const difference_type _Off) const
		{
		current._Verify_offset(_Off);
		}

	template<class _Iter2 = iterator_type,
		enable_if_t<_Unwrappable_v<_Iter2>, int> = 0>
		 constexpr move_iterator<_Unwrapped_t<_Iter2>> _Unwrapped() const
		{
		return (static_cast<move_iterator<_Unwrapped_t<_Iter2>>>(current._Unwrapped()));
		}

	static constexpr bool _Unwrap_when_unverified = _Do_unwrap_when_unverified_v<iterator_type>;

	template<class _Src,
		enable_if_t<_Wrapped_seekable_v<iterator_type, _Src>, int> = 0>
		constexpr void _Seek_to(const move_iterator<_Src>& _It)
		{
		current._Seek_to(_It.base());
		}
protected:
	iterator_type current;	// the wrapped iterator
	};

template<class _Iter>
	 inline move_iterator<_Iter> operator+(
		typename move_iterator<_Iter>::difference_type _Off,
		const move_iterator<_Iter>& _Right)
	{	// return move_iterator + integer
	return (_Right + _Off);
	}

template<class _Iter1,
	class _Iter2>
	 inline auto operator-(
		const move_iterator<_Iter1>& _Left,
		const move_iterator<_Iter2>& _Right)
			-> decltype(_Left.base() - _Right.base())
	{	// return difference of move_iterators
	return (_Left.base() - _Right.base());
	}

template<class _Iter1,
	class _Iter2>
	 inline bool operator==(
		const move_iterator<_Iter1>& _Left,
		const move_iterator<_Iter2>& _Right)
	{	// test for move_iterator equality
	return (_Left.base() == _Right.base());
	}

template<class _Iter1,
	class _Iter2>
	 inline bool operator!=(
		const move_iterator<_Iter1>& _Left,
		const move_iterator<_Iter2>& _Right)
	{	// test for move_iterator inequality
	return (!(_Left == _Right));
	}

template<class _Iter1,
	class _Iter2>
	 inline bool operator<(
		const move_iterator<_Iter1>& _Left,
		const move_iterator<_Iter2>& _Right)
	{	// test for move_iterator < move_iterator
	return (_Left.base() < _Right.base());
	}

template<class _Iter1,
	class _Iter2>
	 inline bool operator>(
		const move_iterator<_Iter1>& _Left,
		const move_iterator<_Iter2>& _Right)
	{	// test for move_iterator > move_iterator
	return (_Right < _Left);
	}

template<class _Iter1,
	class _Iter2>
	 inline bool operator<=(
		const move_iterator<_Iter1>& _Left,
		const move_iterator<_Iter2>& _Right)
	{	// test for move_iterator <= move_iterator
	return (!(_Right < _Left));
	}

template<class _Iter1,
	class _Iter2>
	 inline bool operator>=(
		const move_iterator<_Iter1>& _Left,
		const move_iterator<_Iter2>& _Right)
	{	// test for move_iterator >= move_iterator
	return (!(_Left < _Right));
	}

		// FUNCTION TEMPLATE make_move_iterator
template<class _Iter>
	 inline move_iterator<_Iter> make_move_iterator(_Iter _It)
	{	// make move_iterator from iterator
	return (move_iterator<_Iter>(_It));
	}

		// STRUCT TEMPLATE _Char_traits_eq
template<class _Traits>
	struct _Char_traits_eq
	{
	using _Elem = typename _Traits::char_type;

	bool operator()(_Elem _Left, _Elem _Right) const
		{
		return (_Traits::eq(_Left, _Right));
		}
	};

		// STRUCT TEMPLATE _Char_traits_lt
template<class _Traits>
	struct _Char_traits_lt
	{
	using _Elem = typename _Traits::char_type;

	bool operator()(_Elem _Left, _Elem _Right) const
		{
		return (_Traits::lt(_Left, _Right));
		}
	};

		// FUNCTION TEMPLATE copy
template<class _InIt,
	class _OutIt> inline
	_OutIt _Copy_memmove(_InIt _First, _InIt _Last, _OutIt _Dest)
	{	// implement copy-like function as memmove
	const char * const _First_ch = const_cast<const char *>(reinterpret_cast<const volatile char *>(_First));
	const char * const _Last_ch = const_cast<const char *>(reinterpret_cast<const volatile char *>(_Last));
	char * const _Dest_ch = const_cast<char *>(reinterpret_cast<volatile char *>(_Dest));
	const auto _Count = static_cast<size_t>(_Last_ch - _First_ch);
	:: memmove(_Dest_ch, _First_ch, _Count);
	return (reinterpret_cast<_OutIt>(_Dest_ch + _Count));
	}

template<class _InIt,
	class _OutIt> inline
	_OutIt _Copy_unchecked1(_InIt _First, _InIt _Last,
		_OutIt _Dest, _General_ptr_iterator_tag)
	{	// copy [_First, _Last) to [_Dest, ...), arbitrary iterators
	for (; _First != _Last; ++_Dest, (void)++_First)
		{
		*_Dest = *_First;
		}

	return (_Dest);
	}

template<class _InIt,
	class _OutIt> inline
	_OutIt _Copy_unchecked1(_InIt _First, _InIt _Last,
		_OutIt _Dest, _Trivially_copyable_ptr_iterator_tag)
	{	// copy [_First, _Last) to [_Dest, ...), pointers to trivially copyable
	return (_Copy_memmove(_First, _Last, _Dest));
	}

template<class _InIt,
	class _OutIt> inline
	_OutIt _Copy_unchecked(_InIt _First, _InIt _Last,
		_OutIt _Dest)
	{	// copy [_First, _Last) to [_Dest, ...)
		// note: _Copy_unchecked is called directly from elsewhere in the STL
	return (_Copy_unchecked1(_First, _Last, _Dest, _Ptr_copy_cat(_First, _Dest)));
	}

template<class _InIt,
	class _OutIt> inline
	_OutIt copy(_InIt _First, _InIt _Last, _OutIt _Dest)
	{	// copy [_First, _Last) to [_Dest, ...)
	_Adl_verify_range(_First, _Last);
	const auto _UFirst = _Get_unwrapped(_First);
	const auto _ULast = _Get_unwrapped(_Last);
	const auto _UDest = _Get_unwrapped_n(_Dest, _Idl_distance<_InIt>(_UFirst, _ULast));
	_Seek_wrapped(_Dest, _Copy_unchecked(_UFirst, _ULast, _UDest));
	return (_Dest);
	}

 
template<class _InIt,
	class _DestTy,
	size_t _DestSize> inline
	_DestTy *copy(_InIt _First, _InIt _Last, _DestTy (&_Dest)[_DestSize])
	{	// copy [_First, _Last) to [_Dest, ...)
	return (::std:: copy(_First, _Last, _Array_iterator<_DestTy, _DestSize>(_Dest))._Unwrapped());
	}
 





























		// FUNCTION TEMPLATE copy_n
// TRANSITION: _Copy_n_unchecked, _Copy_n_unchecked1, and _Copy_n_unchecked2 are ABI zombie names
template<class _InIt,
	class _Diff,
	class _OutIt> inline
	_OutIt _Copy_n_unchecked4(_InIt _First, _Diff _Count,
		_OutIt _Dest, _General_ptr_iterator_tag)
	{	// copy [_First, _First + _Count) to [_Dest, ...), no special optimization
		// pre: 0 < _Count
	for (;;)
		{
		*_Dest = *_First;
		++_Dest;
		--_Count;
		if (_Count == 0)
			{	// note that we avoid an extra ++_First here to allow istream_iterator to work,
				// see LWG#2471
			return (_Dest);
			}

		++_First;
		}
	}

template<class _InIt,
	class _Diff,
	class _OutIt> inline
	_OutIt _Copy_n_unchecked4(_InIt _First, _Diff _Count,
		_OutIt _Dest, _Trivially_copyable_ptr_iterator_tag)
	{	// copy [_First, _First + _Count) to [_Dest, ...), memmove optimization
		// pre: 0 < _Count
	return (_Copy_memmove(_First, _First + _Count, _Dest));
	}

template<class _InIt,
	class _Diff,
	class _OutIt> inline
	_OutIt _Copy_n_unchecked3(_InIt _First, _Diff _Count,
		_OutIt _Dest)
	{	// copy [_First, _First + _Count) to [_Dest, ...), choose optimization
		// pre: 0 < _Count
	return (_Copy_n_unchecked4(_First, _Count,
		_Dest, _Ptr_copy_cat(_First, _Dest)));
	}

template<class _InIt,
	class _Diff,
	class _OutIt> inline
	_OutIt copy_n(_InIt _First, _Diff _Count_raw, _OutIt _Dest)
	{	// copy [_First, _First + _Count) to [_Dest, ...)
	const _Algorithm_int_t<_Diff> _Count = _Count_raw;
	if (0 < _Count)
		{
		_Seek_wrapped(_Dest,
			_Copy_n_unchecked3(_Get_unwrapped_n(_First, _Count), _Count, _Get_unwrapped_n(_Dest, _Count)));
		}

	return (_Dest);
	}

 
template<class _SourceTy,
	size_t _SourceSize,
	class _Diff,
	class _OutIt> inline
	_OutIt copy_n(_SourceTy (&_First)[_SourceSize], _Diff _Count_raw, _OutIt _Dest)
	{	// copy [_First, _First + _Count) to [_Dest, ...), array source
	const _Algorithm_int_t<_Diff> _Count = _Count_raw;
	if (0 < _Count)
		{
		do { if ((::std:: size(_First) >= static_cast<common_type_t<size_t, decltype(_Count)>>(_Count))) { } else { do { (void) ((1 != _CrtDbgReport(2, "c:\\visual studio\\vc\\tools\\msvc\\14.16.27023\\include\\xutility", 2557, 0, "%s", "array too small")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"array too small\"", __LPREFIX( __FUNCTION__), L"c:\\visual studio\\vc\\tools\\msvc\\14.16.27023\\include\\xutility", 2557, 0); } while (false); } ; } while (false);
		_Seek_wrapped(_Dest, _Copy_n_unchecked3(_First, _Count, _Get_unwrapped_n(_Dest, _Count)));
		}

	return (_Dest);
	}

template<class _InIt,
	class _Diff,
	class _DestTy,
	size_t _DestSize> inline
	_DestTy *copy_n(_InIt _First, _Diff _Count_raw, _DestTy (&_Dest)[_DestSize])
	{	// copy [_First, _First + _Count) to [_Dest, ...), array dest
	const _Algorithm_int_t<_Diff> _Count = _Count_raw;
	if (0 < _Count)
		{
		do { if ((::std:: size(_Dest) >= static_cast<common_type_t<size_t, decltype(_Count)>>(_Count))) { } else { do { (void) ((1 != _CrtDbgReport(2, "c:\\visual studio\\vc\\tools\\msvc\\14.16.27023\\include\\xutility", 2573, 0, "%s", "array too small")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"array too small\"", __LPREFIX( __FUNCTION__), L"c:\\visual studio\\vc\\tools\\msvc\\14.16.27023\\include\\xutility", 2573, 0); } while (false); } ; } while (false);
		return (_Copy_n_unchecked3(_Get_unwrapped_n(_First, _Count), _Count, _Dest));
		}

	return (_Dest);
	}

template<class _SourceTy,
	size_t _SourceSize,
	class _Diff,
	class _DestTy,
	size_t _DestSize> inline
	_DestTy *copy_n(_SourceTy (&_First)[_SourceSize], _Diff _Count_raw, _DestTy (&_Dest)[_DestSize])
	{	// copy [_First, _First + _Count) to [_Dest, ...), array source/dest
	const _Algorithm_int_t<_Diff> _Count = _Count_raw;
	if (0 < _Count)
		{
		do { if ((::std:: size(_First) >= static_cast<common_type_t<size_t, decltype(_Count)>>(_Count))) { } else { do { (void) ((1 != _CrtDbgReport(2, "c:\\visual studio\\vc\\tools\\msvc\\14.16.27023\\include\\xutility", 2590, 0, "%s", "array too small")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"array too small\"", __LPREFIX( __FUNCTION__), L"c:\\visual studio\\vc\\tools\\msvc\\14.16.27023\\include\\xutility", 2590, 0); } while (false); } ; } while (false);
		do { if ((::std:: size(_Dest) >= static_cast<common_type_t<size_t, decltype(_Count)>>(_Count))) { } else { do { (void) ((1 != _CrtDbgReport(2, "c:\\visual studio\\vc\\tools\\msvc\\14.16.27023\\include\\xutility", 2591, 0, "%s", "array too small")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"array too small\"", __LPREFIX( __FUNCTION__), L"c:\\visual studio\\vc\\tools\\msvc\\14.16.27023\\include\\xutility", 2591, 0); } while (false); } ; } while (false);
		return (_Copy_n_unchecked3(_First, _Count, _Dest));
		}

	return (_Dest);
	}
 

























































		// FUNCTION TEMPLATE copy_backward
template<class _BidIt1,
	class _BidIt2> inline
	_BidIt2 _Copy_backward_memmove(_BidIt1 _First, _BidIt1 _Last, _BidIt2 _Dest)
	{	// implement copy_backward-like function as memmove
	const char * const _First_ch = const_cast<const char *>(reinterpret_cast<const volatile char *>(_First));
	const char * const _Last_ch = const_cast<const char *>(reinterpret_cast<const volatile char *>(_Last));
	char * const _Dest_ch = const_cast<char *>(reinterpret_cast<volatile char *>(_Dest));
	const auto _Count = static_cast<size_t>(_Last_ch - _First_ch);
	return (static_cast<_BidIt2>(
		:: memmove(_Dest_ch - _Count, _First_ch, _Count)));
	}

template<class _BidIt1,
	class _BidIt2> inline
	_BidIt2 _Copy_backward_unchecked(_BidIt1 _First, _BidIt1 _Last,
		_BidIt2 _Dest, _General_ptr_iterator_tag)
	{	// copy [_First, _Last) backwards to [..., _Dest), no special optimization
	while (_First != _Last)
		*--_Dest = *--_Last;
	return (_Dest);
	}

template<class _BidIt1,
	class _BidIt2> inline
	_BidIt2 _Copy_backward_unchecked(_BidIt1 _First, _BidIt1 _Last,
		_BidIt2 _Dest, _Trivially_copyable_ptr_iterator_tag)
	{	// copy [_First, _Last) backwards to [..., _Dest), memmove optimization
	return (_Copy_backward_memmove(_First, _Last, _Dest));
	}

template<class _BidIt1,
	class _BidIt2> inline
	_BidIt2 copy_backward(_BidIt1 _First, _BidIt1 _Last, _BidIt2 _Dest)
	{	// copy [_First, _Last) backwards to [..., _Dest)
	_Adl_verify_range(_First, _Last);
	const auto _UFirst = _Get_unwrapped(_First);
	const auto _ULast = _Get_unwrapped(_Last);
	const auto _UDest = _Get_unwrapped_n(_Dest, -_Idl_distance<_BidIt1>(_UFirst, _ULast));
	_Seek_wrapped(_Dest,
		_Copy_backward_unchecked(_UFirst, _ULast, _UDest, _Ptr_copy_cat(_UFirst, _UDest)));
	return (_Dest);
	}













		// FUNCTION TEMPLATE move
template<class _InIt,
	class _OutIt> inline
	_OutIt _Move_unchecked1(_InIt _First, _InIt _Last,
		_OutIt _Dest, _General_ptr_iterator_tag)
	{	// move [_First, _Last) to [_Dest, ...), no special optimization
	for (; _First != _Last; ++_Dest, (void)++_First)
		*_Dest = ::std:: move(*_First);
	return (_Dest);
	}

template<class _InIt,
	class _OutIt> inline
	_OutIt _Move_unchecked1(_InIt _First, _InIt _Last,
		_OutIt _Dest, _Trivially_copyable_ptr_iterator_tag)
	{	// move [_First, _Last) to [_Dest, ...), memmove optimization
	return (_Copy_memmove(_First, _Last, _Dest));
	}

template<class _InIt,
	class _OutIt> inline
	_OutIt _Move_unchecked(_InIt _First, _InIt _Last,
		_OutIt _Dest)
	{	// move [_First, _Last) to [_Dest, ...), choose optimization
		// note: _Move_unchecked is called directly from elsewhere in the STL
	return (_Move_unchecked1(_First, _Last,
		_Dest, _Ptr_move_cat(_First, _Dest)));
	}

template<class _InIt,
	class _OutIt> inline
	_OutIt move(_InIt _First, _InIt _Last,
		_OutIt _Dest)
	{	// move [_First, _Last) to [_Dest, ...)
	_Adl_verify_range(_First, _Last);
	const auto _UFirst = _Get_unwrapped(_First);
	const auto _ULast = _Get_unwrapped(_Last);
	const auto _UDest = _Get_unwrapped_n(_Dest, _Idl_distance<_InIt>(_UFirst, _ULast));
	_Seek_wrapped(_Dest,
		_Move_unchecked(_UFirst, _ULast, _UDest));
	return (_Dest);
	}

 
template<class _InIt,
	class _DestTy,
	size_t _DestSize> inline
	_DestTy *move(_InIt _First, _InIt _Last, _DestTy (&_Dest)[_DestSize])
	{	// move [_First, _Last) to [_Dest, ...)
	return (::std:: move(_First, _Last, _Array_iterator<_DestTy, _DestSize>(_Dest))._Unwrapped());
	}
 





























		// FUNCTION TEMPLATE move_backward
template<class _BidIt1,
	class _BidIt2> inline
	_BidIt2 _Move_backward_unchecked1(_BidIt1 _First, _BidIt1 _Last,
		_BidIt2 _Dest, _General_ptr_iterator_tag)
	{	// move [_First, _Last) backwards to [..., _Dest), no special optimization
	while (_First != _Last)
		*--_Dest = ::std:: move(*--_Last);
	return (_Dest);
	}

template<class _BidIt1,
	class _BidIt2> inline
	_BidIt2 _Move_backward_unchecked1(_BidIt1 _First, _BidIt1 _Last,
		_BidIt2 _Dest, _Trivially_copyable_ptr_iterator_tag)
	{	// move [_First, _Last) backwards to [..., _Dest), memmove optimization
	return (_Copy_backward_memmove(_First, _Last, _Dest));
	}

template<class _BidIt1,
	class _BidIt2> inline
	_BidIt2 _Move_backward_unchecked(_BidIt1 _First, _BidIt1 _Last, _BidIt2 _Dest)
	{	// move [_First, _Last) backwards to [..., _Dest), choose optimization
		// note: _Move_backward_unchecked is called directly from elsewhere in the STL
	return (_Move_backward_unchecked1(_First, _Last,
		_Dest, _Ptr_move_cat(_First, _Dest)));
	}

template<class _BidIt1,
	class _BidIt2> inline
	_BidIt2 move_backward(_BidIt1 _First, _BidIt1 _Last, _BidIt2 _Dest)
	{	// move [_First, _Last) backwards to [..., _Dest)
	_Adl_verify_range(_First, _Last);
	const auto _UFirst = _Get_unwrapped(_First);
	const auto _ULast = _Get_unwrapped(_Last);
	const auto _UDest = _Get_unwrapped_n(_Dest, -_Idl_distance<_BidIt1>(_UFirst, _ULast));
	_Seek_wrapped(_Dest, _Move_backward_unchecked(_UFirst, _ULast, _UDest));
	return (_Dest);
	}













		// FUNCTION TEMPLATE fill
template<class _Ty>
	struct _Is_character
		: false_type
		{	// by default, not a character type
		};

template<>
	struct _Is_character<char>
		: true_type
		{	// chars are characters
		};

template<>
	struct _Is_character<signed char>
		: true_type
		{	// signed chars are also characters
		};

template<>
	struct _Is_character<unsigned char>
		: true_type
		{	// unsigned chars are also characters
		};

template<class _FwdIt,
	class _Ty>
	struct _Fill_memset_is_safe_helper
	{	// determines if _FwdIt and _Ty are eligible for memset optimization in fill
	using _Value_type = _Iter_value_t<_FwdIt>;

	using _Raw_ty = _Unwrap_enum_t<_Ty>;
	using _Raw_value_type = _Unwrap_enum_t<_Value_type>;

	using type = bool_constant<conjunction_v<
		is_pointer<_FwdIt>,
		disjunction<
			conjunction<
				_Is_character<_Raw_ty>,
				_Is_character<_Raw_value_type>>,
			conjunction<
				is_same<bool, _Raw_ty>,
				is_same<bool, _Raw_value_type>>>,
		is_convertible<_Ty, _Value_type>>>;
	};

template<class _FwdIt,
	class _Ty> inline
	typename _Fill_memset_is_safe_helper<_FwdIt, _Ty>::type
	_Fill_memset_is_safe(const _FwdIt&, const _Ty&)
	{	// type deduction for _Fill_memset_is_safe_helper
	return {};
	}

template<class _FwdIt,
	class _Ty> inline
	void _Fill_unchecked1(_FwdIt _First, _FwdIt _Last, const _Ty& _Val, false_type)
	{	// copy _Val through [_First, _Last), no special optimization
	for (; _First != _Last; ++_First)
		*_First = _Val;
	}

template<class _FwdIt,
	class _Ty> inline
	void _Fill_unchecked1(_FwdIt _First, _FwdIt _Last, const _Ty& _Val, true_type)
	{	// copy _Val through [_First, _Last), memset optimization
	:: memset(_First, static_cast<unsigned char>(_Val), static_cast<size_t>(_Last - _First));
	}

template<class _FwdIt,
	class _Ty> inline
	void _Fill_unchecked(_FwdIt _First, _FwdIt _Last, const _Ty& _Val)
	{	// copy _Val through [_First, _Last), choose optimization
	_Fill_unchecked1(_First, _Last, _Val, _Fill_memset_is_safe(_First, _Val));
	}

template<class _FwdIt,
	class _Ty> inline
	void fill(_FwdIt _First, _FwdIt _Last, const _Ty& _Val)
	{	// copy _Val through [_First, _Last)
	_Adl_verify_range(_First, _Last);
	_Fill_unchecked(_Get_unwrapped(_First), _Get_unwrapped(_Last), _Val);
	}

 












		// FUNCTION TEMPLATE fill_n
// TRANSITION: _Fill_n_unchecked and _Fill_n_unchecked1 are ABI zombie names
template<class _OutIt,
	class _Diff,
	class _Ty> inline
	_OutIt _Fill_n_unchecked2(_OutIt _Dest, _Diff _Count, const _Ty& _Val, false_type)
	{	// copy _Val _Count times through [_Dest, ...), no special optimization
	for (; 0 < _Count; --_Count, (void)++_Dest)
		*_Dest = _Val;
	return (_Dest);
	}

template<class _OutIt,
	class _Diff,
	class _Ty> inline
	_OutIt _Fill_n_unchecked2(_OutIt _Dest, _Diff _Count, const _Ty& _Val, true_type)
	{	// copy _Val _Count times through [_Dest, ...), memset optimization
	:: memset(_Dest, static_cast<unsigned char>(_Val), static_cast<size_t>(_Count));
	return (_Dest + _Count);
	}

template<class _OutIt,
	class _Diff,
	class _Ty> inline
	_OutIt fill_n(_OutIt _Dest, _Diff _Count_raw, const _Ty& _Val)
	{	// copy _Val _Count times through [_Dest, ...)
	const _Algorithm_int_t<_Diff> _Count = _Count_raw;
	if (0 < _Count)
		{
		const auto _UDest = _Get_unwrapped_n(_Dest, _Count);
		_Seek_wrapped(_Dest,
			_Fill_n_unchecked2(_UDest, _Count, _Val, _Fill_memset_is_safe(_UDest, _Val)));
		}

	return (_Dest);
	}

 













		// FUNCTION TEMPLATE equal
template<class _Elem1,
	class _Elem2>
	struct _Value_equality_is_bitwise_equality
		: bool_constant<static_cast<_Elem1>(-1) == static_cast<_Elem2>(-1)>
	{	// Tests whether the usual arithmetic conversions will preserve the bit-pattern
		// when promoting to int
		// e.g. short == unsigned short -> false
		//      int == unsigned int -> true
	};

template<class _Elem1,
	class _Elem2,
	class _Pr>
	struct _Equal_memcmp_is_safe_helper
		: false_type
	{	// determines whether it is safe to call memcmp to compare things;
		// defaults to false
	};

template<class _Elem1,
	class _Elem2>
	struct _Equal_memcmp_is_safe_helper<_Elem1, _Elem2, equal_to<>>
		: bool_constant<conjunction_v<
			_Is_same_size<_Elem1, _Elem2>,
			_Is_nonbool_integral<_Elem1>,
			_Is_nonbool_integral<_Elem2>,
			negation<is_volatile<_Elem1>>,
			negation<is_volatile<_Elem2>>,
			// note that order matters here, as being integral is a precondition
			// of _Value_equality_is_bitwise_equality
			_Value_equality_is_bitwise_equality<_Elem1, _Elem2>
		>>
	{	// allow memcmping same-size integral non-bool non-volatile bitwise types using equal_to<>
	};

template<class _Elem1,
	class _Elem2>
	struct _Equal_memcmp_is_safe_helper<_Elem1 *, _Elem2 *, equal_to<>>
		: is_same<remove_cv_t<_Elem1>, remove_cv_t<_Elem2>>::type
	{	// allow memcmping pointers-to-cv-T with equal_to<>
	};









template<class _Elem>
	struct _Equal_memcmp_is_safe_helper<_Elem, _Elem, _Char_traits_eq<char_traits<_Elem>>>
		: _Equal_memcmp_is_safe_helper<_Elem, _Elem, equal_to<>>::type
	{	// builtin char_traits::eq behaves like equal_to<>
	};

template<class _Elem>
	struct _Equal_memcmp_is_safe_helper<_Elem, _Elem, equal_to<_Elem>>
		: _Equal_memcmp_is_safe_helper<_Elem, _Elem, equal_to<>>::type
	{	// treat equal_to with exact T as equal_to<>
		// this is safe because we only activate the optimization for builtin _Elem (and std::byte)
	};

template<class _Iter1,
	class _Iter2,
	class _Pr> inline
	false_type _Equal_memcmp_is_safe(const _Iter1&, const _Iter2&, const _Pr&)
	{	// return equal optimization category for arbitrary iterators
	return {};
	}

template<class _Obj1,
	class _Obj2,
	class _Pr> inline
	typename _Equal_memcmp_is_safe_helper<
		remove_const_t<_Obj1>,
		remove_const_t<_Obj2>,
		_Pr>::type
		_Equal_memcmp_is_safe(_Obj1 * const&, _Obj2 * const&, const _Pr&)
	{	// return equal optimization category for pointers
	return {};
	}

template<class _InIt1,
	class _InIt2,
	class _Pr> inline
	bool _Equal_unchecked1(_InIt1 _First1, const _InIt1 _Last1,
		_InIt2 _First2, _Pr _Pred, false_type)
	{	// compare [_First1, _Last1) to [_First2, ...) using _Pred, no special optimization
	for (; _First1 != _Last1; ++_First1, (void)++_First2)
		{
		if (!_Pred(*_First1, *_First2))
			{
			return (false);
			}
		}

	return (true);
	}

template<class _InIt1,
	class _InIt2,
	class _Pr> inline
	bool _Equal_unchecked1(const _InIt1 _First1, const _InIt1 _Last1,
		const _InIt2 _First2, _Pr, true_type)
	{	// compare [_First1, _Last1) to [_First2, ...), memcmp optimization
	const auto _First1_ch = reinterpret_cast<const char *>(_First1);
	const auto _First2_ch = reinterpret_cast<const char *>(_First2);
	const auto _Count = static_cast<size_t>(reinterpret_cast<const char *>(_Last1) - _First1_ch);
	return (:: memcmp(_First1_ch, _First2_ch, _Count) == 0);
	}

template<class _InIt1,
	class _InIt2,
	class _Pr> inline
	bool _Equal_unchecked(const _InIt1 _First1, const _InIt1 _Last1,
		const _InIt2 _First2, _Pr _Pred)
	{	// compare [_First1, _Last1) to [_First2, ...) using _Pred, choose optimization
	return (_Equal_unchecked1(_First1, _Last1, _First2, _Pred,
		_Equal_memcmp_is_safe(_First1, _First2, _Pred)));
	}

template<class _InIt1,
	class _InIt2,
	class _Pr>
	 inline bool equal(const _InIt1 _First1, const _InIt1 _Last1,
		const _InIt2 _First2, _Pr _Pred)
	{	// compare [_First1, _Last1) to [_First2, ...) using _Pred
	_Adl_verify_range(_First1, _Last1);
	const auto _UFirst1 = _Get_unwrapped(_First1);
	const auto _ULast1 = _Get_unwrapped(_Last1);
	const auto _UFirst2 = _Get_unwrapped_n(_First2, _Idl_distance<_InIt1>(_UFirst1, _ULast1));
	return (_Equal_unchecked(_UFirst1, _ULast1, _UFirst2, _Pass_fn(_Pred)));
	}

 
template<class _InIt1,
	class _RightTy,
	size_t _RightSize,
	class _Pr,
	enable_if_t<!is_same_v<_RightTy *, _Pr>, int> = 0>
	 inline bool equal(const _InIt1 _First1, const _InIt1 _Last1, _RightTy (&_First2)[_RightSize], _Pr _Pred)
	{	// compare [_First1, _Last1) to [_First2, ...) using _Pred
	return (::std:: equal(_First1, _Last1,
		_Array_iterator<_RightTy, _RightSize>(_First2), _Pass_fn(_Pred)));
	}
 






















template<class _InIt1,
	class _InIt2>
	 inline bool equal(const _InIt1 _First1, const _InIt1 _Last1, const _InIt2 _First2)
	{	// compare [_First1, _Last1) to [_First2, ...)
	return (::std:: equal(_First1, _Last1, _First2, equal_to<>()));
	}

 
template<class _InIt1,
	class _RightTy,
	size_t _RightSize>
	 inline bool equal(const _InIt1 _First1, const _InIt1 _Last1, _RightTy (&_First2)[_RightSize])
	{	// compare [_First1, _Last1) to [_First2, ...)
	return (::std:: equal(_First1, _Last1, _First2, equal_to<>()));
	}
 


























template<class _InIt1,
	class _InIt2,
	class _Pr> inline
	bool _Equal_unchecked(_InIt1 _First1, const _InIt1 _Last1,
		_InIt2 _First2, const _InIt2 _Last2, _Pr _Pred,
		input_iterator_tag, input_iterator_tag)
	{	// compare [_First1, _Last1) to [_First2, _Last2)
		// using _Pred, arbitrary iterators
	for (;;)
		{
		if (_First1 == _Last1)
			{
			return (_First2 == _Last2);
			}

		if (_First2 == _Last2)
			{
			return (false);
			}

		if (!_Pred(*_First1, *_First2))
			{
			return (false);
			}

		++_First1;
		++_First2;
		}
	}

template<class _InIt1,
	class _InIt2,
	class _Pr> inline
	bool _Equal_unchecked(const _InIt1 _First1, const _InIt1 _Last1,
		const _InIt2 _First2, const _InIt2 _Last2, _Pr _Pred,
		random_access_iterator_tag, random_access_iterator_tag)
	{	// compare [_First1, _Last1) to [_First2, _Last2)
		// using _Pred, random-access iterators
	if (_Last1 - _First1 != _Last2 - _First2)
		{
		return (false);
		}

	return (_Equal_unchecked(_First1, _Last1, _First2, _Pred));
	}

template<class _InIt1,
	class _InIt2,
	class _Pr>
	 inline bool equal(const _InIt1 _First1, const _InIt1 _Last1,
		const _InIt2 _First2, const _InIt2 _Last2, _Pr _Pred)
	{	// compare [_First1, _Last1) to [_First2, _Last2) using _Pred
	_Adl_verify_range(_First1, _Last1);
	_Adl_verify_range(_First2, _Last2);
	return (_Equal_unchecked(_Get_unwrapped(_First1), _Get_unwrapped(_Last1),
		_Get_unwrapped(_First2), _Get_unwrapped(_Last2), _Pass_fn(_Pred),
			_Iter_cat_t<_InIt1>(), _Iter_cat_t<_InIt2>()));
	}











template<class _InIt1,
	class _InIt2>
	 inline bool equal(const _InIt1 _First1, const _InIt1 _Last1, const _InIt2 _First2, const _InIt2 _Last2)
	{	// compare [_First1, _Last1) to [_First2, _Last2)
	return (::std:: equal(_First1, _Last1, _First2, _Last2, equal_to<>()));
	}













		// FUNCTION TEMPLATE lexicographical_compare
template<class _Elem1,
	class _Elem2,
	class _FTy>
	struct _Lex_compare_check_element_types_helper
		: bool_constant<conjunction_v<
			_Is_character<_Elem1>,
			_Is_character<_Elem2>,
			_Is_character<_FTy>,
			is_unsigned<_FTy>
		>>
	{	// checks the lex_compare element types for memcmp safety for builtin functors (e.g. less<unsigned char>)
	};

template<class _Elem1,
	class _Elem2>
	struct _Lex_compare_check_element_types_helper<_Elem1, _Elem2, void>
		: bool_constant<conjunction_v<
			_Is_character<_Elem1>,
			_Is_character<_Elem2>,
			is_unsigned<_Elem1>,
			is_unsigned<_Elem2>
		>>
	{	// checks the lex_compare element types for memcmp safety for transparent functors (e.g. less<>)
	};















template<class _Memcmp_pr>
	struct _Lex_compare_optimize
	{	// optimization tag for lexicographical_compare
	};

template<class _Memcmp_pr,
	class _Obj1,
	class _Obj2,
	class _FTy>
	using _Lex_compare_check_element_types = _Lex_compare_optimize<conditional_t<
		_Lex_compare_check_element_types_helper<remove_const_t<_Obj1>, remove_const_t<_Obj2>, _FTy>::value,
		_Memcmp_pr, void>>;	// checks the lex_compare element types for memcmp safety

template<class _InIt1,
	class _InIt2,
	class _Pr> inline
	_Lex_compare_optimize<void> _Lex_compare_memcmp_classify(const _InIt1&, const _InIt2&, const _Pr&)
	{	// return lex_compare optimization category for arbitrary iterators
	return {};
	}

template<class _Obj1,
	class _Obj2,
	class _FTy> inline
	_Lex_compare_check_element_types<less<int>, _Obj1, _Obj2, _FTy>
		_Lex_compare_memcmp_classify(_Obj1 * const&, _Obj2 * const&, const less<_FTy>&)
	{	// return lex_compare optimization category for pointer iterators and less<_FTy>
	return {};
	}

template<class _Obj1,
	class _Obj2,
	class _FTy> inline
	_Lex_compare_check_element_types<greater<int>, _Obj1, _Obj2, _FTy>
		_Lex_compare_memcmp_classify(_Obj1 * const&, _Obj2 * const&, const greater<_FTy>&)
	{	// return lex_compare optimization category for pointer iterators and greater<_FTy>
	return {};
	}

template<class _InIt1,
	class _InIt2,
	class _Pr> inline
	bool _Lex_compare_unchecked(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2, _Pr _Pred, _Lex_compare_optimize<void>)
	{	// order [_First1, _Last1) vs. [_First2, _Last2) using _Pred, no special optimization
	for (; _First1 != _Last1 && _First2 != _Last2; ++_First1, (void)++_First2)
		{	// something to compare, do it
		if (_Debug_lt_pred(_Pred, *_First1, *_First2))
			return (true);
		else if (_Pred(*_First2, *_First1))
			return (false);
		}

	return (_First1 == _Last1 && _First2 != _Last2);
	}

template<class _InIt1,
	class _InIt2,
	class _Pr,
	class _Memcmp_pr> inline
	bool _Lex_compare_unchecked(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2, _Pr, _Lex_compare_optimize<_Memcmp_pr>)
	{	// order [_First1, _Last1) vs. [_First2, _Last2) memcmp optimization
	const auto _Num1 = static_cast<size_t>(_Last1 - _First1);
	const auto _Num2 = static_cast<size_t>(_Last2 - _First2);
	const int _Ans = :: memcmp(_First1, _First2, _Num1 < _Num2 ? _Num1 : _Num2);
	return (_Memcmp_pr{}(_Ans, 0) || (_Ans == 0 && _Num1 < _Num2));
	}

template<class _InIt1,
	class _InIt2,
	class _Pr>
	 inline bool lexicographical_compare(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2, _Pr _Pred)
	{	// order [_First1, _Last1) vs. [_First2, _Last2) using _Pred
	_Adl_verify_range(_First1, _Last1);
	_Adl_verify_range(_First2, _Last2);
	const auto _UFirst1 = _Get_unwrapped(_First1);
	const auto _ULast1 = _Get_unwrapped(_Last1);
	const auto _UFirst2 = _Get_unwrapped(_First2);
	const auto _ULast2 = _Get_unwrapped(_Last2);
	return (_Lex_compare_unchecked(_UFirst1, _ULast1, _UFirst2, _ULast2, _Pass_fn(_Pred),
		_Lex_compare_memcmp_classify(_UFirst1, _UFirst2, _Pred)));
	}

template<class _InIt1,
	class _InIt2>
	 inline bool lexicographical_compare(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2)
	{	// order [_First1, _Last1) vs. [_First2, _Last2)
	return (::std:: lexicographical_compare(_First1, _Last1,
		_First2, _Last2, less<>()));
	}






























		// FUNCTION TEMPLATE find
template<class _Ty> inline
	bool _Within_limits(const _Ty& _Val, true_type, true_type, _Any_tag)
	{	// signed _Elem, signed _Ty
	return ((-128) <= _Val && _Val <= 127);
	}

template<class _Ty> inline
	bool _Within_limits(const _Ty& _Val, true_type, false_type, true_type)
	{	// signed _Elem, unsigned _Ty, -1 == static_cast<_Ty>(-1)
	return (_Val <= 127 || static_cast<_Ty>((-128)) <= _Val);
	}

template<class _Ty> inline
	bool _Within_limits(const _Ty& _Val, true_type, false_type, false_type)
	{	// signed _Elem, unsigned _Ty, -1 != static_cast<_Ty>(-1)
	return (_Val <= 127);
	}

template<class _Ty> inline
	bool _Within_limits(const _Ty& _Val, false_type, true_type, _Any_tag)
	{	// unsigned _Elem, signed _Ty
	return (0 <= _Val && _Val <= 0xff);
	}

template<class _Ty> inline
	bool _Within_limits(const _Ty& _Val, false_type, false_type, _Any_tag)
	{	// unsigned _Elem, unsigned _Ty
	return (_Val <= 0xff);
	}

template<class _InIt,
	class _Ty> inline
	bool _Within_limits(_InIt, const _Ty& _Val)
	{	// check whether _Val is within the limits of _Elem
	using _Elem = remove_pointer_t<_InIt>;
	return (_Within_limits(_Val, is_signed<_Elem>{}, is_signed<_Ty>{},
		bool_constant<-1 == static_cast<_Ty>(-1)>{}));
	}

template<class _InIt> inline
	bool _Within_limits(_InIt, const bool&)
	{	// bools are always within the limits of _Elem
	return (true);
	}

template<class _InIt,
	class _Ty> inline
	_InIt _Find_unchecked1(_InIt _First, const _InIt _Last, const _Ty& _Val, true_type)
	{	// find first byte matching integral _Val
	if (!_Within_limits(_First, _Val))
		{
		return (_Last);
		}

	_First = static_cast<_InIt>(:: memchr(
		_First, static_cast<unsigned char>(_Val), static_cast<size_t>(_Last - _First)));
	return (_First ? _First : _Last);
	}

template<class _InIt,
	class _Ty> inline
	_InIt _Find_unchecked1(_InIt _First, const _InIt _Last, const _Ty& _Val, false_type)
	{	// find first matching _Val
	for (; _First != _Last; ++_First)
		if (*_First == _Val)
			break;
	return (_First);
	}

template<class _InIt,
	class _Ty> inline
	_InIt _Find_unchecked(const _InIt _First, const _InIt _Last, const _Ty& _Val)
	{	// find first matching _Val; choose optimization
	// activate optimization for pointers to (const) bytes and integral values
	using _Memchr_opt = bool_constant<is_integral_v<_Ty> && _Is_any_of_v<_InIt,
		char *, signed char *, unsigned char *, const char *, const signed char *, const unsigned char *>>;

	return (_Find_unchecked1(_First, _Last, _Val, _Memchr_opt{}));
	}

template<class _InIt,
	class _Ty>
	 inline _InIt find(_InIt _First, const _InIt _Last, const _Ty& _Val)
	{	// find first matching _Val
	_Adl_verify_range(_First, _Last);
	_Seek_wrapped(_First,
		_Find_unchecked(_Get_unwrapped(_First), _Get_unwrapped(_Last), _Val));
	return (_First);
	}









		// FUNCTION TEMPLATE _Find_pr
template<class _InIt,
	class _Ty,
	class _Pr> inline
	_InIt _Find_pr(_InIt _First, _InIt _Last, const _Ty& _Val, _Pr _Pred)
	{	// find first matching _Val, using _Pred
	for (; _First != _Last; ++_First)
		{
		if (_Pred(*_First, _Val))
			{
			break;
			}
		}

	return (_First);
	}

		// FUNCTION TEMPLATE count
template<class _InIt,
	class _Ty>
	 inline _Iter_diff_t<_InIt> count(const _InIt _First, const _InIt _Last, const _Ty& _Val)
	{	// count elements that match _Val
	_Adl_verify_range(_First, _Last);
	auto _UFirst = _Get_unwrapped(_First);
	const auto _ULast = _Get_unwrapped(_Last);
	_Iter_diff_t<_InIt> _Count = 0;

	for (; _UFirst != _ULast; ++_UFirst)
		{
		if (*_UFirst == _Val)
			{
			++_Count;
			}
		}

	return (_Count);
	}










		// FUNCTION TEMPLATE _Count_pr
template<class _InIt,
	class _Ty,
	class _Pr> inline
	_Iter_diff_t<_InIt> _Count_pr(_InIt _First, _InIt _Last, const _Ty& _Val, _Pr _Pred)
	{	// count elements that match _Val, using _Pred
	_Iter_diff_t<_InIt> _Count = 0;

	for (; _First != _Last; ++_First)
		{
		if (_Pred(*_First, _Val))
			{
			++_Count;
			}
		}

	return (_Count);
	}

		// FUNCTION TEMPLATE _Trim_matching_suffixes
template<class _FwdIt1,
	class _FwdIt2,
	class _Pr> inline
	void _Trim_matching_suffixes(_FwdIt1&, _FwdIt2&, _Pr,
		forward_iterator_tag, forward_iterator_tag)
	{	// trim matching suffixes, forward iterators (do nothing)
	}

template<class _FwdIt1,
	class _FwdIt2,
	class _Pr> inline
	void _Trim_matching_suffixes(_FwdIt1& _Last1, _FwdIt2& _Last2, _Pr _Pred,
		bidirectional_iterator_tag, bidirectional_iterator_tag)
	{	// trim matching suffixes, bidirectional iterators
	// assumptions: same lengths, non-empty, !_Pred(*_First1, *_First2)
	do
		{	// find last inequality
		--_Last1;
		--_Last2;
		}
	while (_Pred(*_Last1, *_Last2));
	++_Last1;
	++_Last2;
	}

		// FUNCTION TEMPLATE _Check_match_counts
template<class _FwdIt1,
	class _FwdIt2,
	class _Pr> inline
	bool _Check_match_counts(_FwdIt1 _First1, _FwdIt1 _Last1,
		_FwdIt2 _First2, _FwdIt2 _Last2, _Pr _Pred)
	{	// test if [_First1, _Last1) == permuted [_First2, _Last2), using _Pred, same lengths
	_Trim_matching_suffixes(_Last1, _Last2, _Pred,
		_Iter_cat_t<_FwdIt1>(), _Iter_cat_t<_FwdIt2>());
	for (_FwdIt1 _Next1 = _First1; _Next1 != _Last1; ++_Next1)
		{
		if (_Next1 == _Find_pr(_First1, _Next1, *_Next1, _Pred))
			{	// new value, compare match counts
			_Iter_diff_t<_FwdIt2> _Count2 = _Count_pr(_First2, _Last2, *_Next1, _Pred);
			if (_Count2 == 0)
				{
				return (false);	// second range lacks value, fail
				}

			_FwdIt1 _Skip1 = _Next_iter(_Next1);
			_Iter_diff_t<_FwdIt1> _Count1 = _Count_pr(_Skip1, _Last1, *_Next1, _Pred) + 1;
			if (_Count2 != _Count1)
				{
				return (false);	// match counts differ, fail
				}
			}
		}

	return (true);
	}

		// FUNCTION TEMPLATE is_permutation
template<class _FwdIt1,
	class _FwdIt2,
	class _Pr> inline
	bool _Is_permutation_unchecked(_FwdIt1 _First1, _FwdIt1 _Last1, _FwdIt2 _First2, _Pr _Pred)
	{	// test if [_First1, _Last1) == permuted [_First2, ...), using _Pred
	for (; _First1 != _Last1; ++_First1, (void)++_First2)
		{
		if (!_Pred(*_First1, *_First2))
			{	// found first inequality, check match counts in suffix
				// narrowing _Iter_diff_t<_FwdIt1> to _Iter_diff_t<_FwdIt2> is OK because if
				// the 2nd range is shorter than the 1st, the user already triggered UB
			auto _Last2 = ::std:: next(_First2, static_cast<_Iter_diff_t<_FwdIt2>>(::std:: distance(_First1, _Last1)));
			return (_Check_match_counts(_First1, _Last1, _First2, _Last2, _Pred));
			}
		}

	return (true);
	}

template<class _FwdIt1,
	class _FwdIt2,
	class _Pr>
	 inline bool is_permutation(_FwdIt1 _First1, _FwdIt1 _Last1,
		_FwdIt2 _First2, _Pr _Pred)
	{	// test if [_First1, _Last1) == permuted [_First2, ...), using _Pred
	_Adl_verify_range(_First1, _Last1);
	const auto _UFirst1 = _Get_unwrapped(_First1);
	const auto _ULast1 = _Get_unwrapped(_Last1);
	const auto _UFirst2 = _Get_unwrapped_n(_First2, _Idl_distance<_FwdIt1>(_UFirst1, _ULast1));
	return (_Is_permutation_unchecked(_UFirst1, _ULast1, _UFirst2, _Pass_fn(_Pred)));
	}

 
template<class _FwdIt1,
	class _RightTy,
	size_t _RightSize,
	class _Pr,
	class = enable_if_t<!is_same_v<_RightTy *, _Pr>>>
	 inline bool is_permutation(_FwdIt1 _First1, _FwdIt1 _Last1,
		_RightTy (&_First2)[_RightSize], _Pr _Pred)
	{	// test if [_First1, _Last1) == permuted [_First2, ...), using _Pred
	return (::std:: is_permutation(_First1, _Last1,
		_Array_iterator<_RightTy, _RightSize>(_First2), _Pass_fn(_Pred)));
	}
 

template<class _FwdIt1,
	class _FwdIt2> inline
	bool is_permutation(_FwdIt1 _First1, _FwdIt1 _Last1,
		_FwdIt2 _First2)
	{	// test if [_First1, _Last1) == permuted [_First2, ...)
	return (::std:: is_permutation(_First1, _Last1,
		_First2, equal_to<>()));
	}


 
template<class _FwdIt1,
	class _RightTy,
	size_t _RightSize>
	 inline bool is_permutation(_FwdIt1 _First1, _FwdIt1 _Last1, _RightTy (&_First2)[_RightSize])
	{	// test if [_First1, _Last1) == permuted [_First2, ...)
	return (::std:: is_permutation(_First1, _Last1, _First2, equal_to<>()));
	}
 

template<class _FwdIt1,
	class _FwdIt2,
	class _Pr> inline
	bool _Is_permutation_unchecked(_FwdIt1 _First1, _FwdIt1 _Last1,
		_FwdIt2 _First2, _FwdIt2 _Last2, _Pr _Pred,
		forward_iterator_tag, forward_iterator_tag)
	{	// test if [_First1, _Last1) == permuted [_First2, _Last2),
		// using _Pred, arbitrary iterators
	for (; _First1 != _Last1 && _First2 != _Last2; ++_First1, (void)++_First2)
		{
		if (!_Pred(*_First1, *_First2))
			{	// found first inequality, check match counts in suffix
			if (::std:: distance(_First1, _Last1) == ::std:: distance(_First2, _Last2))
				{
				return (_Check_match_counts(_First1, _Last1, _First2, _Last2, _Pred));
				}
			else
				{
				return (false);	// lengths differ, fail
				}
			}
		}

	return (_First1 == _Last1 && _First2 == _Last2);
	}

template<class _FwdIt1,
	class _FwdIt2,
	class _Pr> inline
	bool _Is_permutation_unchecked(_FwdIt1 _First1, _FwdIt1 _Last1,
		_FwdIt2 _First2, _FwdIt2 _Last2, _Pr _Pred,
		random_access_iterator_tag, random_access_iterator_tag)
	{	// test if [_First1, _Last1) == permuted [_First2, _Last2),
		// using _Pred, random-access iterators
	if (_Last1 - _First1 != _Last2 - _First2)
		{
		return (false);
		}

	return (_Is_permutation_unchecked(_First1, _Last1, _First2, _Pred));
	}

template<class _FwdIt1,
	class _FwdIt2,
	class _Pr>
	 inline bool is_permutation(_FwdIt1 _First1, _FwdIt1 _Last1,
		_FwdIt2 _First2, _FwdIt2 _Last2, _Pr _Pred)
	{	// test if [_First1, _Last1) == permuted [_First2, _Last2),
		// using _Pred
	_Adl_verify_range(_First1, _Last1);
	_Adl_verify_range(_First2, _Last2);
	return (_Is_permutation_unchecked(_Get_unwrapped(_First1), _Get_unwrapped(_Last1),
		_Get_unwrapped(_First2), _Get_unwrapped(_Last2), _Pass_fn(_Pred),
		_Iter_cat_t<_FwdIt1>(), _Iter_cat_t<_FwdIt2>()));
	}

		// FUNCTION TEMPLATE is_permutation WITH TWO RANGES
template<class _FwdIt1,
	class _FwdIt2>
	 inline bool is_permutation(_FwdIt1 _First1, _FwdIt1 _Last1,
		_FwdIt2 _First2, _FwdIt2 _Last2)
	{	// test if [_First1, _Last1) == permuted [_First2, _Last2)
	return (::std:: is_permutation(_First1, _Last1, _First2, _Last2, equal_to<>()));
	}

		// FUNCTION TEMPLATE reverse
template<class _BidIt> inline
	void _Reverse_unchecked1(_BidIt _First, _BidIt _Last, integral_constant<size_t, 0>)
	{	// reverse elements in [_First, _Last), general bidirectional iterators
	for (; _First != _Last && _First != --_Last; ++_First)
		{
		::std:: iter_swap(_First, _Last);
		}
	}


template<class _BidIt> inline
	void _Reverse_unchecked1(const _BidIt _First, const _BidIt _Last, integral_constant<size_t, 1>)
	{	// reverse elements in [_First, _Last), pointers to trivially swappable of size 1
	__std_reverse_trivially_swappable_1(_First, _Last);
	}

template<class _BidIt> inline
	void _Reverse_unchecked1(const _BidIt _First, const _BidIt _Last, integral_constant<size_t, 2>)
	{	// reverse elements in [_First, _Last), pointers to trivially swappable of size 2
	__std_reverse_trivially_swappable_2(_First, _Last);
	}

template<class _BidIt> inline
	void _Reverse_unchecked1(const _BidIt _First, const _BidIt _Last, integral_constant<size_t, 4>)
	{	// reverse elements in [_First, _Last), pointers to trivially swappable of size 4
	__std_reverse_trivially_swappable_4(_First, _Last);
	}

template<class _BidIt> inline
	void _Reverse_unchecked1(const _BidIt _First, const _BidIt _Last, integral_constant<size_t, 8>)
	{	// reverse elements in [_First, _Last), pointers to trivially swappable of size 8
	__std_reverse_trivially_swappable_8(_First, _Last);
	}


template<class _BidIt> inline
	void _Reverse_unchecked(const _BidIt _First, const _BidIt _Last)
	{	// reverse elements in [_First, _Last), choose optimization

	using _Elem = remove_pointer_t<_BidIt>;
	constexpr size_t _Opt = is_pointer_v<_BidIt>
		&& _Is_trivially_swappable_v<_Elem>
		&& !is_volatile_v<_Elem>
		&& (sizeof(_Elem) == 1
			|| sizeof(_Elem) == 2
			|| sizeof(_Elem) == 4
			|| sizeof(_Elem) == 8) ? sizeof(_Elem) : 0;



	_Reverse_unchecked1(_First, _Last, integral_constant<size_t, _Opt>{});
	}

template<class _BidIt> inline
	void reverse(const _BidIt _First, const _BidIt _Last)
	{	// reverse elements in [_First, _Last)
	_Adl_verify_range(_First, _Last);
	_Reverse_unchecked(_Get_unwrapped(_First), _Get_unwrapped(_Last));
	}

 










		// FUNCTION TEMPLATE rotate
template<class _FwdIt> inline
	_FwdIt _Rotate_unchecked1(_FwdIt _First, _FwdIt _Mid, _FwdIt _Last,
		forward_iterator_tag)
	{	// rotate [_First, _Last) left by distance(_First, _Mid) positions, forward iterators
	for (_FwdIt _Next = _Mid, _Res = _Last; ; )
		{	// swap [_First, ...) into place
		::std:: iter_swap(_First, _Next);
		if (++_First == _Mid)
			{	// quit if done, else define next interval
			if (++_Next == _Last)
				return (_Res == _Last ? _Mid : _Res);
			else
				_Mid = _Next;	// mark end of next interval
			}
		else if (++_Next == _Last)
			{	// wrap to last end
			if (_Res == _Last)
				_Res = _First;
			_Next = _Mid;
			}
		}
	}

template<class _BidIt> inline
	pair<_BidIt, _BidIt> _Reverse_until_sentinel_unchecked(
		_BidIt _First, _BidIt _Sentinel, _BidIt _Last)
	{	// reverse until either _First or _Last hits _Sentinel
	while (_First != _Sentinel && _Last != _Sentinel)
		{
		::std:: iter_swap(_First, --_Last);
		++_First;
		}

	return (::std:: make_pair(_First, _Last));
	}

template<class _BidIt> inline
	_BidIt _Rotate_unchecked1(_BidIt _First, _BidIt _Mid, _BidIt _Last,
		bidirectional_iterator_tag)
	{	// rotate [_First, _Last) left by distance(_First, _Mid) positions, bidirectional iterators
	_Reverse_unchecked(_First, _Mid);
	_Reverse_unchecked(_Mid, _Last);
	pair<_BidIt, _BidIt> _Tmp = _Reverse_until_sentinel_unchecked(_First, _Mid, _Last);
	_Reverse_unchecked(_Tmp.first, _Tmp.second);
	return (_Mid != _Tmp.first ? _Tmp.first : _Tmp.second);
	}

template<class _RanIt> inline
	_RanIt _Rotate_unchecked1(_RanIt _First, _RanIt _Mid, _RanIt _Last,
		random_access_iterator_tag)
	{	// rotate [_First, _Last) left by distance(_First, _Mid) positions, random-access iterators
	_Reverse_unchecked(_First, _Mid);
	_Reverse_unchecked(_Mid, _Last);
	_Reverse_unchecked(_First, _Last);
	return (_First + (_Last - _Mid));
	}

template<class _FwdIt> inline
	_FwdIt _Rotate_unchecked(_FwdIt _First, _FwdIt _Mid, _FwdIt _Last)
	{	// rotate [_First, _Last) left by distance(_First, _Mid) positions
	if (_First == _Mid)
		return (_Last);
	if (_Mid == _Last)
		return (_First);
	return (_Rotate_unchecked1(_First, _Mid, _Last, _Iter_cat_t<_FwdIt>()));
	}

template<class _FwdIt> inline
	_FwdIt rotate(_FwdIt _First, _FwdIt _Mid, _FwdIt _Last)
	{	// exchange the ranges [_First, _Mid) and [_Mid, _Last)
		// that is, rotates [_First, _Last) left by distance(_First, _Mid) positions
		// returns the iterator pointing at *_First's new home
	_Adl_verify_range(_First, _Mid);
	_Adl_verify_range(_Mid, _Last);
	_Seek_wrapped(_First,
		_Rotate_unchecked(_Get_unwrapped(_First), _Get_unwrapped(_Mid),
		_Get_unwrapped(_Last)));
	return (_First);
	}












		// FUNCTION TEMPLATE lower_bound
template<class _FwdIt,
	class _Ty,
	class _Pr>
	 inline _FwdIt lower_bound(_FwdIt _First, const _FwdIt _Last,
		const _Ty& _Val, _Pr _Pred)
	{	// find first element not before _Val, using _Pred
	_Adl_verify_range(_First, _Last);
	auto _UFirst = _Get_unwrapped(_First);
	_Iter_diff_t<_FwdIt> _Count = ::std:: distance(_UFirst, _Get_unwrapped(_Last));

	while (0 < _Count)
		{	// divide and conquer, find half that contains answer
		const _Iter_diff_t<_FwdIt> _Count2 = _Count >> 1; // TRANSITION, VSO#433486
		const auto _UMid = ::std:: next(_UFirst, _Count2);
		if (_Pred(*_UMid, _Val))
			{	// try top half
			_UFirst = _Next_iter(_UMid);
			_Count -= _Count2 + 1;
			}
		else
			{
			_Count = _Count2;
			}
		}

	_Seek_wrapped(_First, _UFirst);
	return (_First);
	}

	// CLASS TEMPLATE _Rng_from_urng
template<class _Diff,
	class _Urng>
	class _Rng_from_urng
	{	// wrap a URNG as an RNG
public:
	using _Ty0 = make_unsigned_t<_Diff>;
	using _Ty1 = typename _Urng::result_type;

	using _Udiff = conditional_t<sizeof (_Ty1) < sizeof (_Ty0), _Ty0, _Ty1>;

	explicit _Rng_from_urng(_Urng& _Func)
		: _Ref(_Func), _Bits(8 * sizeof (_Udiff)), _Bmask(_Udiff(-1))
		{	// construct from URNG
		for (; (_Urng::max)() - (_Urng::min)() < _Bmask; _Bmask >>= 1)
			--_Bits;
		}

	_Diff operator()(_Diff _Index)
		{	// adapt _Urng closed range to [0, _Index)
		for (;;)
			{	// try a sample random value
			_Udiff _Ret = 0;	// random bits
			_Udiff _Mask = 0;	// 2^N - 1, _Ret is within [0, _Mask]

			while (_Mask < _Udiff(_Index - 1))
				{	// need more random bits
				_Ret <<= _Bits - 1;	// avoid full shift
				_Ret <<= 1;
				_Ret |= _Get_bits();
				_Mask <<= _Bits - 1;	// avoid full shift
				_Mask <<= 1;
				_Mask |= _Bmask;
				}

			// _Ret is [0, _Mask], _Index - 1 <= _Mask, return if unbiased
			if (_Ret / _Index < _Mask / _Index
				|| _Mask % _Index == _Udiff(_Index - 1))
				return (static_cast<_Diff>(_Ret % _Index));
			}
		}

	_Udiff _Get_all_bits()
		{	// return a random value
		_Udiff _Ret = 0;

		for (size_t _Num = 0; _Num < 8 * sizeof (_Udiff);
			_Num += _Bits)
			{	// don't mask away any bits
			_Ret <<= _Bits - 1;	// avoid full shift
			_Ret <<= 1;
			_Ret |= _Get_bits();
			}

		return (_Ret);
		}

	_Rng_from_urng(const _Rng_from_urng&) = delete;
	_Rng_from_urng& operator=(const _Rng_from_urng&) = delete;

private:
	_Udiff _Get_bits()
		{	// return a random value within [0, _Bmask]
		for (;;)
			{	// repeat until random value is in range
			_Udiff _Val = _Ref() - (_Urng::min)();

			if (_Val <= _Bmask)
				return (_Val);
			}
		}

	_Urng& _Ref;	// reference to URNG
	size_t _Bits;	// number of random bits generated by _Get_bits()
	_Udiff _Bmask;	// 2^_Bits - 1
	};

		// CLASS TEMPLATE _Yarn
template<class _Elem>
	class __declspec(dllimport) _Yarn
	{	// wrap a NTBS
public:
	 _Yarn()
		: _Myptr(nullptr), _Nul(0)
		{	// default construct
		}

	 _Yarn(const _Yarn& _Right)
		: _Myptr(nullptr), _Nul(0)
		{	// construct from _Yarn
		*this = _Right;
		}

	 _Yarn(const _Elem * _Right)
		: _Myptr(nullptr), _Nul(0)
		{	// construct from NTBS
		*this = _Right;
		}

	_Yarn&  operator=(const _Yarn& _Right)
		{	// assign from _Yarn
		return (*this = _Right._Myptr);
		}

	_Yarn&  operator=(const _Elem * _Right)
		{	// assign from NTBS
		if (_Myptr != _Right)
			{	// new value, discard old and copy new
			_Tidy();

			if (_Right != nullptr)
				{	// new is not empty, copy it
				const _Elem *_Ptr = _Right;
				while (*_Ptr != (_Elem)0)
					{
					++_Ptr;
					}

				const auto _Count = (++_Ptr - _Right) * sizeof(_Elem);

 
				_Myptr = (_Elem *)_malloc_dbg(_Count, 2,
					"c:\\visual studio\\vc\\tools\\msvc\\14.16.27023\\include\\xutility", 4125);

 



				if (_Myptr != nullptr)
					{
					:: memcpy(_Myptr, _Right, _Count);
					}
				}
			}

		return (*this);
		}

	 ~_Yarn() noexcept
		{	// destroy the object
		_Tidy();
		}

	bool  empty() const
		{	// test if empty string
		return (_Myptr == nullptr);
		}

	  const _Elem * c_str() const
		{	// return NTBS
		return (_Myptr != nullptr ? _Myptr : &_Nul);
		}

	bool  _Empty() const
		{	// test if empty string
		return (_Myptr == nullptr);
		}

	  const _Elem * _C_str() const
		{	// return NTBS
		return (_Myptr != nullptr ? _Myptr : &_Nul);
		}

private:
	void  _Tidy()
		{	// discard any string
		if (_Myptr != nullptr)

 
			_free_dbg(_Myptr, 2);

 



		_Myptr = nullptr;
		}

	_Elem * _Myptr;	// pointer to allocated string
	_Elem _Nul;		// nul terminator for unallocated string
	};


		// CLASS TEMPLATE back_insert_iterator
template<class _Container>
	class back_insert_iterator
	{	// wrap pushes to back of container as output iterator
public:
	using iterator_category = output_iterator_tag;
	using value_type = void;
	using difference_type = void;
	using pointer = void;
	using reference = void;

	using container_type = _Container;

	explicit back_insert_iterator(_Container& _Cont)
		: container(::std:: addressof(_Cont))
		{	// construct with container
		}

	back_insert_iterator& operator=(const typename _Container::value_type& _Val)
		{	// push value into container
		container->push_back(_Val);
		return (*this);
		}

	back_insert_iterator& operator=(typename _Container::value_type&& _Val)
		{	// push value into container
		container->push_back(::std:: move(_Val));
		return (*this);
		}

	 back_insert_iterator& operator*()
		{	// pretend to return designated value
		return (*this);
		}

	back_insert_iterator& operator++()
		{	// pretend to preincrement
		return (*this);
		}

	back_insert_iterator operator++(int)
		{	// pretend to postincrement
		return (*this);
		}

protected:
	_Container *container;	// pointer to container
	};

		// FUNCTION TEMPLATE back_inserter
template<class _Container>
	 inline back_insert_iterator<_Container> back_inserter(_Container& _Cont)
	{	// return a back_insert_iterator
	return (back_insert_iterator<_Container>(_Cont));
	}


	// STRUCT TEMPLATE _Has_allocator_type
template<class _Ty,
	class _Alloc,
	class = void>
	struct _Has_allocator_type
		: false_type
	{	// tests for suitable _Ty::allocator_type
	};

template<class _Ty,
	class _Alloc>
	struct _Has_allocator_type<_Ty, _Alloc, void_t<typename _Ty::allocator_type>>
		: is_convertible<_Alloc, typename _Ty::allocator_type>::type
	{	// tests for suitable _Ty::allocator_type
	};

		// STRUCT allocator_arg_t
struct allocator_arg_t
	{	// tag type for added allocator argument
	explicit allocator_arg_t() = default;
	};

 constexpr allocator_arg_t allocator_arg{};

[[noreturn]]  void __cdecl _Xbad_alloc();
[[noreturn]]  void __cdecl _Xinvalid_argument(  const char *);
[[noreturn]]  void __cdecl _Xlength_error(  const char *);
[[noreturn]]  void __cdecl _Xout_of_range(  const char *);
[[noreturn]]  void __cdecl _Xoverflow_error(  const char *);
[[noreturn]]  void __cdecl _Xruntime_error(  const char *);

		// STRUCT TEMPLATE uses_allocator
template<class _Ty,
	class _Alloc>
	struct uses_allocator
		: _Has_allocator_type<_Ty, _Alloc>::type
	{	// determine whether _Ty has an allocator_type member type
	};

template<class _Ty,
	class _Alloc>
	 constexpr bool uses_allocator_v = uses_allocator<_Ty, _Alloc>::value;

		// STRUCT TEMPLATE iterator
template<class _Category,
	class _Ty,
	class _Diff = ptrdiff_t,
	class _Pointer = _Ty *,
	class _Reference = _Ty&>
	struct  iterator
	{	// base type for iterator classes
	using iterator_category = _Category;
	using value_type = _Ty;
	using difference_type = _Diff;
	using pointer = _Pointer;
	using reference = _Reference;
	};
}
 
 
 #pragma warning(pop)
 #pragma pack(pop)



/*
 * Copyright (c) by P.J. Plauger. All rights reserved.
 * Consult your license regarding permissions and restrictions.
V6.50:0009 */


 #pragma pack(push,8)
 #pragma warning(push,3)
 #pragma warning(disable: 4455 4494  4619 4643 4702 4984 4988 )
 
 
 

namespace std {
		// FUNCTION TEMPLATE _Get_size_of_n
template<size_t _Ty_size> inline
	size_t _Get_size_of_n(const size_t _Count)
	{	// gets the size of _Count copies of a type sized _Ty_size
	constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;
	size_t _Result = _Count * _Ty_size;
	if (_Max_possible < _Count)
		{	// multiply overflow, try allocating all of memory and assume the
			// allocation function will throw bad_alloc
		_Result = static_cast<size_t>(-1);
		}

	return (_Result);
	}

template<> inline
	size_t _Get_size_of_n<1>(const size_t _Count)
	{	// gets the size of _Count copies of a type with size 1
	return (_Count);
	}

		// VARIABLE TEMPLATE _New_alignof
template<class _Ty>
	 constexpr size_t _New_alignof = _Max_value(alignof(_Ty),
		static_cast<size_t>(16ull) // TRANSITION, VSO#522105
		);

		// STRUCT _Default_allocate_traits
struct _Default_allocate_traits
	{
	__declspec(allocator) static void * _Allocate(const size_t _Bytes)
		{
		return (::operator new(_Bytes));
		}

 





	};

constexpr bool _Is_pow_2(const size_t _Value) noexcept
	{
	return (_Value != 0 && (_Value & (_Value - 1)) == 0);
	}

 
constexpr size_t _Big_allocation_threshold = 4096;
constexpr size_t _Big_allocation_alignment = 32;

static_assert(2 * sizeof(void *) <= _Big_allocation_alignment,
	"Big allocation alignment should at least match vector register alignment");
static_assert(_Is_pow_2(_Big_allocation_alignment),
	"Big allocation alignment must be a power of two");

  
constexpr size_t _Non_user_size = 2 * sizeof(void *) + _Big_allocation_alignment - 1;
  



  
constexpr size_t _Big_allocation_sentinel = 0xFAFAFAFAFAFAFAFAULL;
  



		// FUNCTION _Allocate_manually_vector_aligned
template<class _Traits> inline
	__declspec(allocator) void * _Allocate_manually_vector_aligned(const size_t _Bytes)
	{	// allocate _Bytes manually aligned to at least _Big_allocation_alignment
	size_t _Block_size = _Non_user_size + _Bytes;
	if (_Block_size <= _Bytes)
		{	// add overflow, try allocating all of memory and assume the
			// allocation function will throw bad_alloc
		_Block_size = static_cast<size_t>(-1);
		}

	const uintptr_t _Ptr_container = reinterpret_cast<uintptr_t>(_Traits::_Allocate(_Block_size));
	do { if (_Ptr_container != 0) { } else { do { (void) ((1 != _CrtDbgReport(2, "c:\\visual studio\\vc\\tools\\msvc\\14.16.27023\\include\\xmemory0", 101, 0, "%s", "invalid argument")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"invalid argument\"", __LPREFIX( __FUNCTION__), L"c:\\visual studio\\vc\\tools\\msvc\\14.16.27023\\include\\xmemory0", 101, 0); } while (false); } ; } while (false);	// validate even in release since we're doing p[-1]
	void * const _Ptr = reinterpret_cast<void *>((_Ptr_container + _Non_user_size)
		& ~(_Big_allocation_alignment - 1));
	static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

  
	static_cast<uintptr_t *>(_Ptr)[-2] = _Big_allocation_sentinel;
  
	return (_Ptr);
	}

		// FUNCTION TEMPLATE _Adjust_manually_vector_aligned
inline void _Adjust_manually_vector_aligned(void *& _Ptr, size_t& _Bytes)
	{	// adjust parameters from _Allocate_manually_vector_aligned to pass to operator delete
	_Bytes += _Non_user_size;

	const uintptr_t * const _Ptr_user = reinterpret_cast<uintptr_t *>(_Ptr);
	const uintptr_t _Ptr_container = _Ptr_user[-1];

	// If the following asserts, it likely means that we are performing
	// an aligned delete on memory coming from an unaligned allocation.
	do { if (_Ptr_user[-2] == _Big_allocation_sentinel) { } else { do { (void) ((1 != _CrtDbgReport(2, "c:\\visual studio\\vc\\tools\\msvc\\14.16.27023\\include\\xmemory0", 122, 0, "%s", "invalid argument")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"invalid argument\"", __LPREFIX( __FUNCTION__), L"c:\\visual studio\\vc\\tools\\msvc\\14.16.27023\\include\\xmemory0", 122, 0); } while (false); } ; } while (false);

	// Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
	// in range [_Min_back_shift, _Non_user_size]
  
	constexpr uintptr_t _Min_back_shift = 2 * sizeof(void *);
  


	const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
	do { if (_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size) { } else { do { (void) ((1 != _CrtDbgReport(2, "c:\\visual studio\\vc\\tools\\msvc\\14.16.27023\\include\\xmemory0", 132, 0, "%s", "invalid argument")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"invalid argument\"", __LPREFIX( __FUNCTION__), L"c:\\visual studio\\vc\\tools\\msvc\\14.16.27023\\include\\xmemory0", 132, 0); } while (false); } ; } while (false);
	_Ptr = reinterpret_cast<void *>(_Ptr_container);
	}
 

		// FUNCTION TEMPLATES _Allocate and _Deallocate
 





































template<size_t _Align,
	class _Traits = _Default_allocate_traits,
	enable_if_t<(!0 || _Align <= 16ull), int> = 0> inline
	__declspec(allocator) void *_Allocate(const size_t _Bytes)
	{	// allocate _Bytes when !_HAS_ALIGNED_NEW || _Align <= __STDCPP_DEFAULT_NEW_ALIGNMENT__
 
	if (_Bytes >= _Big_allocation_threshold)
		{	// boost the alignment of big allocations to help autovectorization
		return (_Allocate_manually_vector_aligned<_Traits>(_Bytes));
		}
 

	if (_Bytes != 0)
		{
		return (_Traits::_Allocate(_Bytes));
		}

	return (nullptr);
	}

template<size_t _Align,
	enable_if_t<(!0 || _Align <= 16ull), int> = 0> inline
	void _Deallocate(void * _Ptr, size_t _Bytes)
	{	// deallocate storage allocated by _Allocate when !_HAS_ALIGNED_NEW || _Align <= __STDCPP_DEFAULT_NEW_ALIGNMENT__
 
	if (_Bytes >= _Big_allocation_threshold)
		{	// boost the alignment of big allocations to help autovectorization
		_Adjust_manually_vector_aligned(_Ptr, _Bytes);
		}
 

	::operator delete(_Ptr, _Bytes);
	}

		// FUNCTION TEMPLATE _Construct_in_place
template<class _Ty,
	class... _Types> inline
	void _Construct_in_place(_Ty& _Obj, _Types&&... _Args)
		noexcept(is_nothrow_constructible_v<_Ty, _Types...>)
	{	// invoke True Placement New to initialize the referenced object with _Args...
	::new (const_cast<void *>(static_cast<const volatile void *>(::std:: addressof(_Obj))))
		_Ty(::std:: forward<_Types>(_Args)...);
	}

		// FUNCTION TEMPLATE _Global_new
template<class _Ty,
	class... _Types> inline
	_Ty * _Global_new(_Types&&... _Args)
	{	// acts as "new" while disallowing user overload selection
	void * const _Result = _Allocate<_New_alignof<_Ty>>(sizeof(_Ty));
	try {
	::new (_Result) _Ty(::std:: forward<_Types>(_Args)...);
	} catch (...) {
	_Deallocate<_New_alignof<_Ty>>(_Result, sizeof(_Ty));
	throw;
	}
	return (static_cast<_Ty *>(_Result));
	}

		// STRUCT TEMPLATE _Get_first_parameter
template<class _Ty>
	struct _Get_first_parameter;

template<template<class, class...> class _Ty,
	class _First,
	class... _Rest>
	struct _Get_first_parameter<_Ty<_First, _Rest...>>
	{	// given _Ty<_First, _Rest...>, extract _First
	using type = _First;
	};

		// STRUCT TEMPLATE _Replace_first_parameter
template<class _Newfirst,
	class _Ty>
	struct _Replace_first_parameter;

template<class _Newfirst,
	template<class, class...> class _Ty,
	class _First,
	class... _Rest>
	struct _Replace_first_parameter<_Newfirst, _Ty<_First, _Rest...>>
	{	// given _Ty<_First, _Rest...>, replace _First
	using type = _Ty<_Newfirst, _Rest...>;
	};

		// STRUCT TEMPLATE _Get_element_type
template<class _Ty,
	class = void>
	struct _Get_element_type
	{	// provide fallback
	using type = typename _Get_first_parameter<_Ty>::type;
	};

template<class _Ty>
	struct _Get_element_type<_Ty, void_t<typename _Ty::element_type>>
	{	// get _Ty::element_type
	using type = typename _Ty::element_type;
	};

		// STRUCT TEMPLATE _Get_ptr_difference_type
template<class _Ty,
	class = void>
	struct _Get_ptr_difference_type
	{	// provide fallback
	using type = ptrdiff_t;
	};

template<class _Ty>
	struct _Get_ptr_difference_type<_Ty, void_t<typename _Ty::difference_type>>
	{	// get _Ty::difference_type
	using type = typename _Ty::difference_type;
	};

		// STRUCT TEMPLATE _Get_rebind_alias
template<class _Ty,
	class _Other,
	class = void>
	struct _Get_rebind_alias
	{	// provide fallback
	using type = typename _Replace_first_parameter<_Other, _Ty>::type;
	};

template<class _Ty,
	class _Other>
	struct _Get_rebind_alias<_Ty, _Other, void_t<typename _Ty::template rebind<_Other>>>
	{	// get _Ty::rebind<_Other>
	using type = typename _Ty::template rebind<_Other>;
	};

		// STRUCT TEMPLATE pointer_traits
template<class _Ty>
	struct pointer_traits
	{	// defines traits for arbitrary pointers
	using element_type = typename _Get_element_type<_Ty>::type;
	using pointer = _Ty;
	using difference_type = typename _Get_ptr_difference_type<_Ty>::type;

	template<class _Other>
		using rebind = typename _Get_rebind_alias<_Ty, _Other>::type;

	using _Reftype = conditional_t<is_void_v<element_type>,
		char&,
		add_lvalue_reference_t<element_type>>;

	 static pointer pointer_to(_Reftype _Val)
		{	// convert raw reference to pointer
		return (_Ty::pointer_to(_Val));
		}
	};

template<class _Ty>
	struct pointer_traits<_Ty *>
	{	// defines traits for raw pointers
	using element_type = _Ty;
	using pointer = _Ty *;
	using difference_type = ptrdiff_t;

	template<class _Other>
		using rebind = _Other *;

	using _Reftype = conditional_t<is_void_v<_Ty>,
		char&,
		add_lvalue_reference_t<_Ty>>;

	 static pointer pointer_to(_Reftype _Val)
		{	// convert raw reference to pointer
		return (::std:: addressof(_Val));
		}
	};

		// ALIAS TEMPLATE _Rebind_pointer_t
template<class _Ptr,
	class _Ty>
	using _Rebind_pointer_t = typename pointer_traits<_Ptr>::template rebind<_Ty>;

		// FUNCTION TEMPLATE _Refancy
template<class _Pointer,
	enable_if_t<!is_pointer_v<_Pointer>, int> = 0> inline
	_Pointer _Refancy(typename pointer_traits<_Pointer>::element_type * _Ptr)
	{	// transform a plain pointer into a fancy pointer
	return (pointer_traits<_Pointer>::pointer_to(*_Ptr));
	}

template<class _Pointer,
	enable_if_t<is_pointer_v<_Pointer>, int> = 0> inline
	_Pointer _Refancy(_Pointer _Ptr)
	{	// do nothing for plain pointers
	return (_Ptr);
	}

		// FUNCTION TEMPLATE _Destroy_in_place
template<class _Ty> inline
	void _Destroy_in_place(_Ty& _Obj) noexcept
	{	// destroy the referenced object
	_Obj.~_Ty();
	}

		// FUNCTION TEMPLATE _Const_cast
template<class _Ptrty> inline
	auto _Const_cast(_Ptrty _Ptr)
	{	// remove constness from a fancy pointer
	using _Elem = typename pointer_traits<_Ptrty>::element_type;
	using _Modifiable = remove_const_t<_Elem>;
	using _Dest = typename pointer_traits<_Ptrty>::template rebind<_Modifiable>;

	return (pointer_traits<_Dest>::pointer_to(const_cast<_Modifiable&>(*_Ptr)));
	}

template<class _Ty> inline
	auto _Const_cast(_Ty * _Ptr)
	{	// remove constness from a plain pointer
	return (const_cast<remove_const_t<_Ty> *>(_Ptr));
	}

		// STRUCT TEMPLATE _Get_pointer_type
template<class _Ty,
	class = void>
	struct _Get_pointer_type
	{	// provide fallback
	using type = typename _Ty::value_type *;
	};

#pragma warning(push)
#pragma warning(disable: 4996)	
template<class _Ty>
	struct _Get_pointer_type<_Ty, void_t<typename _Ty::pointer>>
	{	// get _Ty::pointer
	using type = typename _Ty::pointer;
	};
#pragma warning(pop)

		// STRUCT TEMPLATE _Get_const_pointer_type
template<class _Ty,
	class = void>
	struct _Get_const_pointer_type
	{	// provide fallback
	using _Ptrty = typename _Get_pointer_type<_Ty>::type;
	using _Valty = typename _Ty::value_type;
	using type = typename pointer_traits<_Ptrty>::template rebind<const _Valty>;
	};

#pragma warning(push)
#pragma warning(disable: 4996)	
template<class _Ty>
	struct _Get_const_pointer_type<_Ty, void_t<typename _Ty::const_pointer>>
	{	// get _Ty::const_pointer
	using type = typename _Ty::const_pointer;
	};
#pragma warning(pop)

		// STRUCT TEMPLATE _Get_void_pointer_type
template<class _Ty,
	class = void>
	struct _Get_void_pointer_type
	{	// provide fallback
	using _Ptrty = typename _Get_pointer_type<_Ty>::type;
	using type = typename pointer_traits<_Ptrty>::template rebind<void>;
	};

template<class _Ty>
	struct _Get_void_pointer_type<_Ty, void_t<typename _Ty::void_pointer>>
	{	// get _Ty::void_pointer
	using type = typename _Ty::void_pointer;
	};

		// STRUCT TEMPLATE _Get_const_void_pointer_type
template<class _Ty,
	class = void>
	struct _Get_const_void_pointer_type
	{	// provide fallback
	using _Ptrty = typename _Get_pointer_type<_Ty>::type;
	using type = typename pointer_traits<_Ptrty>::template rebind<const void>;
	};

template<class _Ty>
	struct _Get_const_void_pointer_type<_Ty, void_t<typename _Ty::const_void_pointer>>
	{	// get _Ty::const_void_pointer
	using type = typename _Ty::const_void_pointer;
	};

		// STRUCT TEMPLATE _Get_difference_type
template<class _Ty,
	class = void>
	struct _Get_difference_type
	{	// provide fallback
	using _Ptrty = typename _Get_pointer_type<_Ty>::type;
	using type = typename pointer_traits<_Ptrty>::difference_type;
	};

#pragma warning(push)
#pragma warning(disable: 4996)	
template<class _Ty>
	struct _Get_difference_type<_Ty, void_t<typename _Ty::difference_type>>
	{	// get _Ty::difference_type
	using type = typename _Ty::difference_type;
	};
#pragma warning(pop)

		// STRUCT TEMPLATE _Get_size_type
template<class _Ty,
	class = void>
	struct _Get_size_type
	{	// provide fallback
	using type = make_unsigned_t<typename _Get_difference_type<_Ty>::type>;
	};

#pragma warning(push)
#pragma warning(disable: 4996)	
template<class _Ty>
	struct _Get_size_type<_Ty, void_t<typename _Ty::size_type>>
	{	// get _Ty::size_type
	using type = typename _Ty::size_type;
	};
#pragma warning(pop)

		// STRUCT TEMPLATE _Get_propagate_on_container_copy
template<class _Ty,
	class = void>
	struct _Get_propagate_on_container_copy
	{	// provide fallback
	using type = false_type;
	};

template<class _Ty>
	struct _Get_propagate_on_container_copy<_Ty, void_t<typename _Ty::propagate_on_container_copy_assignment>>
	{	// get _Ty::propagate_on_container_copy_assignment
	using type = typename _Ty::propagate_on_container_copy_assignment;
	};

		// STRUCT TEMPLATE _Get_propagate_on_container_move
template<class _Ty,
	class = void>
	struct _Get_propagate_on_container_move
	{	// provide fallback
	using type = false_type;
	};

template<class _Ty>
	struct _Get_propagate_on_container_move<_Ty, void_t<typename _Ty::propagate_on_container_move_assignment>>
	{	// get _Ty::propagate_on_container_move_assignment
	using type = typename _Ty::propagate_on_container_move_assignment;
	};

		// STRUCT TEMPLATE _Get_propagate_on_container_swap
template<class _Ty,
	class = void>
	struct _Get_propagate_on_container_swap
	{	// provide fallback
	using type = false_type;
	};

template<class _Ty>
	struct _Get_propagate_on_container_swap<_Ty, void_t<typename _Ty::propagate_on_container_swap>>
	{	// get _Ty::propagate_on_container_swap
	using type = typename _Ty::propagate_on_container_swap;
	};

		// STRUCT TEMPLATE _Get_is_always_equal
template<class _Ty,
	class = void>
	struct _Get_is_always_equal
	{	// provide fallback
	using type = typename is_empty<_Ty>::type;
	};

template<class _Ty>
	struct _Get_is_always_equal<_Ty, void_t<typename _Ty::is_always_equal>>
	{	// get _Ty::is_always_equal
	using type = typename _Ty::is_always_equal;
	};

		// STRUCT TEMPLATE _Get_rebind_type
template<class _Ty,
	class _Other,
	class = void>
	struct _Get_rebind_type
	{	// provide fallback
	using type = typename _Replace_first_parameter<_Other, _Ty>::type;
	};

#pragma warning(push)
#pragma warning(disable: 4996)	
template<class _Ty,
	class _Other>
	struct _Get_rebind_type<_Ty, _Other, void_t<typename _Ty::template rebind<_Other>::other>>
	{	// get _Ty::rebind<_Other>::other
	using type = typename _Ty::template rebind<_Other>::other;
	};
#pragma warning(pop)

		// STRUCT TEMPLATE _Is_default_allocator
template<class _Ty>
	class allocator;

template<class _Alloc,
	class = void>
	struct _Is_default_allocator
		: false_type
	{	// tests whether _Alloc is non-specialized default allocator (N4659 23.10.9 [default.allocator])
	};

template<class _Ty>
	struct _Is_default_allocator<allocator<_Ty>, typename allocator<_Ty>::_Not_user_specialized>
		: true_type
	{	// tests whether _Alloc is non-specialized default allocator (N4659 23.10.9 [default.allocator])
	};

		// ALIAS TEMPLATES _Uses_default_construct AND _Uses_default_construct_t
template<class _Void,
	class... _Types>
	struct _Has_no_alloc_construct
		: true_type
	{	// determines whether _Alloc has no construct
	};

#pragma warning(push)
#pragma warning(disable: 4996)	
template<class _Alloc,
	class _Ptr,
	class... _Args>
	struct _Has_no_alloc_construct<void_t<
		decltype(::std:: declval<_Alloc&>().construct(::std:: declval<_Ptr>(), ::std:: declval<_Args>()...))>,
		_Alloc, _Ptr, _Args...>
		: false_type
	{	// determines whether _Alloc has no construct
	};
#pragma warning(pop)

template<class _Alloc,
	class _Ptr,
	class... _Args>
	using _Uses_default_construct = disjunction<
		_Is_default_allocator<_Alloc>,
		_Has_no_alloc_construct<void, _Alloc, _Ptr, _Args...>>;

template<class _Alloc,
	class _Ptr,
	class... _Args>
	using _Uses_default_construct_t = typename _Uses_default_construct<_Alloc, _Ptr, _Args...>::type;


		// ALIAS TEMPLATE _Uses_default_destroy AND _Uses_default_destroy_t
template<class _Alloc,
	class _Ptr,
	class = void>
	struct _Has_no_alloc_destroy
		: true_type
	{	// determines whether _Alloc has no destroy
	};

#pragma warning(push)
#pragma warning(disable: 4996)	
template<class _Alloc,
	class _Ptr>
	struct _Has_no_alloc_destroy<_Alloc, _Ptr, void_t<decltype(::std:: declval<_Alloc&>().destroy(::std:: declval<_Ptr>()))>>
		: false_type
	{	// determines whether _Alloc has no destroy
	};
#pragma warning(pop)

template<class _Alloc,
	class _Ptr>
	using _Uses_default_destroy = disjunction<
		_Is_default_allocator<_Alloc>,
		_Has_no_alloc_destroy<_Alloc, _Ptr>>;

template<class _Alloc,
	class _Ptr>
	using _Uses_default_destroy_t = typename _Uses_default_destroy<_Alloc, _Ptr>::type;


		// STRUCT TEMPLATE _Has_allocate_hint
template<class _Alloc,
	class _Size_type,
	class _Const_void_pointer,
	class = void>
	struct _Has_allocate_hint
		: false_type
	{	// determines whether _Alloc has allocate(n, hint)
	};

#pragma warning(push)
#pragma warning(disable: 4996)	
template<class _Alloc,
	class _Size_type,
	class _Const_void_pointer>
	struct _Has_allocate_hint<_Alloc, _Size_type, _Const_void_pointer, void_t<
		decltype(::std:: declval<_Alloc&>().allocate(
			::std:: declval<const _Size_type&>(), ::std:: declval<const _Const_void_pointer&>()))>>
		: true_type
	{	// determines whether _Alloc has allocate(n, hint)
	};
#pragma warning(pop)

		// STRUCT TEMPLATE _Has_max_size
template<class _Alloc,
	class = void>
	struct _Has_max_size
		: false_type
	{	// determines whether _Alloc has max_size()
	};

#pragma warning(push)
#pragma warning(disable: 4996)	
template<class _Alloc>
	struct _Has_max_size<_Alloc, void_t<decltype(::std:: declval<const _Alloc&>().max_size())>>
		: true_type
	{	// determines whether _Alloc has max_size()
	};
#pragma warning(pop)

		// STRUCT TEMPLATE _Has_select_on_container_copy_construction
template<class _Alloc,
	class = void>
	struct _Has_select_on_container_copy_construction
		: false_type
	{	// determines whether _Alloc has select_on_container_copy_construction()
	};

template<class _Alloc>
	struct _Has_select_on_container_copy_construction<_Alloc, void_t<
		decltype(::std:: declval<const _Alloc&>().select_on_container_copy_construction())>>
		: true_type
	{	// determines whether _Alloc has select_on_container_copy_construction()
	};


		// STRUCT TEMPLATE allocator_traits
template<class _Alloc>
	struct allocator_traits;

#pragma warning(push)
#pragma warning(disable: 4996)	
template<class _Alloc>
	struct _Normal_allocator_traits
	{	// defines traits for allocators
	using allocator_type = _Alloc;
	using value_type = typename _Alloc::value_type;

	using pointer = typename _Get_pointer_type<_Alloc>::type;
	using const_pointer = typename _Get_const_pointer_type<_Alloc>::type;
	using void_pointer = typename _Get_void_pointer_type<_Alloc>::type;
	using const_void_pointer = typename _Get_const_void_pointer_type<_Alloc>::type;

	using size_type = typename _Get_size_type<_Alloc>::type;
	using difference_type = typename _Get_difference_type<_Alloc>::type;

	using propagate_on_container_copy_assignment = typename _Get_propagate_on_container_copy<_Alloc>::type;
	using propagate_on_container_move_assignment = typename _Get_propagate_on_container_move<_Alloc>::type;
	using propagate_on_container_swap = typename _Get_propagate_on_container_swap<_Alloc>::type;
	using is_always_equal = typename _Get_is_always_equal<_Alloc>::type;

	template<class _Other>
		using rebind_alloc = typename _Get_rebind_type<_Alloc, _Other>::type;

	template<class _Other>
		using rebind_traits = allocator_traits<rebind_alloc<_Other>>;

	 static __declspec(allocator) pointer allocate(_Alloc& _Al, __declspec(guard(overflow)) const size_type _Count)
		{	// allocate array of _Count elements
		return (_Al.allocate(_Count));
		}

	static __declspec(allocator) pointer _Allocate1(_Alloc& _Al, __declspec(guard(overflow)) const size_type _Count,
		const const_void_pointer _Hint, true_type)
		{	// allocate array of _Count elements, with hint, allocator-supplied version
		return (_Al.allocate(_Count, _Hint));
		}

	static __declspec(allocator) pointer _Allocate1(_Alloc& _Al, __declspec(guard(overflow)) const size_type _Count,
		const_void_pointer, false_type)
		{	// allocate array of _Count elements, with hint, default version
		return (_Al.allocate(_Count));
		}

	 static __declspec(allocator) pointer allocate(_Alloc& _Al, __declspec(guard(overflow)) const size_type _Count,
		const const_void_pointer _Hint)
		{	// allocate array of _Count elements, with hint
		return (_Allocate1(_Al, _Count, _Hint, _Has_allocate_hint<_Alloc, size_type, const_void_pointer>{}));
		}

	static void deallocate(_Alloc& _Al, pointer _Ptr, size_type _Count)
		{	// deallocate _Count elements at _Ptr
		_Al.deallocate(_Ptr, _Count);
		}

	template<class _Ty,
		class... _Types>
		static void _Construct1(true_type, _Alloc&, _Ty *_Ptr, _Types&&... _Args)
		{	// construct _Ty(_Types...) at _Ptr, default version
		::new (static_cast<void *>(_Ptr)) _Ty(::std:: forward<_Types>(_Args)...);
		}

	template<class _Ty,
		class... _Types>
		static void _Construct1(false_type, _Alloc& _Al, _Ty *_Ptr, _Types&&... _Args)
		{	// construct _Ty(_Types...) at _Ptr, allocator-supplied version
		_Al.construct(_Ptr, ::std:: forward<_Types>(_Args)...);
		}

	template<class _Ty,
		class... _Types>
		static void construct(_Alloc& _Al, _Ty *_Ptr, _Types&&... _Args)
		{	// construct _Ty(_Types...) at _Ptr
		_Construct1(_Uses_default_construct_t<_Alloc, _Ty *, _Types...>(),
			_Al, _Ptr, ::std:: forward<_Types>(_Args)...);
		}

	template<class _Ty>
		static void _Destroy1(_Alloc&, _Ty *_Ptr, true_type)
		{	// destroy object at _Ptr, default version
		_Ptr->~_Ty();
		}

	template<class _Ty>
		static void _Destroy1(_Alloc& _Al, _Ty *_Ptr, false_type)
		{	// destroy object at _Ptr, allocator-supplied version
		_Al.destroy(_Ptr);
		}

	template<class _Ty>
		static void destroy(_Alloc& _Al, _Ty *_Ptr)
		{	// destroy object at _Ptr
		_Destroy1(_Al, _Ptr, _Uses_default_destroy_t<_Alloc, _Ty *>());
		}

	static size_type _Max_size1(const _Alloc& _Al, true_type) noexcept
		{	// get maximum size, allocator-supplied version
		return (_Al.max_size());
		}

	static size_type _Max_size1(const _Alloc&, false_type) noexcept
		{	// get maximum size, default version
		return ((numeric_limits<size_type>::max)() / sizeof(value_type));
		}

	 static size_type max_size(const _Alloc& _Al) noexcept
		{	// get maximum size
		return (_Max_size1(_Al, _Has_max_size<_Alloc>{}));
		}

	static _Alloc _Select_on_container_copy_construction1(const _Alloc& _Al, true_type)
		{	// get allocator to use, allocator-supplied version
		return (_Al.select_on_container_copy_construction());
		}

	static _Alloc _Select_on_container_copy_construction1(const _Alloc& _Al, false_type)
		{	// get allocator to use, default version
		return (_Al);
		}

	 static _Alloc select_on_container_copy_construction(const _Alloc& _Al)
		{	// get allocator to use
		return (_Select_on_container_copy_construction1(_Al, _Has_select_on_container_copy_construction<_Alloc>{}));
		}
	};
#pragma warning(pop)

template<class _Alloc>
	struct _Default_allocator_traits
	{	// traits for std::allocator
	using allocator_type = _Alloc;
	using value_type = typename _Alloc::value_type;

	using pointer = value_type *;
	using const_pointer = const value_type *;
	using void_pointer = void *;
	using const_void_pointer = const void *;

	using size_type = size_t;
	using difference_type = ptrdiff_t;

	using propagate_on_container_copy_assignment = false_type;
	using propagate_on_container_move_assignment = true_type;
	using propagate_on_container_swap = false_type;
	using is_always_equal = true_type;

	template<class _Other>
		using rebind_alloc = allocator<_Other>;

	template<class _Other>
		using rebind_traits = allocator_traits<allocator<_Other>>;

	 static __declspec(allocator) pointer allocate(_Alloc&, __declspec(guard(overflow)) const size_type _Count)
		{	// allocate array of _Count elements
		return (static_cast<pointer>(_Allocate<_New_alignof<value_type>>(_Get_size_of_n<sizeof(value_type)>(_Count))));
		}

	 static __declspec(allocator) pointer allocate(_Alloc&, __declspec(guard(overflow)) const size_type _Count,
		const_void_pointer)
		{	// allocate array of _Count elements, with hint
		return (static_cast<pointer>(_Allocate<_New_alignof<value_type>>(_Get_size_of_n<sizeof(value_type)>(_Count))));
		}

	static void deallocate(_Alloc&, const pointer _Ptr, const size_type _Count)
		{	// deallocate _Count elements at _Ptr
		// no overflow check on the following multiply; we assume _Allocate did that check
		_Deallocate<_New_alignof<value_type>>(_Ptr, sizeof(value_type) * _Count);
		}

	template<class _Objty,
		class... _Types>
		static void construct(_Alloc&, _Objty * const _Ptr, _Types&&... _Args)
		{	// construct _Objty(_Types...) at _Ptr
		::new (const_cast<void *>(static_cast<const volatile void *>(_Ptr)))
			_Objty(::std:: forward<_Types>(_Args)...);
		}

	template<class _Uty>
		static void destroy(_Alloc&, _Uty * const _Ptr)
		{	// destroy object at _Ptr
		_Ptr->~_Uty();
		}

	 static size_type max_size(const _Alloc&) noexcept
		{	// get maximum size
		return (static_cast<size_t>(-1) / sizeof(value_type));
		}

	 static _Alloc select_on_container_copy_construction(const _Alloc& _Al)
		{	// get allocator to use
		return (_Al);
		}
	};

template<class _Alloc>
	struct allocator_traits
		: conditional_t<_Is_default_allocator<_Alloc>::value,
			_Default_allocator_traits<_Alloc>, _Normal_allocator_traits<_Alloc>>
	{	// defines traits for allocators
	};

		// TYPE TRAIT _Always_equal_after_move
template<class _Alloc>
	 constexpr bool _Always_equal_after_move = allocator_traits<_Alloc>::is_always_equal::value
		|| allocator_traits<_Alloc>::propagate_on_container_move_assignment::value;

		// ALIAS TEMPLATE _Rebind_alloc_t
template<class _Alloc,
	class _Value_type>
	using _Rebind_alloc_t = typename allocator_traits<_Alloc>::template rebind_alloc<_Value_type>;

		// VARIABLE TEMPLATE _Is_simple_alloc_v
template<class _Alloc>	// tests if allocator has simple addressing
	 constexpr bool _Is_simple_alloc_v =
		is_same_v<typename allocator_traits<_Alloc>::size_type, size_t>
		&& is_same_v<typename allocator_traits<_Alloc>::difference_type, ptrdiff_t>
		&& is_same_v<typename allocator_traits<_Alloc>::pointer, typename _Alloc::value_type *>
		&& is_same_v<typename allocator_traits<_Alloc>::const_pointer, const typename _Alloc::value_type *>;

		// STRUCT TEMPLATE _Simple_types
template<class _Value_type>
	struct _Simple_types
	{	// wraps types from allocators with simple addressing for use in iterators
		// and other SCARY machinery
	using value_type = _Value_type;
	using size_type = size_t;
	using difference_type = ptrdiff_t;
	using pointer = value_type *;
	using const_pointer = const value_type *;
	};

		// CLASS TEMPLATE allocator
template<class _Ty>
	class allocator
	{	// generic allocator for objects of class _Ty
public:
	static_assert(!is_const_v<_Ty>,
		"The C++ Standard forbids containers of const elements "
		"because allocator<const T> is ill-formed.");

	using _Not_user_specialized = void;

	using value_type = _Ty;

	 typedef _Ty * pointer;
	 typedef const _Ty * const_pointer;

	 typedef _Ty& reference;
	 typedef const _Ty& const_reference;

	 typedef size_t size_type;
	 typedef ptrdiff_t difference_type;

	using propagate_on_container_move_assignment = true_type;
	using is_always_equal = true_type;

	template<class _Other>
		struct  rebind
		{	// convert this type to allocator<_Other>
		using other = allocator<_Other>;
		};

	  _Ty * address(_Ty& _Val) const noexcept
		{	// return address of mutable _Val
		return (::std:: addressof(_Val));
		}

	  const _Ty * address(const _Ty& _Val) const noexcept
		{	// return address of nonmutable _Val
		return (::std:: addressof(_Val));
		}

	constexpr allocator() noexcept
		{	// construct default allocator (do nothing)
		}

	constexpr allocator(const allocator&) noexcept = default;
	template<class _Other>
		constexpr allocator(const allocator<_Other>&) noexcept
		{	// construct from a related allocator (do nothing)
		}

	void deallocate(_Ty * const _Ptr, const size_t _Count)
		{	// deallocate object at _Ptr
		// no overflow check on the following multiply; we assume _Allocate did that check
		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);
		}

	 __declspec(allocator) _Ty * allocate(__declspec(guard(overflow)) const size_t _Count)
		{	// allocate array of _Count elements
		return (static_cast<_Ty *>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count))));
		}

	  __declspec(allocator) _Ty * allocate(
		__declspec(guard(overflow)) const size_t _Count, const void *)
		{	// allocate array of _Count elements, ignore hint
		return (allocate(_Count));
		}

	template<class _Objty,
		class... _Types>
		 void construct(_Objty * const _Ptr, _Types&&... _Args)
		{	// construct _Objty(_Types...) at _Ptr
		::new (const_cast<void *>(static_cast<const volatile void *>(_Ptr)))
			_Objty(::std:: forward<_Types>(_Args)...);
		}

	template<class _Uty>
		 void destroy(_Uty * const _Ptr)
		{	// destroy object at _Ptr
		_Ptr->~_Uty();
		}

	  size_t max_size() const noexcept
		{	// estimate maximum array size
		return (static_cast<size_t>(-1) / sizeof(_Ty));
		}
	};

		// CLASS allocator<void>
template<>
	class  allocator<void>
	{	// generic allocator for type void
public:
	using value_type = void;
	using pointer = void *;
	using const_pointer = const void *;

	template<class _Other>
		struct rebind
		{	// convert this type to an allocator<_Other>
		using other = allocator<_Other>;
		};
	};

template<class _Ty,
	class _Other>
	 inline bool operator==(const allocator<_Ty>&,
		const allocator<_Other>&) noexcept
	{	// test for allocator equality
	return (true);
	}

template<class _Ty,
	class _Other>
	 inline bool operator!=(const allocator<_Ty>&,
		const allocator<_Other>&) noexcept
	{	// test for allocator inequality
	return (false);
	}









		// FUNCTION TEMPLATE _Pocca
template<class _Alloc> inline
	void _Pocca(_Alloc& _Left, const _Alloc& _Right, true_type) noexcept
	{	// propagate on container copy assignment
	_Left = _Right;
	}

template<class _Alloc> inline
	void _Pocca(_Alloc&, const _Alloc&, false_type) noexcept
	{	// (don't) propagate on container copy assignment
	}

template<class _Alloc> inline
	void _Pocca(_Alloc& _Left, const _Alloc& _Right) noexcept
	{	// (maybe) propagate on container copy assignment
	typename allocator_traits<_Alloc>::propagate_on_container_copy_assignment _Tag;
	_Pocca(_Left, _Right, _Tag);
	}

		// FUNCTION TEMPLATE _Pocma
template<class _Alloc> inline
	void _Pocma(_Alloc& _Left, _Alloc& _Right, true_type) noexcept
	{	// propagate on container move assignment
	_Left = ::std:: move(_Right);
	}

template<class _Alloc> inline
	void _Pocma(_Alloc&, _Alloc&, false_type) noexcept
	{	// (don't) propagate on container move assignment
	}

template<class _Alloc> inline
	void _Pocma(_Alloc& _Left, _Alloc& _Right) noexcept
	{	// (maybe) propagate on container move assignment
	typename allocator_traits<_Alloc>::propagate_on_container_move_assignment _Tag;
	_Pocma(_Left, _Right, _Tag);
	}

		// FUNCTION TEMPLATE _Pocs
template<class _Alloc> inline
	void _Pocs(_Alloc& _Left, _Alloc& _Right, true_type) noexcept
	{	// propagate on container swap
	_Swap_adl(_Left, _Right);
	}

template<class _Alloc> inline
	void _Pocs(_Alloc& _Left, _Alloc& _Right, false_type) noexcept
	{	// (don't) propagate on container swap
	do { if (_Left == _Right) { } else { do { (void) ((1 != _CrtDbgReport(2, "c:\\visual studio\\vc\\tools\\msvc\\14.16.27023\\include\\xmemory0", 1114, 0, "%s", "containers incompatible for swap")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"containers incompatible for swap\"", __LPREFIX( __FUNCTION__), L"c:\\visual studio\\vc\\tools\\msvc\\14.16.27023\\include\\xmemory0", 1114, 0); } while (false); } ; } while (false);
	(void)_Left;
	(void)_Right;
	}

template<class _Alloc> inline
	void _Pocs(_Alloc& _Left, _Alloc& _Right) noexcept
	{	// (maybe) propagate on container swap
	typename allocator_traits<_Alloc>::propagate_on_container_swap _Tag;
	_Pocs(_Left, _Right, _Tag);
	}


		// FUNCTION TEMPLATE _Destroy_range WITH ALLOC
template<class _Alloc> inline
	void _Destroy_range1(
		typename allocator_traits<_Alloc>::pointer _First,
		typename allocator_traits<_Alloc>::pointer _Last,
		_Alloc& _Al, false_type)
	{	// destroy [_First, _Last), no special optimization
	for (; _First != _Last; ++_First)
		{
		allocator_traits<_Alloc>::destroy(_Al, _Unfancy(_First));
		}
	}

template<class _Alloc> inline
	void _Destroy_range1(
		typename allocator_traits<_Alloc>::pointer,
		typename allocator_traits<_Alloc>::pointer,
		_Alloc&, true_type)
	{	// destroy [_First, _Last), trivially destructible and default destroy
		// nothing to do
	}

template<class _Alloc> inline
	void _Destroy_range(
		typename allocator_traits<_Alloc>::pointer _First,
		typename allocator_traits<_Alloc>::pointer _Last,
		_Alloc& _Al)
	{	// destroy [_First, _Last), choose optimization
		// note that this is an optimization for debug mode codegen;
		// in release mode the BE removes all of this
	using _Val = typename _Alloc::value_type;
	_Destroy_range1(_First, _Last, _Al, bool_constant<conjunction_v<
		is_trivially_destructible<_Val>,
		_Uses_default_destroy<_Alloc, _Val *>>>{});
	}


		// FUNCTION TEMPLATE _Destroy_range
template<class _FwdIt> inline
	void _Destroy_range1(_FwdIt _First, _FwdIt _Last, false_type)
	{	// destroy [_First, _Last), no special optimization
	for (; _First != _Last; ++_First)
		{
		_Destroy_in_place(*_First);
		}
	}

template<class _FwdIt> inline
	void _Destroy_range1(_FwdIt, _FwdIt, true_type)
	{	// destroy [_First, _Last), trivially destructible
		// nothing to do
	}

template<class _FwdIt> inline
	void _Destroy_range(_FwdIt _First, _FwdIt _Last)
	{	// destroy [_First, _Last), choose optimization
		// note that this is an optimization for debug mode codegen;
		// in release mode the BE removes all of this
	_Destroy_range1(_First, _Last, is_trivially_destructible<_Iter_value_t<_FwdIt>>());
	}


		// FUNCTION TEMPLATE _Convert_size
template<class _Size_type> inline
	_Size_type _Convert_size(const size_t _Len)
	{	// convert size_t to _Size_type, avoiding truncation
	if (_Len > (numeric_limits<_Size_type>::max)())
		{
		_Xlength_error("size_t too long for _Size_type");
		}

	return (static_cast<_Size_type>(_Len));
	}

template<> inline
	size_t _Convert_size<size_t>(const size_t _Len)
	{	// convert size_t to size_t, unchanged
	return (_Len);
	}

		// FUNCTION TEMPLATE _Deallocate_plain
template<class _Alloc,
	enable_if_t<is_same_v<typename allocator_traits<_Alloc>::pointer,
		typename _Alloc::value_type *>, int> = 0> inline
	void _Deallocate_plain(_Alloc& _Al, typename _Alloc::value_type * const _Ptr)
	{	// deallocate a plain pointer using an allocator, non-fancy pointers special case
	allocator_traits<_Alloc>::deallocate(_Al, _Ptr, 1);
	}

template<class _Alloc,
	enable_if_t<!is_same_v<typename allocator_traits<_Alloc>::pointer,
		typename _Alloc::value_type *>, int> = 0> inline
	void _Deallocate_plain(_Alloc& _Al, typename _Alloc::value_type * const _Ptr)
	{	// deallocate a plain pointer using an allocator
	using _Alloc_traits = allocator_traits<_Alloc>;
	using _Ptr_traits = pointer_traits<typename _Alloc_traits::pointer>;
	_Alloc_traits::deallocate(_Al, _Ptr_traits::pointer_to(*_Ptr), 1);
	}
}

		// ATOMIC REFERENCE COUNTING PRIMITIVES
  
/* xatomic0.h internal header */
#pragma once





 #pragma pack(push,8)
 #pragma warning(push,3)
 #pragma warning(disable: 4455 4494  4619 4643 4702 4984 4988 )
 
 
 

namespace std {
		/* ENUM memory_order */
typedef enum memory_order {
	memory_order_relaxed,
	memory_order_consume,
	memory_order_acquire,
	memory_order_release,
	memory_order_acq_rel,
	memory_order_seq_cst
	} memory_order;

typedef unsigned long _Uint4_t;
typedef _Uint4_t _Atomic_integral_t;

	/* SET SIZES AND FLAGS FOR COMPILER AND TARGET ARCHITECTURE */
	/* Note: the xxx_SIZE macros are used to generate function names,
		so they must expand to the digits representing
		the number of bytes in the type; they cannot be expressions
		that give the number of bytes. */

  
  
  
  
  

  
   
  



		/* ATOMIC REFERENCE COUNTING */
typedef _Atomic_integral_t _Atomic_counter_t;

inline _Atomic_integral_t
	_Get_atomic_count(const _Atomic_counter_t& _Counter)
	{	// get counter
	return (_Counter);
	}

 
  
   
  


 

}
 
 
 #pragma warning(pop)
 #pragma pack(pop)



/*
 * Copyright (c) by P.J. Plauger. All rights reserved.
 * Consult your license regarding permissions and restrictions.
V6.50:0009 */


  
   
/***
*   intrin0.h - declarations of compiler intrinsics used by the C++ Standard Library.
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*   This header file declares compiler intrinsics that are used by the
*   C++ Standard Library, especially <atomic>. Compiler throughput is
*   the only reason that intrin0.h is separate from intrin.h.
*
****/

#pragma once





extern "C" {


/*
** __MACHINE              : everything
** __MACHINEX86           : x86 only
** __MACHINEX64           : x64 only
** __MACHINEX86_X64       : x86 and x64 only
** __MACHINEARM           : ARM only
** __MACHINEARM64         : ARM64 only
** __MACHINEARM_ARM64     : ARM and ARM64 only
** __MACHINEARM_ARM64_X64 : ARM and 64-bit Arch only
** __MACHINEARM64_X64     : ARM64 and x64 only
** __MACHINECHPEX86ARM64  : CHPE x86 on arm64 only
** __MACHINEWVMPURE       : /clr:pure only
** __MACHINEZ             : nothing
*/











/* Most intrinsics not available to pure managed code */






























/* For compatibility with <winnt.h>, some intrinsics are __cdecl except on x64 */































/*******************************************************************
* Note: New intrinsics should be added here IF AND ONLY IF they're *
* being used by the C++ Standard Library.                          *
* OTHERWISE, new intrinsics should be added to intrin.h.           *
*******************************************************************/



unsigned char _BitScanForward(unsigned long * _Index, unsigned long _Mask);
unsigned char _BitScanForward64(unsigned long * _Index, unsigned __int64 _Mask);

unsigned char _BitScanReverse(unsigned long * _Index, unsigned long _Mask);
unsigned char _BitScanReverse64(unsigned long * _Index, unsigned __int64 _Mask);

unsigned char _bittest(long const *, long);
long _InterlockedAnd(long volatile * _Value, long _Mask);
short _InterlockedAnd16(short volatile * _Value, short _Mask);



__int64 _InterlockedAnd64(__int64 volatile * _Value, __int64 _Mask);



char _InterlockedAnd8(char volatile * _Value, char _Mask);






long  _InterlockedCompareExchange(long volatile * _Destination, long _Exchange, long _Comparand);

short _InterlockedCompareExchange16(short volatile * _Destination, short _Exchange, short _Comparand);



__int64 _InterlockedCompareExchange64(__int64 volatile * _Destination, __int64 _Exchange, __int64 _Comparand);



char _InterlockedCompareExchange8(char volatile * _Destination, char _Exchange, char _Comparand);






long  _InterlockedDecrement(long volatile * _Addend);

long  _InterlockedExchange(long volatile * _Target, long _Value);

short _InterlockedExchange16(short volatile * _Target, short _Value);



__int64 _InterlockedExchange64(__int64 volatile * _Target, __int64 _Value);



char _InterlockedExchange8(char volatile * _Target, char _Value);



long  _InterlockedExchangeAdd(long volatile * _Addend, long _Value);
short _InterlockedExchangeAdd16(short volatile * _Addend, short _Value);



__int64 _InterlockedExchangeAdd64(__int64 volatile * _Addend, __int64 _Value);



char _InterlockedExchangeAdd8(char volatile * _Addend, char _Value);









long  _InterlockedIncrement(long volatile * _Addend);

long _InterlockedOr(long volatile * _Value, long _Mask);
short _InterlockedOr16(short volatile * _Value, short _Mask);



__int64 _InterlockedOr64(__int64 volatile * _Value, __int64 _Mask);



char _InterlockedOr8(char volatile * _Value, char _Mask);






long _InterlockedXor(long volatile * _Value, long _Mask);
short _InterlockedXor16(short volatile * _Value, short _Mask);



__int64 _InterlockedXor64(__int64 volatile * _Value, __int64 _Mask);



char _InterlockedXor8(char volatile * _Value, char _Mask);






void _ReadWriteBarrier(void);










unsigned char _interlockedbittestandset(long volatile *, long);



unsigned __int64 __shiftright128(unsigned __int64 _LowPart, unsigned __int64 _HighPart, unsigned char _Shift);
unsigned __int64 _umul128(unsigned __int64 _Multiplier, unsigned __int64 _Multiplicand, unsigned __int64 * _HighProduct);

/*******************************************************************
* Note: New intrinsics should be added here IF AND ONLY IF they're *
* being used by the C++ Standard Library.                          *
* OTHERWISE, new intrinsics should be added to intrin.h.           *
*******************************************************************/


}





   

   


  








 
 
 #pragma warning(pop)
 #pragma pack(pop)



/*
 * Copyright (c) by P.J. Plauger. All rights reserved.
 * Consult your license regarding permissions and restrictions.
V6.50:0009 */


#pragma pack(push,8)
#pragma warning(push,3)
#pragma warning(disable: 4455 4494  4619 4643 4702 4984 4988 )




namespace std {
template<class _Traits>
	using _Traits_ch_t = typename _Traits::char_type;

template<class _Traits>
	using _Traits_ptr_t = const typename _Traits::char_type *;

template<class _Traits>
	constexpr bool _Traits_equal(  const _Traits_ptr_t<_Traits> _Left, const size_t _Left_size,
		  const _Traits_ptr_t<_Traits> _Right, const size_t _Right_size) noexcept
	{	// compare [_Left, _Left + _Left_size) to [_Right, _Right + _Right_size) for equality using _Traits
	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);
	}

template<class _Traits>
	constexpr int _Traits_compare(  const _Traits_ptr_t<_Traits> _Left, const size_t _Left_size,
		  const _Traits_ptr_t<_Traits> _Right, const size_t _Right_size) noexcept
	{	// compare [_Left, _Left + _Left_size) to [_Right, _Right + _Right_size) using _Traits
	const int _Ans = _Traits::compare(_Left, _Right, _Min_value(_Left_size, _Right_size));

	if (_Ans != 0)
		{
		return (_Ans);
		}

	if (_Left_size < _Right_size)
		{
		return (-1);
		}

	if (_Left_size > _Right_size)
		{
		return (1);
		}

	return (0);
	}

template<class _Traits>
	constexpr size_t _Traits_find(
		  const _Traits_ptr_t<_Traits> _Haystack, const size_t _Hay_size, const size_t _Start_at,
		  const _Traits_ptr_t<_Traits> _Needle, const size_t _Needle_size) noexcept
	{	// search [_Haystack, _Haystack + _Hay_size) for [_Needle, _Needle + _Needle_size), at/after _Start_at
	if (_Needle_size > _Hay_size || _Start_at > _Hay_size - _Needle_size)
		{	// xpos cannot exist, report failure
			// N4659 24.3.2.7.2 [string.find]/1 says:
			// 1. _Start_at <= xpos
			// 2. xpos + _Needle_size <= _Hay_size;
			// therefore:
			// 3. _Needle_size <= _Hay_size (by 2) (checked above)
			// 4. _Start_at + _Needle_size <= _Hay_size (substitute 1 into 2)
			// 5. _Start_at <= _Hay_size - _Needle_size (4, move _Needle_size to other side) (also checked above)
		return (static_cast<size_t>(-1));
		}

	if (_Needle_size == 0)
		{	// empty string always matches if xpos is possible
		return (_Start_at);
		}

	const auto _Possible_matches_end = _Haystack + (_Hay_size - _Needle_size) + 1;
	for (auto _Match_try = _Haystack + _Start_at; ; ++_Match_try)
		{
		_Match_try = _Traits::find(_Match_try, static_cast<size_t>(_Possible_matches_end - _Match_try), *_Needle);
		if (!_Match_try)
			{	// didn't find first character; report failure
			return (static_cast<size_t>(-1));
			}

		if (_Traits::compare(_Match_try, _Needle, _Needle_size) == 0)
			{	// found match
			return (static_cast<size_t>(_Match_try - _Haystack));
			}
		}
	}

template<class _Traits>
	constexpr size_t _Traits_find_ch(
		  const _Traits_ptr_t<_Traits> _Haystack, const size_t _Hay_size, const size_t _Start_at,
		const _Traits_ch_t<_Traits> _Ch) noexcept
	{	// search [_Haystack, _Haystack + _Hay_size) for _Ch, at/after _Start_at
	if (_Start_at < _Hay_size)
		{
		const auto _Found_at = _Traits::find(_Haystack + _Start_at, _Hay_size - _Start_at, _Ch);
		if (_Found_at)
			{
			return (static_cast<size_t>(_Found_at - _Haystack));
			}
		}

	return (static_cast<size_t>(-1));	// (npos) no match
	}

template<class _Traits>
	constexpr size_t _Traits_rfind(
		  const _Traits_ptr_t<_Traits> _Haystack, const size_t _Hay_size, const size_t _Start_at,
		  const _Traits_ptr_t<_Traits> _Needle, const size_t _Needle_size) noexcept
	{	// search [_Haystack, _Haystack + _Hay_size) for [_Needle, _Needle + _Needle_size) beginning before _Start_at
	if (_Needle_size == 0)
		{
		return (_Min_value(_Start_at, _Hay_size));	// empty string always matches
		}

	if (_Needle_size <= _Hay_size)
		{	// room for match, look for it
		for (auto _Match_try = _Haystack + _Min_value(_Start_at, _Hay_size - _Needle_size); ; --_Match_try)
			{
			if (_Traits::eq(*_Match_try, *_Needle)
				&& _Traits::compare(_Match_try, _Needle, _Needle_size) == 0)
				{
				return (static_cast<size_t>(_Match_try - _Haystack));	// found a match
				}

			if (_Match_try == _Haystack)
				{
				break;	// at beginning, no more chance for match
				}
			}
		}

	return (static_cast<size_t>(-1));	// no match
	}

template<class _Traits>
	constexpr size_t _Traits_rfind_ch(
		  const _Traits_ptr_t<_Traits> _Haystack, const size_t _Hay_size, const size_t _Start_at,
		const _Traits_ch_t<_Traits> _Ch) noexcept
	{	// search [_Haystack, _Haystack + _Hay_size) for _Ch before _Start_at
	if (_Hay_size != 0)
		{	// room for match, look for it
		for (auto _Match_try = _Haystack + _Min_value(_Start_at, _Hay_size - 1); ; --_Match_try)
			{
			if (_Traits::eq(*_Match_try, _Ch))
				{
				return (static_cast<size_t>(_Match_try - _Haystack));	// found a match
				}

			if (_Match_try == _Haystack)
				{
				break;	// at beginning, no more chance for match
				}
			}
		}

	return (static_cast<size_t>(-1));	// no match
	}

template<class _Elem,
	bool = _Is_character<_Elem>::value>
	class _String_bitmap
	{	// _String_bitmap for character types
public:
	constexpr bool _Mark(const _Elem * _First, const _Elem * const _Last)
		{	// mark this bitmap such that the characters in [_First, _Last) are intended to match
			// returns whether all inputs can be placed in the bitmap
		for (; _First != _Last; ++_First)
			{
			_Matches[static_cast<unsigned char>(*_First)] = true;
			}

		return (true);
		}

	constexpr bool _Match(const _Elem _Ch) const
		{	// test if _Ch is in the bitmap
		return (_Matches[static_cast<unsigned char>(_Ch)]);
		}

private:
	bool _Matches[256] = {};
	};

template<class _Elem>
	class _String_bitmap<_Elem, false>
	{	// _String_bitmap for wchar_t/unsigned short/char16_t/char32_t/etc. types
public:
	static_assert(is_unsigned_v<_Elem>,
		"Standard char_traits is only provided for char, wchar_t, char16_t, and char32_t. See N5687 [char.traits]. "
		"Visual C++ accepts other unsigned integral types as an extension.");

	constexpr bool _Mark(const _Elem * _First, const _Elem * const _Last)
		{	// mark this bitmap such that the characters in [_First, _Last) are intended to match
			// returns whether all inputs can be placed in the bitmap
		for (; _First != _Last; ++_First)
			{
			const auto _Ch = *_First;
			if (_Ch >= 256U)
				{
				return (false);
				}

			_Matches[static_cast<unsigned char>(_Ch)] = true;
			}

		return (true);
		}

	constexpr bool _Match(const _Elem _Ch) const
		{	// test if _Ch is in the bitmap
		return (_Ch < 256U && _Matches[_Ch]);
		}

private:
	bool _Matches[256] = {};
	};

template<class _Traits>
	constexpr size_t _Traits_find_first_of(
		  const _Traits_ptr_t<_Traits> _Haystack, const size_t _Hay_size, const size_t _Start_at,
		  const _Traits_ptr_t<_Traits> _Needle, const size_t _Needle_size, false_type) noexcept
	{	// in [_Haystack, _Haystack + _Hay_size), look for one of [_Needle, _Needle + _Needle_size), at/after _Start_at
		// general algorithm
	if (_Needle_size != 0 && _Start_at < _Hay_size)
		{	// room for match, look for it
		const auto _End = _Haystack + _Hay_size;
		for (auto _Match_try = _Haystack + _Start_at; _Match_try < _End; ++_Match_try)
			{
			if (_Traits::find(_Needle, _Needle_size, *_Match_try))
				{
				return (static_cast<size_t>(_Match_try - _Haystack));	// found a match
				}
			}
		}

	return (static_cast<size_t>(-1));	// no match
	}

template<class _Traits>
	constexpr size_t _Traits_find_first_of(
		  const _Traits_ptr_t<_Traits> _Haystack, const size_t _Hay_size, const size_t _Start_at,
		  const _Traits_ptr_t<_Traits> _Needle, const size_t _Needle_size, true_type) noexcept
	{	// in [_Haystack, _Haystack + _Hay_size), look for one of [_Needle, _Needle + _Needle_size), at/after _Start_at
		// special case for std::char_traits
	if (_Needle_size != 0 && _Start_at < _Hay_size)
		{	// room for match, look for it
		_String_bitmap<typename _Traits::char_type> _Matches;
		if (!_Matches._Mark(_Needle, _Needle + _Needle_size))
			{	// couldn't put one of the characters into the bitmap, fall back to the serial algorithm
			return (_Traits_find_first_of<_Traits>(_Haystack, _Hay_size, _Start_at, _Needle, _Needle_size,
				false_type{}));
			}

		const auto _End = _Haystack + _Hay_size;
		for (auto _Match_try = _Haystack + _Start_at; _Match_try < _End; ++_Match_try)
			{
			if (_Matches._Match(*_Match_try))
				{
				return (static_cast<size_t>(_Match_try - _Haystack));	// found a match
				}
			}
		}

	return (static_cast<size_t>(-1));	// no match
	}

template<class _Traits>
	constexpr size_t _Traits_find_last_of(
		  const _Traits_ptr_t<_Traits> _Haystack, const size_t _Hay_size, const size_t _Start_at,
		  const _Traits_ptr_t<_Traits> _Needle, const size_t _Needle_size, false_type) noexcept
	{	// in [_Haystack, _Haystack + _Hay_size), look for last of [_Needle, _Needle + _Needle_size), before _Start_at
		// general algorithm
	if (_Needle_size != 0 && _Hay_size != 0)
		{	// worth searching, do it
		for (auto _Match_try = _Haystack + _Min_value(_Start_at, _Hay_size - 1); ; --_Match_try)
			{
			if (_Traits::find(_Needle, _Needle_size, *_Match_try))
				{
				return (static_cast<size_t>(_Match_try - _Haystack));	// found a match
				}

			if (_Match_try == _Haystack)
				{
				break;	// at beginning, no more chance for match
				}
			}
		}

	return (static_cast<size_t>(-1));	// no match
	}

template<class _Traits>
	constexpr size_t _Traits_find_last_of(
		  const _Traits_ptr_t<_Traits> _Haystack, const size_t _Hay_size, const size_t _Start_at,
		  const _Traits_ptr_t<_Traits> _Needle, const size_t _Needle_size, true_type) noexcept
	{	// in [_Haystack, _Haystack + _Hay_size), look for last of [_Needle, _Needle + _Needle_size), before _Start_at
		// special case for std::char_traits
	if (_Needle_size != 0 && _Hay_size != 0)
		{	// worth searching, do it
		_String_bitmap<typename _Traits::char_type> _Matches;
		if (!_Matches._Mark(_Needle, _Needle + _Needle_size))
			{	// couldn't put one of the characters into the bitmap, fall back to the serial algorithm
			return (_Traits_find_last_of<_Traits>(_Haystack, _Hay_size, _Start_at, _Needle, _Needle_size,
				false_type{}));
			}

		for (auto _Match_try = _Haystack + _Min_value(_Start_at, _Hay_size - 1); ; --_Match_try)
			{
			if (_Matches._Match(*_Match_try))
				{
				return (static_cast<size_t>(_Match_try - _Haystack));	// found a match
				}

			if (_Match_try == _Haystack)
				{
				break;	// at beginning, no more chance for match
				}
			}
		}

	return (static_cast<size_t>(-1));	// no match
	}

template<class _Traits>
	constexpr size_t _Traits_find_first_not_of(
		  const _Traits_ptr_t<_Traits> _Haystack, const size_t _Hay_size, const size_t _Start_at,
		  const _Traits_ptr_t<_Traits> _Needle, const size_t _Needle_size, false_type) noexcept
	{	// in [_Haystack, _Haystack + _Hay_size), look for none of [_Needle, _Needle + _Needle_size), at/after _Start_at
		// general algorithm
	if (_Start_at < _Hay_size)
		{	// room for match, look for it
		const auto _End = _Haystack + _Hay_size;
		for (auto _Match_try = _Haystack + _Start_at; _Match_try < _End; ++_Match_try)
			{
			if (!_Traits::find(_Needle, _Needle_size, *_Match_try))
				{
				return (static_cast<size_t>(_Match_try - _Haystack));	// found a match
				}
			}
		}

	return (static_cast<size_t>(-1));	// no match
	}

template<class _Traits>
	constexpr size_t _Traits_find_first_not_of(
		  const _Traits_ptr_t<_Traits> _Haystack, const size_t _Hay_size, const size_t _Start_at,
		  const _Traits_ptr_t<_Traits> _Needle, const size_t _Needle_size, true_type) noexcept
	{	// in [_Haystack, _Haystack + _Hay_size), look for none of [_Needle, _Needle + _Needle_size), at/after _Start_at
		// special case for std::char_traits
	if (_Start_at < _Hay_size)
		{	// room for match, look for it
		_String_bitmap<typename _Traits::char_type> _Matches;
		if (!_Matches._Mark(_Needle, _Needle + _Needle_size))
			{	// couldn't put one of the characters into the bitmap, fall back to the serial algorithm
			return (_Traits_find_first_not_of<_Traits>(_Haystack, _Hay_size, _Start_at, _Needle, _Needle_size,
				false_type{}));
			}

		const auto _End = _Haystack + _Hay_size;
		for (auto _Match_try = _Haystack + _Start_at; _Match_try < _End; ++_Match_try)
			{
			if (!_Matches._Match(*_Match_try))
				{
				return (static_cast<size_t>(_Match_try - _Haystack));	// found a match
				}
			}
		}

	return (static_cast<size_t>(-1));	// no match
	}

template<class _Traits>
	constexpr size_t _Traits_find_not_ch(
		  const _Traits_ptr_t<_Traits> _Haystack, const size_t _Hay_size, const size_t _Start_at,
		const _Traits_ch_t<_Traits> _Ch) noexcept
	{	// search [_Haystack, _Haystack + _Hay_size) for any value other than _Ch, at/after _Start_at
	if (_Start_at < _Hay_size)
		{	// room for match, look for it
		const auto _End = _Haystack + _Hay_size;
		for (auto _Match_try = _Haystack + _Start_at; _Match_try < _End; ++_Match_try)
			{
			if (!_Traits::eq(*_Match_try, _Ch))
				{
				return (static_cast<size_t>(_Match_try - _Haystack));	// found a match
				}
			}
		}

	return (static_cast<size_t>(-1));	// no match
	}

template<class _Traits>
	constexpr size_t _Traits_find_last_not_of(
		  const _Traits_ptr_t<_Traits> _Haystack, const size_t _Hay_size, const size_t _Start_at,
		  const _Traits_ptr_t<_Traits> _Needle, const size_t _Needle_size, false_type) noexcept
	{	// in [_Haystack, _Haystack + _Hay_size), look for none of [_Needle, _Needle + _Needle_size), before _Start_at
		// general algorithm
	if (_Hay_size != 0)
		{	// worth searching, do it
		for (auto _Match_try = _Haystack + _Min_value(_Start_at, _Hay_size - 1); ; --_Match_try)
			{
			if (!_Traits::find(_Needle, _Needle_size, *_Match_try))
				{
				return (static_cast<size_t>(_Match_try - _Haystack));	// found a match
				}

			if (_Match_try == _Haystack)
				{
				break;	// at beginning, no more chance for match
				}
			}
		}

	return (static_cast<size_t>(-1));	// no match
	}

template<class _Traits>
	constexpr size_t _Traits_find_last_not_of(
		  const _Traits_ptr_t<_Traits> _Haystack, const size_t _Hay_size, const size_t _Start_at,
		  const _Traits_ptr_t<_Traits> _Needle, const size_t _Needle_size, true_type) noexcept
	{	// in [_Haystack, _Haystack + _Hay_size), look for none of [_Needle, _Needle + _Needle_size), before _Start_at
		// special case for std::char_traits
	if (_Hay_size != 0)
		{	// worth searching, do it
		_String_bitmap<typename _Traits::char_type> _Matches;
		if (!_Matches._Mark(_Needle, _Needle + _Needle_size))
			{	// couldn't put one of the characters into the bitmap, fall back to the serial algorithm
			return (_Traits_find_last_not_of<_Traits>(_Haystack, _Hay_size, _Start_at, _Needle, _Needle_size,
				false_type{}));
			}

		for (auto _Match_try = _Haystack + _Min_value(_Start_at, _Hay_size - 1); ; --_Match_try)
			{
			if (!_Matches._Match(*_Match_try))
				{
				return (static_cast<size_t>(_Match_try - _Haystack));	// found a match
				}

			if (_Match_try == _Haystack)
				{
				break;	// at beginning, no more chance for match
				}
			}
		}

	return (static_cast<size_t>(-1));	// no match
	}

template<class _Traits>
	constexpr size_t _Traits_rfind_not_ch(
		  const _Traits_ptr_t<_Traits> _Haystack, const size_t _Hay_size, const size_t _Start_at,
		const _Traits_ch_t<_Traits> _Ch) noexcept
	{	// search [_Haystack, _Haystack + _Hay_size) for any value other than _Ch before _Start_at
	if (_Hay_size != 0)
		{	// room for match, look for it
		for (auto _Match_try = _Haystack + _Min_value(_Start_at, _Hay_size - 1); ; --_Match_try)
			{
			if (!_Traits::eq(*_Match_try, _Ch))
				{
				return (static_cast<size_t>(_Match_try - _Haystack));	// found a match
				}

			if (_Match_try == _Haystack)
				{
				break;	// at beginning, no more chance for match
				}
			}
		}

	return (static_cast<size_t>(-1));	// no match
	}

























































































































































































































































































































































































































































































































































































































































































































































































































































































































































		// CLASS TEMPLATE _String_const_iterator
template<class _Mystr>
	class _String_const_iterator
		: public _Iterator_base
	{	// iterator for immutable string
public:
	using iterator_category = random_access_iterator_tag;

	using value_type = typename _Mystr::value_type;
	using difference_type = typename _Mystr::difference_type;
	using pointer = typename _Mystr::const_pointer;
	using reference = const value_type&;

	_String_const_iterator()
		: _Ptr()
		{	// construct with null pointer
		}

	_String_const_iterator(pointer _Parg, const _Container_base *_Pstring)
		: _Ptr(_Parg)
		{	// construct with pointer _Parg
		this->_Adopt(_Pstring);
		}

	 reference operator*() const
		{	// return designated object

		do { if (_Ptr) { } else { do { (void) ((1 != _CrtDbgReport(2, "c:\\visual studio\\vc\\tools\\msvc\\14.16.27023\\include\\xstring", 1424, 0, "%s", "cannot dereference value-initialized string iterator")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"cannot dereference value-initialized string iterator\"", __LPREFIX( __FUNCTION__), L"c:\\visual studio\\vc\\tools\\msvc\\14.16.27023\\include\\xstring", 1424, 0); } while (false); } ; } while (false);
		const auto _Mycont = static_cast<const _Mystr *>(this->_Getcont());
		do { if (_Mycont) { } else { do { (void) ((1 != _CrtDbgReport(2, "c:\\visual studio\\vc\\tools\\msvc\\14.16.27023\\include\\xstring", 1427, 0, "%s", "cannot dereference string iterator because the iterator was" " invalidated (e.g. reallocation occurred, or the string was destroyed)")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"cannot dereference string iterator because the iterator was\" \" invalidated (e.g. reallocation occurred, or the string was destroyed)\"", __LPREFIX( __FUNCTION__), L"c:\\visual studio\\vc\\tools\\msvc\\14.16.27023\\include\\xstring", 1427, 0); } while (false); } ; } while (false);
		const auto _Contptr = _Mycont->_Myptr();
		const auto _Rawptr = _Unfancy(_Ptr);
		do { if (_Contptr <= _Rawptr && _Rawptr < _Contptr + _Mycont->_Mysize) { } else { do { (void) ((1 != _CrtDbgReport(2, "c:\\visual studio\\vc\\tools\\msvc\\14.16.27023\\include\\xstring", 1431, 0, "%s", "cannot dereference string iterator because it is out of range (e.g. an end iterator)")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"cannot dereference string iterator because it is out of range (e.g. an end iterator)\"", __LPREFIX( __FUNCTION__), L"c:\\visual studio\\vc\\tools\\msvc\\14.16.27023\\include\\xstring", 1431, 0); } while (false); } ; } while (false);


		;
		return (*_Ptr);
		}

	 pointer operator->() const
		{	// return pointer to class object
		return (pointer_traits<pointer>::pointer_to(**this));
		}

	_String_const_iterator& operator++()
		{	// preincrement

		do { if (_Ptr) { } else { do { (void) ((1 != _CrtDbgReport(2, "c:\\visual studio\\vc\\tools\\msvc\\14.16.27023\\include\\xstring", 1446, 0, "%s", "cannot increment value-initialized string iterator")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"cannot increment value-initialized string iterator\"", __LPREFIX( __FUNCTION__), L"c:\\visual studio\\vc\\tools\\msvc\\14.16.27023\\include\\xstring", 1446, 0); } while (false); } ; } while (false);
		const auto _Mycont = static_cast<const _Mystr *>(this->_Getcont());
		do { if (_Mycont) { } else { do { (void) ((1 != _CrtDbgReport(2, "c:\\visual studio\\vc\\tools\\msvc\\14.16.27023\\include\\xstring", 1449, 0, "%s", "cannot increment string iterator because the iterator was" " invalidated (e.g. reallocation occurred, or the string was destroyed)")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"cannot increment string iterator because the iterator was\" \" invalidated (e.g. reallocation occurred, or the string was destroyed)\"", __LPREFIX( __FUNCTION__), L"c:\\visual studio\\vc\\tools\\msvc\\14.16.27023\\include\\xstring", 1449, 0); } while (false); } ; } while (false);
		do { if (_Unfancy(_Ptr) < _Mycont->_Myptr() + _Mycont->_Mysize) { } else { do { (void) ((1 != _CrtDbgReport(2, "c:\\visual studio\\vc\\tools\\msvc\\14.16.27023\\include\\xstring", 1451, 0, "%s", "cannot increment string iterator past end")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"cannot increment string iterator past end\"", __LPREFIX( __FUNCTION__), L"c:\\visual studio\\vc\\tools\\msvc\\14.16.27023\\include\\xstring", 1451, 0); } while (false); } ; } while (false);


		++_Ptr;
		return (*this);
		}

	_String_const_iterator operator++(int)
		{	// postincrement
		_String_const_iterator _Tmp = *this;
		++*this;
		return (_Tmp);
		}

	_String_const_iterator& operator--()
		{	// predecrement

		do { if (_Ptr) { } else { do { (void) ((1 != _CrtDbgReport(2, "c:\\visual studio\\vc\\tools\\msvc\\14.16.27023\\include\\xstring", 1468, 0, "%s", "cannot decrement value-initialized string iterator")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"cannot decrement value-initialized string iterator\"", __LPREFIX( __FUNCTION__), L"c:\\visual studio\\vc\\tools\\msvc\\14.16.27023\\include\\xstring", 1468, 0); } while (false); } ; } while (false);
		const auto _Mycont = static_cast<const _Mystr *>(this->_Getcont());
		do { if (_Mycont) { } else { do { (void) ((1 != _CrtDbgReport(2, "c:\\visual studio\\vc\\tools\\msvc\\14.16.27023\\include\\xstring", 1471, 0, "%s", "cannot decrement string iterator because the iterator was" " invalidated (e.g. reallocation occurred, or the string was destroyed)")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"cannot decrement string iterator because the iterator was\" \" invalidated (e.g. reallocation occurred, or the string was destroyed)\"", __LPREFIX( __FUNCTION__), L"c:\\visual studio\\vc\\tools\\msvc\\14.16.27023\\include\\xstring", 1471, 0); } while (false); } ; } while (false);
		do { if (_Mycont->_Myptr() < _Unfancy(_Ptr)) { } else { do { (void) ((1 != _CrtDbgReport(2, "c:\\visual studio\\vc\\tools\\msvc\\14.16.27023\\include\\xstring", 1472, 0, "%s", "cannot decrement string iterator before begin")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"cannot decrement string iterator before begin\"", __LPREFIX( __FUNCTION__), L"c:\\visual studio\\vc\\tools\\msvc\\14.16.27023\\include\\xstring", 1472, 0); } while (false); } ; } while (false);


		--_Ptr;
		return (*this);
		}

	_String_const_iterator operator--(int)
		{	// postdecrement
		_String_const_iterator _Tmp = *this;
		--*this;
		return (_Tmp);
		}

	void _Verify_offset(const difference_type _Off) const noexcept
		{

		if (_Off == 0)
			{
			return;
			}

		do { if (_Ptr) { } else { do { (void) ((1 != _CrtDbgReport(2, "c:\\visual studio\\vc\\tools\\msvc\\14.16.27023\\include\\xstring", 1494, 0, "%s", "cannot seek value-initialized string iterator")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"cannot seek value-initialized string iterator\"", __LPREFIX( __FUNCTION__), L"c:\\visual studio\\vc\\tools\\msvc\\14.16.27023\\include\\xstring", 1494, 0); } while (false); } ; } while (false);
		const auto _Mycont = static_cast<const _Mystr *>(this->_Getcont());
		do { if (_Mycont) { } else { do { (void) ((1 != _CrtDbgReport(2, "c:\\visual studio\\vc\\tools\\msvc\\14.16.27023\\include\\xstring", 1497, 0, "%s", "cannot seek string iterator because the iterator was" " invalidated (e.g. reallocation occurred, or the string was destroyed)")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"cannot seek string iterator because the iterator was\" \" invalidated (e.g. reallocation occurred, or the string was destroyed)\"", __LPREFIX( __FUNCTION__), L"c:\\visual studio\\vc\\tools\\msvc\\14.16.27023\\include\\xstring", 1497, 0); } while (false); } ; } while (false);
		const auto _Contptr = _Mycont->_Myptr();
		const auto _Rawptr = _Unfancy(_Ptr);

		if (_Off < 0)
			{
#pragma warning(suppress: 4146)	
			do { if (_Contptr - _Rawptr <= _Off) { } else { do { (void) ((1 != _CrtDbgReport(2, "c:\\visual studio\\vc\\tools\\msvc\\14.16.27023\\include\\xstring", 1504, 0, "%s", "cannot seek string iterator before begin")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"cannot seek string iterator before begin\"", __LPREFIX( __FUNCTION__), L"c:\\visual studio\\vc\\tools\\msvc\\14.16.27023\\include\\xstring", 1504, 0); } while (false); } ; } while (false);
			}

		if (_Off > 0)
			{
			using _Size_type = typename _Mystr::size_type;
			const auto _Left = _Mycont->_Mysize - static_cast<_Size_type>(_Rawptr - _Contptr);
			do { if (static_cast<_Size_type>(_Off) <= _Left) { } else { do { (void) ((1 != _CrtDbgReport(2, "c:\\visual studio\\vc\\tools\\msvc\\14.16.27023\\include\\xstring", 1511, 0, "%s", "cannot seek string iterator after end")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"cannot seek string iterator after end\"", __LPREFIX( __FUNCTION__), L"c:\\visual studio\\vc\\tools\\msvc\\14.16.27023\\include\\xstring", 1511, 0); } while (false); } ; } while (false);
			}



		}

	_String_const_iterator& operator+=(const difference_type _Off)
		{	// increment by integer

		_Verify_offset(_Off);

		_Ptr += _Off;
		return (*this);
		}

	 _String_const_iterator operator+(const difference_type _Off) const
		{	// return this + integer
		_String_const_iterator _Tmp = *this;
		return (_Tmp += _Off);
		}

	_String_const_iterator& operator-=(const difference_type _Off)
		{	// decrement by integer
		return (*this += -_Off);
		}

	 _String_const_iterator operator-(const difference_type _Off) const
		{	// return this - integer
		_String_const_iterator _Tmp = *this;
		return (_Tmp -= _Off);
		}

	 difference_type operator-(const _String_const_iterator& _Right) const
		{	// return difference of iterators
		_Compat(_Right);
		return (_Ptr - _Right._Ptr);
		}

	 reference operator[](const difference_type _Off) const
		{	// subscript
		return (*(*this + _Off));
		}

	 bool operator==(const _String_const_iterator& _Right) const
		{	// test for iterator equality
		_Compat(_Right);
		return (_Ptr == _Right._Ptr);
		}

	 bool operator!=(const _String_const_iterator& _Right) const
		{	// test for iterator inequality
		return (!(*this == _Right));
		}

	 bool operator<(const _String_const_iterator& _Right) const
		{	// test if this < _Right
		_Compat(_Right);
		return (_Ptr < _Right._Ptr);
		}

	 bool operator>(const _String_const_iterator& _Right) const
		{	// test if this > _Right
		return (_Right < *this);
		}

	 bool operator<=(const _String_const_iterator& _Right) const
		{	// test if this <= _Right
		return (!(_Right < *this));
		}

	 bool operator>=(const _String_const_iterator& _Right) const
		{	// test if this >= _Right
		return (!(*this < _Right));
		}

	void _Compat(const _String_const_iterator& _Right) const
		{	// test for compatible iterator pair

		do { if (this->_Getcont() == _Right._Getcont()) { } else { do { (void) ((1 != _CrtDbgReport(2, "c:\\visual studio\\vc\\tools\\msvc\\14.16.27023\\include\\xstring", 1591, 0, "%s", "string iterators incompatible (e.g." " point to different string instances)")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"string iterators incompatible (e.g.\" \" point to different string instances)\"", __LPREFIX( __FUNCTION__), L"c:\\visual studio\\vc\\tools\\msvc\\14.16.27023\\include\\xstring", 1591, 0); } while (false); } ; } while (false);



		}


	friend void _Verify_range(const _String_const_iterator& _First, const _String_const_iterator& _Last)
		{
		do { if (_First._Getcont() == _Last._Getcont()) { } else { do { (void) ((1 != _CrtDbgReport(2, "c:\\visual studio\\vc\\tools\\msvc\\14.16.27023\\include\\xstring", 1601, 0, "%s", "string iterators in range are from different containers")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"string iterators in range are from different containers\"", __LPREFIX( __FUNCTION__), L"c:\\visual studio\\vc\\tools\\msvc\\14.16.27023\\include\\xstring", 1601, 0); } while (false); } ; } while (false);
		do { if (_First._Ptr <= _Last._Ptr) { } else { do { (void) ((1 != _CrtDbgReport(2, "c:\\visual studio\\vc\\tools\\msvc\\14.16.27023\\include\\xstring", 1602, 0, "%s", "string iterator range transposed")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"string iterator range transposed\"", __LPREFIX( __FUNCTION__), L"c:\\visual studio\\vc\\tools\\msvc\\14.16.27023\\include\\xstring", 1602, 0); } while (false); } ; } while (false);
		}


	 pointer _Unwrapped() const
		{
		return (_Ptr);
		}

	void _Seek_to(pointer _It)
		{
		_Ptr = _It;
		}

	pointer _Ptr;	// pointer to element in string
	};

template<class _Mystr>
	 inline _String_const_iterator<_Mystr> operator+(
		typename _String_const_iterator<_Mystr>::difference_type _Off,
		_String_const_iterator<_Mystr> _Next)
	{	// add offset to iterator
	return (_Next += _Off);
	}

		// CLASS TEMPLATE _String_iterator
template<class _Mystr>
	class _String_iterator
		: public _String_const_iterator<_Mystr>
	{	// iterator for mutable string
public:
	using _Mybase = _String_const_iterator<_Mystr>;
	using iterator_category = random_access_iterator_tag;

	using value_type = typename _Mystr::value_type;
	using difference_type = typename _Mystr::difference_type;
	using pointer = typename _Mystr::pointer;
	using reference = value_type&;

	_String_iterator()
		{	// construct with null string pointer
		}

	_String_iterator(pointer _Parg, const _Container_base *_Pstring)
		: _Mybase(_Parg, _Pstring)
		{	// construct with pointer _Parg
		}

	 reference operator*() const
		{	// return designated object
		return (const_cast<reference>(_Mybase::operator*()));
		}

	 pointer operator->() const
		{	// return pointer to class object
		return (pointer_traits<pointer>::pointer_to(**this));
		}

	_String_iterator& operator++()
		{	// preincrement
		++*(_Mybase *)this;
		return (*this);
		}

	_String_iterator operator++(int)
		{	// postincrement
		_String_iterator _Tmp = *this;
		++*this;
		return (_Tmp);
		}

	_String_iterator& operator--()
		{	// predecrement
		--*(_Mybase *)this;
		return (*this);
		}

	_String_iterator operator--(int)
		{	// postdecrement
		_String_iterator _Tmp = *this;
		--*this;
		return (_Tmp);
		}

	_String_iterator& operator+=(const difference_type _Off)
		{	// increment by integer
		*(_Mybase *)this += _Off;
		return (*this);
		}

	 _String_iterator operator+(const difference_type _Off) const
		{	// return this + integer
		_String_iterator _Tmp = *this;
		return (_Tmp += _Off);
		}

	_String_iterator& operator-=(const difference_type _Off)
		{	// decrement by integer
		return (*this += -_Off);
		}

	 _String_iterator operator-(const difference_type _Off) const
		{	// return this - integer
		_String_iterator _Tmp = *this;
		return (_Tmp -= _Off);
		}

	 difference_type operator-(const _Mybase& _Right) const
		{	// return difference of iterators
		return (*(_Mybase *)this - _Right);
		}

	 reference operator[](const difference_type _Off) const
		{	// subscript
		return (*(*this + _Off));
		}

	 pointer _Unwrapped() const
		{
		return (_Const_cast(this->_Ptr));
		}
	};

template<class _Mystr>
	 inline _String_iterator<_Mystr> operator+(
		typename _String_iterator<_Mystr>::difference_type _Off,
		_String_iterator<_Mystr> _Next)
	{	// add offset to iterator
	return (_Next += _Off);
	}

		// basic_string TYPE WRAPPERS
template<class _Value_type,
	class _Size_type,
	class _Difference_type,
	class _Pointer,
	class _Const_pointer,
	class _Reference,
	class _Const_reference>
	struct _String_iter_types
	{	// wraps types needed by iterators
	using value_type = _Value_type;
	using size_type = _Size_type;
	using difference_type = _Difference_type;
	using pointer = _Pointer;
	using const_pointer = _Const_pointer;
	};

template<class _Ty,
	class _Alloc>
	struct _String_base_types
	{	// types needed for a container base
	using _Alty = _Rebind_alloc_t<_Alloc, _Ty>;
	using _Alty_traits = allocator_traits<_Alty>;

	using _Val_types = conditional_t<_Is_simple_alloc_v<_Alty>,
		_Simple_types<_Ty>,
		_String_iter_types<_Ty,
			typename _Alty_traits::size_type,
			typename _Alty_traits::difference_type,
			typename _Alty_traits::pointer,
			typename _Alty_traits::const_pointer,
			_Ty&,
			const _Ty&>>;
	};

		// CLASS TEMPLATE _String_val
template<class _Val_types>
	class _String_val
		: public _Container_base
	{	// base class for basic_string to hold data
public:
	using value_type = typename _Val_types::value_type;
	using size_type = typename _Val_types::size_type;
	using difference_type = typename _Val_types::difference_type;
	using pointer = typename _Val_types::pointer;
	using const_pointer = typename _Val_types::const_pointer;
	using reference = value_type&;
	using const_reference = const value_type&;

	_String_val()
		: _Bx(),
		_Mysize(0),
		_Myres(0)
		{	// initialize values
		}

	enum
		{	// length of internal buffer, [1, 16]
		_BUF_SIZE = 16 / sizeof (value_type) < 1 ? 1
			: 16 / sizeof (value_type)};
	enum
		{	// roundup mask for allocated buffers, [0, 15]
		_ALLOC_MASK = sizeof (value_type) <= 1 ? 15
			: sizeof (value_type) <= 2 ? 7
			: sizeof (value_type) <= 4 ? 3
			: sizeof (value_type) <= 8 ? 1 : 0
		};

	value_type *_Myptr()
		{	// determine current pointer to buffer for mutable string
		value_type * _Result = _Bx._Buf;
		if (_Large_string_engaged())
			{
			_Result = _Unfancy(_Bx._Ptr);
			}

		return (_Result);
		}

	const value_type *_Myptr() const
		{	// determine current pointer to buffer for immutable string
		const value_type * _Result = _Bx._Buf;
		if (_Large_string_engaged())
			{
			_Result = _Unfancy(_Bx._Ptr);
			}

		return (_Result);
		}

	bool _Large_string_engaged() const
		{	// returns whether the large string mode (allocated memory) is engaged
		return (_BUF_SIZE <= _Myres);
		}

	void _Check_offset(const size_type _Off) const
		{	// checks whether _Off is in the bounds of [0, this->size()]
		if (_Mysize < _Off)
			{
			_Xran();
			}
		}

	void _Check_offset_exclusive(const size_type _Off) const
		{	// checks whether _Off is in the bounds of [0, this->size())
		if (_Mysize <= _Off)
			{
			_Xran();
			}
		}

	[[noreturn]] static void _Xran()
		{	// report an out_of_range error
		_Xout_of_range("invalid string position");
		}

	size_type _Clamp_suffix_size(const size_type _Off, const size_type _Size) const noexcept
		{	// trims _Size to the longest it can be assuming a string at/after _Off
		return (_Min_value(_Size, _Mysize - _Off));
		}

	union _Bxty
		{	// storage for small buffer or pointer to larger one
		_Bxty()
			{	// user-provided, for fancy pointers
			}

		~_Bxty() noexcept
			{	// user-provided, for fancy pointers
			}

		value_type _Buf[_BUF_SIZE];
		pointer _Ptr;
		char _Alias[_BUF_SIZE];	// retained for /clr bincompat; unused
		} _Bx;

	size_type _Mysize;	// current length of string
	size_type _Myres;	// current storage reserved for string
	};

		// CLASS TEMPLATE _String_alloc
template<class _Alloc_types>
	class _String_alloc
	{	// base class for basic_string to hold allocator
public:
	using _Alty = typename _Alloc_types::_Alty;
	using _Alty_traits = typename _Alloc_types::_Alty_traits;
	using _Alproxy = _Rebind_alloc_t<_Alty, _Container_proxy>;
	using _Alproxy_traits = allocator_traits<_Alproxy>;
	using _Val_types = typename _Alloc_types::_Val_types;
	using _Mydata_t = _String_val<_Val_types>;
	using _Bxty = typename _Mydata_t::_Bxty;

	using value_type = typename _Val_types::value_type;
	using size_type = typename _Val_types::size_type;
	using difference_type = typename _Val_types::difference_type;
	using pointer = typename _Val_types::pointer;
	using const_pointer = typename _Val_types::const_pointer;
	using reference = value_type&;
	using const_reference = const value_type&;

	using iterator = _String_iterator<_Mydata_t>;
	using const_iterator = _String_const_iterator<_Mydata_t>;

	enum
		{	// length of internal buffer, [1, 16]
		_BUF_SIZE = _Mydata_t::_BUF_SIZE
		};

	enum
		{	// roundup mask for allocated buffers, [0, 15]
		_ALLOC_MASK = _Mydata_t::_ALLOC_MASK
		};


























	_String_alloc()
		: _Mypair(_Zero_then_variadic_args_t())
		{	// default construct allocator
		_Alloc_proxy();
		}

	template<class _Any_alloc,
		class = enable_if_t<!is_same_v<remove_cv_t<remove_reference_t<_Any_alloc>>, _String_alloc>>>
		_String_alloc(_Any_alloc&& _Al)
		: _Mypair(_One_then_variadic_args_t(),
			::std:: forward<_Any_alloc>(_Al))
		{	// construct allocator from _Al
		_Alloc_proxy();
		}

	~_String_alloc() noexcept
		{	// destroy the object
		_Free_proxy();
		}

	void _Copy_alloc(const _Alty& _Al)
		{	// replace old allocator
		const bool _Reload = _Alty_traits::propagate_on_container_copy_assignment::value
			&& _Getal() != _Al;

		if (_Reload)
			{
			_Free_proxy();
			}

		_Pocca(_Getal(), _Al);

		if (_Reload)
			{
			_Alloc_proxy();
			}
		}

	void _Move_alloc(_Alty& _Al)
		{	// replace old allocator
		const bool _Reload = _Alty_traits::propagate_on_container_move_assignment::value
			&& _Getal() != _Al;

		if (_Reload)
			{
			_Free_proxy();
			}

		_Pocma(_Getal(), _Al);

		if (_Reload)
			{
			_Alloc_proxy();
			}
		}

	void _Alloc_proxy()
		{	// construct proxy
		_Alproxy _Proxy_allocator(_Getal());
		_Myproxy() = _Unfancy(_Proxy_allocator.allocate(1));
		_Alproxy_traits::construct(_Proxy_allocator, _Myproxy(), _Container_proxy());
		_Myproxy()->_Mycont = ::std:: addressof(_Get_data());
		}

	void _Free_proxy()
		{	// destroy proxy
		_Alproxy _Proxy_allocator(_Getal());
		_Orphan_all();
		_Alproxy_traits::destroy(_Proxy_allocator, _Myproxy());
		_Deallocate_plain(_Proxy_allocator, _Myproxy());
		_Myproxy() = nullptr;
		}

	_Iterator_base12 **_Getpfirst() const
		{	// get address of iterator chain
		return (_Get_data()._Getpfirst());
		}

	_Container_proxy * & _Myproxy() noexcept
		{	// return reference to _Myproxy
		return (_Get_data()._Myproxy);
		}

	_Container_proxy * const & _Myproxy() const noexcept
		{	// return const reference to _Myproxy
		return (_Get_data()._Myproxy);
		}


	void _Orphan_all()
		{	// orphan all iterators
		_Get_data()._Orphan_all();
		}

	void _Swap_all(_String_alloc& _Right)
		{	// swap all iterators
		_Get_data()._Swap_all(_Right._Get_data());
		}

	_Alty& _Getal() noexcept
		{	// return reference to allocator
		return (_Mypair._Get_first());
		}

	const _Alty& _Getal() const noexcept
		{	// return const reference to allocator
		return (_Mypair._Get_first());
		}

	_Mydata_t& _Get_data() noexcept
		{	// return reference to _String_val
		return (_Mypair._Get_second());
		}

	const _Mydata_t& _Get_data() const noexcept
		{	// return const reference to _String_val
		return (_Mypair._Get_second());
		}

private:
	_Compressed_pair<_Alty, _Mydata_t> _Mypair;
	};


		// CLASS TEMPLATE basic_string
template<class _Ty>
	constexpr size_t _Size_after_ebco_v
		= is_empty_v<_Ty> ? 0 : sizeof(_Ty);	// get _Ty's size after being EBCO'd

template<class _Elem,
	class _Traits = char_traits<_Elem>,
	class _Alloc = allocator<_Elem>>
	class basic_string
		: public _String_alloc<_String_base_types<_Elem, _Alloc>>
	{	// null-terminated transparent array of elements
public:
	static_assert(!0 || is_same_v<_Elem, typename _Alloc::value_type>,
		"basic_string<T, Traits, Allocator>" " requires that Allocator's value_type match " "T" " (See N4659 26.2.1 [container.requirements.general]/16 allocator_type)" " Either fix the allocator value_type or define _ENFORCE_MATCHING_ALLOCATORS=0" " to suppress this diagnostic.");

	static_assert(is_same_v<_Elem, typename _Traits::char_type>,
		"N4659 24.3.2.1 [string.require]/3 requires that the supplied "
		"char_traits character type match the string's character type.");

	using _Mybase = _String_alloc<_String_base_types<_Elem, _Alloc>>;
	using traits_type = _Traits;
	using allocator_type = _Alloc;

	using _Alty = typename _Mybase::_Alty;
	using _Alty_traits = typename _Mybase::_Alty_traits;
	using _Mydata_t = typename _Mybase::_Mydata_t;

	using value_type = typename _Mybase::value_type;
	using size_type = typename _Mybase::size_type;
	using difference_type = typename _Mybase::difference_type;
	using pointer = typename _Mybase::pointer;
	using const_pointer = typename _Mybase::const_pointer;
	using reference = value_type&;
	using const_reference = const value_type&;

	using iterator = typename _Mybase::iterator;
	using const_iterator = typename _Mybase::const_iterator;

	using reverse_iterator = ::std:: reverse_iterator<iterator>;
	using const_reverse_iterator = ::std:: reverse_iterator<const_iterator>;

	// When doing swap / move by memcpy, we are touching:
	//   _String_val::_Bx::_Buf (type is array of _Elem)
	//   _String_val::_Bx::_Ptr (type is pointer)
	//   _String_val::_Mysize   (type is size_type)
	//   _String_val::_Myres    (type is size_type)
	// N4659 24.1 [strings.general]/1 says _Elem must be a non-array POD, so memcpy is safe.
	// We need to ask if pointer is safe to memcpy.
	// size_type must be an unsigned integral type so memcpy is safe.
	// We also need to disable memcpy if the user has supplied _Traits, since
	//   they can observe traits::assign and similar.
	using _Use_memcpy_move = bool_constant<
		_Is_specialization_v<_Traits, char_traits> && is_trivial_v<pointer>>;
	// This offset skips over the _Container_base members, if any
	static constexpr size_t _Memcpy_move_offset = _Size_after_ebco_v<_Container_base>;
	static constexpr size_t _Memcpy_move_size = sizeof(_Mydata_t) - _Memcpy_move_offset;

	template<class _Iter>
		using _Is_elem_cptr = bool_constant<_Is_any_of_v<_Iter,
			const _Elem * const,
			_Elem * const,
			const _Elem *,
			_Elem *>>;









	basic_string(const basic_string& _Right)
		: _Mybase(_Alty_traits::select_on_container_copy_construction(_Right._Getal()))
		{	// construct by copying _Right
		_Construct_lv_contents(_Right);
		}

	basic_string(const basic_string& _Right, const _Alloc& _Al)
		: _Mybase(_Al)
		{	// construct by copying with allocator
		_Construct_lv_contents(_Right);
		}

	basic_string() noexcept(is_nothrow_default_constructible_v<_Alty>)
		: _Mybase()
		{	// construct empty string
		_Tidy_init();
		}

	explicit basic_string(const _Alloc& _Al) noexcept
		: _Mybase(_Al)
		{	// construct empty string with allocator
		_Tidy_init();
		}

	basic_string(const basic_string& _Right, const size_type _Roff, const _Alloc& _Al = _Alloc())
		: _Mybase(_Al)
		{	// construct from _Right [_Roff, <end>)
		_Tidy_init();
		assign(_Right, _Roff, npos);
		}

	basic_string(const basic_string& _Right, const size_type _Roff, const size_type _Count, const _Alloc& _Al = _Alloc())
		: _Mybase(_Al)
		{	// construct from _Right [_Roff, _Roff + _Count)
		_Tidy_init();
		assign(_Right, _Roff, _Count);
		}

	basic_string(  const _Elem * const _Ptr, __declspec(guard(overflow)) const size_type _Count)
		: _Mybase()
		{	// construct from [_Ptr, _Ptr + _Count)
		_Tidy_init();
		assign(_Ptr, _Count);
		}

	basic_string(  const _Elem * const _Ptr, __declspec(guard(overflow)) const size_type _Count,
		const _Alloc& _Al)
		: _Mybase(_Al)
		{	// construct from [_Ptr, _Ptr + _Count) with allocator
		_Tidy_init();
		assign(_Ptr, _Count);
		}

	basic_string(  const _Elem * const _Ptr)
		: _Mybase()
		{	// construct from [_Ptr, <null>)
		_Tidy_init();
		assign(_Ptr);
		}





	basic_string(  const _Elem * const _Ptr, const _Alloc& _Al)
		: _Mybase(_Al)
		{	// construct from [_Ptr, <null>) with allocator
		_Tidy_init();
		assign(_Ptr);
		}

	basic_string(__declspec(guard(overflow)) const size_type _Count, const _Elem _Ch)
		: _Mybase()
		{	// construct from _Count * _Ch
		_Tidy_init();
		assign(_Count, _Ch);
		}





	basic_string(__declspec(guard(overflow)) const size_type _Count, const _Elem _Ch, const _Alloc& _Al)
		: _Mybase(_Al)
		{	// construct from _Count * _Ch with allocator
		_Tidy_init();
		assign(_Count, _Ch);
		}

	template<class _Iter,
		class = enable_if_t<_Is_iterator_v<_Iter>>>
		basic_string(_Iter _First, _Iter _Last, const _Alloc& _Al = _Alloc())
		: _Mybase(_Al)
		{	// construct from [_First, _Last) with optional allocator
		_Tidy_init();
		_Adl_verify_range(_First, _Last);
		_Construct(_Get_unwrapped(_First), _Get_unwrapped(_Last), _Iter_cat_t<_Iter>());
		}

	template<class _Iter>
		void _Construct(_Iter _First, const _Iter _Last, input_iterator_tag)
		{	// initialize from [_First, _Last), input iterators
		try {
		for (; _First != _Last; ++_First)
			{
			push_back(static_cast<_Elem>(*_First));
			}

		} catch (...) {
		_Tidy_deallocate();
		throw;
		}
		}

	template<class _Iter>
		void _Construct(const _Iter _First, const _Iter _Last, forward_iterator_tag)
		{	// initialize from [_First, _Last), forward iterators
		const size_type _Count = _Convert_size<size_type>(static_cast<size_t>(::std:: distance(_First, _Last)));
		reserve(_Count);
		_Construct(_First, _Last, input_iterator_tag());
		}

	void _Construct(_Elem * const _First, _Elem * const _Last, random_access_iterator_tag)
		{	// initialize from [_First, _Last), pointers
		if (_First != _Last)
			{
			assign(_First, _Convert_size<size_type>(static_cast<size_t>(_Last - _First)));
			}
		}

	void _Construct(const _Elem * const _First, const _Elem * const _Last, random_access_iterator_tag)
		{	// initialize from [_First, _Last), const pointers
		if (_First != _Last)
			{
			assign(_First, _Convert_size<size_type>(static_cast<size_t>(_Last - _First)));
			}
		}

	basic_string(basic_string&& _Right) noexcept
		: _Mybase(::std:: move(_Right._Getal()))
		{	// construct by moving _Right
		_Assign_rv_contents_with_alloc_always_equal(::std:: move(_Right), _Use_memcpy_move{});
		}

	basic_string(basic_string&& _Right, const _Alloc& _Al)
		noexcept(_Alty_traits::is_always_equal::value) // strengthened
		: _Mybase(_Al)
		{	// construct by moving _Right, allocator
		_Assign_rv_contents(::std:: move(_Right), typename _Alty_traits::is_always_equal{});
		}






















	basic_string& operator=(basic_string&& _Right) noexcept(_Always_equal_after_move<_Alty>)
		{	// assign by moving _Right
		if (this != ::std:: addressof(_Right))
			{	// different, assign it
			_Tidy_deallocate();
			this->_Move_alloc(_Right._Getal());
			// tag dispatch to remove unnecessary exception handling codegen in the
			// equal allocators case
			_Assign_rv_contents(::std:: move(_Right), bool_constant<_Always_equal_after_move<_Alty>>{});
			}

		return (*this);
		}

	basic_string& assign(basic_string&& _Right) noexcept(_Always_equal_after_move<_Alty>)
		{	// assign by moving _Right
		*this = ::std:: move(_Right);
		return (*this);
		}

	void _Assign_rv_contents(basic_string&& _Right, true_type) noexcept
		{	// assign either as an rvalue or as an lvalue copy, allocators always equal optimization
			// pre: this != &_Right
			// pre: allocator propagation (POCMA) from _Right, if necessary, is complete
			// pre: *this owns no memory, iterators orphaned (note: _Buf/_Ptr/_Mysize/_Myres may be garbage init)
		_Assign_rv_contents_with_alloc_always_equal(::std:: move(_Right), _Use_memcpy_move{});
		}

	void _Assign_rv_contents(basic_string&& _Right, false_type)
		{	// assign either as an rvalue or as an lvalue copy, allocators potentially unequal
			// pre: this != &_Right
			// pre: allocator propagation (POCMA) from _Right, if necessary, is complete
			// pre: *this owns no memory, iterators orphaned (note: _Buf/_Ptr/_Mysize/_Myres may be garbage init)
		if (this->_Getal() == _Right._Getal())
			{
			_Assign_rv_contents_with_alloc_always_equal(::std:: move(_Right), _Use_memcpy_move{});
			}
		else
			{
			_Construct_lv_contents(_Right);
			}
		}

	void _Assign_rv_contents_with_alloc_always_equal(basic_string&& _Right, true_type) noexcept
		{	// assign by stealing _Right's buffer, memcpy optimization
			// pre: this != &_Right
			// pre: allocator propagation (POCMA) from _Right, if necessary, is complete
			// pre: *this owns no memory, iterators orphaned (note: _Buf/_Ptr/_Mysize/_Myres may be garbage init)
		auto& _Right_data = _Right._Get_data();


		if (_Right_data._Large_string_engaged())
			{	// take ownership of _Right's iterators along with its buffer
			this->_Swap_all(_Right);
			}
		else
			{
			_Right._Orphan_all();
			}


		const auto _My_data_mem = reinterpret_cast<unsigned char *>(::std:: addressof(this->_Get_data()))
			+ _Memcpy_move_offset;
		const auto _Right_data_mem = reinterpret_cast<unsigned char *>(::std:: addressof(_Right_data))
			+ _Memcpy_move_offset;
		:: memcpy(_My_data_mem, _Right_data_mem, _Memcpy_move_size);
		_Right._Tidy_init();
		}

	void _Assign_rv_contents_with_alloc_always_equal(basic_string&& _Right, false_type) noexcept
		{	// assign by stealing _Right's buffer, general case
			// pre: this != &_Right
			// pre: allocator propagation (POCMA) from _Right, if necessary, is complete
			// pre: *this owns no memory, iterators orphaned (note: _Buf/_Ptr/_Mysize/_Myres may be garbage init)
		auto& _My_data = this->_Get_data();
		auto& _Right_data = _Right._Get_data();
		if (_Right_data._Large_string_engaged())
			{	// steal buffer
			_Alty_traits::construct(this->_Getal(), ::std:: addressof(_My_data._Bx._Ptr), _Right_data._Bx._Ptr);
			_Right_data._Bx._Ptr = pointer();
			this->_Swap_all(_Right);
			}
		else
			{	// copy small string buffer
			_Traits::copy(_My_data._Bx._Buf, _Right_data._Bx._Buf, _Right_data._Mysize + 1);
			_Right._Orphan_all();
			}

		_My_data._Mysize = _Right_data._Mysize;
		_My_data._Myres = _Right_data._Myres;
		_Right._Tidy_init();
		}

	void _Construct_lv_contents(const basic_string& _Right)
		{	// assign by copying data stored in _Right
			// pre: this != &_Right
			// pre: *this owns no memory, iterators orphaned (note: _Buf/_Ptr/_Mysize/_Myres may be garbage init)
		auto& _My_data = this->_Get_data();
		auto& _Right_data = _Right._Get_data();
		const size_type _Right_size = _Right_data._Mysize;
		const _Elem * const _Right_ptr = _Right_data._Myptr();
		if (_Right_size < this->_BUF_SIZE)
			{	// stay small, don't allocate
			_Traits::copy(_My_data._Bx._Buf, _Right_ptr, this->_BUF_SIZE);
			_My_data._Mysize = _Right_size;
			_My_data._Myres = this->_BUF_SIZE - 1;
			return;
			}

		auto& _Al = this->_Getal();
		const size_type _New_capacity = _Min_value(_Right_size | this->_ALLOC_MASK, max_size());
		const pointer _New_array = _Al.allocate(_New_capacity + 1); // throws
		_Alty_traits::construct(_Al, ::std:: addressof(_My_data._Bx._Ptr), _New_array);
		_Traits::copy(_Unfancy(_New_array), _Right_ptr, _Right_size + 1);
		_My_data._Mysize = _Right_size;
		_My_data._Myres = _New_capacity;
		}

	basic_string(initializer_list<_Elem> _Ilist, const _Alloc& _Al = allocator_type())
		: _Mybase(_Al)
		{	// construct from initializer_list
		_Tidy_init();
		assign(_Ilist.begin(), _Convert_size<size_type>(_Ilist.size()));
		}

	basic_string& operator=(initializer_list<_Elem> _Ilist)
		{	// assign initializer_list
		return (assign(_Ilist.begin(), _Convert_size<size_type>(_Ilist.size())));
		}

	basic_string& operator+=(initializer_list<_Elem> _Ilist)
		{	// append initializer_list
		return (append(_Ilist.begin(), _Convert_size<size_type>(_Ilist.size())));
		}

	basic_string& assign(initializer_list<_Elem> _Ilist)
		{	// assign initializer_list
		return (assign(_Ilist.begin(), _Convert_size<size_type>(_Ilist.size())));
		}

	basic_string& append(initializer_list<_Elem> _Ilist)
		{	// append initializer_list
		return (append(_Ilist.begin(), _Convert_size<size_type>(_Ilist.size())));
		}

	iterator insert(const const_iterator _Where, const initializer_list<_Elem> _Ilist)
		{	// insert initializer_list
		const difference_type _Off = _Where - begin();
		insert(static_cast<size_type>(_Off), _Ilist.begin(), _Convert_size<size_type>(_Ilist.size()));
		return (begin() + _Off);
		}

	basic_string& replace(const const_iterator _First, const const_iterator _Last, const initializer_list<_Elem> _Ilist)
		{	// replace with initializer_list
		return (replace(static_cast<size_type>(_First - begin()), static_cast<size_type>(_Last - _First),
			_Ilist.begin(), _Convert_size<size_type>(_Ilist.size())));
		}

	~basic_string() noexcept
		{	// destroy the string
		_Tidy_deallocate();
		}

	static constexpr auto npos{static_cast<size_type>(-1)};

	basic_string& operator=(const basic_string& _Right)
		{	// assign _Right
		if (this != ::std:: addressof(_Right))
			{	// different, assign it
#pragma warning(push)
#pragma warning(disable: 4127)	
			if (_Alty_traits::propagate_on_container_copy_assignment::value
				&& this->_Getal() != _Right._Getal())
				{	// change allocator before copying
				_Tidy_deallocate();
				}
#pragma warning(pop)

			this->_Copy_alloc(_Right._Getal());

			auto& _Right_data = _Right._Get_data();
			assign(_Right_data._Myptr(), _Right_data._Mysize);
			}

		return (*this);
		}










	basic_string& operator=(  const _Elem * const _Ptr)
		{	// assign [_Ptr, <null>)
		return (assign(_Ptr));
		}

	basic_string& operator=(const _Elem _Ch)
		{	// assign {_Ch, _Elem()}
		auto& _My_data = this->_Get_data();
		_My_data._Mysize = 1;
		_Elem * const _Ptr = _My_data._Myptr();
		_Traits::assign(_Ptr[0], _Ch);
		_Traits::assign(_Ptr[1], _Elem());
		return (*this);
		}

	basic_string& operator+=(const basic_string& _Right)
		{	// append _Right
		return (append(_Right));
		}










	basic_string& operator+=(  const _Elem * const _Ptr)
		{	// append [_Ptr, <null>)
		return (append(_Ptr));
		}

	basic_string& operator+=(_Elem _Ch)
		{	// append 1 * _Ch
		push_back(_Ch);
		return (*this);
		}

	basic_string& append(const basic_string& _Right)
		{	// append _Right
		auto& _Right_data = _Right._Get_data();
		return (append(_Right_data._Myptr(), _Right_data._Mysize));
		}

	basic_string& append(const basic_string& _Right, const size_type _Roff, size_type _Count = npos)
		{	// append _Right [_Roff, _Roff + _Count)
		auto& _Right_data = _Right._Get_data();
		_Right_data._Check_offset(_Roff);
		_Count = _Right_data._Clamp_suffix_size(_Roff, _Count);
		return (append(_Right_data._Myptr() + _Roff, _Count));
		}



















	basic_string& append(  const _Elem * const _Ptr, __declspec(guard(overflow)) const size_type _Count)
		{	// append [_Ptr, _Ptr + _Count)
		auto& _My_data = this->_Get_data();
		const size_type _Old_size = _My_data._Mysize;
		if (_Count <= _My_data._Myres - _Old_size)
			{
			_My_data._Mysize = _Old_size + _Count;
			_Elem * const _Old_ptr = _My_data._Myptr();
			_Traits::move(_Old_ptr + _Old_size, _Ptr, _Count);
			_Traits::assign(_Old_ptr[_Old_size + _Count], _Elem());
			return (*this);
			}

		return (_Reallocate_grow_by(_Count,
			[](_Elem * const _New_ptr, const _Elem * const _Old_ptr, const size_type _Old_size,
				const _Elem * const _Ptr, const size_type _Count) {
			_Traits::copy(_New_ptr, _Old_ptr, _Old_size);
			_Traits::copy(_New_ptr + _Old_size, _Ptr, _Count);
			_Traits::assign(_New_ptr[_Old_size + _Count], _Elem());
			}, _Ptr, _Count));
		}

	basic_string& append(  const _Elem * const _Ptr)
		{	// append [_Ptr, <null>)
		return (append(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));
		}

	basic_string& append(__declspec(guard(overflow)) const size_type _Count, const _Elem _Ch)
		{	// append _Count * _Ch
		auto& _My_data = this->_Get_data();
		const size_type _Old_size = _My_data._Mysize;
		if (_Count <= _My_data._Myres - _Old_size)
			{
			_My_data._Mysize = _Old_size + _Count;
			_Elem * const _Old_ptr = _My_data._Myptr();
			_Traits::assign(_Old_ptr + _Old_size, _Count, _Ch);
			_Traits::assign(_Old_ptr[_Old_size + _Count], _Elem());
			return (*this);
			}

		return (_Reallocate_grow_by(_Count,
			[](_Elem * const _New_ptr, const _Elem * const _Old_ptr, const size_type _Old_size,
				const size_type _Count, const _Elem _Ch) {
			_Traits::copy(_New_ptr, _Old_ptr, _Old_size);
			_Traits::assign(_New_ptr + _Old_size, _Count, _Ch);
			_Traits::assign(_New_ptr[_Old_size + _Count], _Elem());
			}, _Count, _Ch));
		}

	template<class _Iter,
		class = enable_if_t<_Is_iterator_v<_Iter>>>
		basic_string& append(const _Iter _First, const _Iter _Last)
		{	// append [_First, _Last), input iterators
		return (replace(end(), end(), _First, _Last));
		}

	basic_string& assign(const basic_string& _Right)
		{	// assign _Right
		*this = _Right;
		return (*this);
		}

	basic_string& assign(const basic_string& _Right, const size_type _Roff, size_type _Count = npos)
		{	// assign _Right [_Roff, _Roff + _Count)
		auto& _Right_data = _Right._Get_data();
		_Right_data._Check_offset(_Roff);
		_Count = _Right_data._Clamp_suffix_size(_Roff, _Count);
		return (assign(_Right_data._Myptr() + _Roff, _Count));
		}



















	basic_string& assign(  const _Elem * const _Ptr, __declspec(guard(overflow)) const size_type _Count)
		{	// assign [_Ptr, _Ptr + _Count)
		auto& _My_data = this->_Get_data();
		if (_Count <= _My_data._Myres)
			{
			_Elem * const _Old_ptr = _My_data._Myptr();
			_My_data._Mysize = _Count;
			_Traits::move(_Old_ptr, _Ptr, _Count);
			_Traits::assign(_Old_ptr[_Count], _Elem());
			return (*this);
			}

		return (_Reallocate_for(_Count, [](_Elem * const _New_ptr, const size_type _Count, const _Elem * const _Ptr) {
			_Traits::copy(_New_ptr, _Ptr, _Count);
			_Traits::assign(_New_ptr[_Count], _Elem());
			}, _Ptr));
		}

	basic_string& assign(  const _Elem * const _Ptr)
		{	// assign [_Ptr, <null>)
		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));
		}

	basic_string& assign(__declspec(guard(overflow)) const size_type _Count, const _Elem _Ch)
		{	// assign _Count * _Ch
		auto& _My_data = this->_Get_data();
		if (_Count <= _My_data._Myres)
			{
			_Elem * const _Old_ptr = _My_data._Myptr();
			_My_data._Mysize = _Count;
			_Traits::assign(_Old_ptr, _Count, _Ch);
			_Traits::assign(_Old_ptr[_Count], _Elem());
			return (*this);
			}

		return (_Reallocate_for(_Count, [](_Elem * const _New_ptr, const size_type _Count, const _Elem _Ch) {
			_Traits::assign(_New_ptr, _Count, _Ch);
			_Traits::assign(_New_ptr[_Count], _Elem());
			}, _Ch));
		}

	template<class _Iter,
		class = enable_if_t<_Is_iterator_v<_Iter>>>
		basic_string& assign(const _Iter _First, const _Iter _Last)
		{	// assign [_First, _Last), input iterators
		return (replace(begin(), end(), _First, _Last));
		}

	basic_string& insert(const size_type _Off, const basic_string& _Right)
		{	// insert _Right at _Off
		auto& _Right_data = _Right._Get_data();
		return (insert(_Off, _Right_data._Myptr(), _Right_data._Mysize));
		}

	basic_string& insert(const size_type _Off, const basic_string& _Right, const size_type _Roff, size_type _Count = npos)
		{	// insert _Right [_Roff, _Roff + _Count) at _Off
		auto& _Right_data = _Right._Get_data();
		_Right_data._Check_offset(_Roff);
		_Count = _Right_data._Clamp_suffix_size(_Roff, _Count);
		return (insert(_Off, _Right_data._Myptr() + _Roff, _Count));
		}




















	basic_string& insert(const size_type _Off,   const _Elem * const _Ptr,
		__declspec(guard(overflow)) const size_type _Count)
		{	// insert [_Ptr, _Ptr + _Count) at _Off
		auto& _My_data = this->_Get_data();
		_My_data._Check_offset(_Off);
		const size_type _Old_size = _My_data._Mysize;
		if (_Count <= _My_data._Myres - _Old_size)
			{
			_My_data._Mysize = _Old_size + _Count;
			_Elem * const _Old_ptr = _My_data._Myptr();
			_Elem * const _Insert_at = _Old_ptr + _Off;
			// the range [_Ptr, _Ptr + _Ptr_shifted_after) is left alone by moving the suffix out,
			// while the range [_Ptr + _Ptr_shifted_after, _Ptr + _Count) shifts down by _Count
			size_type _Ptr_shifted_after;
			if (_Ptr + _Count <= _Insert_at || _Ptr > _Old_ptr + _Old_size)
				{	// inserted content is before the shifted region, or does not alias
				_Ptr_shifted_after = _Count; // none of _Ptr's data shifts
				}
			else if (_Insert_at <= _Ptr)
				{	// all of [_Ptr, _Ptr + _Count) shifts
				_Ptr_shifted_after = 0;
				}
			else
				{	// [_Ptr, _Ptr + _Count) contains _Insert_at, so only the part after _Insert_at shifts
				_Ptr_shifted_after = static_cast<size_type>(_Insert_at - _Ptr);
				}

			_Traits::move(_Insert_at + _Count, _Insert_at, _Old_size - _Off + 1); // move suffix + null down
			_Traits::copy(_Insert_at, _Ptr, _Ptr_shifted_after);
			_Traits::copy(_Insert_at + _Ptr_shifted_after, _Ptr + _Count + _Ptr_shifted_after,
				_Count - _Ptr_shifted_after);
			return (*this);
			}

		return (_Reallocate_grow_by(_Count,
			[](_Elem * const _New_ptr, const _Elem * const _Old_ptr, const size_type _Old_size,
				const size_type _Off, const _Elem * const _Ptr, const size_type _Count) {
			_Traits::copy(_New_ptr, _Old_ptr, _Off);
			_Traits::copy(_New_ptr + _Off, _Ptr, _Count);
			_Traits::copy(_New_ptr + _Off + _Count, _Old_ptr + _Off, _Old_size - _Off + 1);
			}, _Off, _Ptr, _Count));
		}

	basic_string& insert(const size_type _Off,   const _Elem * const _Ptr)
		{	// insert [_Ptr, <null>) at _Off
		return (insert(_Off, _Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));
		}

	basic_string& insert(const size_type _Off, __declspec(guard(overflow)) const size_type _Count, const _Elem _Ch)
		{	// insert _Count * _Ch at _Off
		auto& _My_data = this->_Get_data();
		_My_data._Check_offset(_Off);
		const size_type _Old_size = _My_data._Mysize;
		if (_Count <= _My_data._Myres - _Old_size)
			{
			_My_data._Mysize = _Old_size + _Count;
			_Elem * const _Old_ptr = _My_data._Myptr();
			_Elem * const _Insert_at = _Old_ptr + _Off;
			_Traits::move(_Insert_at + _Count, _Insert_at, _Old_size - _Off + 1); // move suffix + null down
			_Traits::assign(_Insert_at, _Count, _Ch); // fill hole
			return (*this);
			}

		return (_Reallocate_grow_by(_Count,
			[](_Elem * const _New_ptr, const _Elem * const _Old_ptr, const size_type _Old_size,
				const size_type _Off, const size_type _Count, const _Elem _Ch) {
			_Traits::copy(_New_ptr, _Old_ptr, _Off);
			_Traits::assign(_New_ptr + _Off, _Count, _Ch);
			_Traits::copy(_New_ptr + _Off + _Count, _Old_ptr + _Off, _Old_size - _Off + 1);
			}, _Off, _Count, _Ch));
		}

	iterator insert(const const_iterator _Where, const _Elem _Ch)
		{	// insert _Ch at _Where
		const difference_type _Off = _Where - begin();
		insert(static_cast<size_type>(_Off), 1, _Ch);
		return (begin() + _Off);
		}

	iterator insert(const const_iterator _Where, __declspec(guard(overflow)) const size_type _Count, const _Elem _Ch)
		{	// insert _Count * _Elem at _Where
		const difference_type _Off = _Where - begin();
		insert(static_cast<size_type>(_Off), _Count, _Ch);
		return (begin() + _Off);
		}

	template<class _Iter,
		class = enable_if_t<_Is_iterator_v<_Iter>>>
		iterator insert(const const_iterator _Where, const _Iter _First, const _Iter _Last)
		{	// insert [_First, _Last) at _Where, input iterators
		const difference_type _Off = _Where - begin();
		replace(_Where, _Where, _First, _Last);
		return (begin() + _Off);
		}

	basic_string& erase(const size_type _Off = 0)
		{	// erase elements [_Off, ...)
		auto& _My_data = this->_Get_data();
		_My_data._Check_offset(_Off);
		_Eos(_Off);
		return (*this);
		}

	basic_string& erase(const size_type _Off, size_type _Count)
		{	// erase elements [_Off, _Off + _Count)
		auto& _My_data = this->_Get_data();
		_My_data._Check_offset(_Off);
		_Count = _My_data._Clamp_suffix_size(_Off, _Count);
		const size_type _Old_size = _My_data._Mysize;
		_Elem * const _My_ptr = _My_data._Myptr();
		_Elem * const _Erase_at = _My_ptr + _Off;
		const size_type _New_size = _Old_size - _Count;
		_My_data._Mysize = _New_size;
		_Traits::move(_Erase_at, _Erase_at + _Count, _New_size - _Off + 1); // move suffix + null up
		return (*this);
		}

	iterator erase(const const_iterator _Where)
		{	// erase element at _Where
		const difference_type _Off = _Where - begin();
		erase(static_cast<size_type>(_Off), 1);
		return (begin() + _Off);
		}

	iterator erase(const const_iterator _First, const const_iterator _Last)
		{	// erase substring [_First, _Last)
		_Adl_verify_range(_First, _Last);
		const difference_type _Off = _First - begin();
		erase(static_cast<size_type>(_Off), static_cast<size_type>(_Last - _First));
		return (begin() + _Off);
		}

	void clear() noexcept
		{	// erase all
		_Eos(0);
		}

	basic_string& replace(const size_type _Off, const size_type _N0, const basic_string& _Right)
		{	// replace [_Off, _Off + _N0) with _Right
		auto& _Right_data = _Right._Get_data();
		return (replace(_Off, _N0, _Right_data._Myptr(), _Right_data._Mysize));
		}

	basic_string& replace(const size_type _Off, size_type _N0,
		const basic_string& _Right, const size_type _Roff, size_type _Count = npos)
		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
		auto& _Right_data = _Right._Get_data();
		_Right_data._Check_offset(_Roff);
		_Count = _Right_data._Clamp_suffix_size(_Roff, _Count);
		return (replace(_Off, _N0, _Right_data._Myptr() + _Roff, _Count));
		}




















	basic_string& replace(const size_type _Off, size_type _N0,
		  const _Elem * const _Ptr, const size_type _Count)
		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
		auto& _My_data = this->_Get_data();
		_My_data._Check_offset(_Off);
		_N0 = _My_data._Clamp_suffix_size(_Off, _N0);
		if (_N0 == _Count)
			{	// size doesn't change, so a single move does the trick
			_Traits::move(_My_data._Myptr() + _Off, _Ptr, _Count);
			return (*this);
			}

		const size_type _Old_size = _My_data._Mysize;
		const size_type _Suffix_size = _Old_size - _N0 - _Off + 1;
		if (_Count < _N0)
			{	// suffix shifts backwards; we don't have to move anything out of the way
			_My_data._Mysize = _Old_size - (_N0 - _Count);
			_Elem * const _Old_ptr = _My_data._Myptr();
			_Elem * const _Insert_at = _Old_ptr + _Off;
			_Traits::move(_Insert_at, _Ptr, _Count);
			_Traits::move(_Insert_at + _Count, _Insert_at + _N0, _Suffix_size);
			return (*this);
			}

		const size_type _Growth = static_cast<size_type>(_Count - _N0);
		if (_Growth <= _My_data._Myres - _Old_size)
			{	// growth fits
			_My_data._Mysize = _Old_size + _Growth;
			_Elem * const _Old_ptr = _My_data._Myptr();
			_Elem * const _Insert_at = _Old_ptr + _Off;
			_Elem * const _Suffix_at = _Insert_at + _N0;

			size_type _Ptr_shifted_after; // see rationale in insert
			if (_Ptr + _Count <= _Insert_at || _Ptr > _Old_ptr + _Old_size)
				{
				_Ptr_shifted_after = _Count;
				}
			else if (_Suffix_at <= _Ptr)
				{
				_Ptr_shifted_after = 0;
				}
			else
				{
				_Ptr_shifted_after = static_cast<size_type>(_Suffix_at - _Ptr);
				}

			_Traits::move(_Suffix_at + _Growth, _Suffix_at, _Suffix_size);
			// next case must be move, in case _Ptr begins before _Insert_at and contains part of the hole;
			// this case doesn't occur in insert because the new content must come from outside the removed
			// content there (because in insert there is no removed content)
			_Traits::move(_Insert_at, _Ptr, _Ptr_shifted_after);
			// the next case can be copy, because it comes from the chunk moved out of the way in the
			// first move, and the hole we're filling can't alias the chunk we moved out of the way
			_Traits::copy(_Insert_at + _Ptr_shifted_after, _Ptr + _Growth + _Ptr_shifted_after,
				_Count - _Ptr_shifted_after);
			return (*this);
			}

		return (_Reallocate_grow_by(_Growth,
			[](_Elem * const _New_ptr, const _Elem * const _Old_ptr, const size_type _Old_size,
				const size_type _Off, const size_type _N0, const _Elem * const _Ptr, const size_type _Count) {
			_Traits::copy(_New_ptr, _Old_ptr, _Off);
			_Traits::copy(_New_ptr + _Off, _Ptr, _Count);
			_Traits::copy(_New_ptr + _Off + _Count, _Old_ptr + _Off + _N0, _Old_size - _N0 - _Off + 1);
			}, _Off, _N0, _Ptr, _Count));
		}

	basic_string& replace(const size_type _Off, const size_type _N0,   const _Elem * const _Ptr)
		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
		return (replace(_Off, _N0, _Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));
		}

	basic_string& replace(const size_type _Off, size_type _N0, const size_type _Count, const _Elem _Ch)
		{	// replace [_Off, _Off + _N0) with _Count * _Ch
		auto& _My_data = this->_Get_data();
		_My_data._Check_offset(_Off);
		_N0 = _My_data._Clamp_suffix_size(_Off, _N0);
		if (_Count == _N0)
			{
			_Traits::assign(_My_data._Myptr() + _Off, _Count, _Ch);
			return (*this);
			}

		const size_type _Old_size = _My_data._Mysize;
		if (_Count < _N0 || _Count - _N0 <= _My_data._Myres - _Old_size)
			{	// either we are shrinking, or the growth fits
			_My_data._Mysize = _Old_size + _Count - _N0; // may temporarily overflow;
				// OK because size_type must be unsigned
			_Elem * const _Old_ptr = _My_data._Myptr();
			_Elem * const _Insert_at = _Old_ptr + _Off;
			_Traits::move(_Insert_at + _Count, _Insert_at + _N0, _Old_size - _N0 - _Off + 1);
			_Traits::assign(_Insert_at, _Count, _Ch);
			return (*this);
			}

		return (_Reallocate_grow_by(_Count - _N0,
			[](_Elem * const _New_ptr, const _Elem * const _Old_ptr, const size_type _Old_size,
				const size_type _Off, const size_type _N0, const size_type _Count, const _Elem _Ch) {
			_Traits::copy(_New_ptr, _Old_ptr, _Off);
			_Traits::assign(_New_ptr + _Off, _Count, _Ch);
			_Traits::copy(_New_ptr + _Off + _Count, _Old_ptr + _Off + _N0, _Old_size - _N0 - _Off + 1);
			}, _Off, _N0, _Count, _Ch));
		}

	basic_string& replace(const const_iterator _First, const const_iterator _Last, const basic_string& _Right)
		{	// replace [_First, _Last) with _Right
		return (replace(static_cast<size_type>(_First - begin()), static_cast<size_type>(_Last - _First), _Right));
		}










	basic_string& replace(const const_iterator _First, const const_iterator _Last,
		  const _Elem * const _Ptr, const size_type _Count)
		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
		return (replace(static_cast<size_type>(_First - begin()), static_cast<size_type>(_Last - _First), _Ptr, _Count));
		}

	basic_string& replace(const const_iterator _First, const const_iterator _Last,   const _Elem * const _Ptr)
		{	// replace [_First, _Last) with [_Ptr, <null>)
		return (replace(static_cast<size_type>(_First - begin()), static_cast<size_type>(_Last - _First), _Ptr));
		}

	basic_string& replace(const const_iterator _First, const const_iterator _Last,
		const size_type _Count, const _Elem _Ch)
		{	// replace [_First, _Last) with _Count * _Ch
		return (replace(static_cast<size_type>(_First - begin()), static_cast<size_type>(_Last - _First), _Count, _Ch));
		}

	template<class _Iter>
		basic_string& _Replace_range(const const_iterator _First, const const_iterator _Last,
		const _Iter _First2, const _Iter _Last2, false_type)
		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
		const basic_string _Right(_First2, _Last2, get_allocator());
		replace(_First, _Last, _Right);
		return (*this);
		}

	template<class _Ptr>
		basic_string& _Replace_range(const const_iterator _First, const const_iterator _Last,
		const _Ptr _First2, const _Ptr _Last2, true_type)
		{	// replace [_First, _Last) with [_First2, _Last2), pointers
		return (replace(static_cast<size_type>(_First - cbegin()), static_cast<size_type>(_Last - _First),
			_First2, static_cast<size_type>(_Last2 - _First2)));
		}

	template<class _Iter,
		class = enable_if_t<_Is_iterator_v<_Iter>>>
		basic_string& replace(const const_iterator _First, const const_iterator _Last,
			const _Iter _First2, const _Iter _Last2)
		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
		_Adl_verify_range(_First2, _Last2);
		const auto _UFirst2 = _Get_unwrapped(_First2);
		const auto _ULast2 = _Get_unwrapped(_Last2);
		return (_Replace_range(_First, _Last, _UFirst2, _ULast2, _Is_elem_cptr<decltype(_UFirst2)>()));
		}

	 iterator begin() noexcept
		{	// return iterator for beginning of mutable sequence
		auto _My_data = ::std:: addressof(this->_Get_data());
		return (iterator(_Refancy<pointer>(_My_data->_Myptr()), _My_data));
		}

	 const_iterator begin() const noexcept
		{	// return iterator for beginning of immutable sequence
		auto _My_data = ::std:: addressof(this->_Get_data());
		return (const_iterator(_Refancy<const_pointer>(_My_data->_Myptr()), _My_data));
		}

	 iterator end() noexcept
		{	// return iterator for end of mutable sequence
		auto _My_data = ::std:: addressof(this->_Get_data());
		return (iterator(_Refancy<pointer>(_My_data->_Myptr())
			+ static_cast<difference_type>(_My_data->_Mysize), _My_data));
		}

	 const_iterator end() const noexcept
		{	// return iterator for end of immutable sequence
		auto _My_data = ::std:: addressof(this->_Get_data());
		return (const_iterator(_Refancy<const_pointer>(_My_data->_Myptr())
			+ static_cast<difference_type>(_My_data->_Mysize), _My_data));
		}

	_Elem * _Unchecked_begin() noexcept
		{	// return pointer for beginning of mutable sequence
		return (this->_Get_data()._Myptr());
		}

	const _Elem * _Unchecked_begin() const noexcept
		{	// return pointer for beginning of immutable sequence
		return (this->_Get_data()._Myptr());
		}

	_Elem * _Unchecked_end() noexcept
		{	// return pointer for end of mutable sequence
		auto& _My_data = this->_Get_data();
		return (_My_data._Myptr() + _My_data._Mysize);
		}

	const _Elem * _Unchecked_end() const noexcept
		{	// return pointer for end of immutable sequence
		const auto& _My_data = this->_Get_data();
		return (_My_data._Myptr() + _My_data._Mysize);
		}

	 reverse_iterator rbegin() noexcept
		{	// return iterator for beginning of reversed mutable sequence
		return (reverse_iterator(end()));
		}

	 const_reverse_iterator rbegin() const noexcept
		{	// return iterator for beginning of reversed immutable sequence
		return (const_reverse_iterator(end()));
		}

	 reverse_iterator rend() noexcept
		{	// return iterator for end of reversed mutable sequence
		return (reverse_iterator(begin()));
		}

	 const_reverse_iterator rend() const noexcept
		{	// return iterator for end of reversed immutable sequence
		return (const_reverse_iterator(begin()));
		}

	 const_iterator cbegin() const noexcept
		{	// return iterator for beginning of immutable sequence
		return (begin());
		}

	 const_iterator cend() const noexcept
		{	// return iterator for end of immutable sequence
		return (end());
		}

	 const_reverse_iterator crbegin() const noexcept
		{	// return iterator for beginning of reversed immutable sequence
		return (rbegin());
		}

	 const_reverse_iterator crend() const noexcept
		{	// return iterator for end of reversed immutable sequence
		return (rend());
		}

	void shrink_to_fit()
		{	// reduce capacity
		auto& _My_data = this->_Get_data();
		if (!_My_data._Large_string_engaged())
			{	// can't shrink from small mode
			return;
			}

		if (_My_data._Mysize < this->_BUF_SIZE)
			{
			_Become_small();
			return;
			}

		const size_type _Target_capacity = _Min_value(_My_data._Mysize | this->_ALLOC_MASK, max_size());
		if (_Target_capacity < _My_data._Myres)
			{	// worth shrinking, do it
			auto& _Al = this->_Getal();
			const pointer _New_ptr = _Al.allocate(_Target_capacity + 1); // throws
			this->_Orphan_all();
			_Traits::copy(_Unfancy(_New_ptr), _Unfancy(_My_data._Bx._Ptr), _My_data._Mysize + 1);
			_Al.deallocate(_My_data._Bx._Ptr, _My_data._Myres + 1);
			_My_data._Bx._Ptr = _New_ptr;
			_My_data._Myres = _Target_capacity;
			}
		}

	 reference at(const size_type _Off)
		{	// subscript mutable sequence with checking
		auto& _My_data = this->_Get_data();
		_My_data._Check_offset_exclusive(_Off);
		return (_My_data._Myptr()[_Off]);
		}

	 const_reference at(const size_type _Off) const
		{	// subscript immutable sequence with checking
		auto& _My_data = this->_Get_data();
		_My_data._Check_offset_exclusive(_Off);
		return (_My_data._Myptr()[_Off]);
		}

	 reference operator[](const size_type _Off)
		{	// subscript mutable sequence
		auto& _My_data = this->_Get_data();

		do { if (_Off <= _My_data._Mysize) { } else { do { (void) ((1 != _CrtDbgReport(2, "c:\\visual studio\\vc\\tools\\msvc\\14.16.27023\\include\\xstring", 3204, 0, "%s", "string subscript out of range")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"string subscript out of range\"", __LPREFIX( __FUNCTION__), L"c:\\visual studio\\vc\\tools\\msvc\\14.16.27023\\include\\xstring", 3204, 0); } while (false); } ; } while (false);

		return (_My_data._Myptr()[_Off]);
		}

	 const_reference operator[](const size_type _Off) const
		{	// subscript immutable sequence
		auto& _My_data = this->_Get_data();

		do { if (_Off <= _My_data._Mysize) { } else { do { (void) ((1 != _CrtDbgReport(2, "c:\\visual studio\\vc\\tools\\msvc\\14.16.27023\\include\\xstring", 3213, 0, "%s", "string subscript out of range")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"string subscript out of range\"", __LPREFIX( __FUNCTION__), L"c:\\visual studio\\vc\\tools\\msvc\\14.16.27023\\include\\xstring", 3213, 0); } while (false); } ; } while (false);

		return (_My_data._Myptr()[_Off]);
		}









	void push_back(const _Elem _Ch)
		{	// insert element at end
		auto& _My_data = this->_Get_data();
		const size_type _Old_size = _My_data._Mysize;
		if (_Old_size < _My_data._Myres)
			{
			_My_data._Mysize = _Old_size + 1;
			_Elem * const _Ptr = _My_data._Myptr();
			_Traits::assign(_Ptr[_Old_size], _Ch);
			_Traits::assign(_Ptr[_Old_size + 1], _Elem());
			return;
			}

		_Reallocate_grow_by(1,
			[](_Elem * const _New_ptr, const _Elem * const _Old_ptr, const size_type _Old_size,
				const _Elem _Ch) {
			_Traits::copy(_New_ptr, _Old_ptr, _Old_size);
			_Traits::assign(_New_ptr[_Old_size], _Ch);
			_Traits::assign(_New_ptr[_Old_size + 1], _Elem());
			}, _Ch);
		}

	void pop_back()
		{	// erase element at end
		auto& _My_data = this->_Get_data();
		const size_type _Old_size = _My_data._Mysize;

		do { if (_Old_size != 0) { } else { do { (void) ((1 != _CrtDbgReport(2, "c:\\visual studio\\vc\\tools\\msvc\\14.16.27023\\include\\xstring", 3253, 0, "%s", "invalid to pop_back empty string")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"invalid to pop_back empty string\"", __LPREFIX( __FUNCTION__), L"c:\\visual studio\\vc\\tools\\msvc\\14.16.27023\\include\\xstring", 3253, 0); } while (false); } ; } while (false);

		_Eos(_Old_size - 1);
		}

	 reference front()
		{	// return first element of mutable sequence
		return (*begin());
		}

	 const_reference front() const
		{	// return first element of immutable sequence
		return (*begin());
		}

	 reference back()
		{	// return last element of mutable sequence
		return (*(end() - 1));
		}

	 const_reference back() const
		{	// return last element of immutable sequence
		return (*(end() - 1));
		}

	   const _Elem * c_str() const noexcept
		{	// return pointer to null-terminated immutable array
		return (this->_Get_data()._Myptr());
		}

	   const _Elem * data() const noexcept
		{	// return pointer to immutable array
		return (this->_Get_data()._Myptr());
		}








	 size_type length() const noexcept
		{	// return length of sequence
		return (this->_Get_data()._Mysize);
		}

	 size_type size() const noexcept
		{	// return length of sequence
		return (this->_Get_data()._Mysize);
		}

	 size_type max_size() const noexcept
		{	// return maximum possible length of sequence
		const size_type _Alloc_max = _Alty_traits::max_size(this->_Getal());
		const size_type _Storage_max = // can always store small string
			_Max_value(_Alloc_max, static_cast<size_type>(this->_BUF_SIZE));
		return (_Min_value(
			static_cast<size_type>((numeric_limits<difference_type>::max)()),
			_Storage_max - 1 // -1 is for null terminator and/or npos
			));

		}

	void resize(__declspec(guard(overflow)) const size_type _Newsize, const _Elem _Ch = _Elem())
		{	// determine new length, padding with _Ch elements as needed
		const size_type _Old_size = size();
		if (_Newsize <= _Old_size)
			{
			_Eos(_Newsize);
			}
		else
			{
			append(_Newsize - _Old_size, _Ch);
			}
		}

	 size_type capacity() const noexcept
		{	// return current length of allocated storage
		return (this->_Get_data()._Myres);
		}

	void reserve(__declspec(guard(overflow)) const size_type _Newcap = 0)
		{	// determine new minimum length of allocated storage
		auto& _My_data = this->_Get_data();
		if (_My_data._Mysize > _Newcap)
			{	// requested capacity is not large enough for current size, ignore
			return;	// nothing to do
			}

		if (_My_data._Myres == _Newcap)
			{	// we're already at the requested capacity
			return;	// nothing to do
			}

		if (_My_data._Myres < _Newcap)
			{	// reallocate to grow
			const size_type _Old_size = _My_data._Mysize;
			_Reallocate_grow_by(_Newcap - _Old_size,
				[](_Elem * const _New_ptr, const _Elem * const _Old_ptr, const size_type _Old_size) {
				_Traits::copy(_New_ptr, _Old_ptr, _Old_size + 1);
				});

			_My_data._Mysize = _Old_size;
			return;
			}

		if (this->_BUF_SIZE > _Newcap && _My_data._Large_string_engaged())
			{	// deallocate everything; switch back to "small" mode
			_Become_small();
			return;
			}

		// ignore requests to reserve to [_BUF_SIZE, _Myres)
		}

	 bool empty() const noexcept
		{	// test if sequence is empty
		return (size() == 0);
		}

	size_type copy(  _Elem * const _Ptr,
		size_type _Count, const size_type _Off = 0) const
		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
		auto& _My_data = this->_Get_data();
		_My_data._Check_offset(_Off);
		_Count = _My_data._Clamp_suffix_size(_Off, _Count);
		_Traits::copy(_Ptr, _My_data._Myptr() + _Off, _Count);
		return (_Count);
		}

	  size_type _Copy_s(
		  _Elem * const _Dest, const size_type _Dest_size,
		size_type _Count, const size_type _Off = 0) const
		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Dest_size)
		auto& _My_data = this->_Get_data();
		_My_data._Check_offset(_Off);
		_Count = _My_data._Clamp_suffix_size(_Off, _Count);
		_Traits::_Copy_s(_Dest, _Dest_size, _My_data._Myptr() + _Off, _Count);
		return (_Count);
		}

	void _Swap_data(basic_string& _Right, true_type)
		{	// exchange _Get_data() with _Right._Get_data(), memcpy optimization
		const auto _My_data_mem = reinterpret_cast<unsigned char *>(::std:: addressof(this->_Get_data()))
			+ _Memcpy_move_offset;
		const auto _Right_data_mem = reinterpret_cast<unsigned char *>(::std:: addressof(_Right._Get_data()))
			+ _Memcpy_move_offset;
		unsigned char _Temp_mem[_Memcpy_move_size];
		:: memcpy(_Temp_mem, _My_data_mem, _Memcpy_move_size);
		:: memcpy(_My_data_mem, _Right_data_mem, _Memcpy_move_size);
		:: memcpy(_Right_data_mem, _Temp_mem, _Memcpy_move_size);
		}

	void _Swap_bx_large_with_small(_Mydata_t& _Starts_large, _Mydata_t& _Starts_small)
		{	// exchange a string in large mode with one in small mode
		const pointer _Ptr = _Starts_large._Bx._Ptr;
		auto& _Al = this->_Getal();
		_Alty_traits::destroy(_Al, ::std:: addressof(_Starts_large._Bx._Ptr));
		_Traits::copy(_Starts_large._Bx._Buf, _Starts_small._Bx._Buf, this->_BUF_SIZE);
		_Alty_traits::construct(_Al, ::std:: addressof(_Starts_small._Bx._Ptr), _Ptr);
		}

	void _Swap_data(basic_string& _Right, false_type)
		{	// exchange _Get_data() with _Right._Get_data(), general case
		auto& _My_data = this->_Get_data();
		auto& _Right_data = _Right._Get_data();
		const bool _My_large = _My_data._Large_string_engaged();
		const bool _Right_large = _Right_data._Large_string_engaged();
		if (_My_large)
			{
			if (_Right_large)
				{	// swap buffers, iterators preserved
				_Swap_adl(_My_data._Bx._Ptr, _Right_data._Bx._Ptr);
				}
			else
				{	// swap large with small
				_Swap_bx_large_with_small(_My_data, _Right_data);
				}
			}
		else
			{
			if (_Right_large)
				{	// swap small with large
				_Swap_bx_large_with_small(_Right_data, _My_data);
				}
			else
				{
				_Elem _Temp_buf[this->_BUF_SIZE];
				_Traits::copy(_Temp_buf, _My_data._Bx._Buf, this->_BUF_SIZE);
				_Traits::copy(_My_data._Bx._Buf, _Right_data._Bx._Buf, this->_BUF_SIZE);
				_Traits::copy(_Right_data._Bx._Buf, _Temp_buf, this->_BUF_SIZE);
				}
			}

		::std:: swap(_My_data._Mysize, _Right_data._Mysize);
		::std:: swap(_My_data._Myres, _Right_data._Myres);
		}

	void swap(basic_string& _Right) noexcept // strengthened
		{	// exchange contents with _Right
		if (this != ::std:: addressof(_Right))
			{	// (maybe) swap allocators, swap control information
			_Pocs(this->_Getal(), _Right._Getal());


			auto& _My_data = this->_Get_data();
			auto& _Right_data = _Right._Get_data();
			const bool _My_large = _My_data._Large_string_engaged();
			const bool _Right_large = _Right_data._Large_string_engaged();
			if (!_My_large)
				{
				_My_data._Orphan_all();
				}

			if (!_Right_large)
				{
				_Right_data._Orphan_all();
				}

			if (_My_large || _Right_large)
				{
				_My_data._Swap_all(_Right_data);
				}

			}

		_Swap_data(_Right, _Use_memcpy_move{});
		}













	 size_type find(const basic_string& _Right, const size_type _Off = 0) const noexcept
		{	// look for _Right beginning at or after _Off
		auto& _My_data = this->_Get_data();
		auto& _Right_data = _Right._Get_data();
		return (static_cast<size_type>(
			_Traits_find<_Traits>(_My_data._Myptr(), _My_data._Mysize, _Off,
				_Right_data._Myptr(), _Right_data._Mysize)));
		}

	 size_type find(  const _Elem * const _Ptr, const size_type _Off, const size_type _Count)
		const noexcept // strengthened
		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
		auto& _My_data = this->_Get_data();
		return (static_cast<size_type>(
			_Traits_find<_Traits>(_My_data._Myptr(), _My_data._Mysize, _Off, _Ptr, _Count)));
		}

	 size_type find(  const _Elem * const _Ptr, const size_type _Off = 0) const noexcept // strengthened
		{	// look for [_Ptr, <null>) beginning at or after _Off
		auto& _My_data = this->_Get_data();
		return (static_cast<size_type>(
			_Traits_find<_Traits>(_My_data._Myptr(), _My_data._Mysize, _Off, _Ptr, _Traits::length(_Ptr))));
		}

	 size_type find(const _Elem _Ch, const size_type _Off = 0) const noexcept // strengthened
		{	// look for _Ch at or after _Off
		auto& _My_data = this->_Get_data();
		return (static_cast<size_type>(
			_Traits_find_ch<_Traits>(_My_data._Myptr(), _My_data._Mysize, _Off, _Ch)));
		}













	 size_type rfind(const basic_string& _Right, const size_type _Off = npos) const noexcept
		{	// look for _Right beginning before _Off
		auto& _My_data = this->_Get_data();
		auto& _Right_data = _Right._Get_data();
		return (static_cast<size_type>(
			_Traits_rfind<_Traits>(_My_data._Myptr(), _My_data._Mysize, _Off,
				_Right_data._Myptr(), _Right_data._Mysize)));
		}

	 size_type rfind(  const _Elem * const _Ptr, const size_type _Off,
		const size_type _Count) const noexcept // strengthened
		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
		auto& _My_data = this->_Get_data();
		return (static_cast<size_type>(
			_Traits_rfind<_Traits>(_My_data._Myptr(), _My_data._Mysize, _Off, _Ptr, _Count)));
		}

	 size_type rfind(  const _Elem * const _Ptr, const size_type _Off = npos)
		const noexcept // strengthened
		{	// look for [_Ptr, <null>) beginning before _Off
		auto& _My_data = this->_Get_data();
		return (static_cast<size_type>(
			_Traits_rfind<_Traits>(_My_data._Myptr(), _My_data._Mysize, _Off, _Ptr, _Traits::length(_Ptr))));
		}

	 size_type rfind(const _Elem _Ch, const size_type _Off = npos) const noexcept // strengthened
		{	// look for _Ch before _Off
		auto& _My_data = this->_Get_data();
		return (static_cast<size_type>(
			_Traits_rfind_ch<_Traits>(_My_data._Myptr(), _My_data._Mysize, _Off, _Ch)));
		}













	 size_type find_first_of(const basic_string& _Right, const size_type _Off = 0) const noexcept
		{	// look for one of _Right at or after _Off
		auto& _My_data = this->_Get_data();
		auto& _Right_data = _Right._Get_data();
		return (static_cast<size_type>(_Traits_find_first_of<_Traits>(_My_data._Myptr(), _My_data._Mysize, _Off,
			_Right_data._Myptr(), _Right_data._Mysize, _Is_specialization<_Traits, char_traits>{})));
		}

	 size_type find_first_of(  const _Elem * const _Ptr, const size_type _Off,
		const size_type _Count) const noexcept // strengthened
		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
		auto& _My_data = this->_Get_data();
		return (static_cast<size_type>(
			_Traits_find_first_of<_Traits>(_My_data._Myptr(), _My_data._Mysize, _Off, _Ptr, _Count,
				_Is_specialization<_Traits, char_traits>{})));
		}

	 size_type find_first_of(  const _Elem * const _Ptr, const size_type _Off = 0)
		const noexcept // strengthened
		{	// look for one of [_Ptr, <null>) at or after _Off
		auto& _My_data = this->_Get_data();
		return (static_cast<size_type>(
			_Traits_find_first_of<_Traits>(_My_data._Myptr(), _My_data._Mysize, _Off, _Ptr, _Traits::length(_Ptr),
				_Is_specialization<_Traits, char_traits>{})));
		}

	 size_type find_first_of(const _Elem _Ch, const size_type _Off = 0) const noexcept // strengthened
		{	// look for _Ch at or after _Off
		auto& _My_data = this->_Get_data();
		return (static_cast<size_type>(
			_Traits_find_ch<_Traits>(_My_data._Myptr(), _My_data._Mysize, _Off, _Ch)));
		}













	 size_type find_last_of(const basic_string& _Right, size_type _Off = npos) const noexcept
		{	// look for one of _Right before _Off
		auto& _My_data = this->_Get_data();
		auto& _Right_data = _Right._Get_data();
		return (static_cast<size_type>(_Traits_find_last_of<_Traits>(_My_data._Myptr(), _My_data._Mysize, _Off,
			_Right_data._Myptr(), _Right_data._Mysize, _Is_specialization<_Traits, char_traits>{})));
		}

	 size_type find_last_of(  const _Elem * const _Ptr, const size_type _Off,
		const size_type _Count) const noexcept // strengthened
		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
		auto& _My_data = this->_Get_data();
		return (static_cast<size_type>(
			_Traits_find_last_of<_Traits>(_My_data._Myptr(), _My_data._Mysize, _Off, _Ptr, _Count,
				_Is_specialization<_Traits, char_traits>{})));
		}

	 size_type find_last_of(  const _Elem * const _Ptr, const size_type _Off = npos)
		const noexcept // strengthened
		{	// look for one of [_Ptr, <null>) before _Off
		auto& _My_data = this->_Get_data();
		return (static_cast<size_type>(
			_Traits_find_last_of<_Traits>(_My_data._Myptr(), _My_data._Mysize, _Off, _Ptr, _Traits::length(_Ptr),
				_Is_specialization<_Traits, char_traits>{})));
		}

	 size_type find_last_of(const _Elem _Ch, const size_type _Off = npos) const noexcept // strengthened
		{	// look for _Ch before _Off
		auto& _My_data = this->_Get_data();
		return (static_cast<size_type>(_Traits_rfind_ch<_Traits>(_My_data._Myptr(), _My_data._Mysize, _Off, _Ch)));
		}













	 size_type find_first_not_of(const basic_string& _Right, const size_type _Off = 0) const noexcept
		{	// look for none of _Right at or after _Off
		auto& _My_data = this->_Get_data();
		auto& _Right_data = _Right._Get_data();
		return (static_cast<size_type>(_Traits_find_first_not_of<_Traits>(_My_data._Myptr(), _My_data._Mysize, _Off,
			_Right_data._Myptr(), _Right_data._Mysize, _Is_specialization<_Traits, char_traits>{})));
		}

	 size_type find_first_not_of(  const _Elem * const _Ptr, const size_type _Off,
		const size_type _Count) const noexcept // strengthened
		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
		auto& _My_data = this->_Get_data();
		return (static_cast<size_type>(
			_Traits_find_first_not_of<_Traits>(_My_data._Myptr(), _My_data._Mysize, _Off, _Ptr, _Count,
				_Is_specialization<_Traits, char_traits>{})));
		}

	 size_type find_first_not_of(  const _Elem * const _Ptr, size_type _Off = 0) const
		noexcept // strengthened
		{	// look for one of [_Ptr, <null>) at or after _Off
		auto& _My_data = this->_Get_data();
		return (static_cast<size_type>(
			_Traits_find_first_not_of<_Traits>(_My_data._Myptr(), _My_data._Mysize, _Off, _Ptr,
				_Traits::length(_Ptr), _Is_specialization<_Traits, char_traits>{})));
		}

	 size_type find_first_not_of(const _Elem _Ch, const size_type _Off = 0) const noexcept // strengthened
		{	// look for non _Ch at or after _Off
		auto& _My_data = this->_Get_data();
		return (static_cast<size_type>(_Traits_find_not_ch<_Traits>(_My_data._Myptr(), _My_data._Mysize, _Off, _Ch)));
		}













	 size_type find_last_not_of(const basic_string& _Right, const size_type _Off = npos) const noexcept
		{	// look for none of _Right before _Off
		auto& _My_data = this->_Get_data();
		auto& _Right_data = _Right._Get_data();
		return (static_cast<size_type>(_Traits_find_last_not_of<_Traits>(_My_data._Myptr(), _My_data._Mysize, _Off,
			_Right_data._Myptr(), _Right_data._Mysize, _Is_specialization<_Traits, char_traits>{})));
		}

	 size_type find_last_not_of(  const _Elem * const _Ptr, const size_type _Off,
		const size_type _Count) const noexcept // strengthened
		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
		auto& _My_data = this->_Get_data();
		return (static_cast<size_type>(
			_Traits_find_last_not_of<_Traits>(_My_data._Myptr(), _My_data._Mysize, _Off, _Ptr, _Count,
				_Is_specialization<_Traits, char_traits>{})));
		}

	 size_type find_last_not_of(  const _Elem * const _Ptr, const size_type _Off = npos) const
		noexcept // strengthened
		{	// look for none of [_Ptr, <null>) before _Off
		auto& _My_data = this->_Get_data();
		return (static_cast<size_type>(_Traits_find_last_not_of<_Traits>(_My_data._Myptr(), _My_data._Mysize, _Off,
			_Ptr, _Traits::length(_Ptr), _Is_specialization<_Traits, char_traits>{})));
		}

	 size_type find_last_not_of(const _Elem _Ch, const size_type _Off = npos) const noexcept // strengthened
		{	// look for non _Ch before _Off
		auto& _My_data = this->_Get_data();
		return (static_cast<size_type>(
			_Traits_rfind_not_ch<_Traits>(_My_data._Myptr(), _My_data._Mysize, _Off, _Ch)));
		}








	 basic_string substr(const size_type _Off = 0, const size_type _Count = npos) const
		{	// return [_Off, _Off + _Count) as new string
		return (basic_string(*this, _Off, _Count, get_allocator()));
		}

	bool _Equal(const basic_string& _Right) const noexcept
		{	// compare [0, size()) with _Right for equality
		auto& _My_data = this->_Get_data();
		auto& _Right_data = _Right._Get_data();
		return (_Traits_equal<_Traits>(_My_data._Myptr(), _My_data._Mysize, _Right_data._Myptr(), _Right_data._Mysize));
		}

	bool _Equal(  const _Elem * const _Ptr) const noexcept
		{	// compare [0, size()) with _Ptr for equality
		auto& _My_data = this->_Get_data();
		return (_Traits_equal<_Traits>(_My_data._Myptr(), _My_data._Mysize, _Ptr, _Traits::length(_Ptr)));
		}





































	 int compare(const basic_string& _Right) const noexcept
		{	// compare [0, size()) with _Right
		auto& _My_data = this->_Get_data();
		auto& _Right_data = _Right._Get_data();
		return (_Traits_compare<_Traits>(_My_data._Myptr(), _My_data._Mysize,
			_Right_data._Myptr(), _Right_data._Mysize));
		}

	 int compare(size_type _Off, size_type _N0, const basic_string& _Right) const
		{	// compare [_Off, _Off + _N0) with _Right
		auto& _My_data = this->_Get_data();
		_My_data._Check_offset(_Off);
		auto& _Right_data = _Right._Get_data();
		return (_Traits_compare<_Traits>(_My_data._Myptr() + _Off, _My_data._Clamp_suffix_size(_Off, _N0),
			_Right_data._Myptr(), _Right_data._Mysize));
		}

	 int compare(const size_type _Off, const size_type _N0, const basic_string& _Right,
		const size_type _Roff, const size_type _Count = npos) const
		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
		auto& _My_data = this->_Get_data();
		auto& _Right_data = _Right._Get_data();
		_My_data._Check_offset(_Off);
		_Right_data._Check_offset(_Roff);
		return (_Traits_compare<_Traits>(_My_data._Myptr() + _Off, _My_data._Clamp_suffix_size(_Off, _N0),
			_Right_data._Myptr() + _Roff, _Right_data._Clamp_suffix_size(_Roff, _Count)));
		}

	 int compare(  const _Elem * const _Ptr) const noexcept // strengthened
		{	// compare [0, size()) with [_Ptr, <null>)
		auto& _My_data = this->_Get_data();
		return (_Traits_compare<_Traits>(_My_data._Myptr(), _My_data._Mysize,
			_Ptr, _Traits::length(_Ptr)));
		}

	 int compare(const size_type _Off, const size_type _N0,   const _Elem * const _Ptr) const
		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
		auto& _My_data = this->_Get_data();
		_My_data._Check_offset(_Off);
		return (_Traits_compare<_Traits>(_My_data._Myptr() + _Off, _My_data._Clamp_suffix_size(_Off, _N0),
			_Ptr, _Traits::length(_Ptr)));
		}

	 int compare(const size_type _Off, const size_type _N0,   const _Elem * const _Ptr,
		const size_type _Count) const
		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
		auto& _My_data = this->_Get_data();
		_My_data._Check_offset(_Off);
		return (_Traits_compare<_Traits>(_My_data._Myptr() + _Off, _My_data._Clamp_suffix_size(_Off, _N0),
			_Ptr, _Count));
		}

	 allocator_type get_allocator() const noexcept
		{	// return allocator object for values
		return (static_cast<allocator_type>(this->_Getal()));
		}

	size_type _Calculate_growth(const size_type _Requested) const
		{	// determines the next array size to allocate
		const size_type _Max = max_size();
		auto& _My_data = this->_Get_data();
		const size_type _Masked = _Requested | this->_ALLOC_MASK;
		if (_Masked > _Max)
			{	// the mask overflows, settle for max_size()
			return (_Max);
			}

		const size_type _Old = _My_data._Myres;
		if (_Old > _Max - _Old / 2)
			{	// similarly, geometric overflows
			return (_Max);
			}

		return (_Max_value(_Masked, _Old + _Old / 2));
		}

	template<class _Fty,
		class... _ArgTys>
		basic_string& _Reallocate_for(const size_type _New_size, _Fty _Fn, _ArgTys... _Args)
		{	// reallocate to store exactly _New_size elements, new buffer prepared by
			// _Fn(_New_ptr, _New_size, _Args...)
		if (_New_size > max_size())
			{
			_Xlen();	// result too long
			}

		auto& _My_data = this->_Get_data();
		const size_type _Old_capacity = _My_data._Myres;
		const size_type _New_capacity = _Calculate_growth(_New_size);
		auto& _Al = this->_Getal();
		const pointer _New_ptr = _Al.allocate(_New_capacity + 1); // throws
		_My_data._Orphan_all();
		_My_data._Mysize = _New_size;
		_My_data._Myres = _New_capacity;
		_Fn(_Unfancy(_New_ptr), _New_size, _Args...);
		if (this->_BUF_SIZE <= _Old_capacity)
			{
			_Al.deallocate(_My_data._Bx._Ptr, _Old_capacity + 1);
			_My_data._Bx._Ptr = _New_ptr;
			}
		else
			{
			_Alty_traits::construct(_Al, ::std:: addressof(_My_data._Bx._Ptr), _New_ptr);
			}

		return (*this);
		}

	template<class _Fty,
		class... _ArgTys>
		basic_string& _Reallocate_grow_by(const size_type _Size_increase, _Fty _Fn, _ArgTys... _Args)
		{	// reallocate to increase size by _Size_increase elements, new buffer prepared by
			// _Fn(_New_ptr, _Old_ptr, _Old_size, _Args...)
		auto& _My_data = this->_Get_data();
		const size_type _Old_size = _My_data._Mysize;
		if (max_size() - _Old_size < _Size_increase)
			{
			_Xlen();	// result too long
			}

		const size_type _New_size = _Old_size + _Size_increase;
		const size_type _Old_capacity = _My_data._Myres;
		const size_type _New_capacity = _Calculate_growth(_New_size);
		auto& _Al = this->_Getal();
		const pointer _New_ptr = _Al.allocate(_New_capacity + 1); // throws
		_My_data._Orphan_all();
		_My_data._Mysize = _New_size;
		_My_data._Myres = _New_capacity;
		_Elem * const _Raw_new = _Unfancy(_New_ptr);
		if (this->_BUF_SIZE <= _Old_capacity)
			{
			const pointer _Old_ptr = _My_data._Bx._Ptr;
			_Fn(_Raw_new, _Unfancy(_Old_ptr), _Old_size, _Args...);
			_Al.deallocate(_Old_ptr, _Old_capacity + 1);
			_My_data._Bx._Ptr = _New_ptr;
			}
		else
			{
			_Fn(_Raw_new, _My_data._Bx._Buf, _Old_size, _Args...);
			_Alty_traits::construct(_Al, ::std:: addressof(_My_data._Bx._Ptr), _New_ptr);
			}

		return (*this);
		}

	void _Become_small()
		{	// release any held storage and return to small string mode
			// pre: *this is in large string mode
			// pre: this is small enough to return to small string mode
		auto& _My_data = this->_Get_data();
		_My_data._Orphan_all();
		const pointer _Ptr = _My_data._Bx._Ptr;
		auto& _Al = this->_Getal();
		_Alty_traits::destroy(_Al, ::std:: addressof(_My_data._Bx._Ptr));
		_Traits::copy(_My_data._Bx._Buf, _Unfancy(_Ptr), _My_data._Mysize + 1);
		_Al.deallocate(_Ptr, _My_data._Myres + 1);
		_My_data._Myres = this->_BUF_SIZE - 1;
		}

	void _Eos(const size_type _Newsize)
		{	// set new length and null terminator
		auto& _My_data = this->_Get_data();
		_Traits::assign(_My_data._Myptr()[_My_data._Mysize = _Newsize], _Elem());
		}

	void _Tidy_init()
		{	// initialize basic_string data members
		auto& _My_data = this->_Get_data();
		_My_data._Mysize = 0;
		_My_data._Myres = this->_BUF_SIZE - 1;
		// the _Traits::assign is last so the codegen doesn't think the char
		// write can alias this
		_Traits::assign(_My_data._Bx._Buf[0], _Elem());
		}

	void _Tidy_deallocate()
		{	// initialize buffer, deallocating any storage
		this->_Orphan_all();
		auto& _My_data = this->_Get_data();
		if (_My_data._Large_string_engaged())
			{
			const pointer _Ptr = _My_data._Bx._Ptr;
			auto& _Al = this->_Getal();
			_Alty_traits::destroy(_Al, ::std:: addressof(_My_data._Bx._Ptr));
			_Al.deallocate(_Ptr, _My_data._Myres + 1);
			}

		_My_data._Mysize = 0;
		_My_data._Myres = this->_BUF_SIZE - 1;
		// the _Traits::assign is last so the codegen doesn't think the char
		// write can alias this
		_Traits::assign(_My_data._Bx._Buf[0], _Elem());
		}

	[[noreturn]] static void _Xlen()
		{	// report a length_error
		_Xlength_error("string too long");
		}
	};



























template<class _Elem,
	class _Traits,
	class _Alloc> inline
	void swap(basic_string<_Elem, _Traits, _Alloc>& _Left,
		basic_string<_Elem, _Traits, _Alloc>& _Right) noexcept // strengthened
	{	// swap _Left and _Right strings
	_Left.swap(_Right);
	}

template<class _Elem,
	class _Traits,
	class _Alloc>
	 inline basic_string<_Elem, _Traits, _Alloc> operator+(
		const basic_string<_Elem, _Traits, _Alloc>& _Left,
		const basic_string<_Elem, _Traits, _Alloc>& _Right)
	{	// return string + string
	basic_string<_Elem, _Traits, _Alloc> _Ans;
	_Ans.reserve(_Left.size() + _Right.size());
	_Ans += _Left;
	_Ans += _Right;
	return (_Ans);
	}

template<class _Elem,
	class _Traits,
	class _Alloc>
	 inline basic_string<_Elem, _Traits, _Alloc> operator+(
		  const _Elem * const _Left,
		const basic_string<_Elem, _Traits, _Alloc>& _Right)
	{	// return NTCTS + string
	using _String_type = basic_string<_Elem, _Traits, _Alloc>;
	using _Size_type = typename _String_type::size_type;
	_String_type _Ans;
	_Ans.reserve(_Convert_size<_Size_type>(_Traits::length(_Left) + _Right.size()));
	_Ans += _Left;
	_Ans += _Right;
	return (_Ans);
	}

template<class _Elem,
	class _Traits,
	class _Alloc>
	 inline basic_string<_Elem, _Traits, _Alloc> operator+(
		const _Elem _Left,
		const basic_string<_Elem, _Traits, _Alloc>& _Right)
	{	// return character + string
	basic_string<_Elem, _Traits, _Alloc> _Ans;
	_Ans.reserve(1 + _Right.size());
	_Ans += _Left;
	_Ans += _Right;
	return (_Ans);
	}

template<class _Elem,
	class _Traits,
	class _Alloc>
	 inline basic_string<_Elem, _Traits, _Alloc> operator+(
		const basic_string<_Elem, _Traits, _Alloc>& _Left,
		  const _Elem * const _Right)
	{	// return string + NTCTS
	using _String_type = basic_string<_Elem, _Traits, _Alloc>;
	using _Size_type = typename _String_type::size_type;
	_String_type _Ans;
	_Ans.reserve(_Convert_size<_Size_type>(_Left.size() + _Traits::length(_Right)));
	_Ans += _Left;
	_Ans += _Right;
	return (_Ans);
	}

template<class _Elem,
	class _Traits,
	class _Alloc>
	 inline basic_string<_Elem, _Traits, _Alloc> operator+(
		const basic_string<_Elem, _Traits, _Alloc>& _Left,
		const _Elem _Right)
	{	// return string + character
	basic_string<_Elem, _Traits, _Alloc> _Ans;
	_Ans.reserve(_Left.size() + 1);
	_Ans += _Left;
	_Ans += _Right;
	return (_Ans);
	}

template<class _Elem,
	class _Traits,
	class _Alloc>
	 inline basic_string<_Elem, _Traits, _Alloc> operator+(
		const basic_string<_Elem, _Traits, _Alloc>& _Left,
		basic_string<_Elem, _Traits, _Alloc>&& _Right)
	{	// return string + string
	return (::std:: move(_Right.insert(0, _Left)));
	}

template<class _Elem,
	class _Traits,
	class _Alloc>
	 inline basic_string<_Elem, _Traits, _Alloc> operator+(
		basic_string<_Elem, _Traits, _Alloc>&& _Left,
		const basic_string<_Elem, _Traits, _Alloc>& _Right)
	{	// return string + string
	return (::std:: move(_Left.append(_Right)));
	}

template<class _Elem,
	class _Traits,
	class _Alloc>
	 inline basic_string<_Elem, _Traits, _Alloc> operator+(
		basic_string<_Elem, _Traits, _Alloc>&& _Left,
		basic_string<_Elem, _Traits, _Alloc>&& _Right)
	{	// return string + string
	if (_Right.size() <= _Left.capacity() - _Left.size()
		|| _Right.capacity() - _Right.size() < _Left.size())
		return (::std:: move(_Left.append(_Right)));
	else
		return (::std:: move(_Right.insert(0, _Left)));
	}

template<class _Elem,
	class _Traits,
	class _Alloc>
	 inline basic_string<_Elem, _Traits, _Alloc> operator+(
		  const _Elem * const _Left,
		basic_string<_Elem, _Traits, _Alloc>&& _Right)
	{	// return NTCTS + string
	return (::std:: move(_Right.insert(0, _Left)));
	}

template<class _Elem,
	class _Traits,
	class _Alloc>
	 inline basic_string<_Elem, _Traits, _Alloc> operator+(
		const _Elem _Left,
		basic_string<_Elem, _Traits, _Alloc>&& _Right)
	{	// return character + string
	using size_type = typename allocator_traits<_Alloc>::size_type;
	return (::std:: move(_Right.insert(static_cast<size_type>(0), static_cast<size_type>(1), _Left)));
	}

template<class _Elem,
	class _Traits,
	class _Alloc>
	 inline basic_string<_Elem, _Traits, _Alloc> operator+(
		basic_string<_Elem, _Traits, _Alloc>&& _Left,
		  const _Elem * const _Right)
	{	// return string + NTCTS
	return (::std:: move(_Left.append(_Right)));
	}

template<class _Elem,
	class _Traits,
	class _Alloc>
	 inline basic_string<_Elem, _Traits, _Alloc> operator+(
		basic_string<_Elem, _Traits, _Alloc>&& _Left,
		const _Elem _Right)
	{	// return string + character
	_Left.push_back(_Right);
	return (::std:: move(_Left));
	}

template<class _Elem,
	class _Traits,
	class _Alloc>
	 inline bool operator==(
		const basic_string<_Elem, _Traits, _Alloc>& _Left,
		const basic_string<_Elem, _Traits, _Alloc>& _Right) noexcept
	{	// test for string equality
	return (_Left._Equal(_Right));
	}

template<class _Elem,
	class _Traits,
	class _Alloc>
	 inline bool operator==(
		  const _Elem * const _Left,
		const basic_string<_Elem, _Traits, _Alloc>& _Right)
	{	// test for NTCTS vs. string equality
	return (_Right._Equal(_Left));
	}

template<class _Elem,
	class _Traits,
	class _Alloc>
	 inline bool operator==(
		const basic_string<_Elem, _Traits, _Alloc>& _Left,
		  const _Elem * const _Right)
	{	// test for string vs. NTCTS equality
	return (_Left._Equal(_Right));
	}

template<class _Elem,
	class _Traits,
	class _Alloc>
	 inline bool operator!=(
		const basic_string<_Elem, _Traits, _Alloc>& _Left,
		const basic_string<_Elem, _Traits, _Alloc>& _Right) noexcept
	{	// test for string inequality
	return (!(_Left == _Right));
	}

template<class _Elem,
	class _Traits,
	class _Alloc>
	 inline bool operator!=(
		  const _Elem * const _Left,
		const basic_string<_Elem, _Traits, _Alloc>& _Right)
	{	// test for NTCTS vs. string inequality
	return (!(_Left == _Right));
	}

template<class _Elem,
	class _Traits,
	class _Alloc>
	 inline bool operator!=(
		const basic_string<_Elem, _Traits, _Alloc>& _Left,
		  const _Elem * const _Right)
	{	// test for string vs. NTCTS inequality
	return (!(_Left == _Right));
	}

template<class _Elem,
	class _Traits,
	class _Alloc>
	 inline bool operator<(
		const basic_string<_Elem, _Traits, _Alloc>& _Left,
		const basic_string<_Elem, _Traits, _Alloc>& _Right) noexcept
	{	// test if string < string
	return (_Left.compare(_Right) < 0);
	}

template<class _Elem,
	class _Traits,
	class _Alloc>
	 inline bool operator<(
		  const _Elem * const _Left,
		const basic_string<_Elem, _Traits, _Alloc>& _Right)
	{	// test if NTCTS < string
	return (_Right.compare(_Left) > 0);
	}

template<class _Elem,
	class _Traits,
	class _Alloc>
	 inline bool operator<(
		const basic_string<_Elem, _Traits, _Alloc>& _Left,
		  const _Elem * const _Right)
	{	// test if string < NTCTS
	return (_Left.compare(_Right) < 0);
	}

template<class _Elem,
	class _Traits,
	class _Alloc>
	 inline bool operator>(
		const basic_string<_Elem, _Traits, _Alloc>& _Left,
		const basic_string<_Elem, _Traits, _Alloc>& _Right) noexcept
	{	// test if string > string
	return (_Right < _Left);
	}

template<class _Elem,
	class _Traits,
	class _Alloc>
	 inline bool operator>(
		  const _Elem * const _Left,
		const basic_string<_Elem, _Traits, _Alloc>& _Right)
	{	// test if NTCTS > string
	return (_Right < _Left);
	}

template<class _Elem,
	class _Traits,
	class _Alloc>
	 inline bool operator>(
		const basic_string<_Elem, _Traits, _Alloc>& _Left,
		  const _Elem * const _Right)
	{	// test if string > NTCTS
	return (_Right < _Left);
	}

template<class _Elem,
	class _Traits,
	class _Alloc>
	 inline bool operator<=(
		const basic_string<_Elem, _Traits, _Alloc>& _Left,
		const basic_string<_Elem, _Traits, _Alloc>& _Right) noexcept
	{	// test if string <= string
	return (!(_Right < _Left));
	}

template<class _Elem,
	class _Traits,
	class _Alloc>
	 inline bool operator<=(
		  const _Elem * const _Left,
		const basic_string<_Elem, _Traits, _Alloc>& _Right)
	{	// test if NTCTS <= string
	return (!(_Right < _Left));
	}

template<class _Elem,
	class _Traits,
	class _Alloc>
	 inline bool operator<=(
		const basic_string<_Elem, _Traits, _Alloc>& _Left,
		  const _Elem * const _Right)
	{	// test if string <= NTCTS
	return (!(_Right < _Left));
	}

template<class _Elem,
	class _Traits,
	class _Alloc>
	 inline bool operator>=(
		const basic_string<_Elem, _Traits, _Alloc>& _Left,
		const basic_string<_Elem, _Traits, _Alloc>& _Right) noexcept
	{	// test if string >= string
	return (!(_Left < _Right));
	}

template<class _Elem,
	class _Traits,
	class _Alloc>
	 inline bool operator>=(
		  const _Elem * const _Left,
		const basic_string<_Elem, _Traits, _Alloc>& _Right)
	{	// test if NTCTS >= string
	return (!(_Left < _Right));
	}

template<class _Elem,
	class _Traits,
	class _Alloc>
	 inline bool operator>=(
		const basic_string<_Elem, _Traits, _Alloc>& _Left,
		  const _Elem * const _Right)
	{	// test if string >= NTCTS
	return (!(_Left < _Right));
	}

using string = basic_string<char, char_traits<char>, allocator<char>>;
using wstring = basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t>>;
using u16string = basic_string<char16_t, char_traits<char16_t>, allocator<char16_t>>;
using u32string = basic_string<char32_t, char_traits<char32_t>, allocator<char32_t>>;

	// STRUCT TEMPLATE SPECIALIZATION hash
template<class _Elem,
	class _Traits,
	class _Alloc>
	struct hash<basic_string<_Elem, _Traits, _Alloc>>
	{	// hash functor for basic_string
	 typedef basic_string<_Elem, _Traits, _Alloc> argument_type;
	 typedef size_t result_type;

	 size_t operator()(const basic_string<_Elem, _Traits, _Alloc>& _Keyval) const noexcept
		{	// hash _Keyval to size_t value by pseudorandomizing transform
		return (_Hash_array_representation(_Keyval.c_str(), _Keyval.size()));
		}
	};
}



#pragma warning(pop)
#pragma pack(pop)



/*
 * Copyright (c) by P.J. Plauger. All rights reserved.
 * Consult your license regarding permissions and restrictions.
V6.50:0009 */


 #pragma pack(push,8)
 #pragma warning(push,3)
 #pragma warning(disable: 4455 4494  4619 4643 4702 4984 4988 )
 
 
 
namespace std {
		// CLASS logic_error
class logic_error
	: public exception
	{	// base of all logic-error exceptions
public:
	typedef exception _Mybase;

	explicit logic_error(const string& _Message)
		: _Mybase(_Message.c_str())
		{	// construct from message string
		}

	explicit logic_error(const char *_Message)
		: _Mybase(_Message)
		{	// construct from message string
		}

 

 






	};

		// CLASS domain_error
class domain_error
	: public logic_error
	{	// base of all domain-error exceptions
public:
	typedef logic_error _Mybase;

	explicit domain_error(const string& _Message)
		: _Mybase(_Message.c_str())
		{	// construct from message string
		}

	explicit domain_error(const char *_Message)
		: _Mybase(_Message)
		{	// construct from message string
		}

 

 






	};

		// CLASS invalid_argument
class invalid_argument
	: public logic_error
	{	// base of all invalid-argument exceptions
public:
	typedef logic_error _Mybase;

	explicit invalid_argument(const string& _Message)
		: _Mybase(_Message.c_str())
		{	// construct from message string
		}

	explicit invalid_argument(const char *_Message)
		: _Mybase(_Message)
		{	// construct from message string
		}

 

 






	};

		// CLASS length_error
class length_error
	: public logic_error
	{	// base of all length-error exceptions
public:
	typedef logic_error _Mybase;

	explicit length_error(const string& _Message)
		: _Mybase(_Message.c_str())
		{	// construct from message string
		}

	explicit length_error(const char *_Message)
		: _Mybase(_Message)
		{	// construct from message string
		}

 

 






	};

		// CLASS out_of_range
class out_of_range
	: public logic_error
	{	// base of all out-of-range exceptions
public:
	typedef logic_error _Mybase;

	explicit out_of_range(const string& _Message)
		: _Mybase(_Message.c_str())
		{	// construct from message string
		}

	explicit out_of_range(const char *_Message)
		: _Mybase(_Message)
		{	// construct from message string
		}

 

 






	};

		// CLASS runtime_error
class runtime_error
	: public exception
	{	// base of all runtime-error exceptions
public:
	typedef exception _Mybase;

	explicit runtime_error(const string& _Message)
		: _Mybase(_Message.c_str())
		{	// construct from message string
		}

	explicit runtime_error(const char *_Message)
		: _Mybase(_Message)
		{	// construct from message string
		}

 

 






	};

		// CLASS overflow_error
class overflow_error
	: public runtime_error
	{	// base of all overflow-error exceptions
public:
	typedef runtime_error _Mybase;

	explicit overflow_error(const string& _Message)
		: _Mybase(_Message.c_str())
		{	// construct from message string
		}

	explicit overflow_error(const char *_Message)
		: _Mybase(_Message)
		{	// construct from message string
		}

 

 






	};

		// CLASS underflow_error
class underflow_error
	: public runtime_error
	{	// base of all underflow-error exceptions
public:
	typedef runtime_error _Mybase;

	explicit underflow_error(const string& _Message)
		: _Mybase(_Message.c_str())
		{	// construct from message string
		}

	explicit underflow_error(const char *_Message)
		: _Mybase(_Message)
		{	// construct from message string
		}

 

 






	};

		// CLASS range_error
class range_error
	: public runtime_error
	{	// base of all range-error exceptions
public:
	typedef runtime_error _Mybase;

	explicit range_error(const string& _Message)
		: _Mybase(_Message.c_str())
		{	// construct from message string
		}

	explicit range_error(const char *_Message)
		: _Mybase(_Message)
		{	// construct from message string
		}

 

 






	};
}
 
 
 #pragma warning(pop)
 #pragma pack(pop)



/*
 * Copyright (c) by P.J. Plauger. All rights reserved.
 * Consult your license regarding permissions and restrictions.
V6.50:0009 */


// typeinfo standard header

/***
*typeinfo - Defines the type_info structure and exceptions used for RTTI
*
*	Copyright (c) Microsoft Corporation. All rights reserved.
*	Modified January 1996 by P.J. Plauger
*
*Purpose:
*       Defines the type_info structure and exceptions used for
*       Runtime Type Identification.
*
*       [Public]
*
****/

#pragma once






#pragma pack(push,8)
#pragma warning(push,3)
#pragma warning(disable: 4455 4494  4619 4643 4702 4984 4988 )




#pragma warning(disable: 4275)	


//
// vcruntime_typeinfo.h
//
//      Copyright (c) Microsoft Corporation. All rights reserved.
//
// <typeinfo> functionality that is implemented in the VCRuntime.
//
#pragma once




#pragma pack(push, 8)







    struct __type_info_node;





    extern __type_info_node __type_info_root_node;




__pragma(pack(push, 8)) extern "C" {

struct __std_type_info_data
{
    const char * _UndecoratedName;
    const char   _DecoratedName[1];
    __std_type_info_data() = delete;
    __std_type_info_data(const __std_type_info_data&) = delete;
    __std_type_info_data(__std_type_info_data&&) = delete;

    __std_type_info_data& operator=(const __std_type_info_data&) = delete;
    __std_type_info_data& operator=(__std_type_info_data&&) = delete;
};

 int __cdecl __std_type_info_compare(
      const __std_type_info_data* _Lhs,
      const __std_type_info_data* _Rhs
    );

 size_t __cdecl __std_type_info_hash(
      const __std_type_info_data* _Data
    );

 const char* __cdecl __std_type_info_name(
      __std_type_info_data* _Data,
      __type_info_node*     _RootNode
    );

} __pragma(pack(pop))


#pragma warning(push)
#pragma warning(disable: 4577) 
class type_info
{
public:

    type_info(const type_info&) = delete;
    type_info& operator=(const type_info&) = delete;

    size_t hash_code() const noexcept
    {
        return __std_type_info_hash(&_Data);
    }

    bool operator==(const type_info& _Other) const noexcept
    {
        return __std_type_info_compare(&_Data, &_Other._Data) == 0;
    }

    bool operator!=(const type_info& _Other) const noexcept
    {
        return __std_type_info_compare(&_Data, &_Other._Data) != 0;
    }

    bool before(const type_info& _Other) const noexcept
    {
        return __std_type_info_compare(&_Data, &_Other._Data) < 0;
    }

    const char* name() const noexcept
    {
        


        return __std_type_info_name(&_Data, &__type_info_root_node);
        
    }

    const char* raw_name() const noexcept
    {
        return _Data._DecoratedName;
    }

    virtual ~type_info() noexcept;

private:

    mutable __std_type_info_data _Data;
};
#pragma warning(pop)

namespace std {
	using ::type_info;
}



namespace std {

#pragma warning(push)
#pragma warning(disable: 4577) 
class bad_cast
    : public exception
{
public:

    bad_cast() noexcept
        : exception("bad cast", 1)
    {
    }

    static bad_cast __construct_from_string_literal(const char* const _Message) noexcept
    {
        return bad_cast(_Message, 1);
    }

private:

    bad_cast(const char* const _Message, int) noexcept
        : exception(_Message, 1)
    {
    }
};

class bad_typeid
    : public exception
{
public:

    bad_typeid() noexcept
        : exception("bad typeid", 1)
    {
    }

    static bad_typeid __construct_from_string_literal(const char* const _Message) noexcept
    {
        return bad_typeid(_Message, 1);
    }

private:

    friend class __non_rtti_object;

    bad_typeid(const char* const _Message, int) noexcept
        : exception(_Message, 1)
    {
    }
};

class __non_rtti_object
    : public bad_typeid
{
public:

    static __non_rtti_object __construct_from_string_literal(const char* const _Message) noexcept
    {
        return __non_rtti_object(_Message, 1);
    }

private:

    __non_rtti_object(const char* const _Message, int) noexcept
        : bad_typeid(_Message, 1)
    {
    }
};

#pragma warning(pop)
} // namespace std



#pragma pack(pop)


 namespace std {

// size in pointers of std::function and std::any (roughly 3 pointers larger than std::string when building debug)
constexpr int _Small_object_num_ptrs = 6 + 16 / sizeof (void *);

 






















































 }



#pragma pack(pop)
#pragma warning(pop)



/*
 * Copyright (c) Microsoft Corporation.  ALL RIGHTS RESERVED.
 * Modified January 1996 by P.J. Plauger
 * Modified November 1998 by P.J. Plauger
 * Consult your license regarding permissions and restrictions.
V6.50:0009 */


// xlocinfo internal header for Microsoft
#pragma once




/* xlocinfo.h internal header for Microsoft */
#pragma once




//
// ctype.h
//
//      Copyright (c) Microsoft Corporation. All rights reserved.
//
// This file declares the narrow character (char) classification functionality.
//
#pragma once






__pragma(pack(push, 8)) extern "C" {




//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// Character Classification Function Declarations
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  __declspec(dllimport) int __cdecl _isctype(  int _C,   int _Type);
  __declspec(dllimport) int __cdecl _isctype_l(  int _C,   int _Type,   _locale_t _Locale);
   __declspec(dllimport) int __cdecl isalpha(  int _C);
  __declspec(dllimport) int __cdecl _isalpha_l(  int _C,   _locale_t _Locale);
   __declspec(dllimport) int __cdecl isupper(  int _C);
  __declspec(dllimport) int __cdecl _isupper_l(  int _C,   _locale_t _Locale);
   __declspec(dllimport) int __cdecl islower(  int _C);
  __declspec(dllimport) int __cdecl _islower_l(  int _C,   _locale_t _Locale);


   __declspec(dllimport) int __cdecl isdigit(  int _C);

  __declspec(dllimport) int __cdecl _isdigit_l(  int _C,   _locale_t _Locale);
  __declspec(dllimport) int __cdecl isxdigit(  int _C);
  __declspec(dllimport) int __cdecl _isxdigit_l(  int _C,   _locale_t _Locale);


   __declspec(dllimport) int __cdecl isspace(  int _C);

  __declspec(dllimport) int __cdecl _isspace_l(  int _C,   _locale_t _Locale);
  __declspec(dllimport) int __cdecl ispunct(  int _C);
  __declspec(dllimport) int __cdecl _ispunct_l(  int _C,   _locale_t _Locale);
  __declspec(dllimport) int __cdecl isblank(  int _C);
  __declspec(dllimport) int __cdecl _isblank_l(  int _C,   _locale_t _Locale);
   __declspec(dllimport) int __cdecl isalnum(  int _C);
  __declspec(dllimport) int __cdecl _isalnum_l(  int _C,   _locale_t _Locale);
  __declspec(dllimport) int __cdecl isprint(  int _C);
  __declspec(dllimport) int __cdecl _isprint_l(  int _C,   _locale_t _Locale);
  __declspec(dllimport) int __cdecl isgraph(  int _C);
  __declspec(dllimport) int __cdecl _isgraph_l(  int _C,   _locale_t _Locale);
  __declspec(dllimport) int __cdecl iscntrl(  int _C);
  __declspec(dllimport) int __cdecl _iscntrl_l(  int _C,   _locale_t _Locale);


   __declspec(dllimport) int __cdecl toupper(  int _C);


   __declspec(dllimport) int __cdecl tolower(  int _C);

   __declspec(dllimport) int __cdecl _tolower(  int _C);
  __declspec(dllimport) int __cdecl _tolower_l(  int _C,   _locale_t _Locale);
   __declspec(dllimport) int __cdecl _toupper(  int _C);
  __declspec(dllimport) int __cdecl _toupper_l(  int _C,   _locale_t _Locale);

  __declspec(dllimport) int __cdecl __isascii(  int _C);
  __declspec(dllimport) int __cdecl __toascii(  int _C);
  __declspec(dllimport) int __cdecl __iscsymf(  int _C);
  __declspec(dllimport) int __cdecl __iscsym(  int _C);



//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// Character Classification Macro Definitions
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
__inline int __cdecl __acrt_locale_get_ctype_array_value(
      unsigned short const * const _Locale_pctype_array,
              int                    const _Char_value,
                             int                    const _Mask
    )
{
    // The C Standard specifies valid input to a ctype function ranges from -1 to 255.
    // To avoid undefined behavior, we should check this range for all accesses.
    // Note _locale_pctype array does extend to -127 to support accessing
    // _pctype directly with signed chars.
    if (_Char_value >= -1 && _Char_value <= 255)
    {
        return _Locale_pctype_array[_Char_value] & _Mask;
    }

    return 0;
}



    // Maximum number of bytes in multi-byte character in the current locale
    // (also defined in stdlib.h).
    




















    // In the debug CRT, we make all calls through the validation function to catch
    // invalid integer inputs that yield undefined behavior.
    
        __declspec(dllimport) int __cdecl _chvalidator(  int _Ch,   int _Mask);
        
    






    
    
    
    
    
    
    
    



    














    __inline __crt_locale_data_public* __cdecl __acrt_get_locale_data_prefix(void const volatile* const _LocalePointers)
    {
        _locale_t const _TypedLocalePointers = (_locale_t)_LocalePointers;
        return (__crt_locale_data_public*)_TypedLocalePointers->locinfo;
    }

    
    __declspec(dllimport) int __cdecl _chvalidator_l(  _locale_t,   int _Ch,   int _Mask);
    

    __inline int __cdecl _chvalidchk_l(
              int       const _C,
              int       const _Mask,
          _locale_t const _Locale
        )
    {
        
        return _chvalidator_l(_Locale, _C, _Mask);
        







    }

    
    

    __inline int __cdecl _ischartype_l(
              int       const _C,
              int       const _Mask,
          _locale_t const _Locale
        )
    {
        if (_Locale && __acrt_get_locale_data_prefix(_Locale)->_locale_mb_cur_max > 1)
        {
            return _isctype_l(_C, _Mask, _Locale);
        }

        return _chvalidchk_l(_C, _Mask, _Locale);
    }

    
    
    
    
    
    
    
    
    
    
    
    

    
    

    
    


    // Microsoft C version 2.0 extended ctype macros
    
    
    
    

    
    
    
    





    
    
    
    





} __pragma(pack(pop))



//
// locale.h
//
//      Copyright (c) Microsoft Corporation. All rights reserved.
//
// The C locale library.
//
#pragma once





__pragma(pack(push, 8)) extern "C" {



// Locale categories










// Locale convention structure
struct lconv
{
    char*    decimal_point;
    char*    thousands_sep;
    char*    grouping;
    char*    int_curr_symbol;
    char*    currency_symbol;
    char*    mon_decimal_point;
    char*    mon_thousands_sep;
    char*    mon_grouping;
    char*    positive_sign;
    char*    negative_sign;
    char     int_frac_digits;
    char     frac_digits;
    char     p_cs_precedes;
    char     p_sep_by_space;
    char     n_cs_precedes;
    char     n_sep_by_space;
    char     p_sign_posn;
    char     n_sign_posn;
    wchar_t* _W_decimal_point;
    wchar_t* _W_thousands_sep;
    wchar_t* _W_int_curr_symbol;
    wchar_t* _W_currency_symbol;
    wchar_t* _W_mon_decimal_point;
    wchar_t* _W_mon_thousands_sep;
    wchar_t* _W_positive_sign;
    wchar_t* _W_negative_sign;
};

struct tm;

// ANSI: char lconv members default is CHAR_MAX which is compile time dependent.
// Defining and using __do_unsigned_char_lconv_initialization here causes CRT
// startup code to initialize lconv members properly



















    __declspec(dllimport) void __cdecl _lock_locales(void);
    __declspec(dllimport) void __cdecl _unlock_locales(void);

    
    __declspec(dllimport) int __cdecl _configthreadlocale(
          int _Flag
        );

        
    __declspec(dllimport) char* __cdecl setlocale(
                int         _Category,
          char const* _Locale
        );

    
    __declspec(dllimport) struct lconv* __cdecl localeconv(void);

    
    __declspec(dllimport) _locale_t __cdecl _get_current_locale(void);

    
    __declspec(dllimport) _locale_t __cdecl _create_locale(
            int         _Category,
          char const* _Locale
        );

    __declspec(dllimport) void __cdecl _free_locale(
          _locale_t _Locale
        );

    // Also declared in <wchar.h>
        
    __declspec(dllimport) wchar_t* __cdecl _wsetlocale(
                int            _Category,
          wchar_t const* _Locale
        );

    
    __declspec(dllimport) _locale_t __cdecl _wcreate_locale(
            int            _Category,
          wchar_t const* _Locale
        );



    __declspec(dllimport) wchar_t**    __cdecl ___lc_locale_name_func(void);
    __declspec(dllimport) unsigned int __cdecl ___lc_codepage_func   (void);
    __declspec(dllimport) unsigned int __cdecl ___lc_collate_cp_func (void);




    // Time-related functions
     
     
    __declspec(dllimport) char*    __cdecl _Getdays(void);

     
     
    __declspec(dllimport) char*    __cdecl _Getmonths(void);

    __declspec(dllimport) void*    __cdecl _Gettnames(void);

     
     
    __declspec(dllimport) wchar_t* __cdecl _W_Getdays(void);

     
     
    __declspec(dllimport) wchar_t* __cdecl _W_Getmonths(void);

    __declspec(dllimport) void*    __cdecl _W_Gettnames(void);

     
    __declspec(dllimport) size_t __cdecl _Strftime(
          char*           _Buffer,
                              size_t           _Max_size,
                            char const*      _Format,
                              struct tm const* _Timeptr,
                          void*            _Lc_time_arg);

     
    __declspec(dllimport) size_t __cdecl _Wcsftime(
          wchar_t*        _Buffer,
                              size_t           _Max_size,
                            wchar_t const*   _Format,
                              struct tm const* _Timeptr,
                          void*            _Lc_time_arg
        );




} __pragma(pack(pop))





 #pragma pack(push,8)
 #pragma warning(push,3)
 #pragma warning(disable: 4455 4494  4619 4643 4702 4984 4988 )
 
 
 


 
extern "C" {
 


		/* CTYPE CODE BITS */












		/* SUPPLEMENTAL LOCALE MACROS AND DECLARATIONS */










 
 
 
 
 
 
 
 

typedef struct _Collvec
	{	/* stuff needed by _Strcoll, etc. */
	unsigned int _Page;		// UINT
	wchar_t *_LocaleName;
	} _Collvec;

typedef struct _Ctypevec
	{	/* stuff needed by _Tolower, etc. */
	unsigned int _Page;		// UINT
	const short *_Table;
	int _Delfl;
	wchar_t *_LocaleName;
	} _Ctypevec;

typedef struct _Cvtvec
	{	/* stuff needed by _Mbrtowc, etc. */
	unsigned int _Page;		// UINT
	unsigned int _Mbcurmax;
	int _Isclocale;	// LCID == _CLOCALEHANDLE
	unsigned char _Isleadbyte[32];	// 256 bits
	} _Cvtvec;

		/* FUNCTION DECLARATIONS */
 _Collvec __cdecl _Getcoll(void);
 _Ctypevec __cdecl _Getctype(void);
 _Cvtvec __cdecl _Getcvt(void);



extern "C"

 int __cdecl _Getdateorder(void);


 








 int __cdecl _Mbrtowc(  wchar_t *, const char *, size_t,
	mbstate_t *, const _Cvtvec *);
 

 float __cdecl _Stof(const char *,
	    char **, long);
 double __cdecl _Stod(const char *,
	    char **, long);
 long double __cdecl _Stold(const char *,
	    char **, long);

 int __cdecl _Strcoll(const char *, const char *,
	const char *, const char *, const _Collvec *);
 size_t __cdecl _Strxfrm(
	    char *_String1,
	  char *_End1, const char *, const char *, const _Collvec *);
 int __cdecl _Tolower(int, const _Ctypevec *);
 int __cdecl _Toupper(int, const _Ctypevec *);
 int __cdecl _Wcrtomb(  char *, wchar_t, mbstate_t *,
	const _Cvtvec *);
 int __cdecl _Wcscoll(const wchar_t *, const wchar_t *,
	const wchar_t *, const wchar_t *, const _Collvec *);
 size_t __cdecl _Wcsxfrm(
	    wchar_t *_String1,
	  wchar_t *_End1, const wchar_t *, const wchar_t *, const _Collvec *);

 short __cdecl _Getwctype(wchar_t, const _Ctypevec *);
 const wchar_t *__cdecl _Getwctypes(const wchar_t *,
	const wchar_t *, short *, const _Ctypevec *);
 wchar_t __cdecl _Towlower(wchar_t, const _Ctypevec *);
 wchar_t __cdecl _Towupper(wchar_t, const _Ctypevec *);


 
}
 


extern "C" {
 
 
__declspec(dllimport) char *__cdecl _Getdays(void);

 
 
__declspec(dllimport) char *__cdecl _Getmonths(void);

__declspec(dllimport) void *__cdecl _Gettnames(void);

 
__declspec(dllimport) size_t __cdecl _Strftime(  char *,
	  size_t _Maxsize,   const char *,   const struct tm *,
	  void *);

 
 
__declspec(dllimport) wchar_t *__cdecl _W_Getdays(void);

 
 
__declspec(dllimport) wchar_t *__cdecl _W_Getmonths(void);

__declspec(dllimport) void *__cdecl _W_Gettnames(void);

 
__declspec(dllimport) size_t __cdecl _Wcsftime(  wchar_t *,
	  size_t _Maxsize,   const wchar_t *,   const struct tm *,
	  void *);
}

 







 _locale_t __cdecl _GetLocaleForCP(unsigned int);
 

 
 
 #pragma warning(pop)
 #pragma pack(pop)



/*
 * Copyright (c) by P.J. Plauger. All rights reserved.
 * Consult your license regarding permissions and restrictions.
V6.50:0009 */




 #pragma pack(push,8)
 #pragma warning(push,3)
 #pragma warning(disable: 4455 4494  4619 4643 4702 4984 4988 )
 
 
 

namespace std {
		// CLASS _Timevec
class __declspec(dllimport) _Timevec
	{	// smart pointer to information used by _Strftime
public:
	 _Timevec(void *_Ptr = nullptr)
		: _Timeptr(_Ptr)
		{	// construct from ptr
		}

	 _Timevec(const _Timevec& _Right)
		{	// construct from _Right
		*this = _Right;
		}

	 ~_Timevec() noexcept
		{	// destroy the object
		free(_Timeptr);
		}

	_Timevec&  operator=(const _Timevec& _Right)
		{	// transfer ownership of _Timeptr from _Right
		_Timeptr = _Right._Timeptr;
		((_Timevec *)&_Right)->_Timeptr = nullptr;
		return (*this);
		}

	void * _Getptr() const
		{	// return pointer to time information
		return (_Timeptr);
		}

private:
	void *_Timeptr;	// pointer to time information
	};

		// CLASS _Locinfo
class __declspec(dllimport) _Locinfo
	{	// summary of all stuff peculiar to a locale used by standard facets
public:
	typedef ::_Collvec _Collvec;
	typedef ::_Ctypevec _Ctypevec;
	typedef ::_Cvtvec _Cvtvec;
	typedef ::std:: _Timevec _Timevec;

	static  void __cdecl _Locinfo_ctor(
		_Locinfo *, const char *);
	static  void __cdecl _Locinfo_ctor(
		_Locinfo *, int, const char *);
	static  void __cdecl _Locinfo_dtor(
		_Locinfo *);
	static  _Locinfo& __cdecl _Locinfo_Addcats(
		_Locinfo *, int, const char *);

	 _Locinfo(const char *_Pch = "C")
 
		: _Lock(0)
 

		{	// construct from NTBS
		if (_Pch == nullptr)
			throw runtime_error("bad locale name");
		_Locinfo_ctor(this, _Pch);
		}

	 _Locinfo(int _Cat, const char *_Pch)
 
		: _Lock(0)
 

		{	// construct from category mask and NTBS
		if (_Pch == nullptr)
			throw runtime_error("bad locale name");
		_Locinfo_ctor(this, _Cat, _Pch);
		}

	 ~_Locinfo() noexcept
		{	// destroy the object
		_Locinfo_dtor(this);
		}

	_Locinfo&  _Addcats(int _Cat, const char *_Pch)
		{	// add facets matching category mask and NTBS
		if (_Pch == nullptr)
			throw runtime_error("bad locale name");
		return (_Locinfo_Addcats(this, _Cat, _Pch));
		}

	const char * _Getname() const
		{	// return the new locale name
		return (_Newlocname._C_str());
		}

	_Collvec  _Getcoll() const
		{	// return collation stuff
		return (::_Getcoll());
		}

	_Ctypevec  _Getctype() const
		{	// return ctype stuff
		return (::_Getctype());
		}

	_Cvtvec  _Getcvt() const
		{	// return codecvt stuff
		return (::_Getcvt());
		}

	const lconv * _Getlconv() const
		{	// return localeconv stuff
		return (localeconv());
		}

	_Timevec  _Gettnames() const
		{	// return names used by _Strftime
		return (_Timevec(::_Gettnames()));
		}

	const char * _Getdays() const
		{	// return names for weekdays
		const char *_Ptr = ::_Getdays();

		if (_Ptr != nullptr)
			{	// capture names and free allocated C string
			((_Locinfo *)this)->_Days = _Ptr;
			free((void *)_Ptr);
			}
		return (!_Days._Empty() ? _Days._C_str()
			: ":Sun:Sunday:Mon:Monday:Tue:Tuesday:Wed:Wednesday"
				":Thu:Thursday:Fri:Friday:Sat:Saturday");
		}

	const char * _Getmonths() const
		{	// return names for months
		const char *_Ptr = ::_Getmonths();

		if (_Ptr != nullptr)
			{	// capture names and free allocated C string
			((_Locinfo *)this)->_Months = _Ptr;
			free((void *)_Ptr);
			}
		return (!_Months._Empty() ? _Months._C_str()
			: ":Jan:January:Feb:February:Mar:March"
				":Apr:April:May:May:Jun:June"
				":Jul:July:Aug:August:Sep:September"
				":Oct:October:Nov:November:Dec:December");
		}

	const char * _Getfalse() const
		{	// return false name (no C source)
		return ("false");
		}

	const char * _Gettrue() const
		{	// return true name (no C source)
		return ("true");
		}

	int  _Getdateorder() const
		{	// return date order
		return (::_Getdateorder());
		}

	_Timevec  _W_Gettnames() const
		{	// return names used by _Wcsftime
		return (_Timevec(::_W_Gettnames()));
		}

	const unsigned short * _W_Getdays() const
		{	// return names for weekdays
		const wchar_t *_Ptr = ::_W_Getdays();

		if (_Ptr != nullptr)
			{	// capture names and free allocated C string
			((_Locinfo *)this)->_W_Days = _Ptr;
			free((void *)_Ptr);
			}
		return ((const unsigned short *)(!_W_Days._Empty()
			? _W_Days._C_str()
			: L":Sun:Sunday:Mon:Monday:Tue:Tuesday:Wed:Wednesday"
				L":Thu:Thursday:Fri:Friday:Sat:Saturday"));
		}

	const unsigned short * _W_Getmonths() const
		{	// return names for months
		const wchar_t *_Ptr = ::_W_Getmonths();

		if (_Ptr != nullptr)
			{	// capture names and free allocated C string
			((_Locinfo *)this)->_W_Months = _Ptr;
			free((void *)_Ptr);
			}
		return ((const unsigned short *)(!_W_Months._Empty()
			? _W_Months._C_str()
			: L":Jan:January:Feb:February:Mar:March"
				L":Apr:April:May:May:Jun:June"
				L":Jul:July:Aug:August:Sep:September"
				L":Oct:October:Nov:November:Dec:December"));
		}

	_Locinfo(const _Locinfo&) = delete;
	_Locinfo& operator=(const _Locinfo&) = delete;

private:
 



	_Lockit _Lock;	// thread lock, because global locale is altered
 

	_Yarn<char> _Days;	// weekday names
	_Yarn<char> _Months;	// month names
	_Yarn<wchar_t> _W_Days;	// wide weekday names
	_Yarn<wchar_t> _W_Months;	// wide month names
	_Yarn<char> _Oldlocname;	// old locale name to revert to on destruction
	_Yarn<char> _Newlocname;	// new locale name for this object
	};

		// FUNCTION TEMPLATE _LStrcoll
template<class _Elem> inline
	int __cdecl _LStrcoll(const _Elem *_First1, const _Elem *_Last1,
		const _Elem *_First2, const _Elem *_Last2,
			const _Locinfo::_Collvec *)
	{	// perform locale-specific comparison of _Elem sequences
	for (; _First1 != _Last1 && _First2 != _Last2; ++_First1, ++_First2)
		if (*_First1 < *_First2)
			return (-1);	// [_First1, _Last1) < [_First2, _Last2)
		else if (*_First2 < *_First1)
			return (+1);	// [_First1, _Last1) > [_First2, _Last2)
	return (_First2 != _Last2 ? -1 : _First1 != _Last1 ? +1 : 0);
	}

template<> inline
	int __cdecl _LStrcoll(const char *_First1, const char *_Last1,
		const char *_First2, const char *_Last2,
			const _Locinfo::_Collvec *_Vector)
	{	// perform locale-specific comparison of char sequences
	return (_Strcoll(_First1, _Last1, _First2, _Last2, _Vector));
	}

template<> inline
	int __cdecl _LStrcoll(const wchar_t *_First1, const wchar_t *_Last1,
		const wchar_t *_First2, const wchar_t *_Last2,
			const _Locinfo::_Collvec *_Vector)
	{	// perform locale-specific comparison of wchar_t sequences
	return (_Wcscoll(_First1, _Last1, _First2, _Last2, _Vector));
	}

		// FUNCTION TEMPLATE _LStrxfrm
template<class _Elem> inline
	size_t __cdecl _LStrxfrm(_Elem *_First1, _Elem *_Last1,
		const _Elem *_First2, const _Elem *_Last2,
			const _Locinfo::_Collvec *)
	{	// perform locale-specific transform of _Elems [_First1, _Last1)
	const ptrdiff_t _Count = _Last2 - _First2;
	if (_Count <= _Last1 - _First1)
		{
		:: memcpy(_First1, _First2, _Count * sizeof(_Elem));
		}

	return (_Count);
	}

template<> inline
	size_t __cdecl _LStrxfrm( 
		  char *_First1,   char *_Last1,
		const char *_First2, const char *_Last2,
			const _Locinfo::_Collvec *_Vector)
	{	// perform locale-specific transform of chars [_First1, _Last1)
	return (_Strxfrm(_First1, _Last1, _First2, _Last2, _Vector));
	}

template<> inline
	size_t __cdecl _LStrxfrm( 
		  wchar_t *_First1,   wchar_t *_Last1,
		const wchar_t *_First2, const wchar_t *_Last2,
			const _Locinfo::_Collvec *_Vector)
	{	// perform locale-specific transform of wchar_ts [_First1, _Last1)
	return (_Wcsxfrm(_First1, _Last1, _First2, _Last2, _Vector));
	}
}
 
 
 #pragma warning(pop)
 #pragma pack(pop)



/*
 * Copyright (c) by P.J. Plauger. All rights reserved.
 * Consult your license regarding permissions and restrictions.
V6.50:0009 */


// memory standard header
#pragma once




// xmemory internal header
#pragma once





 #pragma pack(push,8)
 #pragma warning(push,3)
 #pragma warning(disable: 4455 4494  4619 4643 4702 4984 4988 )
 
 
 

namespace std {
		// FUNCTION TEMPLATE _Get_temporary_buffer
template<class _Ty> inline
	pair<_Ty *, ptrdiff_t> _Get_temporary_buffer(ptrdiff_t _Count) noexcept
	{	// get raw temporary buffer of up to _Count elements
	if (static_cast<size_t>(_Count) <= static_cast<size_t>(-1) / sizeof(_Ty))
		{
		for (; 0 < _Count; _Count /= 2)
			{
			const auto _Size = static_cast<size_t>(_Count) * sizeof(_Ty);
			void * _Pbuf;
 










				{
				_Pbuf = ::operator new(_Size, nothrow);
				}
			if (_Pbuf)
				{
				return {static_cast<_Ty *>(_Pbuf), _Count};
				}
			}
		}

	return {nullptr, 0};
	}

		// FUNCTION TEMPLATE _Return_temporary_buffer
template<class _Ty> inline
	void _Return_temporary_buffer(_Ty * const _Pbuf) noexcept
	{	// delete raw temporary buffer
 










		{
		::operator delete(_Pbuf);
		}
	}

		// STRUCT TEMPLATE _Uninitialized_backout
template<class _FwdIt>
	struct _Uninitialized_backout
	{	// struct to undo partially constructed ranges in _Uninitialized_xxx algorithms
	_FwdIt _First;
	_FwdIt _Last;

	explicit _Uninitialized_backout(_FwdIt _Dest)
		: _First(_Dest),
		_Last(_Dest)
		{}

	_Uninitialized_backout(_FwdIt _First_, _FwdIt _Last_)
		: _First(_First_),
		_Last(_Last_)
		{}

	_Uninitialized_backout(const _Uninitialized_backout&) = delete;
	_Uninitialized_backout& operator=(const _Uninitialized_backout&) = delete;

	~_Uninitialized_backout()
		{	// destroy all elements guarded by this instance
		_Destroy_range(_First, _Last);
		}

	template<class... _Types>
		void _Emplace_back(_Types&&... _Vals)
		{	// construct a new element at *_Last and increment
		_Construct_in_place(*_Last, ::std:: forward<_Types>(_Vals)...);
		++_Last;
		}

	_FwdIt _Release()
		{	// suppress any exception handling backout and return _Last
		_First = _Last;
		return (_Last);
		}
	};

		// FUNCTION TEMPLATE _Uninitialized_move_unchecked
template<class _InIt,
	class _FwdIt> inline
	_FwdIt _Uninitialized_move_unchecked1(_InIt _First, const _InIt _Last,
		const _FwdIt _Dest, _General_ptr_iterator_tag)
	{	// move [_First, _Last) to raw [_Dest, ...), no special optimization
	_Uninitialized_backout<_FwdIt> _Backout{_Dest};
	for (; _First != _Last; ++_First)
		{
		_Backout._Emplace_back(::std:: move(*_First));
		}

	return (_Backout._Release());
	}

template<class _InIt,
	class _FwdIt> inline
	_FwdIt _Uninitialized_move_unchecked1(const _InIt _First, const _InIt _Last,
		const _FwdIt _Dest, _Really_trivial_ptr_iterator_tag)
	{	// move [_First, _Last) to raw [_Dest, ...), memmove optimization
	return (_Copy_memmove(_First, _Last, _Dest));
	}

template<class _InIt,
	class _FwdIt> inline
	_FwdIt _Uninitialized_move_unchecked(const _InIt _First, const _InIt _Last,
		const _FwdIt _Dest)
	{	// move [_First, _Last) to raw [_Dest, ...), choose optimization
	return (_Uninitialized_move_unchecked1(_First, _Last, _Dest, _Ptr_move_cat(_First, _Dest)));
	}

		// STRUCT TEMPLATE _Uninitialized_backout_al
template<class _FwdIt,
	class _Alloc>
	class _Uninitialized_backout_al
	{	// struct to undo partially constructed ranges in _Uninitialized_xxx_al algorithms
public:
	_Uninitialized_backout_al(_FwdIt _Dest, _Alloc& _Al_)
		: _First(_Dest),
		_Last(_Dest),
		_Al(_Al_)
		{
		}

	_Uninitialized_backout_al(const _Uninitialized_backout_al&) = delete;
	_Uninitialized_backout_al& operator=(const _Uninitialized_backout_al&) = delete;

	~_Uninitialized_backout_al()
		{	// destroy all elements guarded by this instance
		_Destroy_range(_First, _Last, _Al);
		}

	template<class... _Types>
		void _Emplace_back(_Types&&... _Vals)
		{	// construct a new element at *_Last and increment
		allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), ::std:: forward<_Types>(_Vals)...);
		++_Last;
		}

	_FwdIt _Release()
		{	// suppress any exception handling backout and return _Last
		_First = _Last;
		return (_Last);
		}

private:
	_FwdIt _First;
	_FwdIt _Last;
	_Alloc& _Al;
	};

		// FUNCTION TEMPLATE _Uninitialized_copy WITH ALLOCATOR
template<class _InIt,
	class _FwdIt,
	class _Alloc> inline
	_FwdIt _Uninitialized_copy_al_unchecked(_InIt _First, const _InIt _Last, const _FwdIt _Dest, _Alloc& _Al,
		_General_ptr_iterator_tag, _Any_tag)
	{	// copy [_First, _Last) to raw _Dest, using _Al, no special optimization
	_Uninitialized_backout_al<_FwdIt, _Alloc> _Backout{_Dest, _Al};
	for (; _First != _Last; ++_First)
		{
		_Backout._Emplace_back(*_First);
		}

	return (_Backout._Release());
	}

template<class _Ty1,
	class _Ty2,
	class _Alloc> inline
	_Ty2 *_Uninitialized_copy_al_unchecked(_Ty1 * const _First, _Ty1 * const _Last, _Ty2 * const _Dest, _Alloc&,
		_Really_trivial_ptr_iterator_tag, true_type)
	{	// copy [_First, _Last) to raw _Dest, using default _Alloc construct, memmove optimization
	return (_Copy_memmove(_First, _Last, _Dest));
	}

template<class _InIt,
	class _FwdIt,
	class _Alloc> inline
	_FwdIt _Uninitialized_copy(const _InIt _First, const _InIt _Last, _FwdIt _Dest, _Alloc& _Al)
	{	// copy [_First, _Last) to raw _Dest, using _Al
		// note: only called internally from elsewhere in the STL
	const auto _UFirst = _Get_unwrapped(_First);
	const auto _ULast = _Get_unwrapped(_Last);
	const auto _UDest = _Get_unwrapped_n(_Dest, _Idl_distance<_InIt>(_UFirst, _ULast));
	_Seek_wrapped(_Dest,
		_Uninitialized_copy_al_unchecked(_UFirst, _ULast, _UDest, _Al,
			_Ptr_copy_cat(_UFirst, _UDest),
			_Uses_default_construct_t<_Alloc, decltype(_Unfancy(_UDest)), decltype(*_UFirst)>()));

	return (_Dest);
	}

		// FUNCTION TEMPLATE _Uninitialized_move WITH ALLOCATOR
template<class _InIt,
	class _FwdIt,
	class _Alloc> inline
	_FwdIt _Uninitialized_move_al_unchecked(_InIt _First, const _InIt _Last, const _FwdIt _Dest, _Alloc& _Al,
		_General_ptr_iterator_tag, _Any_tag)
	{	// move [_First, _Last) to raw _Dest, using _Al, no special optimization
	_Uninitialized_backout_al<_FwdIt, _Alloc> _Backout{_Dest, _Al};
	for (; _First != _Last; ++_First)
		{
		_Backout._Emplace_back(::std:: move(*_First));
		}

	return (_Backout._Release());
	}

template<class _Ty1,
	class _Ty2,
	class _Alloc> inline
	_Ty2 *_Uninitialized_move_al_unchecked(_Ty1 * const _First, _Ty1 * const _Last, _Ty2 * const _Dest, _Alloc&,
		_Really_trivial_ptr_iterator_tag, true_type)
	{	// move [_First, _Last) to raw _Dest, using default _Alloc construct, memmove optimization
	return (_Copy_memmove(_First, _Last, _Dest));
	}

template<class _InIt,
	class _FwdIt,
	class _Alloc> inline
	_FwdIt _Uninitialized_move(const _InIt _First, const _InIt _Last, _FwdIt _Dest, _Alloc& _Al)
	{	// move [_First, _Last) to raw _Dest, using _Al
		// note: only called internally from elsewhere in the STL
	const auto _UFirst = _Get_unwrapped(_First);
	const auto _ULast = _Get_unwrapped(_Last);
	const auto _UDest = _Get_unwrapped_n(_Dest, _Idl_distance<_InIt>(_UFirst, _ULast));
	_Seek_wrapped(_Dest,
		_Uninitialized_move_al_unchecked(_UFirst, _ULast, _UDest, _Al,
			_Ptr_move_cat(_UFirst, _UDest),
			_Uses_default_construct_t<_Alloc, decltype(_Unfancy(_UDest)), decltype(::std:: move(*_UFirst))>()));
	return (_Dest);
	}

		// FUNCTION TEMPLATE _Uninitialized_fill_n WITH ALLOCATOR
template<class _FwdIt,
	class _Diff,
	class _Alloc> inline
	_FwdIt _Uninit_alloc_fill_n1(const _FwdIt _First, _Diff _Count, const _Iter_value_t<_FwdIt>& _Val,
		_Alloc& _Al, false_type)
	{	// copy _Count copies of _Val to raw _First, using _Al, no special optimization
	_Uninitialized_backout_al<_FwdIt, _Alloc> _Backout{_First, _Al};
	for (; 0 < _Count; --_Count)
		{
		_Backout._Emplace_back(_Val);
		}

	return (_Backout._Release());
	}

template<class _FwdIt,
	class _Diff,
	class _Alloc> inline
	_FwdIt _Uninit_alloc_fill_n1(const _FwdIt _First, const _Diff _Count, const _Iter_value_t<_FwdIt>& _Val,
		_Alloc&, true_type)
	{	// copy _Count copies of _Val to raw _First, using default _Alloc construct, memset optimization
	:: memset(_First, static_cast<unsigned char>(_Val), static_cast<size_t>(_Count));
	return (_First + _Count);
	}

template<class _FwdIt,
	class _Diff,
	class _Alloc> inline
	_FwdIt _Uninitialized_fill_n(const _FwdIt _First, const _Diff _Count, const _Iter_value_t<_FwdIt>& _Val,
		_Alloc& _Al)
	{	// copy _Count copies of _Val to raw _First, using _Al
	return (_Uninit_alloc_fill_n1(_First, _Count, _Val, _Al,
		bool_constant<conjunction_v<decltype(_Fill_memset_is_safe(_First, _Val)),
			_Uses_default_construct<_Alloc, decltype(_Unfancy(_First)), decltype(_Val)>>>{}));
	}

		// FUNCTION TEMPLATE _Uninitialized_value_construct_n WITH ALLOCATOR
template<class _FwdIt>
	using _Use_memset_value_construct_t = bool_constant<conjunction_v<
		is_pointer<_FwdIt>,
		is_scalar<_Iter_value_t<_FwdIt>>,
		negation<is_volatile<_Iter_value_t<_FwdIt>>>,
		negation<is_member_pointer<_Iter_value_t<_FwdIt>>>>>;

template<class _FwdIt> inline
	_FwdIt _Zero_range(const _FwdIt _First, const _FwdIt _Last)
	{	// fill [_First, _Last) with zeroes
	char * const _First_ch = reinterpret_cast<char *>(_First);
	char * const _Last_ch = reinterpret_cast<char *>(_Last);
	:: memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));
	return (_Last);
	}

template<class _FwdIt,
	class _Diff,
	class _Alloc> inline
	_FwdIt _Uninitialized_value_construct_n1(const _FwdIt _First, _Diff _Count, _Alloc& _Al, false_type)
	{	// value-initialize _Count objects to raw _First, using _Al, no special optimization
	_Uninitialized_backout_al<_FwdIt, _Alloc> _Backout{_First, _Al};
	for (; 0 < _Count; --_Count)
		{
		_Backout._Emplace_back();
		}

	return (_Backout._Release());
	}

template<class _FwdIt,
	class _Diff,
	class _Alloc> inline
	_FwdIt _Uninitialized_value_construct_n1(_FwdIt _First, _Diff _Count, _Alloc&, true_type)
	{	// value-initialize _Count objects to raw _First, using default _Alloc construct, all-bits-zero type
	return (_Zero_range(_First, _First + _Count));
	}

template<class _FwdIt,
	class _Diff,
	class _Alloc> inline
	_FwdIt _Uninitialized_value_construct_n(_FwdIt _First, _Diff _Count, _Alloc& _Al)
	{	// value-initialize _Count objects to raw _First, using _Al
	return (_Uninitialized_value_construct_n1(_First, _Count, _Al,
		bool_constant<conjunction_v<_Use_memset_value_construct_t<_FwdIt>,
			_Uses_default_construct<_Alloc, decltype(_Unfancy(_First))>>>{}));
	}

	// STRUCT _Not_a_node_tag
struct _Not_a_node_tag
	{	// Used as the type of a "pointer" to a non-node.
	};

		// FUNCTION TEMPLATE get_temporary_buffer
template<class _Ty>
	  pair<_Ty *, ptrdiff_t> get_temporary_buffer(ptrdiff_t _Count) noexcept
	{	// get raw temporary buffer of up to _Count elements
	return (_Get_temporary_buffer<_Ty>(_Count));
	}

		// FUNCTION TEMPLATE return_temporary_buffer
template<class _Ty>
	 void return_temporary_buffer(_Ty * _Pbuf)
	{	// delete raw temporary buffer
	_Return_temporary_buffer(_Pbuf);
	}
}

 
 
 #pragma warning(pop)
 #pragma pack(pop)



/*
 * Copyright (c) by P.J. Plauger. All rights reserved.
 * Consult your license regarding permissions and restrictions.
V6.50:0009 */





 #pragma pack(push,8)
 #pragma warning(push,3)
 #pragma warning(disable: 4455 4494  4619 4643 4702 4984 4988 )
 
 
 

namespace std {
		// FUNCTION TEMPLATE uninitialized_copy
template<class _InIt,
	class _FwdIt> inline
	_FwdIt _Uninitialized_copy_unchecked(_InIt _First, const _InIt _Last,
		const _FwdIt _Dest, _General_ptr_iterator_tag)
	{	// copy [_First, _Last) to raw [_Dest, ...), no special optimization
	_Uninitialized_backout<_FwdIt> _Backout{_Dest};
	for (; _First != _Last; ++_First)
		{
		_Backout._Emplace_back(*_First);
		}

	return (_Backout._Release());
	}

template<class _InIt,
	class _FwdIt> inline
	_FwdIt _Uninitialized_copy_unchecked(const _InIt _First, const _InIt _Last,
		const _FwdIt _Dest, _Really_trivial_ptr_iterator_tag)
	{	// copy [_First, _Last) to raw [_Dest, ...), memmove optimization
	return (_Copy_memmove(_First, _Last, _Dest));
	}

template<class _InIt,
	class _FwdIt> inline
	_FwdIt uninitialized_copy(const _InIt _First, const _InIt _Last, _FwdIt _Dest)
	{	// copy [_First, _Last) to raw [_Dest, ...)
	_Adl_verify_range(_First, _Last);
	const auto _UFirst = _Get_unwrapped(_First);
	const auto _ULast = _Get_unwrapped(_Last);
	const auto _UDest = _Get_unwrapped_n(_Dest, _Idl_distance<_InIt>(_UFirst, _ULast));
	_Seek_wrapped(_Dest,
		_Uninitialized_copy_unchecked(_UFirst, _ULast, _UDest, _Ptr_copy_cat(_UFirst, _UDest)));
	return (_Dest);
	}

 
template<class _InIt,
	class _OutTy,
	size_t _OutSize> inline
	_OutTy * uninitialized_copy(const _InIt _First, const _InIt _Last,
		_OutTy (&_Dest)[_OutSize])
	{	// copy [_First, _Last) to raw [_Dest, ...)
	return (::std:: uninitialized_copy(_First, _Last, _Array_iterator<_OutTy, _OutSize>(_Dest))._Unwrapped());
	}
 

		// FUNCTION TEMPLATE uninitialized_copy_n
// TRANSITION: _Uninitialized_copy_n_unchecked and _Uninitialized_copy_n_unchecked1 are ABI zombie names
template<class _InIt,
	class _Diff,
	class _FwdIt> inline
	_FwdIt _Uninitialized_copy_n_unchecked2(_InIt _First, _Diff _Count,
		const _FwdIt _Dest, _General_ptr_iterator_tag)
	{	// copy [_First, _First + _Count) to [_Dest, ...), no special optimization
	_Uninitialized_backout<_FwdIt> _Backout{_Dest};
	for (; 0 < _Count; --_Count, (void)++_First)
		{
		_Backout._Emplace_back(*_First);
		}

	return (_Backout._Release());
	}

template<class _InIt,
	class _Diff,
	class _FwdIt> inline
	_FwdIt _Uninitialized_copy_n_unchecked2(const _InIt _First, const _Diff _Count,
		const _FwdIt _Dest, _Really_trivial_ptr_iterator_tag)
	{	// copy [_First, _First + _Count) to [_Dest, ...), memmove optimization
	return (_Copy_memmove(_First, _First + _Count, _Dest));
	}

template<class _InIt,
	class _Diff,
	class _FwdIt> inline
	_FwdIt uninitialized_copy_n(const _InIt _First, const _Diff _Count_raw, _FwdIt _Dest)
	{	// copy [_First, _First + _Count) to [_Dest, ...)]
	_Algorithm_int_t<_Diff> _Count = _Count_raw;
	if (0 < _Count)
		{
		const auto _UFirst = _Get_unwrapped_n(_First, _Count);
		const auto _UDest = _Get_unwrapped_n(_Dest, _Count);
		_Seek_wrapped(_Dest,
			_Uninitialized_copy_n_unchecked2(_UFirst, _Count, _UDest, _Ptr_copy_cat(_UFirst, _UDest)));
		}

	return (_Dest);
	}

 
template<class _InTy,
	size_t _InSize,
	class _Diff,
	class _FwdIt> inline
	_FwdIt uninitialized_copy_n(_InTy (&_First)[_InSize], const _Diff _Count_raw, _FwdIt _Dest)
	{	// copy [_First, _First + _Count) to [_Dest, ...), array input
	_Algorithm_int_t<_Diff> _Count = _Count_raw;
	if (0 < _Count)
		{
		do { if ((::std:: size(_First) >= static_cast<common_type_t<size_t, decltype(_Count)>>(_Count))) { } else { do { (void) ((1 != _CrtDbgReport(2, "c:\\visual studio\\vc\\tools\\msvc\\14.16.27023\\include\\memory", 119, 0, "%s", "array too small")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"array too small\"", __LPREFIX( __FUNCTION__), L"c:\\visual studio\\vc\\tools\\msvc\\14.16.27023\\include\\memory", 119, 0); } while (false); } ; } while (false);
		const auto _UDest = _Get_unwrapped_n(_Dest, _Count);
		_Seek_wrapped(_Dest,
			_Uninitialized_copy_n_unchecked2(_First, _Count, _UDest, _Ptr_copy_cat(_First, _UDest)));
		}

	return (_Dest);
	}

template<class _InIt,
	class _Diff,
	class _OutTy,
	size_t _OutSize> inline
	_OutTy * uninitialized_copy_n(const _InIt _First, const _Diff _Count_raw, _OutTy (&_Dest)[_OutSize])
	{	// copy [_First, _First + _Count) to [_Dest, ...), array dest
	_Algorithm_int_t<_Diff> _Count = _Count_raw;
	if (0 < _Count)
		{
		do { if ((::std:: size(_Dest) >= static_cast<common_type_t<size_t, decltype(_Count)>>(_Count))) { } else { do { (void) ((1 != _CrtDbgReport(2, "c:\\visual studio\\vc\\tools\\msvc\\14.16.27023\\include\\memory", 137, 0, "%s", "array too small")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"array too small\"", __LPREFIX( __FUNCTION__), L"c:\\visual studio\\vc\\tools\\msvc\\14.16.27023\\include\\memory", 137, 0); } while (false); } ; } while (false);
		const auto _UFirst = _Get_unwrapped_n(_First, _Count);
		return (_Uninitialized_copy_n_unchecked2(_UFirst, _Count, _Dest, _Ptr_copy_cat(_UFirst, _Dest)));
		}

	return (_Dest);
	}

template<class _InTy,
	size_t _InSize,
	class _Diff,
	class _OutTy,
	size_t _OutSize> inline
	_OutTy * uninitialized_copy_n(_InTy (&_First)[_InSize], const _Diff _Count_raw, _OutTy (&_Dest)[_OutSize])
	{	// copy [_First, _First + _Count) to [_Dest, ...), array input/dest
	_Algorithm_int_t<_Diff> _Count = _Count_raw;
	if (0 < _Count)
		{
		do { if ((::std:: size(_First) >= static_cast<common_type_t<size_t, decltype(_Count)>>(_Count))) { } else { do { (void) ((1 != _CrtDbgReport(2, "c:\\visual studio\\vc\\tools\\msvc\\14.16.27023\\include\\memory", 155, 0, "%s", "array too small")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"array too small\"", __LPREFIX( __FUNCTION__), L"c:\\visual studio\\vc\\tools\\msvc\\14.16.27023\\include\\memory", 155, 0); } while (false); } ; } while (false);
		do { if ((::std:: size(_Dest) >= static_cast<common_type_t<size_t, decltype(_Count)>>(_Count))) { } else { do { (void) ((1 != _CrtDbgReport(2, "c:\\visual studio\\vc\\tools\\msvc\\14.16.27023\\include\\memory", 156, 0, "%s", "array too small")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"array too small\"", __LPREFIX( __FUNCTION__), L"c:\\visual studio\\vc\\tools\\msvc\\14.16.27023\\include\\memory", 156, 0); } while (false); } ; } while (false);
		return (_Uninitialized_copy_n_unchecked2(_First, _Count, _Dest, _Ptr_copy_cat(_First, _Dest)));
		}

	return (_Dest);
	}
 














































































































































		// FUNCTION TEMPLATE uninitialized_fill
template<class _FwdIt,
	class _Tval> inline
	void _Uninitialized_fill_unchecked(const _FwdIt _First, const _FwdIt _Last, const _Tval& _Val, false_type)
	{	// copy _Val throughout raw [_First, _Last), no special optimization
	_Uninitialized_backout<_FwdIt> _Backout{_First};
	while (_Backout._Last != _Last)
		{
		_Backout._Emplace_back(_Val);
		}

	_Backout._Release();
	}

template<class _FwdIt,
	class _Tval> inline
	void _Uninitialized_fill_unchecked(const _FwdIt _First, const _FwdIt _Last, const _Tval& _Val, true_type)
	{	// copy _Val throughout raw [_First, _Last), memset optimization
	:: memset(_First, static_cast<unsigned char>(_Val), static_cast<size_t>(_Last - _First));
	}

template<class _FwdIt,
	class _Tval> inline
	void uninitialized_fill(const _FwdIt _First, const _FwdIt _Last, const _Tval& _Val)
	{	// copy _Val throughout raw [_First, _Last)
	_Adl_verify_range(_First, _Last);
	const auto _UFirst = _Get_unwrapped(_First);
	_Uninitialized_fill_unchecked(_UFirst, _Get_unwrapped(_Last), _Val, _Fill_memset_is_safe(_UFirst, _Val));
	}


		// FUNCTION TEMPLATE uninitialized_fill_n
// TRANSITION: _Uninitialized_fill_n_unchecked is an ABI zombie name
template<class _FwdIt,
	class _Diff,
	class _Tval> inline
	_FwdIt _Uninitialized_fill_n_unchecked1(const _FwdIt _First, _Diff _Count, const _Tval& _Val, false_type)
	{	// copy _Count copies of _Val to raw _First, no special optimization
	_Uninitialized_backout<_FwdIt> _Backout{_First};
	for (; 0 < _Count; --_Count)
		{
		_Backout._Emplace_back(_Val);
		}

	return (_Backout._Release());
	}

template<class _FwdIt,
	class _Diff,
	class _Tval> inline
	_FwdIt _Uninitialized_fill_n_unchecked1(const _FwdIt _First, const _Diff _Count, const _Tval& _Val, true_type)
	{	// copy _Count copies of _Val to raw _First, memset optimization
	:: memset(_First, static_cast<unsigned char>(_Val), _Count);
	return (_First + _Count);
	}

template<class _FwdIt,
	class _Diff,
	class _Tval> inline
	_FwdIt uninitialized_fill_n(_FwdIt _First, const _Diff _Count_raw, const _Tval& _Val)
	{	// copy _Count copies of _Val to raw _First
	_Algorithm_int_t<_Diff> _Count = _Count_raw;
	if (0 < _Count)
		{
		const auto _UFirst = _Get_unwrapped_n(_First, _Count);
		_Seek_wrapped(_First,
			_Uninitialized_fill_n_unchecked1(_UFirst, _Count, _Val, _Fill_memset_is_safe(_UFirst, _Val)));
		}

	return (_First);
	}



























































































































































































		// CLASS TEMPLATE raw_storage_iterator
template<class _OutIt,
	class _Ty>
	class  raw_storage_iterator
	{	// wrap stores to raw buffer as output iterator
public:
	using iterator_category = output_iterator_tag;
	using value_type = void;
	using difference_type = void;
	using pointer = void;
	using reference = void;

	explicit raw_storage_iterator(_OutIt _First)
		: _Next(_First)
		{	// construct with iterator
		}

	 raw_storage_iterator& operator*()
		{	// pretend to return designated value
		return (*this);
		}

	raw_storage_iterator& operator=(const _Ty& _Val)
		{	// construct value designated by stored iterator
		_Construct_in_place(*_Next, _Val);
		return (*this);
		}

	raw_storage_iterator& operator=(_Ty&& _Val)
		{	// construct value designated by stored iterator
		_Construct_in_place(*_Next, ::std:: move(_Val));
		return (*this);
		}

	raw_storage_iterator& operator++()
		{	// preincrement
		++_Next;
		return (*this);
		}

	raw_storage_iterator operator++(int)
		{	// postincrement
		raw_storage_iterator _Ans = *this;
		++_Next;
		return (_Ans);
		}

	 _OutIt base() const
		{	// return the stored iterator
		return (_Next);
		}

private:
	_OutIt _Next;	// the stored iterator
	};


 
		// CLASS TEMPLATE auto_ptr
template<class _Ty>
	class auto_ptr;

template<class _Ty>
	struct auto_ptr_ref
		{	// proxy reference for auto_ptr copying
	explicit auto_ptr_ref(_Ty * _Right)
		: _Ref(_Right)
		{	// construct from generic pointer to auto_ptr ptr
		}

	_Ty * _Ref;	// generic pointer to auto_ptr ptr
	};

template<class _Ty>
	class auto_ptr
	{	// wrap an object pointer to ensure destruction
public:
	typedef _Ty element_type;

	explicit auto_ptr(_Ty * _Ptr = nullptr) noexcept
		: _Myptr(_Ptr)
		{	// construct from object pointer
		}

	auto_ptr(auto_ptr& _Right) noexcept
		: _Myptr(_Right.release())
		{	// construct by assuming pointer from _Right auto_ptr
		}

	auto_ptr(auto_ptr_ref<_Ty> _Right) noexcept
		{	// construct by assuming pointer from _Right auto_ptr_ref
		_Ty * _Ptr = _Right._Ref;
		_Right._Ref = nullptr;	// release old
		_Myptr = _Ptr;	// reset this
		}

	template<class _Other>
		operator auto_ptr<_Other>() noexcept
		{	// convert to compatible auto_ptr
		return (auto_ptr<_Other>(*this));
		}

	template<class _Other>
		operator auto_ptr_ref<_Other>() noexcept
		{	// convert to compatible auto_ptr_ref
		_Other * _Cvtptr = _Myptr;	// test implicit conversion
		auto_ptr_ref<_Other> _Ans(_Cvtptr);
		_Myptr = nullptr;	// pass ownership to auto_ptr_ref
		return (_Ans);
		}

	template<class _Other>
		auto_ptr& operator=(auto_ptr<_Other>& _Right) noexcept
		{	// assign compatible _Right (assume pointer)
		reset(_Right.release());
		return (*this);
		}

	template<class _Other>
		auto_ptr(auto_ptr<_Other>& _Right) noexcept
		: _Myptr(_Right.release())
		{	// construct by assuming pointer from _Right
		}

	auto_ptr& operator=(auto_ptr& _Right) noexcept
		{	// assign compatible _Right (assume pointer)
		reset(_Right.release());
		return (*this);
		}

	auto_ptr& operator=(auto_ptr_ref<_Ty> _Right) noexcept
		{	// assign compatible _Right._Ref (assume pointer)
		_Ty * _Ptr = _Right._Ref;
		_Right._Ref = 0;	// release old
		reset(_Ptr);	// set new
		return (*this);
		}

	~auto_ptr() noexcept
		{	// destroy the object
		delete _Myptr;
		}

	 _Ty& operator*() const noexcept
		{	// return designated value
 
		do { if (_Myptr) { } else { do { (void) ((1 != _CrtDbgReport(2, "c:\\visual studio\\vc\\tools\\msvc\\14.16.27023\\include\\memory", 709, 0, "%s", "auto_ptr not dereferencable")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"auto_ptr not dereferencable\"", __LPREFIX( __FUNCTION__), L"c:\\visual studio\\vc\\tools\\msvc\\14.16.27023\\include\\memory", 709, 0); } while (false); } ; } while (false);
 

		return (*get());
		}

	 _Ty * operator->() const noexcept
		{	// return pointer to class object
 
		do { if (_Myptr) { } else { do { (void) ((1 != _CrtDbgReport(2, "c:\\visual studio\\vc\\tools\\msvc\\14.16.27023\\include\\memory", 718, 0, "%s", "auto_ptr not dereferencable")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"auto_ptr not dereferencable\"", __LPREFIX( __FUNCTION__), L"c:\\visual studio\\vc\\tools\\msvc\\14.16.27023\\include\\memory", 718, 0); } while (false); } ; } while (false);
 

		return (get());
		}

	 _Ty * get() const noexcept
		{	// return wrapped pointer
		return (_Myptr);
		}

	_Ty * release() noexcept
		{	// return wrapped pointer and give up ownership
		_Ty * _Tmp = _Myptr;
		_Myptr = nullptr;
		return (_Tmp);
		}

	void reset(_Ty * _Ptr = nullptr)
		{	// destroy designated object and store new pointer
		if (_Ptr != _Myptr)
			delete _Myptr;
		_Myptr = _Ptr;
		}

private:
	_Ty * _Myptr;	// the wrapped object pointer
	};

template<>
	class auto_ptr<void>
	{
public:
	typedef void element_type;
	};
 


	// CLASS bad_weak_ptr
class bad_weak_ptr
	: public exception
	{	// exception type for invalid use of expired weak_ptr object
public:
	bad_weak_ptr() noexcept
		{	// default construct
		}

	 virtual const char *  what() const noexcept override
		{	// return pointer to message string
		return ("bad_weak_ptr");
		}
	};

	// CLASS _Ref_count_base
class __declspec(novtable) _Ref_count_base
	{	// common code for reference counting
private:











	virtual void _Destroy() noexcept = 0;
	virtual void _Delete_this() noexcept = 0;


	_Atomic_counter_t _Uses;
	_Atomic_counter_t _Weaks;

protected:
	_Ref_count_base()
		: _Uses(1), _Weaks(1)	// non-atomic initializations
		{	// construct
		}

public:
	virtual ~_Ref_count_base() noexcept
		{	// TRANSITION, should be non-virtual
		}

	bool _Incref_nz()
		{	// increment use count if not zero, return true if successful
		for (;;)
			{	// loop until state is known
 
			const _Atomic_integral_t _Count =
				static_cast<volatile _Atomic_counter_t&>(_Uses);

			if (_Count == 0)
				return (false);

			if (static_cast<_Atomic_integral_t>(_InterlockedCompareExchange(
					reinterpret_cast<volatile long *>(&_Uses),
					static_cast<long>(_Count + 1), static_cast<long>(_Count))) == _Count)
				return (true);

 









			}
		}

	void _Incref()
		{	// increment use count
		_InterlockedIncrement(reinterpret_cast<volatile long *>(&_Uses));
		}

	void _Incwref()
		{	// increment weak reference count
		_InterlockedIncrement(reinterpret_cast<volatile long *>(&_Weaks));
		}

	void _Decref()
		{	// decrement use count
		if (_InterlockedDecrement(reinterpret_cast<volatile long *>(&_Uses)) == 0)
			{	// destroy managed resource, decrement weak reference count
			_Destroy();
			_Decwref();
			}
		}

	void _Decwref()
		{	// decrement weak reference count
		if (_InterlockedDecrement(reinterpret_cast<volatile long *>(&_Weaks)) == 0)
			{
			_Delete_this();
			}
		}

	long _Use_count() const noexcept
		{	// return use count
		return (static_cast<long>(_Get_atomic_count(_Uses)));
		}

	virtual void * _Get_deleter(const type_info&) const noexcept
		{	// return address of deleter object
		return (nullptr);
		}
	};

	// CLASS TEMPLATE _Ref_count
template<class _Ty>
	class _Ref_count
		: public _Ref_count_base
	{	// handle reference counting for pointer without deleter
public:
	explicit _Ref_count(_Ty * _Px)
		: _Ref_count_base(), _Ptr(_Px)
		{	// construct
		}

private:
	virtual void _Destroy() noexcept override
		{	// destroy managed resource
		delete _Ptr;
		}

	virtual void _Delete_this() noexcept override
		{	// destroy self
		delete this;
		}

	_Ty * _Ptr;
	};

	// CLASS TEMPLATE _Ref_count_resource
template<class _Resource,
	class _Dx>
	class _Ref_count_resource
		: public _Ref_count_base
	{	// handle reference counting for object with deleter
public:
	_Ref_count_resource(_Resource _Px, _Dx _Dt)
		: _Ref_count_base(), _Mypair(_One_then_variadic_args_t(), ::std:: move(_Dt), _Px)
		{	// construct
		}

	virtual void * _Get_deleter(const type_info& _Typeid) const noexcept override
		{	// return address of deleter object

		if (_Typeid == typeid(_Dx))
			{
			return (const_cast<_Dx *>(::std:: addressof(_Mypair._Get_first())));
			}




		return (nullptr);
		}

private:
	virtual void _Destroy() noexcept override
		{	// destroy managed resource
		_Mypair._Get_first()(_Mypair._Get_second());
		}

	virtual void _Delete_this() noexcept override
		{	// destroy self
		delete this;
		}

	_Compressed_pair<_Dx, _Resource> _Mypair;
	};

	// CLASS TEMPLATE _Ref_count_resource_alloc
template<class _Resource,
	class _Dx,
	class _Alloc>
	class _Ref_count_resource_alloc
		: public _Ref_count_base
	{	// handle reference counting for object with deleter and allocator
public:
	_Ref_count_resource_alloc(_Resource _Px, _Dx _Dt, const _Alloc& _Ax)
		: _Ref_count_base(), _Mypair(_One_then_variadic_args_t(), ::std:: move(_Dt),
			_One_then_variadic_args_t(), _Ax, _Px)
		{	// construct
		}

	virtual void * _Get_deleter(const type_info& _Typeid) const noexcept override
		{	// return address of deleter object

		if (_Typeid == typeid(_Dx))
			{
			return (const_cast<_Dx *>(::std:: addressof(_Mypair._Get_first())));
			}




		return (nullptr);
		}

private:
	using _Myalty = _Rebind_alloc_t<_Alloc, _Ref_count_resource_alloc>;

	virtual void _Destroy() noexcept override
		{	// destroy managed resource
		_Mypair._Get_first()(_Mypair._Get_second()._Get_second());
		}

	virtual void _Delete_this() noexcept override
		{	// destroy self
		_Myalty _Al = _Mypair._Get_second()._Get_first();
		allocator_traits<_Myalty>::destroy(_Al, this);
		_Deallocate_plain(_Al, this);
		}

	_Compressed_pair<_Dx, _Compressed_pair<_Myalty, _Resource>> _Mypair;
	};

	// DECLARATIONS
template<class _Ty>
	struct default_delete;

template<class _Ty,
	class _Dx = default_delete<_Ty>>
	class unique_ptr;

template<class _Ty>
	class shared_ptr;

template<class _Ty>
	class weak_ptr;

template<class _Yty,
	class = void>
	struct _Can_enable_shared
		: false_type
	{	// detect unambiguous and accessible inheritance from enable_shared_from_this
	};

template<class _Yty>
	struct _Can_enable_shared<_Yty, void_t<typename _Yty::_Esft_type>>
		: is_convertible<remove_cv_t<_Yty> *, typename _Yty::_Esft_type *>::type
	{	// is_convertible is necessary to verify unambiguous inheritance
	};

template<class _Other,
	class _Yty>
	void _Enable_shared_from_this1(const shared_ptr<_Other>& _This, _Yty * _Ptr, true_type)
	{	// enable shared_from_this
	if (_Ptr && _Ptr->_Wptr.expired())
		{
		_Ptr->_Wptr = shared_ptr<remove_cv_t<_Yty>>(_This, const_cast<remove_cv_t<_Yty> *>(_Ptr));
		}
	}

template<class _Other,
	class _Yty>
	void _Enable_shared_from_this1(const shared_ptr<_Other>&, _Yty *, false_type)
	{	// don't enable shared_from_this
	}

template<class _Other,
	class _Yty>
	void _Enable_shared_from_this(const shared_ptr<_Other>& _This, _Yty * _Ptr)
	{	// possibly enable shared_from_this
	_Enable_shared_from_this1(_This, _Ptr, bool_constant<conjunction_v<
		negation<is_array<_Other>>,
		negation<is_volatile<_Yty>>,
		_Can_enable_shared<_Yty>>>{});
	}

	// CLASS TEMPLATE _Ptr_base
template<class _Ty>
	class _Ptr_base
	{	// base class for shared_ptr and weak_ptr
public:
	using element_type = remove_extent_t<_Ty>;

	 long use_count() const noexcept
		{	// return use count
		return (_Rep ? _Rep->_Use_count() : 0);
		}

	template<class _Ty2>
		 bool owner_before(const _Ptr_base<_Ty2>& _Right) const noexcept
		{	// compare addresses of manager objects
		return (_Rep < _Right._Rep);
		}

	_Ptr_base(const _Ptr_base&) = delete;
	_Ptr_base& operator=(const _Ptr_base&) = delete;

protected:
	 element_type * get() const noexcept
		{	// return pointer to resource
		return (_Ptr);
		}

	constexpr _Ptr_base() noexcept = default;

	~_Ptr_base() = default;

	template<class _Ty2>
		void _Move_construct_from(_Ptr_base<_Ty2>&& _Right)
		{	// implement shared_ptr's (converting) move ctor and weak_ptr's move ctor
		_Ptr = _Right._Ptr;
		_Rep = _Right._Rep;

		_Right._Ptr = nullptr;
		_Right._Rep = nullptr;
		}

	template<class _Ty2>
		void _Copy_construct_from(const shared_ptr<_Ty2>& _Other)
		{	// implement shared_ptr's (converting) copy ctor
		if (_Other._Rep)
			{
			_Other._Rep->_Incref();
			}

		_Ptr = _Other._Ptr;
		_Rep = _Other._Rep;
		}

	template<class _Ty2>
		void _Alias_construct_from(const shared_ptr<_Ty2>& _Other, element_type * _Px)
		{	// implement shared_ptr's aliasing ctor
		if (_Other._Rep)
			{
			_Other._Rep->_Incref();
			}

		_Ptr = _Px;
		_Rep = _Other._Rep;
		}

	template<class _Ty0>
		friend class weak_ptr;	// specifically, weak_ptr::lock()

	template<class _Ty2>
		bool _Construct_from_weak(const weak_ptr<_Ty2>& _Other)
		{	// implement shared_ptr's ctor from weak_ptr, and weak_ptr::lock()
		if (_Other._Rep && _Other._Rep->_Incref_nz())
			{
			_Ptr = _Other._Ptr;
			_Rep = _Other._Rep;
			return (true);
			}

		return (false);
		}

	void _Decref()
		{	// decrement reference count
		if (_Rep)
			{
			_Rep->_Decref();
			}
		}

	void _Swap(_Ptr_base& _Right) noexcept
		{	// swap pointers
		::std:: swap(_Ptr, _Right._Ptr);
		::std:: swap(_Rep, _Right._Rep);
		}

	void _Set_ptr_rep(element_type * _Other_ptr, _Ref_count_base * _Other_rep)
		{	// take new resource
		_Ptr = _Other_ptr;
		_Rep = _Other_rep;
		}

	template<class _Ty2>
		void _Weakly_construct_from(const _Ptr_base<_Ty2>& _Other)
		{	// implement weak_ptr's ctors
		if (_Other._Rep)
			{
			_Other._Rep->_Incwref();
			}

		_Ptr = _Other._Ptr;
		_Rep = _Other._Rep;
		}

	void _Decwref()
		{	// decrement weak reference count
		if (_Rep)
			{
			_Rep->_Decwref();
			}
		}

private:
	element_type * _Ptr{nullptr};
	_Ref_count_base * _Rep{nullptr};

	template<class _Ty0>
		friend class _Ptr_base;


	template<class _Dx,
		class _Ty0>
		friend _Dx * get_deleter(const shared_ptr<_Ty0>& _Sx) noexcept;

	};

	// TYPE TRAIT _Can_scalar_delete
template<class _Yty,
	class = void>
	struct _Can_scalar_delete
		: false_type
	{};
template<class _Yty>
	struct _Can_scalar_delete<_Yty, void_t<decltype(delete ::std:: declval<_Yty *>())>>
		: true_type
	{};

	// TYPE TRAIT _Can_array_delete
template<class _Yty,
	class = void>
	struct _Can_array_delete
		: false_type
	{};
template<class _Yty>
	struct _Can_array_delete<_Yty, void_t<decltype(delete[] ::std:: declval<_Yty *>())>>
		: true_type
	{};

	// TYPE TRAIT _Can_call_function_object
template<class _Fx,
	class _Arg,
	class = void>
	struct _Can_call_function_object
		: false_type
	{};
template<class _Fx,
	class _Arg>
	struct _Can_call_function_object<_Fx, _Arg, void_t<decltype(::std:: declval<_Fx>()(::std:: declval<_Arg>()))>>
		: true_type
	{};

	// TYPE TRAIT _SP_convertible
template<class _Yty,
	class _Ty>
	struct _SP_convertible
		: is_convertible<_Yty *, _Ty *>::type
	{};
template<class _Yty,
	class _Uty>
	struct _SP_convertible<_Yty, _Uty[]>
		: is_convertible<_Yty(*)[], _Uty(*)[]>::type
	{};
template<class _Yty,
	class _Uty,
	size_t _Ext>
	struct _SP_convertible<_Yty, _Uty[_Ext]>
		: is_convertible<_Yty(*)[_Ext], _Uty(*)[_Ext]>::type
	{};

	// TYPE TRAIT _SP_pointer_compatible
template<class _Yty,
	class _Ty>
	struct _SP_pointer_compatible
		: is_convertible<_Yty *, _Ty *>::type
	{	// N4659 [util.smartptr.shared]/5 "a pointer type Y* is said to be compatible with a pointer type T* "
		// "when either Y* is convertible to T* ..."
	};
template<class _Uty,
	size_t _Ext>
	struct _SP_pointer_compatible<_Uty[_Ext], _Uty[]>
		: true_type
	{	// N4659 [util.smartptr.shared]/5 "... or Y is U[N] and T is cv U[]."
	};
template<class _Uty,
	size_t _Ext>
	struct _SP_pointer_compatible<_Uty[_Ext], const _Uty[]>
		: true_type
	{	// N4659 [util.smartptr.shared]/5 "... or Y is U[N] and T is cv U[]."
	};
template<class _Uty,
	size_t _Ext>
	struct _SP_pointer_compatible<_Uty[_Ext], volatile _Uty[]>
		: true_type
	{	// N4659 [util.smartptr.shared]/5 "... or Y is U[N] and T is cv U[]."
	};
template<class _Uty,
	size_t _Ext>
	struct _SP_pointer_compatible<_Uty[_Ext], const volatile _Uty[]>
		: true_type
	{	// N4659 [util.smartptr.shared]/5 "... or Y is U[N] and T is cv U[]."
	};

	// CLASS TEMPLATE shared_ptr
template<class _Ty>
	class shared_ptr
		: public _Ptr_base<_Ty>
	{	// class for reference counted resource management
private:
	using _Mybase = _Ptr_base<_Ty>;

public:
	using typename _Mybase::element_type;





	constexpr shared_ptr() noexcept
		{	// construct empty shared_ptr
		}

	constexpr shared_ptr(nullptr_t) noexcept
		{	// construct empty shared_ptr
		}

	template<class _Ux,
		enable_if_t<conjunction_v<conditional_t<is_array_v<_Ty>, _Can_array_delete<_Ux>, _Can_scalar_delete<_Ux>>,
			_SP_convertible<_Ux, _Ty>>, int> = 0>
		explicit shared_ptr(_Ux * _Px)
		{	// construct shared_ptr object that owns _Px
		_Setp(_Px, is_array<_Ty>{});
		}

	template<class _Ux,
		class _Dx,
		enable_if_t<conjunction_v<is_move_constructible<_Dx>,
			_Can_call_function_object<_Dx&, _Ux *&>,
			_SP_convertible<_Ux, _Ty>>, int> = 0>
		shared_ptr(_Ux * _Px, _Dx _Dt)
		{	// construct with _Px, deleter
		_Setpd(_Px, ::std:: move(_Dt));
		}

	template<class _Ux,
		class _Dx,
		class _Alloc,
		enable_if_t<conjunction_v<is_move_constructible<_Dx>,
			_Can_call_function_object<_Dx&, _Ux *&>,
			_SP_convertible<_Ux, _Ty>>, int> = 0>
		shared_ptr(_Ux * _Px, _Dx _Dt, _Alloc _Ax)
		{	// construct with _Px, deleter, allocator
		_Setpda(_Px, ::std:: move(_Dt), _Ax);
		}

	template<class _Dx,
		enable_if_t<conjunction_v<is_move_constructible<_Dx>,
			_Can_call_function_object<_Dx&, nullptr_t&>
		>, int> = 0>
		shared_ptr(nullptr_t, _Dx _Dt)
		{	// construct with nullptr, deleter
		_Setpd(nullptr, ::std:: move(_Dt));
		}

	template<class _Dx,
		class _Alloc,
		enable_if_t<conjunction_v<is_move_constructible<_Dx>,
			_Can_call_function_object<_Dx&, nullptr_t&>
		>, int> = 0>
		shared_ptr(nullptr_t, _Dx _Dt, _Alloc _Ax)
		{	// construct with nullptr, deleter, allocator
		_Setpda(nullptr, ::std:: move(_Dt), _Ax);
		}

	template<class _Ty2>
		shared_ptr(const shared_ptr<_Ty2>& _Right, element_type * _Px) noexcept
		{	// construct shared_ptr object that aliases _Right
		this->_Alias_construct_from(_Right, _Px);
		}

	shared_ptr(const shared_ptr& _Other) noexcept
		{	// construct shared_ptr object that owns same resource as _Other
		this->_Copy_construct_from(_Other);
		}

	template<class _Ty2,
		enable_if_t<_SP_pointer_compatible<_Ty2, _Ty>::value, int> = 0>
		shared_ptr(const shared_ptr<_Ty2>& _Other) noexcept
		{	// construct shared_ptr object that owns same resource as _Other
		this->_Copy_construct_from(_Other);
		}

	shared_ptr(shared_ptr&& _Right) noexcept
		{	// construct shared_ptr object that takes resource from _Right
		this->_Move_construct_from(::std:: move(_Right));
		}

	template<class _Ty2,
		enable_if_t<_SP_pointer_compatible<_Ty2, _Ty>::value, int> = 0>
		shared_ptr(shared_ptr<_Ty2>&& _Right) noexcept
		{	// construct shared_ptr object that takes resource from _Right
		this->_Move_construct_from(::std:: move(_Right));
		}

	template<class _Ty2,
		enable_if_t<_SP_pointer_compatible<_Ty2, _Ty>::value, int> = 0>
		explicit shared_ptr(const weak_ptr<_Ty2>& _Other)
		{	// construct shared_ptr object that owns resource *_Other
		if (!this->_Construct_from_weak(_Other))
			{
			throw bad_weak_ptr{};
			}
		}

 
	template<class _Ty2,
		enable_if_t<is_convertible_v<_Ty2 *, _Ty *>, int> = 0>
		shared_ptr(auto_ptr<_Ty2>&& _Other)
		{	// construct shared_ptr object that owns *_Other.get()
		_Ty2 * _Px = _Other.get();
		_Set_ptr_rep_and_enable_shared(_Px, new _Ref_count<_Ty2>(_Px));
		_Other.release();
		}
 

	template<class _Ux,
		class _Dx,
		enable_if_t<conjunction_v<
			_SP_pointer_compatible<_Ux, _Ty>,
			is_convertible<typename unique_ptr<_Ux, _Dx>::pointer, element_type *>
		>, int> = 0>
		shared_ptr(unique_ptr<_Ux, _Dx>&& _Other)
		{	// construct from unique_ptr
		using _Fancy_t = typename unique_ptr<_Ux, _Dx>::pointer;
		using _Raw_t = typename unique_ptr<_Ux, _Dx>::element_type *;
		using _Deleter_t = conditional_t<is_reference_v<_Dx>, decltype(::std:: ref(_Other.get_deleter())), _Dx>;

		const _Fancy_t _Fancy = _Other.get();

		if (_Fancy)
			{
			const _Raw_t _Raw = _Fancy;
			const auto _Rx = new _Ref_count_resource<_Fancy_t, _Deleter_t>(_Fancy, _Other.get_deleter());
			_Set_ptr_rep_and_enable_shared(_Raw, _Rx);
			_Other.release();
			}
		}

	~shared_ptr() noexcept
		{	// release resource
		this->_Decref();
		}

	shared_ptr& operator=(const shared_ptr& _Right) noexcept
		{	// assign shared ownership of resource owned by _Right
		shared_ptr(_Right).swap(*this);
		return (*this);
		}

	template<class _Ty2>
		shared_ptr& operator=(const shared_ptr<_Ty2>& _Right) noexcept
		{	// assign shared ownership of resource owned by _Right
		shared_ptr(_Right).swap(*this);
		return (*this);
		}

	shared_ptr& operator=(shared_ptr&& _Right) noexcept
		{	// take resource from _Right
		shared_ptr(::std:: move(_Right)).swap(*this);
		return (*this);
		}

	template<class _Ty2>
		shared_ptr& operator=(shared_ptr<_Ty2>&& _Right) noexcept
		{	// take resource from _Right
		shared_ptr(::std:: move(_Right)).swap(*this);
		return (*this);
		}

 
	template<class _Ty2>
		shared_ptr& operator=(auto_ptr<_Ty2>&& _Right)
		{	// assign ownership of resource pointed to by _Right
		shared_ptr(::std:: move(_Right)).swap(*this);
		return (*this);
		}
 

	template<class _Ux,
		class _Dx>
		shared_ptr& operator=(unique_ptr<_Ux, _Dx>&& _Right)
		{	// move from unique_ptr
		shared_ptr(::std:: move(_Right)).swap(*this);
		return (*this);
		}

	void swap(shared_ptr& _Other) noexcept
		{	// swap pointers
		this->_Swap(_Other);
		}

	void reset() noexcept
		{	// release resource and convert to empty shared_ptr object
		shared_ptr().swap(*this);
		}

	template<class _Ux>
		void reset(_Ux * _Px)
		{	// release, take ownership of _Px
		shared_ptr(_Px).swap(*this);
		}

	template<class _Ux,
		class _Dx>
		void reset(_Ux * _Px, _Dx _Dt)
		{	// release, take ownership of _Px, with deleter _Dt
		shared_ptr(_Px, _Dt).swap(*this);
		}

	template<class _Ux,
		class _Dx,
		class _Alloc>
		void reset(_Ux * _Px, _Dx _Dt, _Alloc _Ax)
		{	// release, take ownership of _Px, with deleter _Dt, allocator _Ax
		shared_ptr(_Px, _Dt, _Ax).swap(*this);
		}

	using _Mybase::get;

	template<class _Ty2 = _Ty,
		enable_if_t<!disjunction_v<is_array<_Ty2>, is_void<_Ty2>>, int> = 0>
		 _Ty2& operator*() const noexcept
		{	// return reference to resource
		return (*get());
		}

	template<class _Ty2 = _Ty,
		enable_if_t<!is_array_v<_Ty2>, int> = 0>
		 _Ty2 * operator->() const noexcept
		{	// return pointer to resource
		return (get());
		}

	template<class _Ty2 = _Ty,
		class _Elem = element_type,
		enable_if_t<is_array_v<_Ty2>, int> = 0>
		 _Elem& operator[](ptrdiff_t _Idx) const
		{	// subscript
		return (get()[_Idx]);
		}

	  bool unique() const noexcept
		{	// return true if no other shared_ptr object owns this resource
		return (this->use_count() == 1);
		}

	explicit operator bool() const noexcept
		{	// test if shared_ptr object owns a resource
		return (get() != nullptr);
		}

private:
	template<class _Ux>
		void _Setp(_Ux * _Px, true_type)
		{	// take ownership of _Px
		_Setpd(_Px, default_delete<_Ux[]>{});
		}

	template<class _Ux>
		void _Setp(_Ux * _Px, false_type)
		{	// take ownership of _Px
		try {	// allocate control block and set
		_Set_ptr_rep_and_enable_shared(_Px, new _Ref_count<_Ux>(_Px));
		} catch (...) {	// allocation failed, delete resource
		delete _Px;
		throw;
		}
		}

	template<class _UxptrOrNullptr,
		class _Dx>
		void _Setpd(_UxptrOrNullptr _Px, _Dx _Dt)
		{	// take ownership of _Px, deleter _Dt
		try {	// allocate control block and set
		_Set_ptr_rep_and_enable_shared(_Px, new _Ref_count_resource<_UxptrOrNullptr, _Dx>(_Px, ::std:: move(_Dt)));
		} catch (...) {	// allocation failed, delete resource
		_Dt(_Px);
		throw;
		}
		}

	template<class _UxptrOrNullptr,
		class _Dx,
		class _Alloc>
		void _Setpda(_UxptrOrNullptr _Px, _Dx _Dt, _Alloc _Ax)
		{	// take ownership of _Px, deleter _Dt, allocator _Ax
		using _Refd = _Ref_count_resource_alloc<_UxptrOrNullptr, _Dx, _Alloc>;
		using _Alref_alloc = _Rebind_alloc_t<_Alloc, _Refd>;
		using _Alref_traits = allocator_traits<_Alref_alloc>;
		_Alref_alloc _Alref(_Ax);

		try {	// allocate control block and set
		const auto _Pfancy = _Alref_traits::allocate(_Alref, 1);
		_Refd * const _Pref = _Unfancy(_Pfancy);
			try {
			_Alref_traits::construct(_Alref, _Pref, _Px, ::std:: move(_Dt), _Ax);
			_Set_ptr_rep_and_enable_shared(_Px, _Pref);
			} catch (...) {
			_Alref_traits::deallocate(_Alref, _Pfancy, 1);
			throw;
			}
		} catch (...) {	// allocation failed, delete resource
		_Dt(_Px);
		throw;
		}
		}

	template<class _Ty0,
		class... _Types>
		friend shared_ptr<_Ty0> make_shared(_Types&&... _Args);

	template<class _Ty0,
		class _Alloc,
		class... _Types>
		friend shared_ptr<_Ty0> allocate_shared(const _Alloc& _Al_arg, _Types&&... _Args);

	template<class _Ux>
		void _Set_ptr_rep_and_enable_shared(_Ux * _Px, _Ref_count_base * _Rx)
		{	// take ownership of _Px
		this->_Set_ptr_rep(_Px, _Rx);
		_Enable_shared_from_this(*this, _Px);
		}

	void _Set_ptr_rep_and_enable_shared(nullptr_t, _Ref_count_base * _Rx)
		{	// take ownership of nullptr
		this->_Set_ptr_rep(nullptr, _Rx);
		}
	};










template<class _Ty1,
	class _Ty2>
	 bool operator==(const shared_ptr<_Ty1>& _Left, const shared_ptr<_Ty2>& _Right) noexcept
	{
	return (_Left.get() == _Right.get());
	}

template<class _Ty1,
	class _Ty2>
	 bool operator!=(const shared_ptr<_Ty1>& _Left, const shared_ptr<_Ty2>& _Right) noexcept
	{
	return (_Left.get() != _Right.get());
	}

template<class _Ty1,
	class _Ty2>
	 bool operator<(const shared_ptr<_Ty1>& _Left, const shared_ptr<_Ty2>& _Right) noexcept
	{
	return (_Left.get() < _Right.get());
	}

template<class _Ty1,
	class _Ty2>
	 bool operator>=(const shared_ptr<_Ty1>& _Left, const shared_ptr<_Ty2>& _Right) noexcept
	{
	return (_Left.get() >= _Right.get());
	}

template<class _Ty1,
	class _Ty2>
	 bool operator>(const shared_ptr<_Ty1>& _Left, const shared_ptr<_Ty2>& _Right) noexcept
	{
	return (_Left.get() > _Right.get());
	}

template<class _Ty1,
	class _Ty2>
	 bool operator<=(const shared_ptr<_Ty1>& _Left, const shared_ptr<_Ty2>& _Right) noexcept
	{
	return (_Left.get() <= _Right.get());
	}

template<class _Ty>
	 bool operator==(const shared_ptr<_Ty>& _Left, nullptr_t) noexcept
	{
	return (_Left.get() == nullptr);
	}

template<class _Ty>
	 bool operator==(nullptr_t, const shared_ptr<_Ty>& _Right) noexcept
	{
	return (nullptr == _Right.get());
	}

template<class _Ty>
	 bool operator!=(const shared_ptr<_Ty>& _Left, nullptr_t) noexcept
	{
	return (_Left.get() != nullptr);
	}

template<class _Ty>
	 bool operator!=(nullptr_t, const shared_ptr<_Ty>& _Right) noexcept
	{
	return (nullptr != _Right.get());
	}

template<class _Ty>
	 bool operator<(const shared_ptr<_Ty>& _Left, nullptr_t) noexcept
	{
	return (_Left.get() < static_cast<typename shared_ptr<_Ty>::element_type *>(nullptr));
	}

template<class _Ty>
	 bool operator<(nullptr_t, const shared_ptr<_Ty>& _Right) noexcept
	{
	return (static_cast<typename shared_ptr<_Ty>::element_type *>(nullptr) < _Right.get());
	}

template<class _Ty>
	 bool operator>=(const shared_ptr<_Ty>& _Left, nullptr_t) noexcept
	{
	return (_Left.get() >= static_cast<typename shared_ptr<_Ty>::element_type *>(nullptr));
	}

template<class _Ty>
	 bool operator>=(nullptr_t, const shared_ptr<_Ty>& _Right) noexcept
	{
	return (static_cast<typename shared_ptr<_Ty>::element_type *>(nullptr) >= _Right.get());
	}

template<class _Ty>
	 bool operator>(const shared_ptr<_Ty>& _Left, nullptr_t) noexcept
	{
	return (_Left.get() > static_cast<typename shared_ptr<_Ty>::element_type *>(nullptr));
	}

template<class _Ty>
	 bool operator>(nullptr_t, const shared_ptr<_Ty>& _Right) noexcept
	{
	return (static_cast<typename shared_ptr<_Ty>::element_type *>(nullptr) > _Right.get());
	}

template<class _Ty>
	 bool operator<=(const shared_ptr<_Ty>& _Left, nullptr_t) noexcept
	{
	return (_Left.get() <= static_cast<typename shared_ptr<_Ty>::element_type *>(nullptr));
	}

template<class _Ty>
	 bool operator<=(nullptr_t, const shared_ptr<_Ty>& _Right) noexcept
	{
	return (static_cast<typename shared_ptr<_Ty>::element_type *>(nullptr) <= _Right.get());
	}

template<class _Elem,
	class _Traits,
	class _Ty>
	basic_ostream<_Elem, _Traits>& operator<<(basic_ostream<_Elem, _Traits>& _Out, const shared_ptr<_Ty>& _Px)
	{	// write contained pointer to stream
	return (_Out << _Px.get());
	}

template<class _Ty>
	void swap(shared_ptr<_Ty>& _Left, shared_ptr<_Ty>& _Right) noexcept
	{	// swap _Left and _Right shared_ptrs
	_Left.swap(_Right);
	}

template<class _Ty1,
	class _Ty2>
	 shared_ptr<_Ty1> static_pointer_cast(const shared_ptr<_Ty2>& _Other) noexcept
	{	// static_cast for shared_ptr that properly respects the reference count control block
	const auto _Ptr = static_cast<typename shared_ptr<_Ty1>::element_type *>(_Other.get());
	return (shared_ptr<_Ty1>(_Other, _Ptr));
	}

template<class _Ty1,
	class _Ty2>
	 shared_ptr<_Ty1> const_pointer_cast(const shared_ptr<_Ty2>& _Other) noexcept
	{	// const_cast for shared_ptr that properly respects the reference count control block
	const auto _Ptr = const_cast<typename shared_ptr<_Ty1>::element_type *>(_Other.get());
	return (shared_ptr<_Ty1>(_Other, _Ptr));
	}

template<class _Ty1,
	class _Ty2>
	 shared_ptr<_Ty1> reinterpret_pointer_cast(const shared_ptr<_Ty2>& _Other) noexcept
	{	// reinterpret_cast for shared_ptr that properly respects the reference count control block
	const auto _Ptr = reinterpret_cast<typename shared_ptr<_Ty1>::element_type *>(_Other.get());
	return (shared_ptr<_Ty1>(_Other, _Ptr));
	}


template<class _Ty1,
	class _Ty2>
	 shared_ptr<_Ty1> dynamic_pointer_cast(const shared_ptr<_Ty2>& _Other) noexcept
	{	// dynamic_cast for shared_ptr that properly respects the reference count control block
	const auto _Ptr = dynamic_cast<typename shared_ptr<_Ty1>::element_type *>(_Other.get());

	if (_Ptr)
		{
		return (shared_ptr<_Ty1>(_Other, _Ptr));
		}

	return (shared_ptr<_Ty1>());
	}







template<class _Dx,
	class _Ty>
	 _Dx * get_deleter(const shared_ptr<_Ty>& _Sx) noexcept
	{	// return pointer to shared_ptr's deleter object if its type is _Dx
	if (_Sx._Rep)
		{
		return (static_cast<_Dx *>(_Sx._Rep->_Get_deleter(typeid(_Dx))));
		}

	return (nullptr);
	}






	// CLASS TEMPLATE _Ref_count_obj
template<class _Ty>
	class _Ref_count_obj
		: public _Ref_count_base
	{	// handle reference counting for object in control block, no allocator
public:
	template<class... _Types>
		explicit _Ref_count_obj(_Types&&... _Args)
		: _Ref_count_base()
		{	// construct from argument list
		::new (static_cast<void *>(&_Storage)) _Ty(::std:: forward<_Types>(_Args)...);
		}

	_Ty * _Getptr()
		{	// get pointer
		return (reinterpret_cast<_Ty *>(&_Storage));
		}

private:
	virtual void _Destroy() noexcept override
		{	// destroy managed resource
		_Getptr()->~_Ty();
		}

	virtual void _Delete_this() noexcept override
		{	// destroy self
		delete this;
		}

	aligned_union_t<1, _Ty> _Storage;
	};

	// CLASS TEMPLATE _Ref_count_obj_alloc
template<class _Ty,
	class _Alloc>
	class _Ref_count_obj_alloc
		: public _Ref_count_base
	{	// handle reference counting for object in control block, allocator
public:
	template<class... _Types>
		explicit _Ref_count_obj_alloc(const _Alloc& _Al_arg, _Types&&... _Args)
		: _Ref_count_base(), _Mypair(_One_then_variadic_args_t(), _Al_arg)
		{	// construct from argument list, allocator
		::new (static_cast<void *>(&_Mypair._Get_second())) _Ty(::std:: forward<_Types>(_Args)...);
		}

	_Ty * _Getptr()
		{	// get pointer
		return (reinterpret_cast<_Ty *>(&_Mypair._Get_second()));
		}

private:
	using _Myalty = _Rebind_alloc_t<_Alloc, _Ref_count_obj_alloc>;
	using _Mystoragety = aligned_union_t<1, _Ty>;

	virtual void _Destroy() noexcept override
		{	// destroy managed resource
		_Getptr()->~_Ty();
		}

	virtual void _Delete_this() noexcept override
		{	// destroy self
		_Myalty _Al = _Mypair._Get_first();
		allocator_traits<_Myalty>::destroy(_Al, this);
		_Deallocate_plain(_Al, this);
		}

	_Compressed_pair<_Myalty, _Mystoragety> _Mypair;
	};

	// FUNCTION TEMPLATE make_shared
template<class _Ty,
	class... _Types>
	 inline shared_ptr<_Ty> make_shared(_Types&&... _Args)
	{	// make a shared_ptr
	const auto _Rx = new _Ref_count_obj<_Ty>(::std:: forward<_Types>(_Args)...);

	shared_ptr<_Ty> _Ret;
	_Ret._Set_ptr_rep_and_enable_shared(_Rx->_Getptr(), _Rx);
	return (_Ret);
	}

	// FUNCTION TEMPLATE allocate_shared
template<class _Ty,
	class _Alloc,
	class... _Types>
	 inline shared_ptr<_Ty> allocate_shared(const _Alloc& _Al_arg, _Types&&... _Args)
	{	// make a shared_ptr
	using _Refoa = _Ref_count_obj_alloc<_Ty, _Alloc>;
	using _Alref_alloc = _Rebind_alloc_t<_Alloc, _Refoa>;
	using _Alref_traits = allocator_traits<_Alref_alloc>;
	_Alref_alloc _Alref(_Al_arg);

	const auto _Rx = _Alref_traits::allocate(_Alref, 1);

	try {
		_Alref_traits::construct(_Alref, _Unfancy(_Rx), _Al_arg, ::std:: forward<_Types>(_Args)...);
	} catch (...) {
		_Alref_traits::deallocate(_Alref, _Rx, 1);
	throw;
	}

	shared_ptr<_Ty> _Ret;
	_Ret._Set_ptr_rep_and_enable_shared(_Rx->_Getptr(), _Unfancy(_Rx));
	return (_Ret);
	}

	// CLASS TEMPLATE weak_ptr
template<class _Ty>
	class weak_ptr
		: public _Ptr_base<_Ty>
	{	// class for pointer to reference counted resource
public:
	constexpr weak_ptr() noexcept
		{	// construct empty weak_ptr object
		}

	weak_ptr(const weak_ptr& _Other) noexcept
		{	// construct weak_ptr object for resource pointed to by _Other
		this->_Weakly_construct_from(_Other);
		}

	template<class _Ty2,
		enable_if_t<_SP_pointer_compatible<_Ty2, _Ty>::value, int> = 0>
		weak_ptr(const shared_ptr<_Ty2>& _Other) noexcept
		{	// construct weak_ptr object for resource owned by _Other
		this->_Weakly_construct_from(_Other);
		}

	template<class _Ty2,
		enable_if_t<_SP_pointer_compatible<_Ty2, _Ty>::value, int> = 0>
		weak_ptr(const weak_ptr<_Ty2>& _Other) noexcept
		{	// construct weak_ptr object for resource pointed to by _Other
		this->_Weakly_construct_from(_Other.lock());
		}

	weak_ptr(weak_ptr&& _Other) noexcept
		{	// move construct from _Other
		this->_Move_construct_from(::std:: move(_Other));
		}

	template<class _Ty2,
		enable_if_t<_SP_pointer_compatible<_Ty2, _Ty>::value, int> = 0>
		weak_ptr(weak_ptr<_Ty2>&& _Other) noexcept
		{	// move construct from _Other
		this->_Weakly_construct_from(_Other.lock());
		_Other.reset();
		}

	~weak_ptr() noexcept
		{	// release resource
		this->_Decwref();
		}

	weak_ptr& operator=(const weak_ptr& _Right) noexcept
		{	// assign from _Right
		weak_ptr(_Right).swap(*this);
		return (*this);
		}

	template<class _Ty2>
		weak_ptr& operator=(const weak_ptr<_Ty2>& _Right) noexcept
		{	// assign from _Right
		weak_ptr(_Right).swap(*this);
		return (*this);
		}

	weak_ptr& operator=(weak_ptr&& _Right) noexcept
		{	// move assign from _Right
		weak_ptr(::std:: move(_Right)).swap(*this);
		return (*this);
		}

	template<class _Ty2>
		weak_ptr& operator=(weak_ptr<_Ty2>&& _Right) noexcept
		{	// move assign from _Right
		weak_ptr(::std:: move(_Right)).swap(*this);
		return (*this);
		}

	template<class _Ty2>
		weak_ptr& operator=(const shared_ptr<_Ty2>& _Right) noexcept
		{	// assign from _Right
		weak_ptr(_Right).swap(*this);
		return (*this);
		}

	void reset() noexcept
		{	// release resource, convert to null weak_ptr object
		weak_ptr().swap(*this);
		}

	void swap(weak_ptr& _Other) noexcept
		{	// swap pointers
		this->_Swap(_Other);
		}

	 bool expired() const noexcept
		{	// return true if resource no longer exists
		return (this->use_count() == 0);
		}

	 shared_ptr<_Ty> lock() const noexcept
		{	// convert to shared_ptr
		shared_ptr<_Ty> _Ret;
		(void) _Ret._Construct_from_weak(*this);
		return (_Ret);
		}
	};






template<class _Ty>
	void swap(weak_ptr<_Ty>& _Left, weak_ptr<_Ty>& _Right) noexcept
	{	// swap contents of _Left and _Right
	_Left.swap(_Right);
	}

	// CLASS TEMPLATE enable_shared_from_this
template<class _Ty>
	class enable_shared_from_this
	{	// provide member functions that create shared_ptr to this
public:
	using _Esft_type = enable_shared_from_this;

	 shared_ptr<_Ty> shared_from_this()
		{	// return shared_ptr
		return (shared_ptr<_Ty>(_Wptr));
		}

	 shared_ptr<const _Ty> shared_from_this() const
		{	// return shared_ptr
		return (shared_ptr<const _Ty>(_Wptr));
		}

	 weak_ptr<_Ty> weak_from_this() noexcept
		{	// return weak_ptr
		return (_Wptr);
		}

	 weak_ptr<const _Ty> weak_from_this() const noexcept
		{	// return weak_ptr
		return (_Wptr);
		}

protected:
	constexpr enable_shared_from_this() noexcept
		: _Wptr()
		{	// construct
		}

	enable_shared_from_this(const enable_shared_from_this&) noexcept
		: _Wptr()
		{	// construct (must value-initialize _Wptr)
		}

	enable_shared_from_this& operator=(const enable_shared_from_this&) noexcept
		{	// assign (must not change _Wptr)
		return (*this);
		}

	~enable_shared_from_this() = default;

private:
	template<class _Other,
		class _Yty>
		friend void _Enable_shared_from_this1(const shared_ptr<_Other>& _This, _Yty * _Ptr, true_type);

	mutable weak_ptr<_Ty> _Wptr;
	};


	// CLASS TEMPLATE unique_ptr AND HELPERS

	// STRUCT TEMPLATE default_delete
template<class _Ty>
	struct default_delete
	{	// default deleter for unique_ptr
	constexpr default_delete() noexcept = default;

	template<class _Ty2,
		enable_if_t<is_convertible_v<_Ty2 *, _Ty *>, int> = 0>
		default_delete(const default_delete<_Ty2>&) noexcept
		{	// construct from another default_delete
		}

	void operator()(_Ty * _Ptr) const noexcept
		{	// delete a pointer
		static_assert(0 < sizeof (_Ty),
			"can't delete an incomplete type");
		delete _Ptr;
		}
	};

template<class _Ty>
	struct default_delete<_Ty[]>
	{	// default deleter for unique_ptr to array of unknown size
	constexpr default_delete() noexcept = default;

	template<class _Uty,
		enable_if_t<is_convertible_v<_Uty(*)[], _Ty(*)[]>, int> = 0>
		default_delete(const default_delete<_Uty[]>&) noexcept
		{	// construct from another default_delete
		}

	template<class _Uty,
		enable_if_t<is_convertible_v<_Uty(*)[], _Ty(*)[]>, int> = 0>
		void operator()(_Uty * _Ptr) const noexcept
		{	// delete a pointer
		static_assert(0 < sizeof (_Uty),
			"can't delete an incomplete type");
		delete[] _Ptr;
		}
	};

		// STRUCT TEMPLATE _Get_deleter_pointer_type
template<class _Ty,
	class _Dx_noref,
	class = void>
	struct _Get_deleter_pointer_type
	{	// provide fallback
	typedef _Ty * type;
	};

template<class _Ty,
	class _Dx_noref>
	struct _Get_deleter_pointer_type<_Ty, _Dx_noref, void_t<typename _Dx_noref::pointer>>
	{	// get _Dx_noref::pointer
	typedef typename _Dx_noref::pointer type;
	};

	// CLASS TEMPLATE _Unique_ptr_base
template<class _Ty,
	class _Dx>
	class _Unique_ptr_base
	{	// stores pointer and deleter
public:
	typedef remove_reference_t<_Dx> _Dx_noref;
	typedef typename _Get_deleter_pointer_type<_Ty, _Dx_noref>::type pointer;

	template<class _Ptr2,
		class _Dx2>
		_Unique_ptr_base(_Ptr2 _Ptr, _Dx2&& _Dt)
		: _Mypair(_One_then_variadic_args_t(), ::std:: forward<_Dx2>(_Dt), _Ptr)
		{	// construct with compatible pointer and deleter
		}

	template<class _Ptr2>
		constexpr _Unique_ptr_base(_Ptr2 _Ptr)
		: _Mypair(_Zero_then_variadic_args_t(), _Ptr)
		{	// construct with compatible pointer
		}

	 _Dx& get_deleter() noexcept
		{	// return reference to deleter
		return (_Mypair._Get_first());
		}

	 const _Dx& get_deleter() const noexcept
		{	// return const reference to deleter
		return (_Mypair._Get_first());
		}

	pointer& _Myptr() noexcept
		{	// return reference to pointer
		return (_Mypair._Get_second());
		}

	const pointer& _Myptr() const noexcept
		{	// return const reference to pointer
		return (_Mypair._Get_second());
		}

	_Compressed_pair<_Dx, pointer> _Mypair;
	};

template<class _Dx2>
	using _Unique_ptr_enable_default_t = enable_if_t<conjunction_v<negation<is_pointer<_Dx2>>,
		is_default_constructible<_Dx2>>, int>;

	// CLASS TEMPLATE unique_ptr SCALAR
template<class _Ty,
	class _Dx>	// = default_delete<_Ty>
	class unique_ptr
		: public _Unique_ptr_base<_Ty, _Dx>
	{	// non-copyable pointer to an object
public:
	typedef _Unique_ptr_base<_Ty, _Dx> _Mybase;
	typedef typename _Mybase::pointer pointer;
	typedef _Ty element_type;
	typedef _Dx deleter_type;

	using _Mybase::get_deleter;

	template<class _Dx2 = _Dx,
		_Unique_ptr_enable_default_t<_Dx2> = 0>
		constexpr unique_ptr() noexcept
			: _Mybase(pointer())
		{	// default construct
		}

	template<class _Dx2 = _Dx,
		_Unique_ptr_enable_default_t<_Dx2> = 0>
		constexpr unique_ptr(nullptr_t) noexcept
			: _Mybase(pointer())
		{	// null pointer construct
		}

	unique_ptr& operator=(nullptr_t) noexcept
		{	// assign a null pointer
		reset();
		return (*this);
		}

	template<class _Dx2 = _Dx,
		_Unique_ptr_enable_default_t<_Dx2> = 0>
		explicit unique_ptr(pointer _Ptr) noexcept
			: _Mybase(_Ptr)
		{	// construct with pointer
		}

	template<class _Dx2 = _Dx,
		enable_if_t<is_constructible_v<_Dx2, const _Dx2&>, int> = 0>
		unique_ptr(pointer _Ptr, const _Dx& _Dt) noexcept
			: _Mybase(_Ptr, _Dt)
		{	// construct with pointer and (maybe const) deleter&
		}

	template<class _Dx2 = _Dx,
		enable_if_t<conjunction_v<negation<is_reference<_Dx2>>,
			is_constructible<_Dx2, _Dx2>>, int> = 0>
		unique_ptr(pointer _Ptr, _Dx&& _Dt) noexcept
			: _Mybase(_Ptr, ::std:: move(_Dt))
		{	// construct by moving deleter
		}

	template<class _Dx2 = _Dx,
		enable_if_t<conjunction_v<is_reference<_Dx2>,
			is_constructible<_Dx2, remove_reference_t<_Dx2>>>, int> = 0>
		unique_ptr(pointer, remove_reference_t<_Dx>&&) = delete;

	unique_ptr(unique_ptr&& _Right) noexcept
		: _Mybase(_Right.release(),
			::std:: forward<_Dx>(_Right.get_deleter()))
		{	// construct by moving _Right
		}

	template<class _Ty2,
		class _Dx2,
		enable_if_t<conjunction_v<negation<is_array<_Ty2>>,
			is_convertible<typename unique_ptr<_Ty2, _Dx2>::pointer, pointer>,
			conditional_t<is_reference_v<_Dx>, is_same<_Dx2, _Dx>, is_convertible<_Dx2, _Dx>>
		>, int> = 0>
		unique_ptr(unique_ptr<_Ty2, _Dx2>&& _Right) noexcept
			: _Mybase(_Right.release(),
				::std:: forward<_Dx2>(_Right.get_deleter()))
		{	// construct by moving _Right
		}

 
	template<class _Ty2,
		enable_if_t<conjunction_v<is_convertible<_Ty2 *, _Ty *>,
			is_same<_Dx, default_delete<_Ty>>>, int> = 0>
		unique_ptr(auto_ptr<_Ty2>&& _Right) noexcept
			: _Mybase(_Right.release())
		{	// construct by moving _Right
		}
 

	template<class _Ty2,
		class _Dx2,
		enable_if_t<conjunction_v<negation<is_array<_Ty2>>,
			is_assignable<_Dx&, _Dx2>,
			is_convertible<typename unique_ptr<_Ty2, _Dx2>::pointer, pointer>
		>, int> = 0>
		unique_ptr& operator=(unique_ptr<_Ty2, _Dx2>&& _Right) noexcept
		{	// assign by moving _Right
		reset(_Right.release());
		this->get_deleter() = ::std:: forward<_Dx2>(_Right.get_deleter());
		return (*this);
		}

	unique_ptr& operator=(unique_ptr&& _Right) noexcept
		{	// assign by moving _Right
		if (this != ::std:: addressof(_Right))
			{	// different, do the move
			reset(_Right.release());
			this->get_deleter() = ::std:: forward<_Dx>(_Right.get_deleter());
			}
		return (*this);
		}

	void swap(unique_ptr& _Right) noexcept
		{	// swap elements
		_Swap_adl(this->_Myptr(), _Right._Myptr());
		_Swap_adl(this->get_deleter(), _Right.get_deleter());
		}

	~unique_ptr() noexcept
		{	// destroy the object
		if (get() != pointer())
			{
			this->get_deleter()(get());
			}
		}

	 add_lvalue_reference_t<_Ty> operator*() const
		{	// return reference to object
		return (*get());
		}

	 pointer operator->() const noexcept
		{	// return pointer to class object
		return (this->_Myptr());
		}

	 pointer get() const noexcept
		{	// return pointer to object
		return (this->_Myptr());
		}

	explicit operator bool() const noexcept
		{	// test for non-null pointer
		return (get() != pointer());
		}

	pointer release() noexcept
		{	// yield ownership of pointer
		pointer _Ans = get();
		this->_Myptr() = pointer();
		return (_Ans);
		}

	void reset(pointer _Ptr = pointer()) noexcept
		{	// establish new pointer
		pointer _Old = get();
		this->_Myptr() = _Ptr;
		if (_Old != pointer())
			{
			this->get_deleter()(_Old);
			}
		}

	unique_ptr(const unique_ptr&) = delete;
	unique_ptr& operator=(const unique_ptr&) = delete;
	};

	// CLASS TEMPLATE unique_ptr ARRAY
template<class _Ty,
	class _Dx>
	class unique_ptr<_Ty[], _Dx>
		: public _Unique_ptr_base<_Ty, _Dx>
	{	// non-copyable pointer to an array object
public:
	typedef _Unique_ptr_base<_Ty, _Dx> _Mybase;
	typedef typename _Mybase::pointer pointer;
	typedef _Ty element_type;
	typedef _Dx deleter_type;

	using _Mybase::get_deleter;

	template<class _Dx2 = _Dx,
		_Unique_ptr_enable_default_t<_Dx2> = 0>
		constexpr unique_ptr() noexcept
			: _Mybase(pointer())
		{	// default construct
		}

	template<class _Uty,
		class _Is_nullptr = is_same<_Uty, nullptr_t>>
		using _Enable_ctor_reset = enable_if_t<
			is_same_v<_Uty, pointer>
			|| _Is_nullptr::value
			|| (is_same_v<pointer, element_type *>
			&& is_pointer_v<_Uty>
			&& is_convertible_v<
				remove_pointer_t<_Uty>(*)[],
				element_type(*)[]
			>)>;

	template<class _Uty,
		class _Dx2 = _Dx,
		_Unique_ptr_enable_default_t<_Dx2> = 0,
		class = _Enable_ctor_reset<_Uty>>
		explicit unique_ptr(_Uty _Ptr) noexcept
			: _Mybase(_Ptr)
		{	// construct with pointer
		}

	template<class _Uty,
		class _Dx2 = _Dx,
		enable_if_t<is_constructible_v<_Dx2, const _Dx2&>, int> = 0,
		class = _Enable_ctor_reset<_Uty>>
		unique_ptr(_Uty _Ptr, const _Dx& _Dt) noexcept
			: _Mybase(_Ptr, _Dt)
		{	// construct with pointer and (maybe const) deleter&
		}

	template<class _Uty,
		class _Dx2 = _Dx,
		enable_if_t<conjunction_v<negation<is_reference<_Dx2>>,
			is_constructible<_Dx2, _Dx2>>, int> = 0,
		class = _Enable_ctor_reset<_Uty>>
		unique_ptr(_Uty _Ptr, _Dx&& _Dt) noexcept
			: _Mybase(_Ptr, ::std:: move(_Dt))
		{	// construct by moving deleter
		}

	template<class _Uty,
		class _Dx2 = _Dx,
		enable_if_t<conjunction_v<is_reference<_Dx2>,
			is_constructible<_Dx2, remove_reference_t<_Dx2>>>, int> = 0>
		unique_ptr(_Uty, remove_reference_t<_Dx>&&) = delete;

	unique_ptr(unique_ptr&& _Right) noexcept
		: _Mybase(_Right.release(),
			::std:: forward<_Dx>(_Right.get_deleter()))
		{	// construct by moving _Right
		}

	unique_ptr& operator=(unique_ptr&& _Right) noexcept
		{	// assign by moving _Right
		if (this != ::std:: addressof(_Right))
			{	// different, do the swap
			reset(_Right.release());
			this->get_deleter() = ::std:: move(_Right.get_deleter());
			}
		return (*this);
		}

	template<class _Uty,
		class _Ex,
		class _More,
		class _UP_pointer = typename unique_ptr<_Uty, _Ex>::pointer,
		class _UP_element_type = typename unique_ptr<_Uty, _Ex>::element_type>
		using _Enable_conversion = enable_if_t<conjunction_v<
			is_array<_Uty>,
			is_same<pointer, element_type *>,
			is_same<_UP_pointer, _UP_element_type *>,
			is_convertible<_UP_element_type(*)[], element_type(*)[]>,
			_More>>;

	template<class _Uty,
		class _Ex,
		class = _Enable_conversion<_Uty, _Ex,
			conditional_t<is_reference_v<_Dx>, is_same<_Ex, _Dx>, is_convertible<_Ex, _Dx>>>>
		unique_ptr(unique_ptr<_Uty, _Ex>&& _Right) noexcept
			: _Mybase(_Right.release(),
				::std:: forward<_Ex>(_Right.get_deleter()))
		{	// construct by moving _Right
		}

	template<class _Uty,
		class _Ex,
		class = _Enable_conversion<_Uty, _Ex, is_assignable<_Dx&, _Ex>>>
		unique_ptr& operator=(unique_ptr<_Uty, _Ex>&& _Right) noexcept
		{	// assign by moving _Right
		reset(_Right.release());
		this->get_deleter() = ::std:: forward<_Ex>(_Right.get_deleter());
		return (*this);
		}

	template<class _Dx2 = _Dx,
		_Unique_ptr_enable_default_t<_Dx2> = 0>
		constexpr unique_ptr(nullptr_t) noexcept
			: _Mybase(pointer())
		{	// null pointer construct
		}

	unique_ptr& operator=(nullptr_t) noexcept
		{	// assign a null pointer
		reset();
		return (*this);
		}

	void reset(nullptr_t = nullptr) noexcept
		{	// establish new null pointer
		reset(pointer());
		}

	void swap(unique_ptr& _Right) noexcept
		{	// swap elements
		_Swap_adl(this->_Myptr(), _Right._Myptr());
		_Swap_adl(this->get_deleter(), _Right.get_deleter());
		}

	~unique_ptr() noexcept
		{	// destroy the object
		_Delete();
		}

	 _Ty& operator[](size_t _Idx) const
		{	// return reference to object
		return (get()[_Idx]);
		}

	 pointer get() const noexcept
		{	// return pointer to object
		return (this->_Myptr());
		}

	explicit operator bool() const noexcept
		{	// test for non-null pointer
		return (get() != pointer());
		}

	pointer release() noexcept
		{	// yield ownership of pointer
		pointer _Ans = get();
		this->_Myptr() = pointer();
		return (_Ans);
		}

	template<class _Uty,
		class = _Enable_ctor_reset<_Uty, false_type>>
		void reset(_Uty _Ptr) noexcept
		{	// establish new pointer
		pointer _Old = get();
		this->_Myptr() = _Ptr;
		if (_Old != pointer())
			{
			this->get_deleter()(_Old);
			}
		}

	unique_ptr(const unique_ptr&) = delete;
	unique_ptr& operator=(const unique_ptr&) = delete;

private:
	void _Delete()
		{	// delete the pointer
		if (get() != pointer())
			{
			this->get_deleter()(get());
			}
		}
	};


	// FUNCTION TEMPLATE make_unique
template<class _Ty,
	class... _Types,
	enable_if_t<!is_array_v<_Ty>, int> = 0>
	 inline unique_ptr<_Ty> make_unique(_Types&&... _Args)
	{	// make a unique_ptr
	return (unique_ptr<_Ty>(new _Ty(::std:: forward<_Types>(_Args)...)));
	}

template<class _Ty,
	enable_if_t<is_array_v<_Ty> && extent_v<_Ty> == 0, int> = 0>
	 inline unique_ptr<_Ty> make_unique(size_t _Size)
	{	// make a unique_ptr
	typedef remove_extent_t<_Ty> _Elem;
	return (unique_ptr<_Ty>(new _Elem[_Size]()));
	}

template<class _Ty,
	class... _Types,
	enable_if_t<extent_v<_Ty> != 0, int> = 0>
	void make_unique(_Types&&...) = delete;


	// FUNCTION TEMPLATE _Make_unique_alloc
template<class _Alloc>
	struct _Allocator_deleter
	{
	_Alloc _Al;

	using pointer = typename allocator_traits<_Alloc>::pointer;
	void operator()(pointer _Ptr) noexcept
		{	// delete the pointer
		allocator_traits<_Alloc>::destroy(_Al, _Unfancy(_Ptr));
		_Al.deallocate(_Ptr, 1);
		}
	};

template<class _Alloc>
	using _Unique_ptr_alloc = unique_ptr<typename _Alloc::value_type, _Allocator_deleter<_Alloc>>;

template<class _Alloc,
	class... _Args>
	_Unique_ptr_alloc<_Alloc> _Make_unique_alloc(_Alloc& _Al, _Args&&... _Vals)
	{	// construct an object with an allocator and return it owned by a unique_ptr
	auto _Ptr = _Al.allocate(1);
	try {
		allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Ptr), ::std:: forward<_Args>(_Vals)...);
	} catch (...) {
		_Al.deallocate(_Ptr, 1);
	throw;
	}

	return (_Unique_ptr_alloc<_Alloc>(_Ptr, _Allocator_deleter<_Alloc>{_Al}));
	}

template<class _Ty,
	class _Dx,
	enable_if_t<_Is_swappable<_Dx>::value, int> = 0>
	void swap(unique_ptr<_Ty, _Dx>& _Left, unique_ptr<_Ty, _Dx>& _Right) noexcept
	{	// swap _Left with _Right
	_Left.swap(_Right);
	}

template<class _Ty1,
	class _Dx1,
	class _Ty2,
	class _Dx2>
	 bool operator==(const unique_ptr<_Ty1, _Dx1>& _Left, const unique_ptr<_Ty2, _Dx2>& _Right)
	{	// test if unique_ptr _Left equals _Right
	return (_Left.get() == _Right.get());
	}

template<class _Ty1,
	class _Dx1,
	class _Ty2,
	class _Dx2>
	 bool operator!=(const unique_ptr<_Ty1, _Dx1>& _Left, const unique_ptr<_Ty2, _Dx2>& _Right)
	{	// test if unique_ptr _Left doesn't equal _Right
	return (!(_Left == _Right));
	}

template<class _Ty1,
	class _Dx1,
	class _Ty2,
	class _Dx2>
	 bool operator<(const unique_ptr<_Ty1, _Dx1>& _Left, const unique_ptr<_Ty2, _Dx2>& _Right)
	{	// test if unique_ptr _Left precedes _Right
	typedef typename unique_ptr<_Ty1, _Dx1>::pointer _Ptr1;
	typedef typename unique_ptr<_Ty2, _Dx2>::pointer _Ptr2;
	typedef common_type_t<_Ptr1, _Ptr2> _Common;
	return (less<_Common>()(_Left.get(), _Right.get()));
	}

template<class _Ty1,
	class _Dx1,
	class _Ty2,
	class _Dx2>
	 bool operator>=(const unique_ptr<_Ty1, _Dx1>& _Left, const unique_ptr<_Ty2, _Dx2>& _Right)
	{	// test if unique_ptr _Left doesn't precede _Right
	return (!(_Left < _Right));
	}

template<class _Ty1,
	class _Dx1,
	class _Ty2,
	class _Dx2>
	 bool operator>(const unique_ptr<_Ty1, _Dx1>& _Left, const unique_ptr<_Ty2, _Dx2>& _Right)
	{	// test if unique_ptr _Right precedes _Left
	return (_Right < _Left);
	}

template<class _Ty1,
	class _Dx1,
	class _Ty2,
	class _Dx2>
	 bool operator<=(const unique_ptr<_Ty1, _Dx1>& _Left, const unique_ptr<_Ty2, _Dx2>& _Right)
	{	// test if unique_ptr _Right doesn't precede _Left
	return (!(_Right < _Left));
	}

template<class _Ty,
	class _Dx>
	 bool operator==(const unique_ptr<_Ty, _Dx>& _Left, nullptr_t) noexcept
	{	// test if unique_ptr == nullptr
	return (!_Left);
	}

template<class _Ty,
	class _Dx>
	 bool operator==(nullptr_t, const unique_ptr<_Ty, _Dx>& _Right) noexcept
	{	// test if nullptr == unique_ptr
	return (!_Right);
	}

template<class _Ty,
	class _Dx>
	 bool operator!=(const unique_ptr<_Ty, _Dx>& _Left, nullptr_t _Right) noexcept
	{	// test if unique_ptr != nullptr
	return (!(_Left == _Right));
	}

template<class _Ty,
	class _Dx>
	 bool operator!=(nullptr_t _Left, const unique_ptr<_Ty, _Dx>& _Right) noexcept
	{	// test if nullptr != unique_ptr
	return (!(_Left == _Right));
	}

template<class _Ty,
	class _Dx>
	 bool operator<(const unique_ptr<_Ty, _Dx>& _Left, nullptr_t _Right)
	{	// test if unique_ptr < nullptr
	typedef typename unique_ptr<_Ty, _Dx>::pointer _Ptr;
	return (less<_Ptr>()(_Left.get(), _Right));
	}

template<class _Ty,
	class _Dx>
	 bool operator<(nullptr_t _Left, const unique_ptr<_Ty, _Dx>& _Right)
	{	// test if nullptr < unique_ptr
	typedef typename unique_ptr<_Ty, _Dx>::pointer _Ptr;
	return (less<_Ptr>()(_Left, _Right.get()));
	}

template<class _Ty,
	class _Dx>
	 bool operator>=(const unique_ptr<_Ty, _Dx>& _Left, nullptr_t _Right)
	{	// test if unique_ptr >= nullptr
	return (!(_Left < _Right));
	}

template<class _Ty,
	class _Dx>
	 bool operator>=(nullptr_t _Left, const unique_ptr<_Ty, _Dx>& _Right)
	{	// test if nullptr >= unique_ptr
	return (!(_Left < _Right));
	}

template<class _Ty,
	class _Dx>
	 bool operator>(const unique_ptr<_Ty, _Dx>& _Left, nullptr_t _Right)
	{	// test if unique_ptr > nullptr
	return (_Right < _Left);
	}

template<class _Ty,
	class _Dx>
	 bool operator>(nullptr_t _Left, const unique_ptr<_Ty, _Dx>& _Right)
	{	// test if nullptr > unique_ptr
	return (_Right < _Left);
	}

template<class _Ty,
	class _Dx>
	 bool operator<=(const unique_ptr<_Ty, _Dx>& _Left, nullptr_t _Right)
	{	// test if unique_ptr <= nullptr
	return (!(_Right < _Left));
	}

template<class _Ty,
	class _Dx>
	 bool operator<=(nullptr_t _Left, const unique_ptr<_Ty, _Dx>& _Right)
	{	// test if nullptr <= unique_ptr
	return (!(_Right < _Left));
	}

template<class _OutTy,
	class _PxTy,
	class = void>
	struct _Can_stream_unique_ptr
		: false_type
	{};
template<class _OutTy,
	class _PxTy>
	struct _Can_stream_unique_ptr<_OutTy, _PxTy, void_t<
		decltype(::std:: declval<_OutTy>() << ::std:: declval<_PxTy>().get())>>
		: true_type
	{};

template<class _Elem,
	class _Traits,
	class _Yty,
	class _Dx,
	enable_if_t<_Can_stream_unique_ptr<basic_ostream<_Elem, _Traits>&, const unique_ptr<_Yty, _Dx>&>::value, int> = 0>
	basic_ostream<_Elem, _Traits>& operator<<(basic_ostream<_Elem, _Traits>& _Out, const unique_ptr<_Yty, _Dx>& _Px)
	{	// write contained pointer to stream
	_Out << _Px.get();
	return (_Out);
	}

		// GARBAGE COLLECTION
enum class pointer_safety {	// return codes for get_pointer_safety
	relaxed,
	preferred,
	strict
	};

inline void declare_reachable(void *)
	{	// increment pointer reachable count
	}

template<class _Ty> inline
	_Ty * undeclare_reachable(_Ty * _Ptr)
	{	// decrement pointer reachable count
	return (_Ptr);
	}

inline void declare_no_pointers(char *, size_t)
	{	// declare region to be pointer free
	}

inline void undeclare_no_pointers(char *, size_t)
	{	// undeclare region to be pointer free
	}

inline pointer_safety get_pointer_safety() noexcept
	{	// get pointer safety status
	return (pointer_safety::relaxed);
	}

		// STRUCT TEMPLATE owner_less
template<class _Ty = void>
	struct owner_less;	// not defined

template<class _Ty>
	struct owner_less<shared_ptr<_Ty>>
	{	// functor for owner_before
	 typedef shared_ptr<_Ty> first_argument_type;
	 typedef shared_ptr<_Ty> second_argument_type;
	 typedef bool result_type;

	 bool operator()(const shared_ptr<_Ty>& _Left, const shared_ptr<_Ty>& _Right) const noexcept
		{	// apply owner_before to operands
		return (_Left.owner_before(_Right));
		}

	 bool operator()(const shared_ptr<_Ty>& _Left, const weak_ptr<_Ty>& _Right) const noexcept
		{	// apply owner_before to operands
		return (_Left.owner_before(_Right));
		}

	 bool operator()(const weak_ptr<_Ty>& _Left, const shared_ptr<_Ty>& _Right) const noexcept
		{	// apply owner_before to operands
		return (_Left.owner_before(_Right));
		}
	};

template<class _Ty>
	struct owner_less<weak_ptr<_Ty>>
	{	// functor for owner_before
	 typedef weak_ptr<_Ty> first_argument_type;
	 typedef weak_ptr<_Ty> second_argument_type;
	 typedef bool result_type;

	 bool operator()(const weak_ptr<_Ty>& _Left, const weak_ptr<_Ty>& _Right) const noexcept
		{	// apply owner_before to operands
		return (_Left.owner_before(_Right));
		}

	 bool operator()(const weak_ptr<_Ty>& _Left, const shared_ptr<_Ty>& _Right) const noexcept
		{	// apply owner_before to operands
		return (_Left.owner_before(_Right));
		}

	 bool operator()(const shared_ptr<_Ty>& _Left, const weak_ptr<_Ty>& _Right) const noexcept
		{	// apply owner_before to operands
		return (_Left.owner_before(_Right));
		}
	};

template<>
	struct owner_less<void>
	{	// functor for owner_before
	using is_transparent = int;

	template<class _Ty,
		class _Uty>
		 bool operator()(const shared_ptr<_Ty>& _Left, const shared_ptr<_Uty>& _Right) const noexcept
		{	// apply owner_before to operands
		return (_Left.owner_before(_Right));
		}

	template<class _Ty,
		class _Uty>
		 bool operator()(const shared_ptr<_Ty>& _Left, const weak_ptr<_Uty>& _Right) const noexcept
		{	// apply owner_before to operands
		return (_Left.owner_before(_Right));
		}

	template<class _Ty,
		class _Uty>
		 bool operator()(const weak_ptr<_Ty>& _Left, const shared_ptr<_Uty>& _Right) const noexcept
		{	// apply owner_before to operands
		return (_Left.owner_before(_Right));
		}

	template<class _Ty,
		class _Uty>
		 bool operator()(const weak_ptr<_Ty>& _Left, const weak_ptr<_Uty>& _Right) const noexcept
		{	// apply owner_before to operands
		return (_Left.owner_before(_Right));
		}
	};

	// STRUCT TEMPLATE SPECIALIZATION hash
template<class _Ty,
	class _Dx>
	struct hash<unique_ptr<_Ty, _Dx>>
		: _Conditionally_enabled_hash<unique_ptr<_Ty, _Dx>,
			is_default_constructible_v<hash<typename unique_ptr<_Ty, _Dx>::pointer>>>
	{	// hash functor
	static size_t _Do_hash(const unique_ptr<_Ty, _Dx>& _Keyval)
			noexcept(_Is_nothrow_hashable<typename unique_ptr<_Ty, _Dx>::pointer>::value) // strengthened
		{	// hash _Keyval to size_t value by pseudorandomizing transform
		return (hash<typename unique_ptr<_Ty, _Dx>::pointer>{}(_Keyval.get()));
		}
	};

template<class _Ty>
	struct hash<shared_ptr<_Ty>>
	{	// hash functor
	 typedef shared_ptr<_Ty> argument_type;
	 typedef size_t result_type;

	 size_t operator()(const shared_ptr<_Ty>& _Keyval) const noexcept
		{	// hash _Keyval to size_t value by pseudorandomizing transform
		return (hash<typename shared_ptr<_Ty>::element_type *>()(_Keyval.get()));
		}
	};

		// FUNCTION align
inline void * align(size_t _Bound, size_t _Size, void *& _Ptr, size_t& _Space) noexcept
	{	// try to carve out _Size bytes on boundary _Bound
	size_t _Off = static_cast<size_t>(reinterpret_cast<uintptr_t>(_Ptr) & (_Bound - 1));
	if (_Off != 0)
		{
		_Off = _Bound - _Off;	// number of bytes to skip
		}

	if (_Space < _Off || _Space - _Off < _Size)
		{
		return (nullptr);
		}

	// enough room, update
	_Ptr = static_cast<char *>(_Ptr) + _Off;
	_Space -= _Off;
	return (_Ptr);
	}



		/* SPIN LOCKS */
extern "C" {
 void __cdecl _Lock_shared_ptr_spin_lock();
 void __cdecl _Unlock_shared_ptr_spin_lock();
}

		// WRAP SPIN-LOCK
struct _Shared_ptr_spin_lock
	{	// class to manage a spin lock for shared_ptr atomic operations
	_Shared_ptr_spin_lock()
		{	// lock the spin lock
		_Lock_shared_ptr_spin_lock();
		}

	~_Shared_ptr_spin_lock() noexcept
		{	// unlock the spin lock
		_Unlock_shared_ptr_spin_lock();
		}
	};

template<class _Ty>
	 inline bool atomic_is_lock_free(const shared_ptr<_Ty> *)
	{	// return true if atomic operations on shared_ptr<_Ty> are lock-free
	return (false);
	}

template<class _Ty>
	 inline shared_ptr<_Ty> atomic_load_explicit(const shared_ptr<_Ty> * _Ptr,
		memory_order)
	{	// load *_Ptr atomically
	_Shared_ptr_spin_lock _Lock;
	shared_ptr<_Ty> _Result = *_Ptr;
	return (_Result);
	}

template<class _Ty>
	 inline shared_ptr<_Ty> atomic_load(const shared_ptr<_Ty> * _Ptr)
	{	// load *_Ptr atomically
	return (::std:: atomic_load_explicit(_Ptr, memory_order_seq_cst));
	}

template<class _Ty> inline
	void atomic_store_explicit(shared_ptr<_Ty> * _Ptr, shared_ptr<_Ty> _Other,
		memory_order)
	{	// store _Other to *_Ptr atomically
	_Shared_ptr_spin_lock _Lock;
	_Ptr->swap(_Other);
	}

template<class _Ty> inline
	void atomic_store(shared_ptr<_Ty> * _Ptr, shared_ptr<_Ty> _Other)
	{	// store _Other to *_Ptr atomically
	::std:: atomic_store_explicit(_Ptr, ::std:: move(_Other), memory_order_seq_cst);
	}

template<class _Ty> inline
	shared_ptr<_Ty> atomic_exchange_explicit(
		shared_ptr<_Ty> * _Ptr, shared_ptr<_Ty> _Other,
		memory_order)
	{	// copy _Other to *_Ptr and return previous value of *_Ptr atomically
	_Shared_ptr_spin_lock _Lock;
	_Ptr->swap(_Other);
	return (_Other);
	}

template<class _Ty> inline
	shared_ptr<_Ty> atomic_exchange(
		shared_ptr<_Ty> * _Ptr, shared_ptr<_Ty> _Other)
	{	// copy _Other to *_Ptr and return previous value of *_Ptr atomically
	return (::std:: atomic_exchange_explicit(_Ptr, ::std:: move(_Other), memory_order_seq_cst));
	}

template<class _Ty> inline
	bool atomic_compare_exchange_weak_explicit(
		shared_ptr<_Ty> * _Ptr, shared_ptr<_Ty> * _Exp, shared_ptr<_Ty> _Value,
		memory_order, memory_order)
	{	// atomically compare and exchange
	shared_ptr<_Ty> _Old_exp;	// destroyed outside spin lock
	_Shared_ptr_spin_lock _Lock;
	bool _Success = _Ptr->get() == _Exp->get()
		&& !_Ptr->owner_before(*_Exp)
		&& !_Exp->owner_before(*_Ptr);
	if (_Success)
		_Ptr->swap(_Value);
	else
		{	// match failed
		_Exp->swap(_Old_exp);
		*_Exp = *_Ptr;
		}
	return (_Success);
	}

template<class _Ty> inline
	bool atomic_compare_exchange_weak(
		shared_ptr<_Ty> * _Ptr, shared_ptr<_Ty> * _Exp,
			shared_ptr<_Ty> _Value)
	{	// atomically compare and exchange
	return (::std:: atomic_compare_exchange_weak_explicit(_Ptr, _Exp, ::std:: move(_Value),
		memory_order_seq_cst, memory_order_seq_cst));
	}

template<class _Ty> inline
	bool atomic_compare_exchange_strong_explicit(
		shared_ptr<_Ty> * _Ptr, shared_ptr<_Ty> * _Exp, shared_ptr<_Ty> _Value,
		memory_order, memory_order)
	{	// atomically compare and exchange
	return (::std:: atomic_compare_exchange_weak_explicit(_Ptr, _Exp, ::std:: move(_Value),
		memory_order_seq_cst, memory_order_seq_cst));
	}

template<class _Ty> inline
	bool atomic_compare_exchange_strong(
	shared_ptr<_Ty> * _Ptr, shared_ptr<_Ty> * _Exp,
		shared_ptr<_Ty> _Value)
	{	// atomically compare and exchange
	return (::std:: atomic_compare_exchange_strong_explicit(_Ptr, _Exp, ::std:: move(_Value),
		memory_order_seq_cst, memory_order_seq_cst));
	}


namespace [[deprecated("warning STL4002: " "The non-Standard std::tr1 namespace and TR1-only machinery are deprecated and will be REMOVED. You can " "define _SILENCE_TR1_NAMESPACE_DEPRECATION_WARNING to acknowledge that you have received this warning.")]] tr1 {
using ::std:: allocate_shared;
using ::std:: bad_weak_ptr;
using ::std:: const_pointer_cast;
using ::std:: dynamic_pointer_cast;
using ::std:: enable_shared_from_this;
using ::std:: get_deleter;
using ::std:: make_shared;
using ::std:: shared_ptr;
using ::std:: static_pointer_cast;
using ::std:: swap;
using ::std:: weak_ptr;
}


}
 
 
 #pragma warning(pop)
 #pragma pack(pop)



/*
 * Copyright (c) by P.J. Plauger. All rights reserved.
 * Consult your license regarding permissions and restrictions.
V6.50:0009 */



// xfacet internal header
#pragma once





 #pragma pack(push,8)
 #pragma warning(push,3)
 #pragma warning(disable: 4455 4494  4619 4643 4702 4984 4988 )
 
 
 

// This must be as small as possible, because its contents are
// injected into the msvcprt.lib and msvcprtd.lib import libraries.
// Do not include or define anything else here.
// In particular, basic_string must not be included here.

namespace std {
	// CLASS _Facet_base
class __declspec(dllimport) _Facet_base
	{	// code for reference counting a facet
public:
	virtual  ~_Facet_base() noexcept
		{	// ensure that derived classes can be destroyed properly
		}

	// increment use count
	virtual void  _Incref() = 0;

	// decrement use count
	virtual _Facet_base *  _Decref() = 0;
	};

 



void __cdecl _Facet_Register(_Facet_base *);
 
}
 
 
 #pragma warning(pop)
 #pragma pack(pop)



 /*
 * Copyright (c) by P.J. Plauger. All rights reserved.
  * Consult your license regarding permissions and restrictions.
V6.50:0009 */


 #pragma pack(push,8)
 #pragma warning(push,3)
 #pragma warning(disable: 4455 4494  4619 4643 4702 4984 4988 )
 
 
 

namespace std {
		// CLASS TEMPLATE _Locbase
template<class _Dummy>
	class _Locbase
	{	// define templatized category constants, instantiate on demand
public:
	 static const int collate = ((1 << (1)) >> 1);
	 static const int ctype = ((1 << (2)) >> 1);
	 static const int monetary = ((1 << (3)) >> 1);
	 static const int numeric = ((1 << (4)) >> 1);
	 static const int time = ((1 << (5)) >> 1);
	 static const int messages = ((1 << (6)) >> 1);
	 static const int all = (((1 << ((6 + 1))) >> 1) - 1);
	 static const int none = 0;
	};

template<class _Dummy>
	const int _Locbase<_Dummy>::collate;
template<class _Dummy>
	const int _Locbase<_Dummy>::ctype;
template<class _Dummy>
	const int _Locbase<_Dummy>::monetary;
template<class _Dummy>
	const int _Locbase<_Dummy>::numeric;
template<class _Dummy>
	const int _Locbase<_Dummy>::time;
template<class _Dummy>
	const int _Locbase<_Dummy>::messages;
template<class _Dummy>
	const int _Locbase<_Dummy>::all;
template<class _Dummy>
	const int _Locbase<_Dummy>::none;

		// CLASS locale
class locale;
template<class _Facet>
	const _Facet& __cdecl use_facet(const locale&);
template<class _Elem>
	class collate;

struct __declspec(dllimport) _Crt_new_delete
	{	// base class for marking allocations as CRT blocks
  
	void * __cdecl operator new(size_t _Size)
		{	// replace operator new
		void * _Ptr = operator new(_Size, nothrow);
		if (!_Ptr)
			_Xbad_alloc();
		return (_Ptr);
		}

	void * __cdecl operator new(size_t _Size, const nothrow_t&) noexcept
		{	// replace nothrow operator new
		return (_malloc_dbg(_Size > 0 ? _Size : 1, 2, "c:\\visual studio\\vc\\tools\\msvc\\14.16.27023\\include\\xlocale", 75));
		}

	void __cdecl operator delete(void * _Ptr) noexcept
		{	// replace operator delete
		:: free(_Ptr);
		}

	void __cdecl operator delete(void * _Ptr, const nothrow_t&) noexcept
		{	// replace nothrow operator delete
		operator delete(_Ptr);
		}

	void * __cdecl operator new(size_t, void *_Ptr) noexcept
		{	// imitate True Placement New
		return (_Ptr);
		}

	void __cdecl operator delete(void *, void *) noexcept
		{	// imitate True Placement Delete
		}
  
	};

class locale
	: public _Locbase<int>, public _Crt_new_delete
	{	// nonmutable collection of facets that describe a locale
public:
	typedef int category;

			// CLASS id
	class __declspec(dllimport) id
		{	// identifier stamp, unique for each distinct kind of facet
	public:
		 id(size_t _Val = 0)
			: _Id(_Val)
			{	// construct with specified stamp value
			}

		 operator size_t()
			{	// get stamp, with lazy allocation
			if (_Id == 0)
				{	// still zero, allocate stamp
				{ ::std:: _Lockit _Lock(0);
					if (_Id == 0)
						{
						_Id = static_cast<size_t>(++_Id_cnt);
						}
				}
				}
			return (_Id);
			}

	private:
		size_t _Id;	// the identifier stamp

		 static int _Id_cnt;

	public:
		 id(const id&) = delete;
		id&  operator=(const id&) = delete;
		};

	class _Locimp;

			// CLASS facet
	class __declspec(dllimport) facet
		: public _Facet_base, public _Crt_new_delete
		{	// base class for all locale facets, performs reference counting
	public:
		static size_t __cdecl _Getcat(const facet ** = nullptr,
			const locale * = nullptr)
			{	// get category value, or -1 if no corresponding C category
			return (static_cast<size_t>(-1));
			}

		virtual void  _Incref() override
			{	// increment use count
			_InterlockedIncrement(reinterpret_cast<volatile long *>(&_Myrefs));
			}

		virtual _Facet_base * _Decref() override
			{	// decrement use count
			if (_InterlockedDecrement(reinterpret_cast<volatile long *>(&_Myrefs)) == 0)
				{
				return (this);
				}

			return (nullptr);
			}

	private:
		_Atomic_counter_t _Myrefs;	// the reference count

	protected:
		explicit  facet(size_t _Initrefs = 0)
			: _Myrefs(static_cast<_Atomic_integral_t>(_Initrefs))	// non-atomic initialization
			{	// construct with initial reference count
			}

		virtual  ~facet() noexcept
			{	// ensure that derived classes can be destroyed properly
			}

	public:
		 facet(const facet&) = delete;
		facet&  operator=(const facet&) = delete;
		};

			// CLASS _Locimp
	class __declspec(dllimport) _Locimp
		: public facet
		{	// reference-counted actual implementation of a locale
	protected:
		 ~_Locimp() noexcept
		{	// destroy the object
		_Locimp_dtor(this);
		}

	private:
		static  _Locimp *__cdecl
			_New_Locimp(bool _Transparent = false);
		static  _Locimp *__cdecl
			_New_Locimp(const _Locimp& _Right);

		static  void __cdecl
			_Locimp_dtor(_Locimp *);
		static  void __cdecl
			_Locimp_Addfac(_Locimp *, facet *, size_t);	// add a facet
		static void __cdecl
			_Locimp_ctor(_Locimp *, const _Locimp&);

		friend locale;

		 _Locimp(bool _Transparent)
			: locale::facet(1), _Facetvec(nullptr), _Facetcount(0),
				_Catmask(none), _Xparent(_Transparent),
					_Name("*")
			{	// construct an empty _Locimp
			}

		 _Locimp(const _Locimp& _Right)
			: locale::facet(1), _Facetvec(nullptr), _Facetcount(_Right._Facetcount),
				_Catmask(_Right._Catmask), _Xparent(_Right._Xparent),
					_Name(_Right._Name.c_str())
			{	// construct by copying
			_Locimp_ctor(this, _Right);
			}

		void  _Addfac(facet *_Pfacet, size_t _Id)
			{	// add a facet
			_Locimp_Addfac(this, _Pfacet, _Id);
			}

		static _Locimp *__cdecl _Makeloc(const _Locinfo&,
			category, _Locimp *, const locale *);	// make essential facets

		static void __cdecl _Makewloc(const _Locinfo&,
			category, _Locimp *, const locale *);	// make wchar_t facets

 
		static void __cdecl _Makeushloc(const _Locinfo&,
			category, _Locimp *, const locale *);	// make ushort facets
 

		static void __cdecl _Makexloc(const _Locinfo&,
			category, _Locimp *, const locale *);	// make remaining facets

		facet **_Facetvec;	// pointer to vector of facets
		size_t _Facetcount;	// size of vector of facets
		category _Catmask;	// mask describing implemented categories
		bool _Xparent;	// true if locale is transparent
		_Yarn<char> _Name;	// locale name, or "*" if not known

		 static _Locimp *_Clocptr;

public:
		_Locimp&  operator=(const _Locimp&) = delete;
		};

	template<class _Elem,
		class _Traits,
		class _Alloc>
		bool operator()(const basic_string<_Elem, _Traits, _Alloc>& _Left,
			const basic_string<_Elem, _Traits, _Alloc>& _Right) const
		{	// compare _Left and _Right strings using collate facet in locale
		const auto& _Coll_fac = use_facet<::std:: collate<_Elem>>(*this);

		return (_Coll_fac.compare(_Left.c_str(), _Left.c_str() + _Left.size(),
			_Right.c_str(), _Right.c_str() + _Right.size()) < 0);
		}

	template<class _Facet>
		locale combine(const locale& _Loc) const
		{	// combine two locales
		_Facet *_Facptr;

		try {
			_Facptr = (_Facet *)&use_facet<_Facet>(_Loc);
		} catch (...) {
			_Xruntime_error("locale::combine facet missing");
		}

		_Locimp *_Newimp = _Locimp::_New_Locimp(*_Ptr);
		_Newimp->_Addfac(_Facptr, _Facet::id);
		_Newimp->_Catmask = none;
		_Newimp->_Name = "*";
		return (locale(_Newimp));
		}

	template<class _Facet>
		locale(const locale& _Loc, const _Facet *_Facptr)
			: _Ptr(_Locimp::_New_Locimp(*_Loc._Ptr))
		{	// construct from _Loc, replacing facet with *_Facptr
		if (_Facptr != nullptr)
			{	// replace facet
			_Ptr->_Addfac((_Facet *)_Facptr, _Facet::id);
			_Ptr->_Catmask = none;
			_Ptr->_Name = "*";
			}
		}

	locale(_Uninitialized)
		{	// defer construction
		}

	locale(const locale& _Right) noexcept
		: _Ptr(_Right._Ptr)
		{	// construct by copying
		_Ptr->_Incref();
		}

	locale() noexcept
		: _Ptr(_Init(true))
		{	// construct from current locale
		}

 
	locale(const locale& _Loc, const locale& _Other,
		category _Cat)
		: _Ptr(_Locimp::_New_Locimp(*_Loc._Ptr))
		{	// construct a locale by copying named facets
		if (_Cat != none)
			{	// worth adding, do it
			try {
				{ _Locinfo _Lobj;
					_Locimp::_Makeloc(_Lobj, _Cat, _Ptr, &_Other);
					_Lobj._Addcats(_Loc._Ptr->_Catmask,
						_Loc.name().c_str());
					_Lobj._Addcats(_Other._Ptr->_Catmask,
						_Other.name().c_str());
					_Ptr->_Catmask = _Loc._Ptr->_Catmask
						| _Other._Ptr->_Catmask;
					_Ptr->_Name = _Lobj._Getname();
				}
			} catch (...) {
			delete _Ptr->_Decref();
			throw;
			}
			}
		}

private:
	void _Construct(const string &_Str,
		category _Cat)
		{	// construct a locale with named facets
		bool _Bad = false;
		_Init();
		if (_Cat != none)
			{	// worth adding, do it
			try {
				{ _Locinfo _Lobj(_Cat, _Str.c_str());
					if (_Badname(_Lobj))
						_Bad = true;
					else
						{	// name okay, build the locale
						_Locimp::_Makeloc(_Lobj, _Cat, _Ptr, nullptr);
						_Ptr->_Catmask = _Cat;
						_Ptr->_Name = _Str.c_str();
						}
				}
			} catch (...) {
			delete _Ptr->_Decref();
			throw;
			}
			}

		if (_Bad)
			{	// Don't throw within _BEGIN_LOCINFO if we can avoid it
			delete _Ptr->_Decref();
			_Xruntime_error("bad locale name");
			}
		}

public:
	explicit locale(const char *_Locname,
		category _Cat = all)
		: _Ptr(_Locimp::_New_Locimp())
		{	// construct a locale with named facets
		// _Locname might have been returned from setlocale().
		// Therefore, _Construct() takes const string&.
		if (_Locname == nullptr)
			_Xruntime_error("bad locale name");
		_Construct(_Locname, _Cat);
		}

	locale(const locale& _Loc, const char *_Locname,
		category _Cat)
		: _Ptr(_Locimp::_New_Locimp(*_Loc._Ptr))
		{	// construct a locale by copying, replacing named facets
		// _Locname might have been returned from setlocale().
		// Therefore, _Construct() takes const string&.
		if (_Locname == nullptr)
			_Xruntime_error("bad locale name");
		_Construct(_Locname, _Cat);
		}

	explicit locale(const string& _Str,
		category _Cat = all)
		: _Ptr(_Locimp::_New_Locimp())
		{	// construct a locale with named facets
		_Construct(_Str, _Cat);
		}

	locale(const locale& _Loc, const string& _Str,
		category _Cat)
		: _Ptr(_Locimp::_New_Locimp(*_Loc._Ptr))
		{	// construct a locale by copying, replacing named facets
		_Construct(_Str, _Cat);
		}
 

	~locale() noexcept
		{	// destroy the object
		if (_Ptr != nullptr)
			delete _Ptr->_Decref();
		}

	locale& operator=(const locale& _Right) noexcept
		{	// assign a locale
		if (_Ptr != _Right._Ptr)
			{	// different implementation, point at new one
			delete _Ptr->_Decref();
			_Ptr = _Right._Ptr;
			_Ptr->_Incref();
			}
		return (*this);
		}

	string name() const
		{	// return locale name
		return (_Ptr == nullptr ? string() : _Ptr->_Name.c_str());
		}

	  const char *c_str() const
		{	// return locale name as NTBS
		return (_Ptr == nullptr ? "" : _Ptr->_Name.c_str());
		}

	const facet *_Getfacet(size_t _Id) const
		{	// look up a facet in locale object
		const facet *_Facptr = _Id < _Ptr->_Facetcount
			? _Ptr->_Facetvec[_Id] : nullptr;	// null if id off end
		if (_Facptr != nullptr || !_Ptr->_Xparent)
			return (_Facptr);	// found facet or not transparent
		else
			{	// look in current locale
			locale::_Locimp *_Ptr0 = _Getgloballocale();
			return (_Id < _Ptr0->_Facetcount
				? _Ptr0->_Facetvec[_Id]	// get from current locale
				: nullptr);	// no entry in current locale
			}
		}

	 bool operator==(const locale& _Loc) const
		{	// compare locales for equality
		return (_Ptr == _Loc._Ptr
			|| (name().compare("*") != 0
				&& name().compare(_Loc.name()) == 0));
		}

	 bool operator!=(const locale& _Right) const
		{	// test for locale inequality
		return (!(*this == _Right));
		}

	static  const locale& __cdecl
		classic();	// classic "C" locale

	static  locale __cdecl
		global(const locale&);	// current locale

	static  locale __cdecl
		empty();	// empty (transparent) locale

private:
	locale(_Locimp *_Ptrimp)
		: _Ptr(_Ptrimp)
		{	// construct from _Locimp pointer
		}

	static  _Locimp *__cdecl
		_Init(bool _Do_incref = false);	// initialize locale
	static  _Locimp *__cdecl
		_Getgloballocale();
	static  void __cdecl
		_Setgloballocale(void *);

	bool _Badname(const _Locinfo& _Lobj)
		{	// test if name is "*"
		return (:: strcmp(_Lobj._Getname(), "*") == 0);
		}

	_Locimp *_Ptr;	// pointer to locale implementation object
	};

		// SUPPORT TEMPLATES
template<class _Facet>
	struct _Facetptr
	{	// store pointer to lazy facet for use_facet
	 static const locale::facet *_Psave;
	};

template<class _Facet>
	 const locale::facet *_Facetptr<_Facet>::
		_Psave = nullptr;

template<class _Facet> inline
	const _Facet& __cdecl use_facet(const locale& _Loc)

	{	// get facet reference from locale
	{ ::std:: _Lockit _Lock(0);	// the thread lock, make get atomic
		const locale::facet *_Psave =
			_Facetptr<_Facet>::_Psave;	// static pointer to lazy facet

		const size_t _Id = _Facet::id;
		const locale::facet *_Pf = _Loc._Getfacet(_Id);

		if (_Pf == nullptr)
			{
			if (_Psave != nullptr)
				{
				_Pf = _Psave;	// lazy facet already allocated
				}
			else if (_Facet::_Getcat(&_Psave, &_Loc) == static_cast<size_t>(-1))
				{
 
				throw bad_cast{};	// lazy disallowed
 


				}
			else
				{	// queue up lazy facet for destruction
				auto _Pfmod = const_cast<locale::facet *>(_Psave);
				unique_ptr<_Facet_base> _Psave_guard(static_cast<_Facet_base *>(_Pfmod));

 


				_Facet_Register(_Pfmod);
 

				_Pfmod->_Incref();
				_Facetptr<_Facet>::_Psave = _Psave;
				_Pf = _Psave;

				(void) _Psave_guard.release();
				}
			}

		return (static_cast<const _Facet&>(*_Pf));	// should be dynamic_cast
	}
	}	// end of use_facet body

		// FUNCTION TEMPLATE _Getloctxt
template<class _Elem,
	class _InIt> inline
	int __cdecl _Getloctxt(_InIt& _First, _InIt& _Last, size_t _Numfields,
		const _Elem *_Ptr)
	{	// find field at _Ptr that matches longest in [_First, _Last)
	for (size_t _Off = 0; _Ptr[_Off] != (_Elem)0; ++_Off)
		if (_Ptr[_Off] == _Ptr[0])
			++_Numfields;	// add fields with leading mark to initial count
	string _Str(_Numfields, '\0');	// one column counter for each field

	int _Ans = -2;	// no candidates so far
	for (size_t _Column = 1; ; ++_Column, (void)++_First, _Ans = -1)
		{	// test each element against all viable fields
		bool _Prefix = false;	// seen at least one valid prefix
		size_t _Off = 0;	// offset into fields
		size_t _Field = 0;	// current field number

		for (; _Field < _Numfields; ++_Field)
			{	// test element at _Column in field _Field
			while (_Ptr[_Off] != (_Elem)0 && _Ptr[_Off] != _Ptr[0])
				{	// find beginning of field
				++_Off;
				}

			if (_Str[_Field] != '\0')
				{
				_Off += _Str[_Field];	// skip tested columns in field
				}
			else if (_Ptr[_Off += _Column] == _Ptr[0] || _Ptr[_Off] == (_Elem)0)
				{	// matched all of field, save as possible answer
				_Str[_Field] = (char)(_Column < 127 ? _Column : 127);	// save skip count if small enough
				_Ans = (int)_Field;	// save answer
				}
			else if (_First == _Last || _Ptr[_Off] != *_First)
				{
				_Str[_Field] = (char)(_Column < 127 ? _Column : 127);	// no match, just save skip count
				}
			else
				{
				_Prefix = true;	// still a valid prefix
				}
			}

		if (!_Prefix || _First == _Last)
			break;	// no pending prefixes or no input, give up
		}
	return (_Ans);	// return field number or negative value on failure
	}

		// FUNCTION TEMPLATE _Maklocbyte
template<class _Elem> inline
	char __cdecl _Maklocbyte(_Elem _Char,
		const _Locinfo::_Cvtvec&)
	{	// convert _Elem to char using _Cvtvec
	return ((char)(unsigned char)_Char);
	}

template<> inline
	char __cdecl _Maklocbyte(wchar_t _Char,
		const _Locinfo::_Cvtvec& _Cvt)
	{	// convert wchar_t to char using _Cvtvec
	char _Byte = '\0';
	mbstate_t _Mbst1 = {};
	_Wcrtomb(&_Byte, _Char, &_Mbst1, &_Cvt);
	return (_Byte);
	}

 
template<> inline
	char __cdecl _Maklocbyte(unsigned short _Char,
		const _Locinfo::_Cvtvec &_Cvt)
	{	// convert unsigned short to char using _Cvtvec
	char _Byte = '\0';
	mbstate_t _Mbst1 = {};
	_Wcrtomb(&_Byte, (wchar_t)_Char, &_Mbst1, &_Cvt);
	return (_Byte);
	}
 

		// FUNCTION TEMPLATE _Maklocchr
template<class _Elem> inline
	_Elem __cdecl _Maklocchr(char _Byte, _Elem *,
		const _Locinfo::_Cvtvec&)
	{	// convert char to _Elem using _Cvtvec
	return ((_Elem)(unsigned char)_Byte);
	}

template<> inline
	wchar_t __cdecl _Maklocchr(char _Byte, wchar_t *,
		const _Locinfo::_Cvtvec& _Cvt)
	{	// convert char to wchar_t using _Cvtvec
	wchar_t _Wc = L'\0';
	mbstate_t _Mbst1 = {};
	_Mbrtowc(&_Wc, &_Byte, 1, &_Mbst1, &_Cvt);
	return (_Wc);
	}

 
template<> inline
	unsigned short __cdecl _Maklocchr(char _Byte, unsigned short *,
		const _Locinfo::_Cvtvec &_Cvt)
	{	// convert char to unsigned short using _Cvtvec
	unsigned short _Wc = (unsigned short)0;
	mbstate_t _Mbst1 = {};
	_Mbrtowc((wchar_t *)&_Wc, &_Byte, 1, &_Mbst1, &_Cvt);
	return (_Wc);
	}
 

		// FUNCTION TEMPLATE _Maklocstr
template<class _Elem> inline
	_Elem *__cdecl _Maklocstr(const char *_Ptr, _Elem *,
		const _Locinfo::_Cvtvec&)
	{	// convert C string to _Elem sequence using _Cvtvec
	size_t _Count = :: strlen(_Ptr) + 1;

	_Elem *_Ptrdest = (_Elem *)_calloc_dbg(_Count, sizeof (_Elem),
		2, "c:\\visual studio\\vc\\tools\\msvc\\14.16.27023\\include\\xlocale", 668);

	if (!_Ptrdest)
		_Xbad_alloc();

	for (_Elem *_Ptrnext = _Ptrdest; 0 < _Count; --_Count, ++_Ptrnext, ++_Ptr)
		*_Ptrnext = (_Elem)(unsigned char)*_Ptr;

	return (_Ptrdest);
	}

template<> inline
	wchar_t *__cdecl _Maklocstr(const char *_Ptr, wchar_t *,
		const _Locinfo::_Cvtvec& _Cvt)
	{	// convert C string to wchar_t sequence using _Cvtvec
	size_t _Count, _Count1;
	size_t _Wchars;
	const char *_Ptr1;
	int _Bytes;
	wchar_t _Wc;
	mbstate_t _Mbst1 = {};

	_Count1 = :: strlen(_Ptr) + 1;
	for (_Count = _Count1, _Wchars = 0, _Ptr1 = _Ptr; 0 < _Count;
		_Count -= _Bytes, _Ptr1 += _Bytes, ++_Wchars)
		if ((_Bytes = _Mbrtowc(&_Wc, _Ptr1, _Count, &_Mbst1, &_Cvt)) <= 0)
			break;
	++_Wchars;	// count terminating nul

	wchar_t *_Ptrdest = (wchar_t *)_calloc_dbg(_Wchars, sizeof (wchar_t),
		2, "c:\\visual studio\\vc\\tools\\msvc\\14.16.27023\\include\\xlocale", 698);

	if (!_Ptrdest)
		_Xbad_alloc();
	wchar_t *_Ptrnext = _Ptrdest;
	mbstate_t _Mbst2 = {};

	for (; 0 < _Wchars;
		_Count -= _Bytes, _Ptr += _Bytes, --_Wchars, ++_Ptrnext)
		if ((_Bytes = _Mbrtowc(_Ptrnext, _Ptr, _Count1, &_Mbst2, &_Cvt)) <= 0)
			break;
	*_Ptrnext = L'\0';

	return (_Ptrdest);
	}

 
template<> inline
	unsigned short *__cdecl _Maklocstr(const char *_Ptr, unsigned short *,
		const _Locinfo::_Cvtvec &_Cvt)
	{	// convert C string to unsigned short sequence using _Cvtvec
	size_t _Count, _Count1;
	size_t _Wchars;
	const char *_Ptr1;
	int _Bytes;
	unsigned short _Wc;
	mbstate_t _Mbst1 = {};

	_Count1 = :: strlen(_Ptr) + 1;
	for (_Count = _Count1, _Wchars = 0, _Ptr1 = _Ptr; 0 < _Count;
		_Count -= _Bytes, _Ptr1 += _Bytes, ++_Wchars)
		{
		if ((_Bytes =
			_Mbrtowc((wchar_t *)&_Wc, _Ptr1, _Count, &_Mbst1, &_Cvt)) <= 0)
			{
			break;
			}
		}

	++_Wchars;	// count terminating nul

	wchar_t *_Ptrdest = (wchar_t *)_calloc_dbg(_Wchars, sizeof (wchar_t),
		2, "c:\\visual studio\\vc\\tools\\msvc\\14.16.27023\\include\\xlocale", 740);

	if (!_Ptrdest)
		{
		_Xbad_alloc();
		}

	wchar_t *_Ptrnext = _Ptrdest;
	mbstate_t _Mbst2 = {};
	for (; 0 < _Wchars;
		_Count -= _Bytes, _Ptr += _Bytes, --_Wchars, ++_Ptrnext)
		{
		if ((_Bytes = _Mbrtowc(_Ptrnext, _Ptr, _Count1, &_Mbst2, &_Cvt)) <= 0)
			{
			break;
			}
		}

	*_Ptrnext = L'\0';
	return ((unsigned short *)_Ptrdest);
	}
 

		// STRUCT codecvt_base
class __declspec(dllimport) codecvt_base
	: public locale::facet
	{	// base class for codecvt
public:
	enum
		{	// constants for different parse states
		ok, partial, error, noconv};
	typedef int result;

	 codecvt_base(size_t _Refs = 0)
		: locale::facet(_Refs)
		{	// default constructor
		}

	bool  always_noconv() const noexcept
		{	// return true if conversions never change input (from codecvt)
		return (do_always_noconv());
		}

	int  max_length() const noexcept
		{	// return maximum length required for a conversion (from codecvt)
		return (do_max_length());
		}

	int  encoding() const noexcept
		{	// return length of code sequence (from codecvt)
		return (do_encoding());
		}

	 ~codecvt_base() noexcept
		{	// destroy the object
		}

protected:
	virtual bool  do_always_noconv() const noexcept
		{	// return true if conversions never change input (from codecvt)
		return (false);
		}

	virtual int  do_max_length() const noexcept
		{	// return maximum length required for a conversion (from codecvt)
		return (1);
		}

	virtual int  do_encoding() const noexcept
		{	// return length of code sequence (from codecvt)
		return (1);	// -1 ==> state dependent, 0 ==> varying length
		}
	};

		// CLASS TEMPLATE codecvt
template<class _Elem,
	class _Byte,
	class _Statype>
	class codecvt
		: public codecvt_base
	{	// facet for converting between _Elem and char (_Byte) sequences
public:
	typedef _Elem intern_type;
	typedef _Byte extern_type;
	typedef _Statype state_type;

	result  in(_Statype& _State,
		const _Byte *_First1, const _Byte *_Last1, const _Byte *& _Mid1,
		_Elem *_First2, _Elem *_Last2, _Elem *& _Mid2) const
		{	// convert bytes [_First1, _Last1) to [_First2, _Last)
		return (do_in(_State,
			_First1, _Last1, _Mid1, _First2, _Last2, _Mid2));
		}

	result  out(_Statype& _State,
		const _Elem *_First1, const _Elem *_Last1, const _Elem *& _Mid1,
		_Byte *_First2, _Byte *_Last2, _Byte *& _Mid2) const
		{	// convert [_First1, _Last1) to bytes [_First2, _Last2)
		return (do_out(_State,
			_First1, _Last1, _Mid1, _First2, _Last2, _Mid2));
		}

	result  unshift(_Statype& _State,
		_Byte *_First2, _Byte *_Last2, _Byte *& _Mid2) const
		{	// generate bytes to return to default shift state
		return (do_unshift(_State, _First2, _Last2, _Mid2));
		}

	int  length(_Statype& _State, const _Byte *_First1,
		const _Byte *_Last1, size_t _Count) const
		{	// return min(_Count, converted length of bytes [_First1, _Last1))
		return (do_length(_State, _First1, _Last1, _Count));
		}

	 static locale::id id;	// unique facet id

	explicit  codecvt(size_t _Refs = 0)
		: codecvt_base(_Refs)
		{	// construct from current locale
		_Init(_Locinfo());
		}

	 codecvt(const _Locinfo& _Lobj, size_t _Refs = 0)
		: codecvt_base(_Refs)
		{	// construct from specified locale
		_Init(_Lobj);
		}

	static size_t __cdecl _Getcat(const locale::facet **_Ppf = nullptr,
		const locale *_Ploc = nullptr)
		{	// return locale category mask and construct standard facet
		if (_Ppf != nullptr && *_Ppf == nullptr)
			*_Ppf = new codecvt<_Elem, _Byte, _Statype>(
				_Locinfo(_Ploc->c_str()));
		return (2);
		}

protected:
	virtual  ~codecvt() noexcept
		{	// destroy the object
		}

	void  _Init(const _Locinfo&)
		{	// initialize from _Locinfo object
		}

	virtual bool  do_always_noconv() const noexcept
		{	// return true if conversions never change input (from codecvt)
		return (is_same_v<_Byte, _Elem>);
		}

	virtual result  do_in(_Statype&,
		const _Byte *_First1, const _Byte *_Last1, const _Byte *& _Mid1,
		_Elem *_First2, _Elem *_Last2, _Elem *& _Mid2) const
		{	// convert bytes [_First1, _Last1) to [_First2, _Last)
		_Mid1 = _First1;
		_Mid2 = _First2;
		if (is_same_v<_Byte, _Elem>)
			{
			return (noconv);	// convert nothing
			}

		// types differ, copy one for one
		for (; _Mid1 != _Last1 && _Mid2 != _Last2; ++_Mid1, ++_Mid2)
			{
			*_Mid2 = (_Elem)*_Mid1;
			}

		return (ok);
		}

	virtual result  do_out(_Statype&,
		const _Elem *_First1, const _Elem *_Last1, const _Elem *& _Mid1,
		_Byte *_First2, _Byte *_Last2, _Byte *& _Mid2) const
		{	// convert [_First1, _Last1) to bytes [_First2, _Last)
		_Mid1 = _First1;
		_Mid2 = _First2;
		if (is_same_v<_Byte, _Elem>)
			{
			return (noconv);	// convert nothing
			}

		// types differ, copy one for one
		for (; _Mid1 != _Last1 && _Mid2 != _Last2; ++_Mid1, ++_Mid2)
			{
			*_Mid2 = (_Byte)*_Mid1;
			}

		return (ok);
		}

	virtual result  do_unshift(_Statype&,
		_Byte *_First2, _Byte *, _Byte *&_Mid2) const
		{	// generate bytes to return to default shift state
		_Mid2 = _First2;
		return (ok);	// convert nothing
		}

	virtual int  do_length(_Statype&, const _Byte *_First1,
		const _Byte *_Last1, size_t _Count) const
		{	// return min(_Count, converted length of bytes [_First1, _Last1))
		return (static_cast<int>(_Min_value(_Count, static_cast<size_t>(_Last1 - _First1)))); // assumes 1:1 conversion
		}
	};

		// STATIC codecvt::id OBJECT





template<class _Elem,
	class _Byte,
	class _Statype>
	 locale::id codecvt<_Elem, _Byte, _Statype>::id;





		// ENUM _Codecvt_mode
enum _Codecvt_mode {
	_Consume_header = 4,
	_Generate_header = 2
	};

		// CLASS codecvt<char16_t, char, _Mbstatet>
template<>
	class __declspec(dllimport) codecvt<char16_t, char, _Mbstatet>
	: public codecvt_base
	{	// facet for converting between char16_t and UTF-8 byte sequences
public:
	typedef codecvt<char16_t, char, _Mbstatet> _Mybase;
	typedef char16_t _Elem;
	typedef char _Byte;
	typedef _Mbstatet _Statype;
	typedef _Elem intern_type;
	typedef _Byte extern_type;
	typedef _Statype state_type;

	result  in(_Statype& _State,
		const _Byte *_First1, const _Byte *_Last1, const _Byte *& _Mid1,
		_Elem *_First2, _Elem *_Last2, _Elem *& _Mid2) const
		{	// convert bytes [_First1, _Last1) to [_First2, _Last)
		return (do_in(_State,
			_First1, _Last1, _Mid1, _First2, _Last2, _Mid2));
		}

	result  out(_Statype& _State,
		const _Elem *_First1, const _Elem *_Last1, const _Elem *& _Mid1,
		_Byte *_First2, _Byte *_Last2, _Byte *& _Mid2) const
		{	// convert [_First1, _Last1) to bytes [_First2, _Last)
		return (do_out(_State,
			_First1, _Last1, _Mid1, _First2, _Last2, _Mid2));
		}

	result  unshift(_Statype& _State,
		_Byte *_First2, _Byte *_Last2, _Byte *& _Mid2) const
		{	// generate bytes to return to default shift state
		return (do_unshift(_State,
			_First2, _Last2, _Mid2));
		}

	int  length(_Statype& _State, const _Byte *_First1,
		const _Byte *_Last1, size_t _Count) const
		{	// return min(_Count, converted length of bytes [_First1, _Last1))
		return (do_length(_State, _First1, _Last1, _Count));
		}

	 static locale::id id;

	explicit  codecvt(size_t _Refs = 0)
		: codecvt_base(_Refs), _Maxcode(0x10ffff), _Mode(_Consume_header)
		{	// construct from current locale
		{ _Locinfo _Lobj;
			_Init(_Lobj);
		}
		}

	 codecvt(const _Locinfo& _Lobj, size_t _Refs = 0)
		: codecvt_base(_Refs), _Maxcode(0x10ffff), _Mode(_Consume_header)
		{	// construct from specified locale
		_Init(_Lobj);
		}

	 codecvt(const _Locinfo& _Lobj, unsigned long _Maxcode_arg,
		_Codecvt_mode _Mode_arg, size_t _Refs = 0)
		: codecvt_base(_Refs), _Maxcode(_Maxcode_arg), _Mode(_Mode_arg)
		{	// construct from specified locale and parameters
		_Init(_Lobj);
		}

	static size_t __cdecl _Getcat(const locale::facet **_Ppf = nullptr,
		const locale *_Ploc = nullptr)
		{	// return locale category mask and construct standard facet
		if (_Ppf != nullptr && *_Ppf == nullptr)
			{
			*_Ppf = new codecvt<_Elem, _Byte, _Statype>(_Locinfo(_Ploc->c_str()));
			}

		return (2);
		}

protected:
	virtual  ~codecvt() noexcept
		{	// destroy the object
		}

	void  _Init(const _Locinfo&)
		{	// initialize
		}

	virtual result  do_in(_Statype& _State,
		const _Byte *_First1, const _Byte *_Last1, const _Byte *& _Mid1,
		_Elem *_First2, _Elem *_Last2, _Elem *& _Mid2) const
		{	// convert bytes [_First1, _Last1) to [_First2, _Last2)
		unsigned short *_Pstate = (unsigned short *)&_State;
		_Mid1 = _First1;
		_Mid2 = _First2;

		while (_Mid1 != _Last1 && _Mid2 != _Last2)
			{	// convert a multibyte sequence
			unsigned char _By = (unsigned char)*_Mid1;
			unsigned long _Ch;
			int _Nextra, _Nskip;

			if (*_Pstate > 1)
				{
				if (_By < 0x80 || 0xc0 <= _By)
					{
					return (_Mybase::error);	// not continuation byte
					}

				// deliver second half of two-word value
				++_Mid1;
				*_Mid2++ = (_Elem)(*_Pstate | (_By & 0x3f));
				*_Pstate = 1;
				continue;
				}

			if (_By < 0x80)
				{
				_Ch = _By;
				_Nextra = 0;
				}
			else if (_By < 0xc0)
				{	// 0x80-0xdf not first byte
				++_Mid1;
				return (_Mybase::error);
				}
			else if (_By < 0xe0)
				{
				_Ch = static_cast<unsigned long>(_By & 0x1f);
				_Nextra = 1;
				}
			else if (_By < 0xf0)
				{
				_Ch = static_cast<unsigned long>(_By & 0x0f);
				_Nextra = 2;
				}
			else if (_By < 0xf8)
				{
				_Ch = static_cast<unsigned long>(_By & 0x07);
				_Nextra = 3;
				}
			else
				{
				_Ch = static_cast<unsigned long>(_By & 0x03);
				_Nextra = _By < 0xfc ? 4 : 5;
				}

			_Nskip = _Nextra < 3 ? 0 : 1;	// leave a byte for 2nd word
			_First1 = _Mid1;	// roll back point

			if (_Nextra == 0)
				{
				++_Mid1;
				}
			else if (_Last1 - _Mid1 < _Nextra + 1 - _Nskip)
				{
				break;	// not enough input
				}
			else
				{
				for (++_Mid1; _Nskip < _Nextra; --_Nextra, ++_Mid1)
					{
					if ((_By = (unsigned char)*_Mid1) < 0x80 || 0xc0 <= _By)
						{
						return (_Mybase::error);	// not continuation byte
						}
					else
						{
						_Ch = _Ch << 6 | (_By & 0x3f);
						}
					}
				}

			if (0 < _Nskip)
				{
				_Ch <<= 6;	// get last byte on next call
				}

			if ((_Maxcode < 0x10ffff ? _Maxcode : 0x10ffff) < _Ch)
				{
				return (_Mybase::error);	// value too large
				}

			if (0xffff < _Ch)
				{	// deliver first half of two-word value, save second word
				unsigned short _Ch0 =
					(unsigned short)(0xd800 | (_Ch >> 10) - 0x0040);

				*_Mid2++ = (_Elem)_Ch0;
				*_Pstate = (unsigned short)(0xdc00 | (_Ch & 0x03ff));
				continue;
				}

			if (_Nskip != 0)
				{
				if (_Mid1 == _Last1)
					{	// not enough bytes, noncanonical value
					_Mid1 = _First1;
					break;
					}

				if ((_By = (unsigned char)*_Mid1++) < 0x80 || 0xc0 <= _By)
					{
					return (_Mybase::error);	// not continuation byte
					}

				_Ch |= _By & 0x3f;	// complete noncanonical value
				}

			if (*_Pstate == 0)
				{	// first time, maybe look for and consume header
				*_Pstate = 1;

				if ((_Mode & _Consume_header) != 0 && _Ch == 0xfeff)
					{	// drop header and retry
					const result _Ans = do_in(_State, _Mid1, _Last1, _Mid1,
						_First2, _Last2, _Mid2);

					if (_Ans == _Mybase::partial)
						{	// roll back header determination
						*_Pstate = 0;
						_Mid1 = _First1;
						}

					return (_Ans);
					}
				}

			*_Mid2++ = (_Elem)_Ch;
			}

		return (_First1 == _Mid1 ? _Mybase::partial : _Mybase::ok);
		}

	virtual result  do_out(_Statype& _State,
		const _Elem *_First1, const _Elem *_Last1, const _Elem *& _Mid1,
		_Byte *_First2, _Byte *_Last2, _Byte *& _Mid2) const
		{	// convert [_First1, _Last1) to bytes [_First2, _Last)
		unsigned short *_Pstate = (unsigned short *)&_State;
		_Mid1 = _First1;
		_Mid2 = _First2;

		while (_Mid1 != _Last1 && _Mid2 != _Last2)
			{	// convert and put a wide char
			unsigned long _Ch;
			const unsigned short _Ch1 = (unsigned short)*_Mid1;
			bool _Save = false;

			if (1 < *_Pstate)
				{	// get saved MS 11 bits from *_Pstate
				if (_Ch1 < 0xdc00 || 0xe000 <= _Ch1)
					return (_Mybase::error);	// bad second word
				_Ch = static_cast<unsigned long>((*_Pstate << 10) | (_Ch1 - 0xdc00));
				}
			else if (0xd800 <= _Ch1 && _Ch1 < 0xdc00)
				{	// get new first word
				_Ch = static_cast<unsigned long>((_Ch1 - 0xd800 + 0x0040) << 10);
				_Save = true;	// put only first byte, rest with second word
				}
			else
				_Ch = _Ch1;	// not first word, just put it

			_Byte _By;
			int _Nextra;

			if (_Ch < 0x0080)
				{
				_By = (_Byte)_Ch;
				_Nextra = 0;
				}
			else if (_Ch < 0x0800)
				{
				_By = (_Byte)(0xc0 | _Ch >> 6);
				_Nextra = 1;
				}
			else if (_Ch < 0x10000)
				{
				_By = (_Byte)(0xe0 | _Ch >> 12);
				_Nextra = 2;
				}
			else
				{
				_By = (_Byte)(0xf0 | _Ch >> 18);
				_Nextra = 3;
				}

			int _Nput = _Nextra < 3 ? _Nextra + 1 : _Save ? 1 : 3;

			if (_Last2 - _Mid2 < _Nput)
				{
				break;	// not enough room, even without header
				}

			if (*_Pstate == 0 && (_Mode & _Generate_header) != 0)
				{
				if (_Last2 - _Mid2 < 3 + _Nput)
					{
					break;	// not enough room for header + output
					}

				// prepend header
				*_Mid2++ = (_Byte)(unsigned char)0xef;
				*_Mid2++ = (_Byte)(unsigned char)0xbb;
				*_Mid2++ = (_Byte)(unsigned char)0xbf;
				}

			++_Mid1;
			if (_Save || _Nextra < 3)
				{	// put first byte of sequence, if not already put
				*_Mid2++ = _By;
				--_Nput;
				}

			for (; 0 < _Nput; --_Nput)
				{
				*_Mid2++ = (_Byte)((_Ch >> 6 * --_Nextra & 0x3f) | 0x80);
				}

			*_Pstate = (unsigned short)(_Save ? _Ch >> 10 : 1);
			}

		return (_First1 == _Mid1 ? _Mybase::partial : _Mybase::ok);
		}

	virtual result  do_unshift(_Statype& _State,
		_Byte *_First2, _Byte *, _Byte *& _Mid2) const
		{	// generate bytes to return to default shift state
		unsigned short *_Pstate = (unsigned short *)&_State;
		_Mid2 = _First2;

		return (1 < *_Pstate
			? _Mybase::error : _Mybase::ok);	// fail if trailing first word
		}

	virtual int  do_length(_Statype& _State, const _Byte *_First1,
		const _Byte *_Last1, size_t _Count) const
		{	// return min(_Count, converted length of bytes [_First1, _Last1))
		size_t _Wchars = 0;
		_Statype _Mystate = _State;

		while (_Wchars < _Count && _First1 != _Last1)
			{	// convert another wide character
			const _Byte *_Mid1;
			_Elem *_Mid2;
			_Elem _Ch;
			const auto _Result = do_in(_Mystate, _First1, _Last1, _Mid1, &_Ch, &_Ch + 1, _Mid2);
			if (_Result == _Mybase::noconv)
				{
				_Wchars += static_cast<size_t>(_Last1 - _First1);
				break;
				}

			if (_Result == _Mybase::ok)
				{
				if (_Mid2 == &_Ch + 1)
					{
					++_Wchars;	// replacement do_in might not convert one
					}

				_First1 = _Mid1;
				continue;
				}

			break;	// error or partial
			}

		return (static_cast<int>(_Min_value(static_cast<size_t>(2147483647), _Wchars)));
		}

	virtual bool  do_always_noconv() const noexcept override
		{	// return true if conversions never change input
		return (false);
		}

	virtual int  do_max_length() const noexcept override
		{	// return maximum length required for a conversion
		return ((_Mode & _Consume_header) != 0 ? 9	// header + max input
			: (_Mode & _Generate_header) != 0 ? 7	// header + max output
			: 6);	// 6-byte max input sequence, no 3-byte header
		}

	virtual int do_encoding() const noexcept override
		{	// return length of code sequence (from codecvt)
		return (0);	// 0 => varying length
		}

private:
	unsigned long _Maxcode;	// default: 0x10ffff
	_Codecvt_mode _Mode;	// default: _Consume_header
	};

		// CLASS codecvt<char32_t, char, _Mbstatet>
template<>
	class __declspec(dllimport) codecvt<char32_t, char, _Mbstatet>
	: public codecvt_base
	{	// facet for converting between char32_t and UTF-8 byte sequences
public:
	typedef codecvt<char32_t, char, _Mbstatet> _Mybase;
	typedef char32_t _Elem;
	typedef char _Byte;
	typedef _Mbstatet _Statype;
	typedef _Elem intern_type;
	typedef _Byte extern_type;
	typedef _Statype state_type;

	result  in(_Statype& _State,
		const _Byte *_First1, const _Byte *_Last1, const _Byte *& _Mid1,
		_Elem *_First2, _Elem *_Last2, _Elem *& _Mid2) const
		{	// convert bytes [_First1, _Last1) to [_First2, _Last)
		return (do_in(_State,
			_First1, _Last1, _Mid1, _First2, _Last2, _Mid2));
		}

	result  out(_Statype& _State,
		const _Elem *_First1, const _Elem *_Last1, const _Elem *& _Mid1,
		_Byte *_First2, _Byte *_Last2, _Byte *& _Mid2) const
		{	// convert [_First1, _Last1) to bytes [_First2, _Last)
		return (do_out(_State,
			_First1, _Last1, _Mid1, _First2, _Last2, _Mid2));
		}

	result  unshift(_Statype& _State,
		_Byte *_First2, _Byte *_Last2, _Byte *& _Mid2) const
		{	// generate bytes to return to default shift state
		return (do_unshift(_State,
			_First2, _Last2, _Mid2));
		}

	int  length(_Statype& _State, const _Byte *_First1,
		const _Byte *_Last1, size_t _Count) const
		{	// return min(_Count, converted length of bytes [_First1, _Last1))
		return (do_length(_State, _First1, _Last1, _Count));
		}

	 static locale::id id;

	explicit  codecvt(size_t _Refs = 0)
		: codecvt_base(_Refs), _Maxcode(0xffffffff), _Mode(_Consume_header)
		{	// construct from current locale
		{ _Locinfo _Lobj;
			_Init(_Lobj);
		}
		}

	 codecvt(const _Locinfo& _Lobj, size_t _Refs = 0)
		: codecvt_base(_Refs), _Maxcode(0xffffffff), _Mode(_Consume_header)
		{	// construct from specified locale
		_Init(_Lobj);
		}

	 codecvt(const _Locinfo& _Lobj, unsigned long _Maxcode_arg,
		_Codecvt_mode _Mode_arg, size_t _Refs = 0)
		: codecvt_base(_Refs), _Maxcode(_Maxcode_arg), _Mode(_Mode_arg)
		{	// construct from specified locale and parameters
		_Init(_Lobj);
		}

	static size_t __cdecl _Getcat(const locale::facet **_Ppf = nullptr,
		const locale *_Ploc = nullptr)
		{	// return locale category mask and construct standard facet
		if (_Ppf != nullptr && *_Ppf == nullptr)
			*_Ppf = new codecvt<_Elem, _Byte, _Statype>(
				_Locinfo(_Ploc->c_str()));
		return (2);
		}

protected:
	virtual  ~codecvt() noexcept
		{	// destroy the object
		}

	void  _Init(const _Locinfo&)
		{	// initialize
		}

	virtual result  do_in(_Statype& _State,
		const _Byte *_First1, const _Byte *_Last1, const _Byte *& _Mid1,
		_Elem *_First2, _Elem *_Last2, _Elem *& _Mid2) const
		{	// convert bytes [_First1, _Last1) to [_First2, _Last)
		char *_Pstate = (char *)&_State;
		_Mid1 = _First1;
		_Mid2 = _First2;

		while (_Mid1 != _Last1 && _Mid2 != _Last2)
			{	// convert a multibyte sequence
			unsigned char _By = (unsigned char)*_Mid1;
			unsigned long _Ch;
			int _Nextra;

			if (_By < 0x80)
				{
				_Ch = _By;
				_Nextra = 0;
				}
			else if (_By < 0xc0)
				{	// 0x80-0xdf not first byte
				++_Mid1;
				return (_Mybase::error);
				}
			else if (_By < 0xe0)
				{
				_Ch = static_cast<unsigned long>(_By & 0x1f);
				_Nextra = 1;
				}
			else if (_By < 0xf0)
				{
				_Ch = static_cast<unsigned long>(_By & 0x0f);
				_Nextra = 2;
				}
			else if (_By < 0xf8)
				{
				_Ch = static_cast<unsigned long>(_By & 0x07);
				_Nextra = 3;
				}
			else
				{
				_Ch = static_cast<unsigned long>(_By & 0x03);
				_Nextra = _By < 0xfc ? 4 : 5;
				}

			if (_Nextra == 0)
				{
				++_Mid1;
				}
			else if (_Last1 - _Mid1 < _Nextra + 1)
				{
				break;	// not enough input
				}
			else
				{
				for (++_Mid1; 0 < _Nextra; --_Nextra, ++_Mid1)
					{
					if ((_By = (unsigned char)*_Mid1) < 0x80 || 0xc0 <= _By)
						{
						return (_Mybase::error);	// not continuation byte
						}
					else
						{
						_Ch = _Ch << 6 | (_By & 0x3f);
						}
					}
				}

			if (*_Pstate == 0)
				{	// first time, maybe look for and consume header
				*_Pstate = 1;

				if ((_Mode & _Consume_header) != 0 && _Ch == 0xfeff)
					{	// drop header and retry
					const result _Ans = do_in(_State, _Mid1, _Last1, _Mid1,
						_First2, _Last2, _Mid2);

					if (_Ans == _Mybase::partial)
						{	// roll back header determination
						*_Pstate = 0;
						_Mid1 = _First1;
						}
					return (_Ans);
					}
				}

			if (_Maxcode < _Ch)
				{
				return (_Mybase::error);	// code too large
				}

			*_Mid2++ = (_Elem)_Ch;
			}

		return (_First1 == _Mid1 ? _Mybase::partial : _Mybase::ok);
		}

	virtual result  do_out(_Statype& _State,
		const _Elem *_First1, const _Elem *_Last1, const _Elem *& _Mid1,
		_Byte *_First2, _Byte *_Last2, _Byte *& _Mid2) const
		{	// convert [_First1, _Last1) to bytes [_First2, _Last)
		char *_Pstate = (char *)&_State;
		_Mid1 = _First1;
		_Mid2 = _First2;

		while (_Mid1 != _Last1 && _Mid2 != _Last2)
			{	// convert and put a wide char
			_Byte _By;
			int _Nextra;
			unsigned long _Ch = (unsigned long)*_Mid1;

			if (_Maxcode < _Ch)
				return (_Mybase::error);

			if (_Ch < 0x0080)
				{
				_By = (_Byte)_Ch;
				_Nextra = 0;
				}
			else if (_Ch < 0x0800)
				{
				_By = (_Byte)(0xc0 | _Ch >> 6);
				_Nextra = 1;
				}
			else if (_Ch < 0x00010000)
				{
				_By = (_Byte)(0xe0 | _Ch >> 12);
				_Nextra = 2;
				}
			else if (_Ch < 0x00200000)
				{
				_By = (_Byte)(0xf0 | _Ch >> 18);
				_Nextra = 3;
				}
			else if (_Ch < 0x04000000)
				{
				_By = (_Byte)(0xf8 | _Ch >> 24);
				_Nextra = 4;
				}
			else
				{
				_By = (_Byte)(0xfc | (_Ch >> 30 & 0x03));
				_Nextra = 5;
				}

			if (*_Pstate == 0)
				{	// first time, maybe generate header
				*_Pstate = 1;
				if ((_Mode & _Generate_header) != 0)
					{
					if (_Last2 - _Mid2 < 3 + 1 + _Nextra)
						{
						return (_Mybase::partial);	// not enough room for both
						}

					// prepend header
					*_Mid2++ = (_Byte)(unsigned char)0xef;
					*_Mid2++ = (_Byte)(unsigned char)0xbb;
					*_Mid2++ = (_Byte)(unsigned char)0xbf;
					}
				}

			if (_Last2 - _Mid2 < 1 + _Nextra)
				{
				break;	// not enough room for output
				}

			++_Mid1;
			for (*_Mid2++ = _By; 0 < _Nextra; )
				{
				*_Mid2++ = (_Byte)((_Ch >> 6 * --_Nextra & 0x3f) | 0x80);
				}
			}
		return (_First1 == _Mid1 ? _Mybase::partial : _Mybase::ok);
		}

	virtual result  do_unshift(_Statype&,
		_Byte *_First2, _Byte *, _Byte *& _Mid2) const
		{	// generate bytes to return to default shift state
		_Mid2 = _First2;

		return (_Mybase::ok);
		}

	virtual int  do_length(_Statype& _State, const _Byte *_First1,
		const _Byte *_Last1, size_t _Count) const
		{	// return min(_Count, converted length of bytes [_First1, _Last1))
		size_t _Wchars = 0;
		_Statype _Mystate = _State;

		while (_Wchars < _Count && _First1 != _Last1)
			{	// convert another wide character
			const _Byte *_Mid1;
			_Elem *_Mid2;
			_Elem _Ch;
			const auto _Result = do_in(_Mystate, _First1, _Last1, _Mid1, &_Ch, &_Ch + 1, _Mid2);
			if (_Result == _Mybase::noconv)
				{
				_Wchars += static_cast<size_t>(_Last1 - _First1);
				break;
				}

			if (_Result == _Mybase::ok)
				{
				if (_Mid2 == &_Ch + 1)
					{
					++_Wchars;	// replacement do_in might not convert one
					}

				_First1 = _Mid1;
				continue;
				}

			break;	// error or partial
			}

		return (static_cast<int>(_Min_value(static_cast<size_t>(2147483647), _Wchars)));
		}

	virtual bool  do_always_noconv() const noexcept override
		{	// return true if conversions never change input
		return (false);
		}

	virtual int  do_max_length() const noexcept override
		{	// return maximum length required for a conversion
		return ((_Mode & (_Consume_header | _Generate_header)) != 0
			? 9 : 6);
		}

	virtual int  do_encoding() const noexcept override
		{	// return length of code sequence (from codecvt)
		return ((_Mode & (_Consume_header | _Generate_header)) != 0
			? -1 : 0);	// -1 => state dependent, 0 => varying length
		}

private:
	unsigned long _Maxcode;	// default: 0xffffffff
	_Codecvt_mode _Mode;	// default: _Consume_header
	};

		// CLASS codecvt<wchar_t, char, _Mbstatet>
template<>
	class __declspec(dllimport) codecvt<wchar_t, char, _Mbstatet>
	: public codecvt_base
	{	// facet for converting between wchar_t and char (_Byte) sequences
public:
	typedef wchar_t _Elem;
	typedef char _Byte;
	typedef _Mbstatet _Statype;
	typedef _Elem intern_type;
	typedef _Byte extern_type;
	typedef _Statype state_type;

	result  in(_Statype& _State,
		const _Byte *_First1, const _Byte *_Last1, const _Byte *& _Mid1,
		_Elem *_First2, _Elem *_Last2, _Elem *& _Mid2) const
		{	// convert bytes [_First1, _Last1) to [_First2, _Last)
		return (do_in(_State,
			_First1, _Last1, _Mid1, _First2, _Last2, _Mid2));
		}

	result  out(_Statype& _State,
		const _Elem *_First1, const _Elem *_Last1, const _Elem *& _Mid1,
		_Byte *_First2, _Byte *_Last2, _Byte *& _Mid2) const
		{	// convert [_First1, _Last1) to bytes [_First2, _Last)
		return (do_out(_State,
			_First1, _Last1, _Mid1, _First2, _Last2, _Mid2));
		}

	result  unshift(_Statype& _State,
		_Byte *_First2, _Byte *_Last2, _Byte *& _Mid2) const
		{	// generate bytes to return to default shift state
		return (do_unshift(_State,
			_First2, _Last2, _Mid2));
		}

	int  length(_Statype& _State, const _Byte *_First1,
		const _Byte *_Last1, size_t _Count) const
		{	// return min(_Count, converted length of bytes [_First1, _Last1))
		return (do_length(_State, _First1, _Last1, _Count));
		}

	 static locale::id id;

	explicit  codecvt(size_t _Refs = 0)
		: codecvt_base(_Refs)
		{	// construct from current locale
		{ _Locinfo _Lobj;
			_Init(_Lobj);
		}
		}

	 codecvt(const _Locinfo& _Lobj, size_t _Refs = 0)
		: codecvt_base(_Refs)
		{	// construct from specified locale
		_Init(_Lobj);
		}

	static size_t __cdecl _Getcat(const locale::facet **_Ppf = nullptr,
		const locale *_Ploc = nullptr)
		{	// return locale category mask and construct standard facet
		if (_Ppf != nullptr && *_Ppf == nullptr)
			*_Ppf = new codecvt<_Elem, _Byte, _Statype>(
				_Locinfo(_Ploc->c_str()));
		return (2);
		}

protected:
	virtual  ~codecvt() noexcept
		{	// destroy the object
		}

	void  _Init(const _Locinfo& _Lobj)
		{	// initialize from _Lobj
		_Cvt = _Lobj._Getcvt();
		}

	virtual result  do_in(_Statype&,
		const _Byte *_First1, const _Byte *_Last1, const _Byte *& _Mid1,
			_Elem *_First2, _Elem *_Last2, _Elem *& _Mid2) const
		{	// convert bytes [_First1, _Last1) to [_First2, _Last)
		_Statype _Mystate{};
		_Adl_verify_range(_First1, _Last1);
		_Adl_verify_range(_First2, _Last2);
		_Mid1 = _First1;
		_Mid2 = _First2;
		for (;;)
			{
			if (_Mid1 == _Last1)
				{
				return (ok);
				}

			if (_Mid2 == _Last2)
				{
				return (partial);
				}

			int _Bytes = _Mbrtowc(_Mid2, _Mid1, static_cast<size_t>(_Last1 - _Mid1), &_Mystate, &_Cvt);
			switch (_Bytes)
				{
				case -2:	// partial conversion
					return (partial);

				case -1:	// failed conversion
					return (error);

				case 0:	// converted NULL character, TRANSITION, VSO#654347
					_Bytes = 1;
					// [[fallthrough]];

				default:	// converted some other character
					_Mid1 += _Bytes;
					++_Mid2;
					break;
				}
			}
		}

	virtual result  do_out(_Statype& _State,
		const _Elem *_First1, const _Elem *_Last1, const _Elem *& _Mid1,
			_Byte *_First2, _Byte *_Last2, _Byte *& _Mid2) const
		{	// convert [_First1, _Last1) to bytes [_First2, _Last)
		_Adl_verify_range(_First1, _Last1);
		_Adl_verify_range(_First2, _Last2);
		_Mid1 = _First1;
		_Mid2 = _First2;
		int _Bytes;

		while (_Mid1 != _Last1 && _Mid2 != _Last2)
			{
			if ((int)5 <= _Last2 - _Mid2)
				{
				if ((_Bytes = _Wcrtomb(_Mid2, *_Mid1,
					&_State, &_Cvt)) < 0)
					{
					return (error);	// locale-specific wcrtomb failed
					}
				else
					{
					++_Mid1;
					_Mid2 += _Bytes;
					}
				}
			else
				{	// destination too small, convert into buffer
				_Byte _Buf[5];
				_Statype _Stsave = _State;

				if ((_Bytes = _Wcrtomb(_Buf, *_Mid1,
					&_State, &_Cvt)) < 0)
					{
					return (error);	// locale-specific wcrtomb failed
					}
				else if (_Last2 - _Mid2 < _Bytes)
					{	// converted too many, roll back and return previous
					_State = _Stsave;
					break;
					}
				else
					{	// copy converted bytes from buffer
					:: memcpy(_Mid2, _Buf, static_cast<size_t>(_Bytes));
					++_Mid1;
					_Mid2 += _Bytes;
					}
				}
			}

		return (_Mid1 == _Last1 ? ok : partial);
		}

	virtual result  do_unshift(_Statype& _State,
		_Byte *_First2, _Byte *_Last2, _Byte *& _Mid2) const
		{	// generate bytes to return to default shift state
		_Adl_verify_range(_First2, _Last2);
		_Mid2 = _First2;
		result _Ans = ok;
		int _Bytes;
		_Byte _Buf[5];
		_Statype _Stsave = _State;

		if ((_Bytes = _Wcrtomb(_Buf, L'\0', &_State, &_Cvt)) <= 0)
			_Ans = error;	// locale-specific wcrtomb failed
		else if (_Last2 - _Mid2 < --_Bytes)
			{	// converted too many, roll back and return
			_State = _Stsave;
			_Ans = partial;
			}
		else if (0 < _Bytes)
			{	// copy converted bytes from buffer
			:: memcpy(_Mid2, _Buf, static_cast<size_t>(_Bytes));
			_Mid2 += _Bytes;
			}
		return (_Ans);
		}

	virtual int  do_length(_Statype&, const _Byte *_First1,
		const _Byte *_Last1, size_t _Count) const
		{	// return min(_Count, converted length of bytes [_First1, _Last1))
		_Adl_verify_range(_First1, _Last1);
		size_t _Wchars = 0;
		_Statype _Mystate{};

		while (_Wchars < _Count && _First1 != _Last1)
			{
			_Elem _Ch;
			int _Bytes = _Mbrtowc(&_Ch, _First1, static_cast<size_t>(_Last1 - _First1), &_Mystate, &_Cvt);
			if (_Bytes < 0)
				{	// partial or failed conversion
				break;
				}

			if (_Bytes == 0)
				{	// converted NULL character, TRANSITION, VSO#654347
				_Bytes = 1;
				}

			// converted _Bytes bytes to a wchar_t:
			_First1 += _Bytes;
			++_Wchars;
			}

		return (static_cast<int>(_Min_value(static_cast<size_t>(2147483647), _Wchars)));
		}

	virtual bool  do_always_noconv() const noexcept override
		{	// return true if conversions never change input
		return (false);
		}

	virtual int  do_max_length() const noexcept override
		{	// return maximum length required for a conversion (from codecvt)
		return (5);
		}

	virtual int  do_encoding() const noexcept override
		{	// return length of code sequence (from codecvt)
		return (0);	// 0 => varying length
		}

private:
	_Locinfo::_Cvtvec _Cvt;	// locale info passed to _Mbrtowc, _Wcrtomb
	};

 
		// CLASS codecvt<unsigned short, char, _Mbstatet>
template<>
	class __declspec(dllimport) codecvt<unsigned short, char, _Mbstatet>
	: public codecvt_base
	{	// facet for converting between unsigned short and char sequences
public:
	typedef unsigned short _Elem;
	typedef char _Byte;
	typedef _Mbstatet _Statype;
	typedef _Elem intern_type;
	typedef _Byte extern_type;
	typedef _Statype state_type;

	result  in(_Statype& _State,
		const _Byte *_First1, const _Byte *_Last1, const _Byte *& _Mid1,
		_Elem *_First2, _Elem *_Last2, _Elem *& _Mid2) const
		{	// convert bytes [_First1, _Last1) to [_First2, _Last)
		return (do_in(_State,
			_First1, _Last1, _Mid1, _First2, _Last2, _Mid2));
		}

	result  out(_Statype& _State,
		const _Elem *_First1, const _Elem *_Last1, const _Elem *& _Mid1,
		_Byte *_First2, _Byte *_Last2, _Byte *& _Mid2) const
		{	// convert [_First1, _Last1) to bytes [_First2, _Last)
		return (do_out(_State,
			_First1, _Last1, _Mid1, _First2, _Last2, _Mid2));
		}

	result  unshift(_Statype& _State,
		_Byte *_First2, _Byte *_Last2, _Byte *& _Mid2) const
		{	// generate bytes to return to default shift state
		return (do_unshift(_State,
			_First2, _Last2, _Mid2));
		}

	int  length(_Statype& _State, const _Byte *_First1,
		const _Byte *_Last1, size_t _Count) const
		{	// return min(_Count, converted length of bytes [_First1, _Last1))
		return (do_length(_State, _First1, _Last1, _Count));
		}

	 static locale::id id;

	explicit  codecvt(size_t _Refs = 0)
		: codecvt_base(_Refs)
		{	// construct from current locale
		{ _Locinfo _Lobj;
			_Init(_Lobj);
		}
		}

	 codecvt(const _Locinfo& _Lobj, size_t _Refs = 0)
		: codecvt_base(_Refs)
		{	// construct from specified locale
		_Init(_Lobj);
		}

	static size_t __cdecl _Getcat(const locale::facet **_Ppf = nullptr,
		const locale *_Ploc = nullptr)
		{	// return locale category mask and construct standard facet
		if (_Ppf != nullptr && *_Ppf == nullptr)
			*_Ppf = new codecvt<_Elem, _Byte, _Statype>(
				_Locinfo(_Ploc->c_str()));
		return (2);
		}

protected:
	virtual  ~codecvt() noexcept
		{	// destroy the object
		}

	void  _Init(const _Locinfo& _Lobj)
		{	// initialize from _Lobj
		_Cvt = _Lobj._Getcvt();
		}

	virtual result  do_in(_Statype&,
		const _Byte *_First1, const _Byte *_Last1, const _Byte *& _Mid1,
			_Elem *_First2, _Elem *_Last2, _Elem *& _Mid2) const
		{	// convert bytes [_First1, _Last1) to [_First2, _Last)
		_Statype _Mystate{};
		_Adl_verify_range(_First1, _Last1);
		_Adl_verify_range(_First2, _Last2);
		_Mid1 = _First1;
		_Mid2 = _First2;
		for (;;)
			{
			if (_Mid1 == _Last1)
				{
				return (ok);
				}

			if (_Mid2 == _Last2)
				{
				return (partial);
				}

			int _Bytes = _Mbrtowc(reinterpret_cast<wchar_t *>(_Mid2), _Mid1,
				static_cast<size_t>(_Last1 - _Mid1), &_Mystate, &_Cvt);
			switch (_Bytes)
				{
				case -2:	// partial conversion
					return (partial);

				case -1:	// failed conversion
					return (error);

				case 0:	// converted NULL character, TRANSITION, VSO#654347
					_Bytes = 1;
					// [[fallthrough]];

				default:	// converted some other character
					_Mid1 += _Bytes;
					++_Mid2;
					break;
				}
			}
		}

	virtual result  do_out(_Statype& _State,
		const _Elem *_First1, const _Elem *_Last1, const _Elem *& _Mid1,
			_Byte *_First2, _Byte *_Last2, _Byte *& _Mid2) const
		{	// convert [_First1, _Last1) to bytes [_First2, _Last)
		_Adl_verify_range(_First1, _Last1);
		_Adl_verify_range(_First2, _Last2);
		_Mid1 = _First1;
		_Mid2 = _First2;
		int _Bytes;

		while (_Mid1 != _Last1 && _Mid2 != _Last2)
			{
			if ((int)5 <= _Last2 - _Mid2)
				{
				if ((_Bytes = _Wcrtomb(_Mid2, *_Mid1,
					&_State, &_Cvt)) < 0)
					{
					return (error);	// locale-specific wcrtomb failed
					}
				else
					{
					++_Mid1;
					_Mid2 += _Bytes;
					}
				}
			else
				{	// destination too small, convert into buffer
				_Byte _Buf[5];
				_Statype _Stsave = _State;

				if ((_Bytes = _Wcrtomb(_Buf, *_Mid1,
					&_State, &_Cvt)) < 0)
					{
					return (error);	// locale-specific wcrtomb failed
					}
				else if (_Last2 - _Mid2 < _Bytes)
					{	// converted too many, roll back and return previous
					_State = _Stsave;
					break;
					}
				else
					{	// copy converted bytes from buffer
					:: memcpy(_Mid2, _Buf, static_cast<size_t>(_Bytes));
					++_Mid1;
					_Mid2 += _Bytes;
					}
				}
			}

		return (_Mid1 == _Last1 ? ok : partial);
		}

	virtual result  do_unshift(_Statype& _State,
		_Byte *_First2, _Byte *_Last2, _Byte *& _Mid2) const
		{	// generate bytes to return to default shift state
		_Adl_verify_range(_First2, _Last2);
		_Mid2 = _First2;
		result _Ans = ok;
		int _Bytes;
		_Byte _Buf[5];
		_Statype _Stsave = _State;

		if ((_Bytes = _Wcrtomb(_Buf, L'\0', &_State, &_Cvt)) <= 0)
			{
			_Ans = error;	// locale-specific wcrtomb failed
			}
		else if (_Last2 - _Mid2 < --_Bytes)
			{	// converted too many, roll back and return
			_State = _Stsave;
			_Ans = partial;
			}
		else if (0 < _Bytes)
			{	// copy converted bytes from buffer
			:: memcpy(_Mid2, _Buf, static_cast<size_t>(_Bytes));
			_Mid2 += _Bytes;
			}

		return (_Ans);
		}

	virtual int  do_length(_Statype&, const _Byte *_First1,
		const _Byte *_Last1, size_t _Count) const
		{	// return min(_Count, converted length of bytes [_First1, _Last1))
		_Adl_verify_range(_First1, _Last1);
		size_t _Wchars = 0;
		_Statype _Mystate{};

		while (_Wchars < _Count && _First1 != _Last1)
			{
			wchar_t _Ch;
			int _Bytes = _Mbrtowc(&_Ch, _First1, static_cast<size_t>(_Last1 - _First1), &_Mystate, &_Cvt);
			if (_Bytes < 0)
				{	// partial or failed conversion
				break;
				}

			if (_Bytes == 0)
				{	// converted NULL character, TRANSITION, VSO#654347
				_Bytes = 1;
				}

			// converted _Bytes bytes to a wchar_t:
			_First1 += _Bytes;
			++_Wchars;
			}

		return (static_cast<int>(_Min_value(static_cast<size_t>(2147483647), _Wchars)));
		}

	virtual bool  do_always_noconv() const noexcept override
		{	// return true if conversions never change input
		return (false);
		}

	virtual int  do_max_length() const noexcept override
		{	// return maximum length required for a conversion (from codecvt)
		return (5);
		}

	virtual int  do_encoding() const noexcept override
		{	// return length of code sequence (from codecvt)
		return (0);	// 0 => varying length
		}

private:
	_Locinfo::_Cvtvec _Cvt;	// locale info passed to _Mbrtowc, _Wcrtomb
	};
 

		// CLASS TEMPLATE codecvt_byname
template<class _Elem,
	class _Byte,
	class _Statype>
	class codecvt_byname
		: public codecvt<_Elem, _Byte, _Statype>
	{	// codecvt for named locale
public:
	explicit  codecvt_byname(const char *_Locname, size_t _Refs = 0)
		: codecvt<_Elem, _Byte, _Statype>(_Locinfo(_Locname), _Refs)
		{	// construct for named locale
		}

	explicit  codecvt_byname(const string& _Str, size_t _Refs = 0)
		: codecvt<_Elem, _Byte, _Statype>(_Locinfo(_Str.c_str()), _Refs)
		{	// construct for named locale
		}

protected:
	virtual  ~codecvt_byname() noexcept
		{	// destroy the object
		}
	};

		// STRUCT ctype_base
struct __declspec(dllimport) ctype_base
	: public locale::facet
	{	// base for ctype
	enum
		{	// constants for character classifications
		alnum = 0x04 | 0x02 | 0x01 | 0x100, alpha = 0x02 | 0x01 | 0x100,
		cntrl = 0x20, digit = 0x04, graph = 0x04 | 0x02 | 0x10 | 0x01 | 0x100,
		lower = 0x02, print = 0x04 | 0x02 | 0x10 | 0x40 | 0x01 | 0x100 | 0x80,
		punct = 0x10, space = 0x08 | 0x40 | 0x000, upper = 0x01,
		xdigit = 0x80, blank = 0x08 | 0x40 | 0x000 | 0x000};
	typedef short mask;	// to match <ctype.h>

	 ctype_base(size_t _Refs = 0)
		: locale::facet(_Refs)
		{	// default constructor
		}

	 ~ctype_base() noexcept
		{	// destroy the object
		}
	};

		// CLASS TEMPLATE ctype
template<class _Elem>
	class ctype
		: public ctype_base
	{	// facet for classifying elements, converting cases
public:
	typedef _Elem char_type;

	bool  is(mask _Maskval, _Elem _Ch) const
		{	// test if element fits any mask classifications
		return (do_is(_Maskval, _Ch));
		}

	const _Elem * is(const _Elem *_First, const _Elem *_Last,
		mask *_Dest) const
		{	// get mask sequence for elements in [_First, _Last)
		return (do_is(_First, _Last, _Dest));
		}

	const _Elem * scan_is(mask _Maskval, const _Elem *_First,
		const _Elem *_Last) const
		{	// find first in [_First, _Last) that fits mask classification
		return (do_scan_is(_Maskval, _First, _Last));
		}

	const _Elem * scan_not(mask _Maskval, const _Elem *_First,
		const _Elem *_Last) const
		{	// find first in [_First, _Last) not fitting mask classification
		return (do_scan_not(_Maskval, _First, _Last));
		}

	_Elem  tolower(_Elem _Ch) const
		{	// convert element to lower case
		return (do_tolower(_Ch));
		}

	const _Elem * tolower(_Elem *_First, const _Elem *_Last) const
		{	// convert [_First, _Last) in place to lower case
		return (do_tolower(_First, _Last));
		}

	_Elem  toupper(_Elem _Ch) const
		{	// convert element to upper case
		return (do_toupper(_Ch));
		}

	const _Elem * toupper(_Elem *_First, const _Elem *_Last) const
		{	// convert [_First, _Last) in place to upper case
		return (do_toupper(_First, _Last));
		}

	_Elem  widen(char _Byte) const
		{	// widen char
		return (do_widen(_Byte));
		}

	const char * widen(const char *_First, const char *_Last,
		_Elem *_Dest) const
		{	// widen chars in [_First, _Last)
		return (do_widen(_First, _Last, _Dest));
		}

	char  narrow(_Elem _Ch, char _Dflt = '\0') const
		{	// narrow element to char
		return (do_narrow(_Ch, _Dflt));
		}

	const _Elem * narrow(const _Elem *_First, const _Elem *_Last,
		char _Dflt, char *_Dest) const
		{	// narrow elements in [_First, _Last) to chars
		return (do_narrow(_First, _Last, _Dflt, _Dest));
		}

	 static locale::id id;

	explicit  ctype(size_t _Refs = 0)
		: ctype_base(_Refs)
		{	// construct from current locale
		{ _Locinfo _Lobj;
			_Init(_Lobj);
		}
		}

	 ctype(const _Locinfo& _Lobj, size_t _Refs = 0)
		: ctype_base(_Refs)
		{	// construct from specified locale
		_Init(_Lobj);
		}

	static size_t __cdecl _Getcat(const locale::facet **_Ppf = nullptr,
		const locale *_Ploc = nullptr)
		{	// return locale category mask and construct standard facet
		if (_Ppf != nullptr && *_Ppf == nullptr)
			*_Ppf = new ctype<_Elem>(
				_Locinfo(_Ploc->c_str()));
		return (2);
		}

protected:
	virtual  ~ctype() noexcept
		{	// destroy the object
		if (_Ctype._Delfl)
			:: free((void *)_Ctype._Table);

		:: free(_Ctype._LocaleName);
		}

	void  _Init(const _Locinfo& _Lobj)
		{	// initialize from _Lobj
		_Ctype = _Lobj._Getctype();
		_Cvt = _Lobj._Getcvt();
		}

	virtual bool  do_is(mask _Maskval, _Elem _Ch) const
		{	// test if element fits any mask classifications
		return ((_Ctype._Table[(unsigned char)narrow(_Ch)]
			& _Maskval) != 0);
		}

	virtual const _Elem * do_is(const _Elem *_First, const _Elem *_Last,
		mask *_Dest) const
		{	// get mask sequence for elements in [_First, _Last)
		_Adl_verify_range(_First, _Last);
		for (; _First != _Last; ++_First, ++_Dest)
			{
			*_Dest = _Ctype._Table[(unsigned char)narrow(*_First)];
			}

		return (_First);
		}

	virtual const _Elem * do_scan_is(mask _Maskval,
		const _Elem *_First, const _Elem *_Last) const
		{	// find first in [_First, _Last) that fits mask classification
		_Adl_verify_range(_First, _Last);
		while (_First != _Last && !is(_Maskval, *_First))
			{
			++_First;
			}

		return (_First);
		}

	virtual const _Elem * do_scan_not(mask _Maskval,
		const _Elem *_First, const _Elem *_Last) const
		{	// find first in [_First, _Last) not fitting mask classification
		_Adl_verify_range(_First, _Last);
		while (_First != _Last && is(_Maskval, *_First))
			{
			++_First;
			}

		return (_First);
		}

	virtual _Elem  do_tolower(_Elem _Ch) const
		{	// convert element to lower case
		unsigned char _Byte = (unsigned char)narrow(_Ch, '\0');
		if (_Byte == '\0')
			{
			return (_Ch);
			}

		return (widen((char)_Tolower(_Byte, &_Ctype)));
		}

	virtual const _Elem * do_tolower(_Elem *_First,
		const _Elem *_Last) const
		{	// convert [_First, _Last) in place to lower case
		_Adl_verify_range((const _Elem *)_First, _Last);
		for (; _First != _Last; ++_First)
			{	// convert *_First to lower case
			unsigned char _Byte = (unsigned char)narrow(*_First, '\0');
			if (_Byte != '\0')
				{
				*_First = (widen((char)_Tolower(_Byte, &_Ctype)));
				}
			}
		return ((const _Elem *)_First);
		}

	virtual _Elem  do_toupper(_Elem _Ch) const
		{	// convert element to upper case
		unsigned char _Byte = (unsigned char)narrow(_Ch, '\0');
		if (_Byte == '\0')
			{
			return (_Ch);
			}

		return (widen((char)_Toupper(_Byte, &_Ctype)));
		}

	virtual const _Elem * do_toupper(_Elem *_First,
		const _Elem *_Last) const
		{	// convert [_First, _Last) in place to upper case
		_Adl_verify_range((const _Elem *)_First, _Last);
		for (; _First != _Last; ++_First)
			{	// convert *_First to upper case
			unsigned char _Byte = (unsigned char)narrow(*_First, '\0');
			if (_Byte != '\0')
				{
				*_First = (widen((char)_Toupper(_Byte, &_Ctype)));
				}
			}

		return ((const _Elem *)_First);
		}

	virtual _Elem  do_widen(char _Byte) const
		{	// widen char
		return (_Maklocchr(_Byte, static_cast<_Elem *>(nullptr), _Cvt));
		}

	virtual const char * do_widen(const char *_First,
		const char *_Last, _Elem *_Dest) const
		{	// widen chars in [_First, _Last)
		_Adl_verify_range(_First, _Last);
		for (; _First != _Last; ++_First, ++_Dest)
			{
			*_Dest = _Maklocchr(*_First, static_cast<_Elem *>(nullptr), _Cvt);
			}

		return (_First);
		}

	char  _Donarrow(_Elem _Ch, char _Dflt) const
		{	// narrow element to char
		char _Byte;
		if (_Ch == (_Elem)0)
			{
			return ('\0');
			}

		if ((_Byte = _Maklocbyte(_Ch, _Cvt)) == '\0')
			{
			return (_Dflt);
			}

		return (_Byte);
		}

	virtual char  do_narrow(_Elem _Ch, char _Dflt) const
		{	// narrow element to char
		return (_Donarrow(_Ch, _Dflt));
		}

	virtual const _Elem * do_narrow(const _Elem *_First,
		const _Elem *_Last, char _Dflt, char *_Dest) const
		{	// narrow elements in [_First, _Last) to chars
		_Adl_verify_range(_First, _Last);
		for (; _First != _Last; ++_First, ++_Dest)
			{
			*_Dest = _Donarrow(*_First, _Dflt);
			}

		return (_First);
		}

private:
	_Locinfo::_Ctypevec _Ctype;	// locale info passed to _Tolower, etc.
	_Locinfo::_Cvtvec _Cvt;		// conversion information
	};

		// STATIC ctype::id OBJECT





template<class _Elem>
	locale::id ctype<_Elem>::id;





		// CLASS ctype<char>
template<>
	class __declspec(dllimport) ctype<char>
	: public ctype_base
	{	// facet for classifying char elements, converting cases
public:
	typedef char _Elem;
	typedef _Elem char_type;

	bool  is(mask _Maskval, _Elem _Ch) const
		{	// test if element fits any mask classifications
		return ((_Ctype._Table[(unsigned char)_Ch] & _Maskval) != 0);
		}

	const _Elem * is(const _Elem *_First,
		const _Elem *_Last, mask *_Dest) const
		{	// get mask sequence for elements in [_First, _Last)
		_Adl_verify_range(_First, _Last);
		for (; _First != _Last; ++_First, ++_Dest)
			*_Dest = _Ctype._Table[(unsigned char)*_First];
		return (_First);
		}

	const _Elem * scan_is(mask _Maskval,
		const _Elem *_First, const _Elem *_Last) const
		{	// find first in [_First, _Last) that fits mask classification
		_Adl_verify_range(_First, _Last);
		while (_First != _Last && !is(_Maskval, *_First))
			{
			++_First;
			}

		return (_First);
		}

	const _Elem * scan_not(mask _Maskval,
		const _Elem *_First, const _Elem *_Last) const
		{	// find first in [_First, _Last) not fitting mask classification
		_Adl_verify_range(_First, _Last);
		while (_First != _Last && is(_Maskval, *_First))
			{
			++_First;
			}

		return (_First);
		}

	_Elem  tolower(_Elem _Ch) const
		{	// convert element to lower case
		return (do_tolower(_Ch));
		}

	const _Elem * tolower(_Elem *_First, const _Elem *_Last) const
		{	// convert [_First, _Last) in place to lower case
		return (do_tolower(_First, _Last));
		}

	_Elem  toupper(_Elem _Ch) const
		{	// convert element to upper case
		return (do_toupper(_Ch));
		}

	const _Elem * toupper(_Elem *_First, const _Elem *_Last) const
		{	// convert [_First, _Last) in place to upper case
		return (do_toupper(_First, _Last));
		}

	_Elem  widen(char _Byte) const
		{	// widen char
		return (do_widen(_Byte));
		}

	const _Elem * widen(const char *_First, const char *_Last,
		_Elem *_Dest) const
		{	// widen chars in [_First, _Last)
		return (do_widen(_First, _Last, _Dest));
		}

	_Elem  narrow(_Elem _Ch, char _Dflt = '\0') const
		{	// narrow element to char
		return (do_narrow(_Ch, _Dflt));
		}

	const _Elem * narrow(const _Elem *_First, const _Elem *_Last,
		char _Dflt, char *_Dest) const
		{	// narrow elements in [_First, _Last) to chars
		return (do_narrow(_First, _Last, _Dflt, _Dest));
		}

	 static locale::id id;

	explicit  ctype(const mask *_Table = nullptr,
		bool _Deletetable = false,
		size_t _Refs = 0)
		: ctype_base(_Refs)
		{	// construct with specified table and delete flag for table
		{ _Locinfo _Lobj;
			_Init(_Lobj);
		}

		_Tidy();	// free existing table, as needed
		if (_Table != nullptr)
			{	// replace existing char to mask table
			_Ctype._Table = _Table;
			_Ctype._Delfl = _Deletetable ? -1 : 0;
			}
		else
			{	// use classic table
			_Ctype._Table = classic_table();
			_Ctype._Delfl = 0;
			}
		}

	 ctype(const _Locinfo& _Lobj, size_t _Refs = 0)
		: ctype_base(_Refs)
		{	// construct from current locale
		_Init(_Lobj);
		}

	static size_t __cdecl _Getcat(const locale::facet **_Ppf = nullptr,
		const locale *_Ploc = nullptr)
		{	// return locale category mask and construct standard facet
		if (_Ppf != nullptr && *_Ppf == nullptr)
			*_Ppf = new ctype<_Elem>(
				_Locinfo(_Ploc->c_str()));
		return (2);
		}

	const mask * table() const noexcept
		{	// return address of char to mask table
		return (_Ctype._Table);
		}

	static const mask *__cdecl classic_table() noexcept
		{	// return address of char to mask table for "C" locale
		return (::std:: use_facet<ctype>(locale::classic()).table());
		}

	 static const size_t table_size =
		1 << 8;	// size of ctype mapping table, typically 256

protected:
	virtual  ~ctype() noexcept
		{	// destroy the object
		_Tidy();
		}

	void  _Init(const _Locinfo& _Lobj)
		{	// initialize from _Lobj
		_Ctype = _Lobj._Getctype();
		}

	void  _Tidy()
		{	// free any allocated storage
		if (0 < _Ctype._Delfl)
			:: free((void *)_Ctype._Table);
		else if (_Ctype._Delfl < 0)
			delete[] _Ctype._Table;

		:: free(_Ctype._LocaleName);
		}

	virtual _Elem  do_tolower(_Elem _Ch) const
		{	// convert element to lower case
		return ((_Elem)_Tolower((unsigned char)_Ch, &_Ctype));
		}

	virtual const _Elem * do_tolower(_Elem *_First,
		const _Elem *_Last) const
		{	// convert [_First, _Last) in place to lower case
		_Adl_verify_range((const _Elem *)_First, _Last);
		for (; _First != _Last; ++_First)
			{
			*_First = (_Elem)_Tolower((unsigned char)*_First, &_Ctype);
			}

		return ((const _Elem *)_First);
		}

	virtual _Elem  do_toupper(_Elem _Ch) const
		{	// convert element to upper case
		return ((_Elem)_Toupper((unsigned char)_Ch, &_Ctype));
		}

	virtual const _Elem * do_toupper(_Elem *_First,
		const _Elem *_Last) const
		{	// convert [_First, _Last) in place to upper case
		_Adl_verify_range((const _Elem *)_First, _Last);
		for (; _First != _Last; ++_First)
			{
			*_First = (_Elem)_Toupper((unsigned char)*_First, &_Ctype);
			}

		return ((const _Elem *)_First);
		}

	virtual _Elem  do_widen(char _Byte) const
		{	// widen char
		return (_Byte);
		}

	virtual const _Elem * do_widen(const char *_First,
		const char *_Last, _Elem *_Dest) const
		{	// widen chars in [_First, _Last)
		_Adl_verify_range(_First, _Last);
		:: memcpy(_Dest, _First, static_cast<size_t>(_Last - _First));
		return (_Last);
		}

	virtual _Elem  do_narrow(_Elem _Ch, char) const
		{	// narrow char
		return (_Ch);
		}

	virtual const _Elem * do_narrow(const _Elem *_First,
		const _Elem *_Last, char, char *_Dest) const
		{	// narrow elements in [_First, _Last) to chars
		_Adl_verify_range(_First, _Last);
		:: memcpy(_Dest, _First, static_cast<size_t>(_Last - _First));
		return (_Last);
		}

private:
	_Locinfo::_Ctypevec _Ctype;	// information
	};

		// CLASS ctype<wchar_t>
template<>
	class __declspec(dllimport) ctype<wchar_t>
	: public ctype_base
	{	// facet for classifying wchar_t elements, converting cases
public:
	typedef wchar_t _Elem;
	typedef _Elem char_type;

	bool  is(mask _Maskval, _Elem _Ch) const
		{	// test if element fits any mask classifications
		return (do_is(_Maskval, _Ch));
		}

	const _Elem * is(const _Elem *_First, const _Elem *_Last,
		mask *_Dest) const
		{	// get mask sequence for elements in [_First, _Last)
		return (do_is(_First, _Last, _Dest));
		}

	const _Elem * scan_is(mask _Maskval, const _Elem *_First,
		const _Elem *_Last) const
		{	// find first in [_First, _Last) that fits mask classification
		return (do_scan_is(_Maskval, _First, _Last));
		}

	const _Elem * scan_not(mask _Maskval, const _Elem *_First,
		const _Elem *_Last) const
		{	// find first in [_First, _Last) not fitting mask classification
		return (do_scan_not(_Maskval, _First, _Last));
		}

	_Elem  tolower(_Elem _Ch) const
		{	// convert element to lower case
		return (do_tolower(_Ch));
		}

	const _Elem * tolower(_Elem *_First, const _Elem *_Last) const
		{	// convert [_First, _Last) in place to lower case
		return (do_tolower(_First, _Last));
		}

	_Elem  toupper(_Elem _Ch) const
		{	// convert element to upper case
		return (do_toupper(_Ch));
		}

	const _Elem * toupper(_Elem *_First, const _Elem *_Last) const
		{	// convert [_First, _Last) in place to upper case
		return (do_toupper(_First, _Last));
		}

	_Elem  widen(char _Byte) const
		{	// widen char
		return (do_widen(_Byte));
		}

	const char * widen(const char *_First, const char *_Last,
		_Elem *_Dest) const
		{	// widen chars in [_First, _Last)
		return (do_widen(_First, _Last, _Dest));
		}

	char  narrow(_Elem _Ch, char _Dflt = '\0') const
		{	// narrow element to char
		return (do_narrow(_Ch, _Dflt));
		}

	const _Elem * narrow(const _Elem *_First, const _Elem *_Last,
		char _Dflt, char *_Dest) const
		{	// narrow elements in [_First, _Last) to chars
		return (do_narrow(_First, _Last, _Dflt, _Dest));
		}

	 static locale::id id;

	explicit  ctype(size_t _Refs = 0)
		: ctype_base(_Refs)
		{	// construct from current locale
		{ _Locinfo _Lobj;
			_Init(_Lobj);
		}
		}

	 ctype(const _Locinfo& _Lobj, size_t _Refs = 0)
		: ctype_base(_Refs)
		{	// construct from specified locale
		_Init(_Lobj);
		}

	static size_t __cdecl _Getcat(const locale::facet **_Ppf = nullptr,
		const locale *_Ploc = nullptr)
		{	// return locale category mask and construct standard facet
		if (_Ppf != nullptr && *_Ppf == nullptr)
			{
			*_Ppf = new ctype<_Elem>(_Locinfo(_Ploc->c_str()));
			}

		return (2);
		}

protected:
	virtual  ~ctype() noexcept
		{	// destroy the object
		if (_Ctype._Delfl)
			:: free((void *)_Ctype._Table);

		:: free(_Ctype._LocaleName);
		}

	void  _Init(const _Locinfo& _Lobj)
		{	// initialize from _Lobj
		_Ctype = _Lobj._Getctype();
		_Cvt = _Lobj._Getcvt();
		}

	virtual bool  do_is(mask _Maskval, _Elem _Ch) const
		{	// test if element fits any mask classifications
		return ((:: _Getwctype(_Ch, &_Ctype) & _Maskval) != 0);
		}

	virtual const _Elem * do_is(const _Elem *_First,
		const _Elem *_Last, mask *_Dest) const
		{	// get mask sequence for elements in [_First, _Last)
		_Adl_verify_range(_First, _Last);
		return (:: _Getwctypes(_First, _Last, _Dest, &_Ctype));
		}

	virtual const _Elem * do_scan_is(mask _Maskval,
		const _Elem *_First, const _Elem *_Last) const
		{	// find first in [_First, _Last) that fits mask classification
		_Adl_verify_range(_First, _Last);
		while (_First != _Last && !is(_Maskval, *_First))
			{
			++_First;
			}

		return (_First);
		}

	virtual const _Elem * do_scan_not(mask _Maskval,
		const _Elem *_First, const _Elem *_Last) const
		{	// find first in [_First, _Last) not fitting mask classification
		_Adl_verify_range(_First, _Last);
		while (_First != _Last && is(_Maskval, *_First))
			{
			++_First;
			}

		return (_First);
		}

	virtual _Elem  do_tolower(_Elem _Ch) const
		{	// convert element to lower case
		return (_Towlower(_Ch, &_Ctype));
		}

	virtual const _Elem * do_tolower(_Elem *_First,
		const _Elem *_Last) const
		{	// convert [_First, _Last) in place to lower case
		_Adl_verify_range((const _Elem *)_First, _Last);
		for (; _First != _Last; ++_First)
			{
			*_First = _Towlower(*_First, &_Ctype);
			}

		return ((const _Elem *)_First);
		}

	virtual _Elem  do_toupper(_Elem _Ch) const
		{	// convert element to upper case
		return (_Towupper(_Ch, &_Ctype));
		}

	virtual const _Elem * do_toupper(_Elem *_First,
		const _Elem *_Last) const
		{	// convert [_First, _Last) in place to upper case
		_Adl_verify_range((const _Elem *)_First, _Last);
		for (; _First != _Last; ++_First)
			{
			*_First = _Towupper(*_First, &_Ctype);
			}

		return ((const _Elem *)_First);
		}

	_Elem  _Dowiden(char _Byte) const
		{	// widen char
		mbstate_t _Mbst = {};
		wchar_t _Wc;
		return (_Mbrtowc(&_Wc, &_Byte, 1, &_Mbst, &_Cvt) < 0
			? (wchar_t)((wint_t)(0xFFFF)) : _Wc);
		}

	virtual _Elem  do_widen(char _Byte) const
		{	// widen char
		return (_Dowiden(_Byte));
		}

	virtual const char * do_widen(const char *_First,
		const char *_Last, _Elem *_Dest) const
		{	// widen chars in [_First, _Last)
		_Adl_verify_range(_First, _Last);
		for (; _First != _Last; ++_First, ++_Dest)
			{
			*_Dest = _Dowiden(*_First);
			}

		return (_First);
		}

	char  _Donarrow(_Elem _Ch, char _Dflt) const
		{	// narrow element to char
		char _Buf[5];
		mbstate_t _Mbst = {};
		return (_Wcrtomb(_Buf, _Ch, &_Mbst, &_Cvt) != 1
			? _Dflt : _Buf[0]);
		}

	virtual char  do_narrow(_Elem _Ch, char _Dflt) const
		{	// narrow element to char
		return (_Donarrow(_Ch, _Dflt));
		}

	virtual const _Elem * do_narrow(const _Elem *_First,
		const _Elem *_Last, char _Dflt, char *_Dest) const
		{	// narrow elements in [_First, _Last) to chars
		_Adl_verify_range(_First, _Last);
		for (; _First != _Last; ++_First, ++_Dest)
			{
			*_Dest = _Donarrow(*_First, _Dflt);
			}

		return (_First);
		}

private:
	_Locinfo::_Ctypevec _Ctype;	// locale info passed to _Tolower, etc.
	_Locinfo::_Cvtvec _Cvt;		// conversion information
	};

 
		// CLASS ctype<unsigned short>
template<>
	class __declspec(dllimport) ctype<unsigned short>
	: public ctype_base
	{	// facet for classifying unsigned short elements, converting cases
public:
	typedef unsigned short _Elem;
	typedef _Elem char_type;

	bool  is(mask _Maskval, _Elem _Ch) const
		{	// test if element fits any mask classifications
		return (do_is(_Maskval, _Ch));
		}

	const _Elem * is(const _Elem *_First, const _Elem *_Last,
		mask *_Dest) const
		{	// get mask sequence for elements in [_First, _Last)
		return (do_is(_First, _Last, _Dest));
		}

	const _Elem * scan_is(mask _Maskval, const _Elem *_First,
		const _Elem *_Last) const
		{	// find first in [_First, _Last) that fits mask classification
		return (do_scan_is(_Maskval, _First, _Last));
		}

	const _Elem * scan_not(mask _Maskval, const _Elem *_First,
		const _Elem *_Last) const
		{	// find first in [_First, _Last) not fitting mask classification
		return (do_scan_not(_Maskval, _First, _Last));
		}

	_Elem  tolower(_Elem _Ch) const
		{	// convert element to lower case
		return (do_tolower(_Ch));
		}

	const _Elem * tolower(_Elem *_First, const _Elem *_Last) const
		{	// convert [_First, _Last) in place to lower case
		return (do_tolower(_First, _Last));
		}

	_Elem  toupper(_Elem _Ch) const
		{	// convert element to upper case
		return (do_toupper(_Ch));
		}

	const _Elem * toupper(_Elem *_First, const _Elem *_Last) const
		{	// convert [_First, _Last) in place to upper case
		return (do_toupper(_First, _Last));
		}

	_Elem  widen(char _Byte) const
		{	// widen char
		return (do_widen(_Byte));
		}

	const char * widen(const char *_First, const char *_Last,
		_Elem *_Dest) const
		{	// widen chars in [_First, _Last)
		return (do_widen(_First, _Last, _Dest));
		}

	char  narrow(_Elem _Ch, char _Dflt = '\0') const
		{	// narrow element to char
		return (do_narrow(_Ch, _Dflt));
		}

	const _Elem * narrow(const _Elem *_First, const _Elem *_Last,
		char _Dflt, char *_Dest) const
		{	// narrow elements in [_First, _Last) to chars
		return (do_narrow(_First, _Last, _Dflt, _Dest));
		}

	 static locale::id id;

	explicit  ctype(size_t _Refs = 0)
		: ctype_base(_Refs)
		{	// construct from current locale
		{ _Locinfo _Lobj;
			_Init(_Lobj);
		}
		}

	 ctype(const _Locinfo& _Lobj, size_t _Refs = 0)
		: ctype_base(_Refs)
		{	// construct from specified locale
		_Init(_Lobj);
		}

	static size_t __cdecl _Getcat(const locale::facet **_Ppf = nullptr,
		const locale *_Ploc = nullptr)
		{	// return locale category mask and construct standard facet
		if (_Ppf != nullptr && *_Ppf == nullptr)
			{
			*_Ppf = new ctype<_Elem>(_Locinfo(_Ploc->c_str()));
			}

		return (2);
		}

protected:
	virtual  ~ctype() noexcept
		{	// destroy the object
		if (_Ctype._Delfl)
			:: free((void *)_Ctype._Table);

		:: free(_Ctype._LocaleName);
		}

	void  _Init(const _Locinfo& _Lobj)
		{	// initialize from _Lobj
		_Ctype = _Lobj._Getctype();
		_Cvt = _Lobj._Getcvt();
		}

	virtual bool  do_is(mask _Maskval, _Elem _Ch) const
		{	// test if element fits any mask classifications
		return ((:: _Getwctype(_Ch, &_Ctype) & _Maskval) != 0);
		}

	virtual const _Elem * do_is(const _Elem *_First,
		const _Elem *_Last, mask *_Dest) const
		{	// get mask sequence for elements in [_First, _Last)
		_Adl_verify_range(_First, _Last);
		return ((const _Elem *):: _Getwctypes((const wchar_t *)_First,
			(const wchar_t *)_Last, _Dest, &_Ctype));
		}

	virtual const _Elem * do_scan_is(mask _Maskval,
		const _Elem *_First, const _Elem *_Last) const
		{	// find first in [_First, _Last) that fits mask classification
		_Adl_verify_range(_First, _Last);
		while (_First != _Last && !is(_Maskval, *_First))
			{
			++_First;
			}

		return (_First);
		}

	virtual const _Elem * do_scan_not(mask _Maskval,
		const _Elem *_First, const _Elem *_Last) const
		{	// find first in [_First, _Last) not fitting mask classification
		_Adl_verify_range(_First, _Last);
		while (_First != _Last && is(_Maskval, *_First))
			{
			++_First;
			}

		return (_First);
		}

	virtual _Elem  do_tolower(_Elem _Ch) const
		{	// convert element to lower case
		return (_Towlower(_Ch, &_Ctype));
		}

	virtual const _Elem * do_tolower(_Elem *_First,
		const _Elem *_Last) const
		{	// convert [_First, _Last) in place to lower case
		_Adl_verify_range((const _Elem *)_First, _Last);
		for (; _First != _Last; ++_First)
			{
			*_First = _Towlower(*_First, &_Ctype);
			}

		return ((const _Elem *)_First);
		}

	virtual _Elem  do_toupper(_Elem _Ch) const
		{	// convert element to upper case
		return (_Towupper(_Ch, &_Ctype));
		}

	virtual const _Elem * do_toupper(_Elem *_First,
		const _Elem *_Last) const
		{	// convert [_First, _Last) in place to upper case
		_Adl_verify_range((const _Elem *)_First, _Last);
		for (; _First != _Last; ++_First)
			{
			*_First = _Towupper(*_First, &_Ctype);
			}

		return ((const _Elem *)_First);
		}

	_Elem  _Dowiden(char _Byte) const
		{	// widen char
		mbstate_t _Mbst = {};
		unsigned short _Wc;
		return (_Mbrtowc((wchar_t *)&_Wc, &_Byte, 1, &_Mbst, &_Cvt) < 0
			? (unsigned short)((wint_t)(0xFFFF)) : _Wc);
		}

	virtual _Elem  do_widen(char _Byte) const
		{	// widen char
		return (_Dowiden(_Byte));
		}

	virtual const char * do_widen(const char *_First,
		const char *_Last, _Elem *_Dest) const
		{	// widen chars in [_First, _Last)
		_Adl_verify_range(_First, _Last);
		for (; _First != _Last; ++_First, ++_Dest)
			{
			*_Dest = _Dowiden(*_First);
			}

		return (_First);
		}

	char  _Donarrow(_Elem _Ch, char _Dflt) const
		{	// narrow element to char
		char _Buf[5];
		mbstate_t _Mbst = {};
		return (_Wcrtomb(_Buf, _Ch, &_Mbst, &_Cvt) != 1
			? _Dflt : _Buf[0]);
		}

	virtual char  do_narrow(_Elem _Ch, char _Dflt) const
		{	// narrow element to char
		return (_Donarrow(_Ch, _Dflt));
		}

	virtual const _Elem * do_narrow(const _Elem *_First,
		const _Elem *_Last, char _Dflt, char *_Dest) const
		{	// narrow elements in [_First, _Last) to chars
		_Adl_verify_range(_First, _Last);
		for (; _First != _Last; ++_First, ++_Dest)
			{
			*_Dest = _Donarrow(*_First, _Dflt);
			}

		return (_First);
		}

private:
	_Locinfo::_Ctypevec _Ctype;	// locale info passed to _Tolower, etc.
	_Locinfo::_Cvtvec _Cvt;		// conversion information
	};
 

		// CLASS TEMPLATE ctype_byname
template<class _Elem>
	class ctype_byname
	: public ctype<_Elem>
	{	// ctype for named locale
public:
	explicit  ctype_byname(const char *_Locname, size_t _Refs = 0)
		: ctype<_Elem>(_Locinfo(_Locname), _Refs)
		{	// construct for named locale
		}

	explicit  ctype_byname(const string& _Str, size_t _Refs = 0)
		: ctype<_Elem>(_Locinfo(_Str.c_str()), _Refs)
		{	// construct for named locale
		}

protected:
	virtual  ~ctype_byname() noexcept
		{	// destroy the object
		}
	};

		// CLASS TEMPLATE ctype_byname<char>
template<>
	class ctype_byname<char>
	: public ctype<char>
	{	// ctype_byname<char> for named locale
public:
	explicit  ctype_byname(const char *_Locname, size_t _Refs = 0)
		: ctype<char>(_Locinfo(_Locname), _Refs)
		{	// construct for named locale
		}

	explicit  ctype_byname(const string& _Str, size_t _Refs = 0)
		: ctype<char>(_Locinfo(_Str.c_str()), _Refs)
		{	// construct for named locale
		}

protected:
	virtual  ~ctype_byname() noexcept
		{	// destroy the object
		}
	};

 

  
template class __declspec(dllimport) codecvt<char, char, _Mbstatet>;
  
 
}
 
 
 #pragma warning(pop)
 #pragma pack(pop)



/*
 * Copyright (c) by P.J. Plauger. All rights reserved.
 * Consult your license regarding permissions and restrictions.
V6.50:0009 */


 
// system_error standard header
#pragma once




// cerrno standard header
#pragma once









/*
 * Copyright (c) by P.J. Plauger. All rights reserved.
 * Consult your license regarding permissions and restrictions.
V6.50:0009 */




// xcall_once.h internal header
#pragma once






 #pragma pack(push,8)
 #pragma warning(push,3)
 #pragma warning(disable: 4455 4494  4619 4643 4702 4984 4988 )
 
 
 

namespace std {
		// STRUCT once_flag
struct once_flag
	{	// opaque data structure for call_once()
	constexpr once_flag() noexcept
		: _Opaque(nullptr)
		{	// default construct
		}

	once_flag(const once_flag&) = delete;
	once_flag& operator=(const once_flag&) = delete;

	void *_Opaque;
	};

typedef int (__stdcall *_Execute_once_fp_t)(void *, void *, void **);
 int __cdecl _Execute_once(
	once_flag& _Flag, _Execute_once_fp_t _Callback, void *_Pv) noexcept;

}

 
 
 #pragma warning(pop)
 #pragma pack(pop)



/*
 * Copyright (c) by P.J. Plauger. All rights reserved.
 * Consult your license regarding permissions and restrictions.
V6.50:0009 */


// xerrc.h internal header
#pragma once






#pragma pack(push,8)
#pragma warning(push,3)
#pragma warning(disable: 4455 4494  4619 4643 4702 4984 4988 )




namespace std {
	// ENUM CLASS errc
enum class errc
	{	// names for generic error codes
	address_family_not_supported = 102, // EAFNOSUPPORT
	address_in_use = 100, // EADDRINUSE
	address_not_available = 101, // EADDRNOTAVAIL
	already_connected = 113, // EISCONN
	argument_list_too_long = 7, // E2BIG
	argument_out_of_domain = 33, // EDOM
	bad_address = 14, // EFAULT
	bad_file_descriptor = 9, // EBADF
	bad_message = 104, // EBADMSG
	broken_pipe = 32, // EPIPE
	connection_aborted = 106, // ECONNABORTED
	connection_already_in_progress = 103, // EALREADY
	connection_refused = 107, // ECONNREFUSED
	connection_reset = 108, // ECONNRESET
	cross_device_link = 18, // EXDEV
	destination_address_required = 109, // EDESTADDRREQ
	device_or_resource_busy = 16, // EBUSY
	directory_not_empty = 41, // ENOTEMPTY
	executable_format_error = 8, // ENOEXEC
	file_exists = 17, // EEXIST
	file_too_large = 27, // EFBIG
	filename_too_long = 38, // ENAMETOOLONG
	function_not_supported = 40, // ENOSYS
	host_unreachable = 110, // EHOSTUNREACH
	identifier_removed = 111, // EIDRM
	illegal_byte_sequence = 42, // EILSEQ
	inappropriate_io_control_operation = 25, // ENOTTY
	interrupted = 4, // EINTR
	invalid_argument = 22, // EINVAL
	invalid_seek = 29, // ESPIPE
	io_error = 5, // EIO
	is_a_directory = 21, // EISDIR
	message_size = 115, // EMSGSIZE
	network_down = 116, // ENETDOWN
	network_reset = 117, // ENETRESET
	network_unreachable = 118, // ENETUNREACH
	no_buffer_space = 119, // ENOBUFS
	no_child_process = 10, // ECHILD
	no_link = 121, // ENOLINK
	no_lock_available = 39, // ENOLCK
	no_message_available = 120, // ENODATA
	no_message = 122, // ENOMSG
	no_protocol_option = 123, // ENOPROTOOPT
	no_space_on_device = 28, // ENOSPC
	no_stream_resources = 124, // ENOSR
	no_such_device_or_address = 6, // ENXIO
	no_such_device = 19, // ENODEV
	no_such_file_or_directory = 2, // ENOENT
	no_such_process = 3, // ESRCH
	not_a_directory = 20, // ENOTDIR
	not_a_socket = 128, // ENOTSOCK
	not_a_stream = 125, // ENOSTR
	not_connected = 126, // ENOTCONN
	not_enough_memory = 12, // ENOMEM
	not_supported = 129, // ENOTSUP
	operation_canceled = 105, // ECANCELED
	operation_in_progress = 112, // EINPROGRESS
	operation_not_permitted = 1, // EPERM
	operation_not_supported = 130, // EOPNOTSUPP
	operation_would_block = 140, // EWOULDBLOCK
	owner_dead = 133, // EOWNERDEAD
	permission_denied = 13, // EACCES
	protocol_error = 134, // EPROTO
	protocol_not_supported = 135, // EPROTONOSUPPORT
	read_only_file_system = 30, // EROFS
	resource_deadlock_would_occur = 36, // EDEADLK
	resource_unavailable_try_again = 11, // EAGAIN
	result_out_of_range = 34, // ERANGE
	state_not_recoverable = 127, // ENOTRECOVERABLE
	stream_timeout = 137, // ETIME
	text_file_busy = 139, // ETXTBSY
	timed_out = 138, // ETIMEDOUT
	too_many_files_open_in_system = 23, // ENFILE
	too_many_files_open = 24, // EMFILE
	too_many_links = 31, // EMLINK
	too_many_symbolic_link_levels = 114, // ELOOP
	value_too_large = 132, // EOVERFLOW
	wrong_protocol_type = 136 // EPROTOTYPE
	};

}



#pragma warning(pop)
#pragma pack(pop)




/*
 * Copyright (c) by P.J. Plauger. All rights reserved.
 * Consult your license regarding permissions and restrictions.
V6.50:0009 */


 #pragma pack(push,8)
 #pragma warning(push,3)
 #pragma warning(disable: 4455 4494  4619 4643 4702 4984 4988 )
 
 
 

namespace std {
		// ENUM CLASS io_errc
enum class io_errc {	// error codes for ios_base::failure
	stream = 1
	};

		// STRUCT TEMPLATE is_error_code_enum
template<class _Enum>
	struct is_error_code_enum
		: false_type
	{	// tests for error_code enumeration
	};

template<>
	struct is_error_code_enum<io_errc>
		: true_type
	{	// tests for error_condition enumeration
	};

template<class _Ty>
	 constexpr bool is_error_code_enum_v = is_error_code_enum<_Ty>::value;

		// STRUCT TEMPLATE is_error_condition_enum
template<class _Enum>
	struct is_error_condition_enum
		: false_type
	{	// tests for error_condition enumeration
	};

template<>
	struct is_error_condition_enum<errc>
		: true_type
	{	// tests for error_condition enumeration
	};

template<class _Ty>
	 constexpr bool is_error_condition_enum_v = is_error_condition_enum<_Ty>::value;

class error_code;
class error_condition;
 error_code make_error_code(errc) noexcept;
 error_code make_error_code(io_errc) noexcept;
 error_condition make_error_condition(errc) noexcept;
 error_condition make_error_condition(io_errc) noexcept;

		// CLASS error_category
class error_category;

 const error_category& generic_category() noexcept;
 const error_category& iostream_category() noexcept;
 const error_category& system_category() noexcept;

class __declspec(novtable) error_category
	{	// categorize an error
public:
	/* constexpr */ error_category() noexcept	// TRANSITION
		{	// default constructor
		_Addr = reinterpret_cast<uintptr_t>(this);
		}

	virtual ~error_category() noexcept
		{
		}

	 virtual const char *name() const noexcept = 0;

	 virtual string message(int _Errval) const = 0;

	 virtual error_condition default_error_condition(int _Errval) const noexcept;

	 virtual bool equivalent(int _Errval, const error_condition& _Cond) const noexcept;

	 virtual bool equivalent(const error_code& _Code, int _Errval) const noexcept;

	 bool operator==(const error_category& _Right) const noexcept
		{	// compare categories for equality
		return (_Addr == _Right._Addr);
		}

	 bool operator!=(const error_category& _Right) const noexcept
		{	// compare categories for inequality
		return (!(*this == _Right));
		}

	 bool operator<(const error_category& _Right) const noexcept
		{	// compare categories for order
		return (_Addr < _Right._Addr);
		}

	error_category(const error_category&) = delete;
	error_category& operator=(const error_category&) = delete;

protected:
	uintptr_t _Addr;

	enum : uintptr_t
		{	// imaginary addresses for Standard error_category objects
		_Future_addr = 1,
		_Generic_addr = 3,
		_Iostream_addr = 5,
		_System_addr = 7
		};
	};

		// CLASS error_code
class error_code
	{	// store an implementation-specific error code and category
public:
	error_code() noexcept
		: _Myval(0),
		_Mycat(&system_category())
		{	// construct non-error
		}

	error_code(int _Val, const error_category& _Cat) noexcept
		: _Myval(_Val),
		_Mycat(&_Cat)
		{	// construct from error code and category
		}

	template<class _Enum,
		enable_if_t<is_error_code_enum_v<_Enum>, int> = 0>
		error_code(_Enum _Errcode) noexcept
		: _Myval(0),
		_Mycat(nullptr)
		{	// construct from enumerated error code
		*this = make_error_code(_Errcode);	// using ADL
		}

	void assign(int _Val, const error_category& _Cat) noexcept
		{	// assign error code and category
		_Myval = _Val;
		_Mycat = &_Cat;
		}

	template<class _Enum,
		enable_if_t<is_error_code_enum_v<_Enum>, int> = 0>
		error_code& operator=(_Enum _Errcode) noexcept
		{	// assign enumerated error code
		*this = make_error_code(_Errcode);	// using ADL
		return (*this);
		}

	void clear() noexcept
		{	// assign non-error
		_Myval = 0;
		_Mycat = &system_category();
		}

	 int value() const noexcept
		{	// get error code
		return (_Myval);
		}

	 const error_category& category() const noexcept
		{	// get category
		return (*_Mycat);
		}

	 error_condition default_error_condition() const noexcept;

	 string message() const
		{	// get name of error code
		return (category().message(value()));
		}

	explicit operator bool() const noexcept
		{	// test for actual error
		return (value() != 0);
		}

private:
	int _Myval;	// the stored error number
	const error_category *_Mycat;	// pointer to error category
	};

		// CLASS error_condition
class error_condition
	{	// store an abstract error code and category
public:
	error_condition() noexcept
		: _Myval(0),
		_Mycat(&generic_category())
		{	// construct non-error
		}

	error_condition(int _Val, const error_category& _Cat) noexcept
		: _Myval(_Val),
		_Mycat(&_Cat)
		{	// construct from error code and category
		}

	template<class _Enum,
		enable_if_t<is_error_condition_enum_v<_Enum>, int> = 0>
		error_condition(_Enum _Errcode) noexcept
		: _Myval(0),
		_Mycat(nullptr)
		{	// construct from enumerated error code
		*this = make_error_condition(_Errcode);	// using ADL
		}

	void assign(int _Val, const error_category& _Cat) noexcept
		{	// assign error code and category
		_Myval = _Val;
		_Mycat = &_Cat;
		}

	template<class _Enum,
		enable_if_t<is_error_condition_enum_v<_Enum>, int> = 0>
		error_condition& operator=(_Enum _Errcode) noexcept
		{	// assign enumerated error code
		*this = make_error_condition(_Errcode);	// using ADL
		return (*this);
		}

	void clear() noexcept
		{	// assign non-error
		_Myval = 0;
		_Mycat = &generic_category();
		}

	 int value() const noexcept
		{	// get error code
		return (_Myval);
		}

	 const error_category& category() const noexcept
		{	// get category
		return (*_Mycat);
		}

	 string message() const
		{	// get name of error code
		return (category().message(value()));
		}

	explicit operator bool() const noexcept
		{	// test for actual error
		return (value() != 0);
		}

private:
	int _Myval;	// the stored error number
	const error_category * _Mycat;	// pointer to error category
	};

		// operator== FOR error_code/error_condition
 inline bool operator==(const error_code& _Left, const error_code& _Right) noexcept
	{	// test errors for equality
	return (_Left.category() == _Right.category()
		&& _Left.value() == _Right.value());
	}

 inline bool operator==(const error_code& _Left, const error_condition& _Right) noexcept
	{	// test errors for equality
	return (_Left.category().equivalent(_Left.value(), _Right)
		|| _Right.category().equivalent(_Left, _Right.value()));
	}

 inline bool operator==(const error_condition& _Left, const error_code& _Right) noexcept
	{	// test errors for equality
	return (_Right.category().equivalent(_Right.value(), _Left)
		|| _Left.category().equivalent(_Right, _Left.value()));
	}

 inline bool operator==(const error_condition& _Left, const error_condition& _Right) noexcept
	{	// test errors for equality
	return (_Left.category() == _Right.category()
		&& _Left.value() == _Right.value());
	}

		// operator!= FOR error_code/error_condition
 inline bool operator!=(const error_code& _Left, const error_code& _Right) noexcept
	{	// test errors for inequality
	return (!(_Left == _Right));
	}

 inline bool operator!=(const error_code& _Left, const error_condition& _Right) noexcept
	{	// test errors for inequality
	return (!(_Left == _Right));
	}

 inline bool operator!=(const error_condition& _Left, const error_code& _Right) noexcept
	{	// test errors for inequality
	return (!(_Left == _Right));
	}

 inline bool operator!=(const error_condition& _Left, const error_condition& _Right) noexcept
	{	// test errors for inequality
	return (!(_Left == _Right));
	}

		// operator< FOR error_code/error_condition
 inline bool operator<(const error_code& _Left, const error_code& _Right) noexcept
	{	// test if _Left < _Right
	return (_Left.category() < _Right.category()
		|| (_Left.category() == _Right.category()
			&& _Left.value() < _Right.value()));
	}

 inline bool operator<(const error_condition& _Left, const error_condition& _Right) noexcept
	{	// test if _Left < _Right
	return (_Left.category() < _Right.category()
		|| (_Left.category() == _Right.category()
			&& _Left.value() < _Right.value()));
	}

		// VIRTUALS FOR error_category
 inline error_condition error_category::default_error_condition(int _Errval) const noexcept
	{	// make error_condition for error code
	return (error_condition(_Errval, *this));
	}

 inline bool error_category::equivalent(int _Errval, const error_condition& _Cond) const noexcept
	{	// test if error code same condition
	return (default_error_condition(_Errval) == _Cond);
	}

 inline bool error_category::equivalent(const error_code& _Code, int _Errval) const noexcept
	{	// test if conditions same for this category
	return (*this == _Code.category() && _Code.value() == _Errval);
	}

		// MEMBER FUNCTIONS for error_code
 inline error_condition error_code::default_error_condition() const noexcept
	{	// make error_condition for error code
	return (category().default_error_condition(value()));
	}

		// FUNCTION make_error_code
 inline error_code make_error_code(errc _Errno) noexcept
	{	// make an error_code
	return (error_code((int)_Errno, generic_category()));
	}

 inline error_code make_error_code(io_errc _Errno) noexcept
	{	// make an error_code
	return (error_code((int)_Errno, iostream_category()));
	}

		// FUNCTION make_error_condition
 inline error_condition make_error_condition(errc _Errno) noexcept
	{	// make an error_condition
	return (error_condition((int)_Errno, generic_category()));
	}

 inline error_condition make_error_condition(io_errc _Errno) noexcept
	{	// make an error_condition
	return (error_condition((int)_Errno, iostream_category()));
	}

		// STRUCT TEMPLATE SPECIALIZATION hash
template<>
	struct hash<error_code>
	{	// hash functor for error_code
	 typedef error_code argument_type;
	 typedef size_t result_type;

	 size_t operator()(const error_code& _Keyval) const noexcept
		{	// hash _Keyval to size_t value by pseudorandomizing transform
		return (hash<int>{}(_Keyval.value()));
		}
	};

template<>
	struct hash<error_condition>
	{	// hash functor for error_condition
	 typedef error_condition argument_type;
	 typedef size_t result_type;

	 size_t operator()(const error_condition& _Keyval) const noexcept
		{	// hash _Keyval to size_t value by pseudorandomizing transform
		return (hash<int>{}(_Keyval.value()));
		}
	};

		// CLASS system_error
class _System_error
	: public runtime_error
	{	// base of all system-error exceptions
private:
	static string _Makestr(error_code _Errcode, string _Message)
		{	// compose error message
		if (!_Message.empty())
			{
			_Message.append(": ");
			}

		_Message.append(_Errcode.message());
		return (_Message);
		}

protected:
	_System_error(error_code _Errcode, const string& _Message)
		: runtime_error(_Makestr(_Errcode, _Message)),
		_Mycode(_Errcode)
		{	// construct from error code and message string
		}

	error_code _Mycode;	// the stored error code
	};

class system_error
	: public _System_error
	{	// base of all system-error exceptions
private:
	typedef _System_error _Mybase;

public:
	system_error(error_code _Errcode)
		: _Mybase(_Errcode, "")
		{	// construct from error code
		}

	system_error(error_code _Errcode, const string& _Message)
		: _Mybase(_Errcode, _Message)
		{	// construct from error code and message string
		}

	system_error(error_code _Errcode, const char *_Message)
		: _Mybase(_Errcode, _Message)
		{	// construct from error code and message string
		}

	system_error(int _Errval, const error_category& _Errcat)
		: _Mybase(error_code(_Errval, _Errcat), "")
		{	// construct from error code components
		}

	system_error(int _Errval, const error_category& _Errcat, const string& _Message)
		: _Mybase(error_code(_Errval, _Errcat), _Message)
		{	// construct from error code components and message string
		}

	system_error(int _Errval, const error_category& _Errcat, const char *_Message)
		: _Mybase(error_code(_Errval, _Errcat), _Message)
		{	// construct from error code components and message string
		}

	 const error_code& code() const noexcept
		{	// return stored error code
		return (_Mycode);
		}

 

 






	};

 const char *__cdecl _Syserror_map(int);
 int __cdecl _Winerror_map(int);
 unsigned long __cdecl _Winerror_message(
	unsigned long _Message_id, char *_Narrow, unsigned long _Size);

		// CLASS _Generic_error_category
class _Generic_error_category
	: public error_category
	{	// categorize a generic error
public:
	_Generic_error_category() noexcept
		{	// default constructor
		_Addr = _Generic_addr;
		}

	 virtual const char *name() const noexcept override
		{	// get name of category
		return ("generic");
		}

	 virtual string message(int _Errcode) const override
		{	// convert to name of error
		return (_Syserror_map(_Errcode));
		}
	};

		// CLASS _Iostream_error_category
class _Iostream_error_category
	: public _Generic_error_category
	{	// categorize an iostream error
public:
	_Iostream_error_category() noexcept
		{	// default constructor
		_Addr = _Iostream_addr;
		}

	 virtual const char *name() const noexcept override
		{	// get name of category
		return ("iostream");
		}

	 virtual string message(int _Errcode) const override
		{	// convert to name of error
		if (_Errcode == (int)io_errc::stream)
			{
			return ("iostream stream error");
			}
		else
			{
			return (_Generic_error_category::message(_Errcode));
			}
		}
	};

		// CLASS _System_error_category
class _System_error_category
	: public error_category
	{	// categorize an operating system error
public:
	_System_error_category() noexcept
		{	// default constructor
		_Addr = _System_addr;
		}

	 virtual const char *name() const noexcept override
		{	// get name of category
		return ("system");
		}

	 virtual string message(int _Errcode) const override
		{	// convert to name of error
		const unsigned long _Size = 32767;
		string _Narrow(_Size, '\0');

		const unsigned long _Val = _Winerror_message(static_cast<unsigned long>(_Errcode), &_Narrow[0], _Size);
		if (_Val == 0)
			{
			_Narrow = "unknown error";
			}
		else
			{
			_Narrow.resize(_Val);
			}

		_Narrow.shrink_to_fit();
		return (_Narrow);
		}

	 virtual error_condition default_error_condition(int _Errval) const noexcept override
		{	// make error_condition for error code (generic if possible)
		const int _Posv = _Winerror_map(_Errval);
		if (_Posv == 0)
			{
			return (error_condition(_Errval, system_category()));
			}
		else
			{
			return (error_condition(_Posv, generic_category()));
			}
		}
	};























template<class _Ty> inline
	int __stdcall _Immortalize_impl(void *, void * _Storage_ptr, void **) noexcept
	{	// adapt True Placement New to _Execute_once
	::new (_Storage_ptr) _Ty();
	return (1);
	}

template<class _Ty> inline
	_Ty& _Immortalize()
	{	// return a reference to an object that will live forever
	static_assert(sizeof(void *) == sizeof(once_flag), "TRANSITION, VSO#406237");
	static_assert(alignof(void *) == alignof(once_flag), "TRANSITION, VSO#406237");
	static void * _Flag = nullptr;
	static aligned_union_t<1, _Ty> _Storage;
	if (_Execute_once(reinterpret_cast<once_flag&>(_Flag), _Immortalize_impl<_Ty>, &_Storage) == 0)
		{	// _Execute_once should never fail if the callback never fails
		::std:: terminate();
		}

	return (reinterpret_cast<_Ty&>(_Storage));
	}


 inline const error_category& generic_category() noexcept
	{	// get generic_category
	return (_Immortalize<_Generic_error_category>());
	}

 inline const error_category& iostream_category() noexcept
	{	// get iostream_category
	return (_Immortalize<_Iostream_error_category>());
	}

 inline const error_category& system_category() noexcept
	{	// get system_category
	return (_Immortalize<_System_error_category>());
	}
}
 
 
 #pragma warning(pop)
 #pragma pack(pop)



/*
 * Copyright (c) by P.J. Plauger. All rights reserved.
 * Consult your license regarding permissions and restrictions.
V6.50:0009 */


 
//
// share.h
//
//      Copyright (c) Microsoft Corporation. All rights reserved.
//
// Defines the file sharing modes for the sopen() family of functions.
//
#pragma once







 #pragma pack(push,8)
 #pragma warning(push,3)
 #pragma warning(disable: 4455 4494  4619 4643 4702 4984 4988 )
 
 
 

 

namespace std {
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 

 
 

 
 
 

		// CLASS TEMPLATE _Iosb
template<class _Dummy>
	class _Iosb
	{	// define templatized bitmask/enumerated types, instantiate on demand
public:
	enum _Dummy_enum {_Dummy_enum_val = 1};	// don't ask
	enum _Fmtflags
		{	// constants for formatting options
		_Fmtmask = 0xffff, _Fmtzero = 0};

	static constexpr _Fmtflags skipws = (_Fmtflags)0x0001;
	static constexpr _Fmtflags unitbuf = (_Fmtflags)0x0002;
	static constexpr _Fmtflags uppercase = (_Fmtflags)0x0004;
	static constexpr _Fmtflags showbase = (_Fmtflags)0x0008;
	static constexpr _Fmtflags showpoint = (_Fmtflags)0x0010;
	static constexpr _Fmtflags showpos = (_Fmtflags)0x0020;
	static constexpr _Fmtflags left = (_Fmtflags)0x0040;
	static constexpr _Fmtflags right = (_Fmtflags)0x0080;
	static constexpr _Fmtflags internal = (_Fmtflags)0x0100;
	static constexpr _Fmtflags dec = (_Fmtflags)0x0200;
	static constexpr _Fmtflags oct = (_Fmtflags)0x0400;
	static constexpr _Fmtflags hex = (_Fmtflags)0x0800;
	static constexpr _Fmtflags scientific = (_Fmtflags)0x1000;
	static constexpr _Fmtflags fixed = (_Fmtflags)0x2000;

	static constexpr _Fmtflags hexfloat =
		(_Fmtflags)0x3000;	// added with TR1 (not in C++11)

	static constexpr _Fmtflags boolalpha = (_Fmtflags)0x4000;
	static constexpr _Fmtflags _Stdio = (_Fmtflags)0x8000;
	static constexpr _Fmtflags adjustfield = (_Fmtflags)(0x0040
		| 0x0080 | 0x0100);
	static constexpr _Fmtflags basefield = (_Fmtflags)(0x0200
		| 0x0400 | 0x0800);
	static constexpr _Fmtflags floatfield = (_Fmtflags)(0x1000
		| 0x2000);

	enum _Iostate
		{	// constants for stream states
		_Statmask = 0x17};

	static constexpr _Iostate goodbit = (_Iostate)0x0;
	static constexpr _Iostate eofbit = (_Iostate)0x1;
	static constexpr _Iostate failbit = (_Iostate)0x2;
	static constexpr _Iostate badbit = (_Iostate)0x4;

	enum _Openmode
		{	// constants for file opening options
		_Openmask = 0xff};

	static constexpr _Openmode in = (_Openmode)0x01;
	static constexpr _Openmode out = (_Openmode)0x02;
	static constexpr _Openmode ate = (_Openmode)0x04;
	static constexpr _Openmode app = (_Openmode)0x08;
	static constexpr _Openmode trunc = (_Openmode)0x10;
	static constexpr _Openmode _Nocreate = (_Openmode)0x40;
	static constexpr _Openmode _Noreplace = (_Openmode)0x80;
	static constexpr _Openmode binary = (_Openmode)0x20;

	enum _Seekdir
		{	// constants for file positioning options
		_Seekbeg,
		_Seekcur,
		_Seekend
		};

	static constexpr _Seekdir beg = _Seekbeg;
	static constexpr _Seekdir cur = _Seekcur;
	static constexpr _Seekdir end = _Seekend;

	enum
		{	// constant for default file opening protection
		_Openprot = 0x40};
	};

template<class _Dummy>
	const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::skipws;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::unitbuf;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::uppercase;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::showbase;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::showpoint;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::showpos;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::left;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::right;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::internal;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::dec;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::oct;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::hex;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::scientific;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::fixed;

template<class _Dummy>
	const typename _Iosb<_Dummy>::_Fmtflags
		_Iosb<_Dummy>::hexfloat;	// added with TR1 (not in C++11)

template<class _Dummy>
	const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::boolalpha;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::_Stdio;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::adjustfield;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::basefield;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::floatfield;

template<class _Dummy>
	const typename _Iosb<_Dummy>::_Iostate _Iosb<_Dummy>::goodbit;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Iostate _Iosb<_Dummy>::eofbit;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Iostate _Iosb<_Dummy>::failbit;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Iostate _Iosb<_Dummy>::badbit;

template<class _Dummy>
	const typename _Iosb<_Dummy>::_Openmode _Iosb<_Dummy>::in;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Openmode _Iosb<_Dummy>::out;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Openmode _Iosb<_Dummy>::ate;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Openmode _Iosb<_Dummy>::app;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Openmode _Iosb<_Dummy>::trunc;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Openmode _Iosb<_Dummy>::_Nocreate;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Openmode _Iosb<_Dummy>::_Noreplace;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Openmode _Iosb<_Dummy>::binary;

template<class _Dummy>
	const typename _Iosb<_Dummy>::_Seekdir _Iosb<_Dummy>::beg;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Seekdir _Iosb<_Dummy>::cur;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Seekdir _Iosb<_Dummy>::end;

		// CLASS ios_base
class __declspec(dllimport) ios_base
	: public _Iosb<int>
	{	// base class for ios
public:
	typedef int fmtflags;
	typedef int iostate;
	typedef int openmode;
	typedef int seekdir;

 
	typedef ::std:: streamoff streamoff;
	typedef ::std:: streampos streampos;
 

	enum event
		{	// constants for ios events
		erase_event, imbue_event, copyfmt_event};

	typedef void (__cdecl *event_callback)(event, ios_base&, int);

 
	typedef unsigned int io_state, open_mode, seek_dir;
 

			// CLASS failure
	class failure

		: public system_error
		{	// base of all iostreams exceptions
	public:
		explicit failure(const string &_Message,
			const error_code& _Errcode = make_error_code(io_errc::stream))
			: system_error(_Errcode, _Message)
			{	// construct with message
			}

		explicit failure(const char *_Message,
			const error_code& _Errcode = make_error_code(io_errc::stream))
			: system_error(_Errcode, _Message)
			{	// construct with message
			}


 

 






		};

			// CLASS Init
	class __declspec(dllimport) Init
		{	// controller for standard-stream initialization
	public:
		 Init()
			{	// initialize standard streams on first construction
			_Init_ctor(this);
			}

		 ~Init() noexcept
			{	// flush standard streams on last destruction
			_Init_dtor(this);
			}

	private:
		static  void __cdecl _Init_ctor(Init *);
		static  void __cdecl _Init_dtor(Init *);

		 static int _Init_cnt;	// net ctor count

		static  int& __cdecl _Init_cnt_func();
		};

	explicit  operator bool() const
		{	// test if no stream operation has failed
		return (!fail());
		}

	 bool  operator!() const
		{	// test if any stream operation has failed
		return (fail());
		}

	void  clear(iostate _State, bool _Reraise)
		{	// set state, possibly reraise exception
		_State &= _Statmask;
		_Mystate = _State;
		const auto _Filtered = _State & _Except;
		if (_Filtered)
			{
			if (_Reraise)
				{
				throw;
				}

			const char * _Msg;
			if (_Filtered & ios_base::badbit)
				{
				_Msg = "ios_base::badbit set";
				}
			else if (_Filtered & ios_base::failbit)
				{
				_Msg = "ios_base::failbit set";
				}
			else
				{
				_Msg = "ios_base::eofbit set";
				}

			throw failure(_Msg);
			}
		}

	void  clear(iostate _State = goodbit)
		{	// set state to argument
		clear(_State, false);
		}

 
	void  clear(io_state _State)
		{	// set state to argument, old-style
		clear((iostate)_State);
		}
 

	 iostate  rdstate() const
		{	// return stream state
		return (_Mystate);
		}

	void  setstate(iostate _State, bool _Exreraise)
		{	// merge in state argument, possibly reraise exception
		clear(rdstate() | _State, _Exreraise);
		}

	void  setstate(iostate _State)
		{	// merge in state argument
		clear(rdstate() | _State, false);
		}

 
	void  setstate(io_state _State)
		{	// merge in state argument, old style
		setstate((iostate)_State);
		}
 

	 bool  good() const
		{	// test if no state bits are set
		return (rdstate() == ios_base::goodbit);
		}

	 bool  eof() const
		{	// test if eofbit is set in stream state
		return (rdstate() & ios_base::eofbit);
		}

	 bool  fail() const
		{	// test if badbit or failbit is set in stream state
		return (rdstate() & (ios_base::badbit | ios_base::failbit));
		}

	 bool  bad() const
		{	// test if badbit is set in stream state
		return (rdstate() & ios_base::badbit);
		}

	 iostate  exceptions() const
		{	// return exception mask
		return (_Except);
		}

	void  exceptions(iostate _Newexcept)
		{	// set exception mask to argument
		_Except = _Newexcept & _Statmask;
		clear(rdstate());
		}

 
	void  exceptions(io_state _State)
		{	// set exception mask to argument, old style
		exceptions((iostate)_State);
		}
 

	 fmtflags  flags() const
		{	// return format flags
		return (_Fmtfl);
		}

	fmtflags  flags(fmtflags _Newfmtflags)
		{	// set format flags to argument
		const fmtflags _Oldfmtflags = _Fmtfl;
		_Fmtfl = _Newfmtflags & _Fmtmask;
		return (_Oldfmtflags);
		}

	fmtflags  setf(fmtflags _Newfmtflags)
		{	// merge in format flags argument
		const ios_base::fmtflags _Oldfmtflags = _Fmtfl;
		_Fmtfl |= _Newfmtflags & _Fmtmask;
		return (_Oldfmtflags);
		}

	fmtflags  setf(fmtflags _Newfmtflags, fmtflags _Mask)
		{	// merge in format flags argument under mask argument
		const ios_base::fmtflags _Oldfmtflags = _Fmtfl;
		_Fmtfl = (_Oldfmtflags & ~_Mask) | (_Newfmtflags & _Mask & _Fmtmask);
		return (_Oldfmtflags);
		}

	void  unsetf(fmtflags _Mask)
		{	// clear format flags under mask argument
		_Fmtfl &= ~_Mask;
		}

	 streamsize  precision() const
		{	// return precision
		return (_Prec);
		}

	streamsize  precision(streamsize _Newprecision)
		{	// set precision to argument
		const streamsize _Oldprecision = _Prec;
		_Prec = _Newprecision;
		return (_Oldprecision);
		}

	 streamsize  width() const
		{	// return width
		return (_Wide);
		}

	streamsize  width(streamsize _Newwidth)
		{	// set width to argument
		const streamsize _Oldwidth = _Wide;
		_Wide = _Newwidth;
		return (_Oldwidth);
		}

	 locale  getloc() const
		{	// get locale
		return (*_Ploc);
		}

	locale  imbue(const locale& _Loc)
		{	// set locale to argument
		locale _Oldlocale = *_Ploc;
		*_Ploc = _Loc;
		_Callfns(imbue_event);
		return (_Oldlocale);
		}

	 static int __cdecl xalloc()
		{	// allocate new iword/pword index
		{ ::std:: _Lockit _Lock(2);	// lock thread to ensure atomicity
			return (_Index++);
		}
		}

	 long&  iword(int _Idx)
		{	// return reference to long element
		return (_Findarr(_Idx)._Lo);
		}

	 void *&  pword(int _Idx)
		{	// return reference to pointer element
		return (_Findarr(_Idx)._Vp);
		}

	void  register_callback(event_callback _Pfn,
		int _Idx)
		{	// register event handler
		_Calls = new _Fnarray(_Idx, _Pfn, _Calls);
		}

	ios_base&  copyfmt(const ios_base& _Other)
		{	// copy format stuff
		if (this != ::std:: addressof(_Other))
			{	// copy all but _Mystate
			_Tidy();
			*_Ploc = *_Other._Ploc;
			_Fmtfl = _Other._Fmtfl;
			_Prec = _Other._Prec;
			_Wide = _Other._Wide;
			_Iosarray *_Ptr = _Other._Arr;

			for (_Arr = nullptr; _Ptr != nullptr; _Ptr = _Ptr->_Next)
				if (_Ptr->_Lo != 0 || _Ptr->_Vp != nullptr)
					{	// copy over nonzero array values
					iword(_Ptr->_Index) = _Ptr->_Lo;
					pword(_Ptr->_Index) = _Ptr->_Vp;
					}

			for (_Fnarray *_Pfa = _Other._Calls; _Pfa != nullptr;
				_Pfa = _Pfa->_Next)
				register_callback(_Pfa->_Pfn, _Pfa->_Index);

			_Callfns(copyfmt_event);	// call callbacks
			exceptions(_Other._Except);	// cause any throw at end
			}
		return (*this);
		}

	static bool __cdecl sync_with_stdio(bool _Newsync = true)
		{	// set C/C++ synchronization flag from argument
		{ ::std:: _Lockit _Lock(2);	// lock thread to ensure atomicity
			const bool _Oldsync = _Sync;
			_Sync = _Newsync;
			return (_Oldsync);
		}
		}

	void  swap(ios_base& _Right)
		{	// swap with _Right
		if (this != ::std:: addressof(_Right))
			{	// different, do the move
			::std:: swap(_Mystate, _Right._Mystate);
			::std:: swap(_Except, _Right._Except);
			::std:: swap(_Fmtfl, _Right._Fmtfl);
			::std:: swap(_Prec, _Right._Prec);
			::std:: swap(_Wide, _Right._Wide);

			::std:: swap(_Arr, _Right._Arr);
			::std:: swap(_Calls, _Right._Calls);
			::std:: swap(_Ploc, _Right._Ploc);
			}
		}

	virtual  ~ios_base() noexcept	// destroy the object
		{	// destroy the object
		_Ios_base_dtor(this);
		}

	static  void __cdecl
		_Addstd(ios_base *);	// add standard stream

	size_t _Stdstr;	// if > 0 index of standard stream to suppress destruction

protected:
	 ios_base()
		{	// default constructor
		}

	void  _Init()
		{	// initialize a new ios_base
		_Ploc = nullptr;
		_Stdstr = 0;
		_Except = goodbit;
		_Fmtfl = (fmtflags)(skipws | dec);
		_Prec = 6;
		_Wide = 0;
		_Arr = nullptr;
		_Calls = nullptr;
		clear(goodbit);
		_Ploc = new locale;
		}

private:
			// STRUCT _Iosarray
	struct _Iosarray
		: public _Crt_new_delete
		{	// list element for open-ended sparse array of longs/pointers
	public:
		 _Iosarray(int _Idx, _Iosarray *_Link)
			: _Next(_Link), _Index(_Idx), _Lo(0), _Vp(nullptr)
			{	// construct node for index _Idx and link it in
			}

		_Iosarray *_Next;	// pointer to next node
		int _Index;	// index of this node
		long _Lo;	// stored long value
		void *_Vp;	// stored pointer value
		};

			// STRUCT _Fnarray
	struct _Fnarray
		: public _Crt_new_delete
		{	// list element for open-ended sparse array of event handlers
		 _Fnarray(int _Idx, event_callback _Pnew, _Fnarray *_Link)
			: _Next(_Link), _Index(_Idx), _Pfn(_Pnew)
			{	// construct node for index _Idx and link it in
			}

		_Fnarray *_Next;	// pointer to next node
		int _Index;	// index of this node
		event_callback _Pfn;	// pointer to event handler
		};

	void  _Callfns(event _Ev)
		{	// call all event handlers, reporting event
		for (_Fnarray *_Pfa = _Calls; _Pfa != nullptr; _Pfa = _Pfa->_Next)
			(*_Pfa->_Pfn)(_Ev, *this, _Pfa->_Index);
		}

	_Iosarray&  _Findarr(int _Idx)
		{	// locate or make a variable array element
		_Iosarray *_Ptr1, *_Ptr2;

		for (_Ptr1 = _Arr, _Ptr2 = nullptr; _Ptr1 != nullptr; _Ptr1 = _Ptr1->_Next)
			if (_Ptr1->_Index == _Idx)
				return (*_Ptr1);	// found element, return it
			else if (_Ptr2 == nullptr && _Ptr1->_Lo == 0 && _Ptr1->_Vp == nullptr)
				_Ptr2 = _Ptr1;	// found recycling candidate

		if (_Ptr2 != nullptr)
			{	// recycle existing element
			_Ptr2->_Index = _Idx;
			return (*_Ptr2);
			}

		_Arr = new _Iosarray(_Idx, _Arr);	// make a new element
		return (*_Arr);
		}

	void  _Tidy()
		{	// discard storage for an ios_base
		_Callfns(erase_event);
		_Iosarray *_Ptr1, *_Ptr2;

		for (_Ptr1 = _Arr; _Ptr1 != nullptr; _Ptr1 = _Ptr2)
			{	// delete array element
			_Ptr2 = _Ptr1->_Next;
			delete _Ptr1;
			}
		_Arr = nullptr;

		_Fnarray *_Pfa1, *_Pfa2;
		for (_Pfa1 = _Calls; _Pfa1 != nullptr; _Pfa1 = _Pfa2)
			{	// delete callback element
			_Pfa2 = _Pfa1->_Next;
			delete _Pfa1;
			}
		_Calls = nullptr;
		}

	iostate _Mystate;	// stream state
	iostate _Except;	// exception mask
	fmtflags _Fmtfl;	// format flags
	streamsize _Prec;	// field precision
	streamsize _Wide;	// field width
	_Iosarray *_Arr;	// pointer to first node of long/pointer array
	_Fnarray *_Calls;	// pointer to first node of call list
	locale *_Ploc;	// pointer to locale

	 static int _Index;
	 static bool _Sync;

	static  void __cdecl
		_Ios_base_dtor(ios_base *);

public:
	ios_base(const ios_base&) = delete;
	ios_base& operator=(const ios_base&) = delete;
	};
}
 
 
 #pragma warning(pop)
 #pragma pack(pop)



/*
 * Copyright (c) by P.J. Plauger. All rights reserved.
 * Consult your license regarding permissions and restrictions.
V6.50:0009 */


 #pragma pack(push,8)
 #pragma warning(push,3)
 #pragma warning(disable: 4455 4494  4619 4643 4702 4984 4988 )
 
 
 

namespace std {
		// CLASS TEMPLATE basic_streambuf
template<class _Elem,
	class _Traits>
	class basic_streambuf
	{	// control read/write buffers
protected:
	 basic_streambuf()
		: _Plocale(new locale)
		{	// construct with no buffers
		_Init();
		}

	 basic_streambuf(_Uninitialized)
		{	// construct uninitialized
		}

	 basic_streambuf(const basic_streambuf& _Right)
		: _Plocale(new locale(_Right.getloc()))
		{	// construct by copying _Right
		_Init();
		setp(_Right.pbase(), _Right.pptr(), _Right.epptr());
		setg(_Right.eback(), _Right.gptr(), _Right.egptr());
		}

	basic_streambuf&  operator=(const basic_streambuf& _Right)
		{	// assign from _Right
		if (this != ::std:: addressof(_Right))
			{	// different, worth copying
			setp(_Right.pbase(), _Right.pptr(), _Right.epptr());
			setg(_Right.eback(), _Right.gptr(), _Right.egptr());
			pubimbue(_Right.getloc());
			}
		return (*this);
		}

	void  swap(basic_streambuf& _Right)
		{	// swap with _Right
		if (this != ::std:: addressof(_Right))
			{	// different, worth swapping
			_Elem *_Pfirst0 = pbase();
			_Elem *_Pnext0 = pptr();
			_Elem *_Pend = epptr();
			_Elem *_Gfirst0 = eback();
			_Elem *_Gnext0 = gptr();
			_Elem *_Gend = egptr();

			setp(_Right.pbase(), _Right.pptr(), _Right.epptr());
			_Right.setp(_Pfirst0, _Pnext0, _Pend);

			setg(_Right.eback(), _Right.gptr(), _Right.egptr());
			_Right.setg(_Gfirst0, _Gnext0, _Gend);

			::std:: swap(_Plocale, _Right._Plocale);
			}
		}

public:
	typedef _Elem char_type;
	typedef _Traits traits_type;

	virtual  ~basic_streambuf() noexcept
		{	// destroy the object
		delete _Plocale;
		}

	typedef typename _Traits::int_type int_type;
	typedef typename _Traits::pos_type pos_type;
	typedef typename _Traits::off_type off_type;

	pos_type  pubseekoff(off_type _Off,
		ios_base::seekdir _Way,
		ios_base::openmode _Mode = ios_base::in | ios_base::out)
		{	// change position by _Off, according to _Way, _Mode
		return (seekoff(_Off, _Way, _Mode));
		}

 
	pos_type  pubseekoff(off_type _Off,
		ios_base::seek_dir _Way,
		ios_base::open_mode _Mode)
		{	// change position by _Off, according to _Way, _Mode (old style)
		return (pubseekoff(_Off, (ios_base::seekdir)_Way,
			(ios_base::openmode)_Mode));
		}
 

	pos_type  pubseekpos(pos_type _Pos,
		ios_base::openmode _Mode = ios_base::in | ios_base::out)
		{	// change position to _Pos, according to _Mode
		return (seekpos(_Pos, _Mode));
		}

 
	pos_type  pubseekpos(pos_type _Pos,
		ios_base::open_mode _Mode)
		{	// change position to _Pos, according to _Mode (old style)
		return (seekpos(_Pos, (ios_base::openmode)_Mode));
		}
 

	basic_streambuf * pubsetbuf(_Elem *_Buffer,
		streamsize _Count)
		{	// offer _Buffer to external agent
		return (setbuf(_Buffer, _Count));
		}

	locale  pubimbue(const locale &_Newlocale)
		{	// set locale to argument
		locale _Oldlocale = *_Plocale;
		imbue(_Newlocale);
		*_Plocale = _Newlocale;
		return (_Oldlocale);
		}

	locale  getloc() const
		{	// get locale
		return (*_Plocale);
		}

	streamsize  in_avail()
		{	// return count of buffered input characters
		streamsize _Res = _Gnavail();
		return (0 < _Res ? _Res : showmanyc());
		}

	int  pubsync()
		{	// synchronize with external agent
		return (sync());
		}

	int_type  sbumpc()
		{	// get a character and point past it
		return (0 < _Gnavail()
			? _Traits::to_int_type(*_Gninc()) : uflow());
		}

	int_type  sgetc()
		{	// get a character and don't point past it
		return (0 < _Gnavail()
			? _Traits::to_int_type(*gptr()) : underflow());
		}

	streamsize  sgetn(_Elem *_Ptr,
		streamsize _Count)
		{	// get up to _Count characters into array beginning at _Ptr
		return (xsgetn(_Ptr, _Count));
		}

	int_type  snextc()
		{	// point to next character and return it
		return (1 < _Gnavail()
			? _Traits::to_int_type(*_Gnpreinc())
			: _Traits::eq_int_type(_Traits::eof(), sbumpc())
				? _Traits::eof() : sgetc());
		}

	int_type  sputbackc(_Elem _Ch)
		{	// put back _Ch
		return (gptr() != nullptr && eback() < gptr()
			&& _Traits::eq(_Ch, gptr()[-1])
			? _Traits::to_int_type(*_Gndec())
			: pbackfail(_Traits::to_int_type(_Ch)));
		}

 
	void  stossc()
		{	// point past a character
		if (0 < _Gnavail())
			_Gninc();
		else
			uflow();
		}
 

	int_type  sungetc()
		{	// back up one position
		return (gptr() != nullptr && eback() < gptr()
			? _Traits::to_int_type(*_Gndec()) : pbackfail());
		}

	int_type  sputc(_Elem _Ch)
		{	// put a character
		return (0 < _Pnavail()
			? _Traits::to_int_type(*_Pninc() = _Ch)
			: overflow(_Traits::to_int_type(_Ch)));
		}

	streamsize  sputn(const _Elem *_Ptr,
		streamsize _Count)
		{	// put _Count characters from array beginning at _Ptr
		return (xsputn(_Ptr, _Count));
		}

	virtual void  _Lock()
		{	// set the thread lock (overridden by basic_filebuf)
		}

	virtual void  _Unlock()
		{	// clear the thread lock (overridden by basic_filebuf)
		}

protected:
	_Elem * eback() const
		{	// return beginning of read buffer
		return (*_IGfirst);
		}

	_Elem * gptr() const
		{	// return current position in read buffer
		return (*_IGnext);
		}

	_Elem * pbase() const
		{	// return beginning of write buffer
		return (*_IPfirst);
		}

	_Elem * pptr() const
		{	// return current position in write buffer
		return (*_IPnext);
		}

	_Elem * egptr() const
		{	// return end of read buffer
		return (*_IGnext + *_IGcount);
		}

	void  gbump(int _Off)
		{	// alter current position in read buffer by _Off
		*_IGcount -= _Off;
		*_IGnext += _Off;
		}

	void  setg(_Elem *_First, _Elem *_Next, _Elem *_Last)
		{	// set pointers for read buffer
		*_IGfirst = _First;
		*_IGnext = _Next;
		*_IGcount = (int)(_Last - _Next);
		}

	_Elem * epptr() const
		{	// return end of write buffer
		return (*_IPnext + *_IPcount);
		}

	_Elem * _Gndec()
		{	// decrement current position in read buffer
		++*_IGcount;
		return (--*_IGnext);
		}

	_Elem * _Gninc()
		{	// increment current position in read buffer
		--*_IGcount;
		return ((*_IGnext)++);
		}

	_Elem * _Gnpreinc()
		{	// preincrement current position in read buffer
		--*_IGcount;
		return (++(*_IGnext));
		}

	streamsize  _Gnavail() const
		{	// count number of available elements in read buffer
		return (*_IGnext != nullptr ? *_IGcount : 0);
		}

	void  pbump(int _Off)
		{	// alter current position in write buffer by _Off
		*_IPcount -= _Off;
		*_IPnext += _Off;
		}

	void  setp(_Elem *_First, _Elem *_Last)
		{	// set pointers for write buffer
		*_IPfirst = _First;
		*_IPnext = _First;
		*_IPcount = (int)(_Last - _First);
		}

	void  setp(_Elem *_First, _Elem *_Next, _Elem *_Last)
		{	// set pointers for write buffer, extended version
		*_IPfirst = _First;
		*_IPnext = _Next;
		*_IPcount = (int)(_Last - _Next);
		}

	_Elem * _Pninc()
		{	// increment current position in write buffer
		--*_IPcount;
		return ((*_IPnext)++);
		}

	streamsize  _Pnavail() const
		{	// count number of available positions in write buffer
		return (*_IPnext != nullptr ? *_IPcount : 0);
		}

	void  _Init()
		{	// initialize buffer parameters for no buffers
		_IGfirst = &_Gfirst;
		_IPfirst = &_Pfirst;
		_IGnext = &_Gnext;
		_IPnext = &_Pnext;
		_IGcount = &_Gcount;
		_IPcount = &_Pcount;
		setp(nullptr, nullptr);
		setg(nullptr, nullptr, nullptr);
		}

	void  _Init(_Elem **_Gf, _Elem **_Gn, int *_Gc,
		_Elem **_Pf, _Elem **_Pn, int *_Pc)
		{	// initialize buffer parameters as specified
		_IGfirst = _Gf;
		_IPfirst = _Pf;
		_IGnext = _Gn;
		_IPnext = _Pn;
		_IGcount = _Gc;
		_IPcount = _Pc;
		}

	virtual int_type  overflow(int_type = _Traits::eof())
		{	// put a character to stream (always fail)
		return (_Traits::eof());
		}

	virtual int_type  pbackfail(int_type = _Traits::eof())
		{	// put a character back to stream (always fail)
		return (_Traits::eof());
		}

	virtual streamsize  showmanyc()
		{	// return count of input characters
		return (0);
		}

	virtual int_type  underflow()
		{	// get a character from stream, but don't point past it
		return (_Traits::eof());
		}

	virtual int_type  uflow()
		{	// get a character from stream, point past it
		return (_Traits::eq_int_type(_Traits::eof(), underflow())
			? _Traits::eof() : _Traits::to_int_type(*_Gninc()));
		}

	virtual streamsize  xsgetn(_Elem * _Ptr, streamsize _Count)
		{	// get _Count characters from stream
		const streamsize _Start_count = _Count;

		while (0 < _Count)
			{
			streamsize _Size = _Gnavail();
			if (0 < _Size)
				{	// copy from read buffer
				if (_Count < _Size)
					{
					_Size = _Count;
					}

				_Traits::copy(_Ptr, gptr(), static_cast<size_t>(_Size));
				_Ptr += _Size;
				_Count -= _Size;
				gbump(static_cast<int>(_Size));
				}
			else
				{
				const int_type _Meta = uflow();
				if (_Traits::eq_int_type(_Traits::eof(), _Meta))
					{
					break;	// end of file, quit
					}

				// get a single character
				*_Ptr++ = _Traits::to_char_type(_Meta);
				--_Count;
				}
			}

		return (_Start_count - _Count);
		}

	virtual streamsize  xsputn(const _Elem *_Ptr, streamsize _Count)
		{	// put _Count characters to stream
		const streamsize _Start_count = _Count;
		while (0 < _Count)
			{
			streamsize _Size = _Pnavail();
			if (0 < _Size)
				{	// copy to write buffer
				if (_Count < _Size)
					{
					_Size = _Count;
					}

				_Traits::copy(pptr(), _Ptr, static_cast<size_t>(_Size));
				_Ptr += _Size;
				_Count -= _Size;
				pbump(static_cast<int>(_Size));
				}
			else if (_Traits::eq_int_type(_Traits::eof(), overflow(_Traits::to_int_type(*_Ptr))))
				{
				break;	// single character put failed, quit
				}
			else
				{	// count character successfully put
				++_Ptr;
				--_Count;
				}
			}

		return (_Start_count - _Count);
		}

	virtual pos_type  seekoff(off_type,
		ios_base::seekdir,
		ios_base::openmode = ios_base::in | ios_base::out)
		{	// change position by offset, according to way and mode
		return (streampos(-1));
		}

	virtual pos_type  seekpos(pos_type,
		ios_base::openmode = ios_base::in | ios_base::out)
		{	// change to specified position, according to mode
		return (streampos(-1));
		}

	virtual basic_streambuf * setbuf(_Elem *, streamsize)
		{	// offer buffer to external agent (do nothing)
		return (this);
		}

	virtual int  sync()
		{	// synchronize with external agent (do nothing)
		return (0);
		}

	virtual void  imbue(const locale&)
		{	// set locale to argument (do nothing)
		}

private:
	_Elem *_Gfirst;	// beginning of read buffer
	_Elem *_Pfirst;	// beginning of write buffer
	_Elem **_IGfirst;	// pointer to beginning of read buffer
	_Elem **_IPfirst;	// pointer to beginning of write buffer
	_Elem *_Gnext;	// current position in read buffer
	_Elem *_Pnext;	// current position in write buffer
	_Elem **_IGnext;	// pointer to current position in read buffer
	_Elem **_IPnext;	// pointer to current position in write buffer

	int _Gcount;	// length of read buffer
	int _Pcount;	// length of write buffer
	int *_IGcount;	// pointer to length of read buffer
	int *_IPcount;	// pointer to length of write buffer

protected:
	locale *_Plocale;	// pointer to imbued locale object
	};

 

  
template class __declspec(dllimport) basic_streambuf<char, char_traits<char> >;
template class __declspec(dllimport) basic_streambuf<wchar_t, char_traits<wchar_t> >;
  

  



 

		// CLASS TEMPLATE istreambuf_iterator
template<class _Elem,
	class _Traits>
	class istreambuf_iterator
	{	// wrap stream buffer as input iterator
public:
	using iterator_category = input_iterator_tag;
	using value_type = _Elem;
	using difference_type = typename _Traits::off_type;
	using pointer = const _Elem *;
	using reference = _Elem;

	using char_type = _Elem;
	using traits_type = _Traits;
	using streambuf_type = basic_streambuf<_Elem, _Traits>;
	using istream_type = basic_istream<_Elem, _Traits>;

	using int_type = typename traits_type::int_type;

	constexpr istreambuf_iterator() noexcept
		: _Strbuf(nullptr),
		_Got(true),
		_Val()
		{
		}

	istreambuf_iterator(streambuf_type * _Sb) noexcept
		: _Strbuf(_Sb),
		_Got(_Sb == nullptr),
		_Val()
		{	// construct from stream buffer _Sb
		}

	istreambuf_iterator(istream_type& _Istr) noexcept
		: _Strbuf(_Istr.rdbuf()),
		_Got(_Strbuf == nullptr),
		_Val()
		{	// construct from stream buffer in istream _Istr
		}

private:
	class _Istreambuf_proxy
		{
	public:
		 _Elem operator*() const
			{
			return (_Keep);
			}
	private:
		friend istreambuf_iterator;
		_Istreambuf_proxy(streambuf_type * _Strbuf_, _Elem _Keep_)
			: _Strbuf(_Strbuf_),
			_Keep(_Keep_)
			{
			}

		streambuf_type * _Strbuf;
		_Elem _Keep;
		};

public:
	istreambuf_iterator(const _Istreambuf_proxy& _Px) noexcept
		: _Strbuf(_Px._Strbuf),
		_Got(_Strbuf == nullptr),
		_Val()
		{	// construct from proxy
		}

	 _Elem operator*() const
		{	// return designated value
		if (!_Got)
			_Peek();

 
		do { if (_Strbuf != nullptr) { } else { do { (void) ((1 != _CrtDbgReport(2, "c:\\visual studio\\vc\\tools\\msvc\\14.16.27023\\include\\streambuf", 565, 0, "%s", "istreambuf_iterator is not dereferencable")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"istreambuf_iterator is not dereferencable\"", __LPREFIX( __FUNCTION__), L"c:\\visual studio\\vc\\tools\\msvc\\14.16.27023\\include\\streambuf", 565, 0); } while (false); } ; } while (false);
 

		return (_Val);
		}

	istreambuf_iterator& operator++()
		{	// preincrement
 
		do { if (_Strbuf != nullptr) { } else { do { (void) ((1 != _CrtDbgReport(2, "c:\\visual studio\\vc\\tools\\msvc\\14.16.27023\\include\\streambuf", 574, 0, "%s", "istreambuf_iterator is not incrementable")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"istreambuf_iterator is not incrementable\"", __LPREFIX( __FUNCTION__), L"c:\\visual studio\\vc\\tools\\msvc\\14.16.27023\\include\\streambuf", 574, 0); } while (false); } ; } while (false);
 

		_Inc();
		return (*this);
		}

	_Istreambuf_proxy operator++(int)
		{	// postincrement
		if (!_Got)
			_Peek();
		_Istreambuf_proxy _Tmp{_Strbuf, _Val};
		++*this;
		return (_Tmp);
		}

	 bool equal(const istreambuf_iterator& _Right) const
		{	// test for equality
		if (!_Got)
			_Peek();
		if (!_Right._Got)
			_Right._Peek();
		return ((_Strbuf == nullptr && _Right._Strbuf == nullptr)
			|| (_Strbuf != nullptr && _Right._Strbuf != nullptr));
		}

private:
	void _Inc()
		{	// skip to next input element
		if (_Strbuf == nullptr
			|| traits_type::eq_int_type(traits_type::eof(),
				_Strbuf->sbumpc()))
			{
			_Strbuf = nullptr;
			_Got = true;
			}
		else
			{
			_Got = false;
			}
		}

	_Elem _Peek() const
		{	// peek at next input element
		int_type _Meta;
		if (_Strbuf == nullptr
			|| traits_type::eq_int_type(traits_type::eof(),
				_Meta = _Strbuf->sgetc()))
			_Strbuf = nullptr;
		else
			_Val = traits_type::to_char_type(_Meta);
		_Got = true;
		return (_Val);
		}

	mutable streambuf_type * _Strbuf;	// the wrapped stream buffer
	mutable bool _Got;	// true if _Val is valid
	mutable _Elem _Val;	// next element to deliver
	};

template<class _Elem,
	class _Traits>
	 inline bool operator==(
		const istreambuf_iterator<_Elem, _Traits>& _Left,
		const istreambuf_iterator<_Elem, _Traits>& _Right)
	{	// test for istreambuf_iterator equality
	return (_Left.equal(_Right));
	}

template<class _Elem,
	class _Traits>
	 inline bool operator!=(
		const istreambuf_iterator<_Elem, _Traits>& _Left,
		const istreambuf_iterator<_Elem, _Traits>& _Right)
	{	// test for istreambuf_iterator inequality
	return (!(_Left == _Right));
	}

		// CLASS TEMPLATE ostreambuf_iterator
template<class _Elem,
	class _Traits>
	class ostreambuf_iterator
	{	// wrap stream buffer as output iterator
public:
	using iterator_category = output_iterator_tag;
	using value_type = void;
	using difference_type = void;
	using pointer = void;
	using reference = void;

	using char_type = _Elem;
	using traits_type = _Traits;
	using streambuf_type = basic_streambuf<_Elem, _Traits>;
	using ostream_type = basic_ostream<_Elem, _Traits>;

	ostreambuf_iterator(streambuf_type *_Sb) noexcept
		: _Failed(false), _Strbuf(_Sb)
		{	// construct from stream buffer _Sb
		}

	ostreambuf_iterator(ostream_type& _Ostr) noexcept
		: _Failed(false), _Strbuf(_Ostr.rdbuf())
		{	// construct from stream buffer in _Ostr
		}

	ostreambuf_iterator& operator=(_Elem _Right)
		{	// store element and increment
		if (_Strbuf == nullptr
			|| traits_type::eq_int_type(_Traits::eof(),
				_Strbuf->sputc(_Right)))
			_Failed = true;
		return (*this);
		}

	 ostreambuf_iterator& operator*()
		{	// pretend to get designated element
		return (*this);
		}

	ostreambuf_iterator& operator++()
		{	// pretend to preincrement
		return (*this);
		}

	ostreambuf_iterator& operator++(int)
		{	// pretend to postincrement
		return (*this);
		}

	 bool failed() const noexcept
		{	// return true if any stores failed
		return (_Failed);
		}

private:
	bool _Failed;	// true if any stores have failed
	streambuf_type *_Strbuf;	// the wrapped stream buffer
	};
}

 
 
 #pragma warning(pop)
 #pragma pack(pop)



/*
 * Copyright (c) by P.J. Plauger. All rights reserved.
 * Consult your license regarding permissions and restrictions.
V6.50:0009 */


 #pragma pack(push,8)
 #pragma warning(push,3)
 #pragma warning(disable: 4455 4494  4619 4643 4702 4984 4988 )
 
 
 

		// TEXT-TO-NUMERIC CONVERSION FUNCTIONS

 
extern "C" {
 

extern  float __cdecl _Stofx(const char *,
	    char **,
	long, int *);
extern  double __cdecl _Stodx(const char *,
	    char **,
	long, int *);
extern  long double __cdecl _Stoldx(const char *,
	    char **,
	long, int *);
extern  long __cdecl _Stolx(const char *,
	    char **,
	int, int *);
extern  unsigned long __cdecl _Stoulx(const char *,
	    char **,
	int, int *);
extern  long long __cdecl _Stollx(const char *,
	    char **,
	int, int *);
extern  unsigned long long __cdecl _Stoullx(const char *,
	    char **,
	int, int *);

 
}
 

namespace std {

		// FUNCTION _Stodx_v2
inline double _Stodx_v2(const char *_Str, char **_Endptr, int _Pten, int *_Perr)
	{	// convert string to double
	int& _Errno_ref = (*_errno());	// Nonzero cost, pay it once
	const int _Orig = _Errno_ref;

	_Errno_ref = 0;
	double _Val = :: strtod(_Str, _Endptr);
	*_Perr = _Errno_ref;
	_Errno_ref = _Orig;

	if (_Pten != 0)
		_Val *= :: pow(10.0, static_cast<double>(_Pten));

	return (_Val);
	}

		// FUNCTION _Stofx_v2
inline float _Stofx_v2(const char *_Str, char **_Endptr, int _Pten, int *_Perr)
	{	// convert string to float
	int& _Errno_ref = (*_errno());	// Nonzero cost, pay it once
	const int _Orig = _Errno_ref;

	_Errno_ref = 0;
	float _Val = :: strtof(_Str, _Endptr);
	*_Perr = _Errno_ref;
	_Errno_ref = _Orig;

	if (_Pten != 0)
		_Val *= :: powf(10.0f, static_cast<float>(_Pten));

	return (_Val);
	}

		// FUNCTION TEMPLATE _Find_elem
template<class _Elem,
	size_t _Base_size> inline
	size_t _Find_elem(const _Elem (&_Base)[_Base_size], const _Elem _Ch)
	{	// lookup _Ch in array storing NUL-terminated string _Base
		// pre: _Base contains no nulls except for _Base[_Base_size - 1]
	return (static_cast<size_t>(_Find_unchecked(_Base, _Base + (_Base_size - 1), _Ch) - _Base));
	}

inline wchar_t *_Maklocwcs(const wchar_t *_Ptr)
	{	// copy NTWCS to allocated storage
	const size_t _Count = :: wcslen(_Ptr) + 1;

	wchar_t *_Ptrdest = (wchar_t *)_calloc_dbg(_Count, sizeof (wchar_t),
		2, "c:\\visual studio\\vc\\tools\\msvc\\14.16.27023\\include\\xlocnum", 101);

	if (!_Ptrdest)
		_Xbad_alloc();
	:: wmemcpy(_Ptrdest, _Ptr, _Count);
	return (_Ptrdest);
	}

		// CLASS TEMPLATE numpunct
template<class _Elem>
	class numpunct
		: public locale::facet
	{	// facet for defining numeric punctuation text
public:
	typedef basic_string<_Elem, char_traits<_Elem>, allocator<_Elem> >
		string_type;
	typedef _Elem char_type;

	 __declspec(dllimport) static locale::id id;	// unique facet id

	_Elem decimal_point() const
		{	// return decimal point
		return (do_decimal_point());
		}

	_Elem thousands_sep() const
		{	// return thousands separator
		return (do_thousands_sep());
		}

	string grouping() const
		{	// return grouping string
		return (do_grouping());
		}

	string_type falsename() const
		{	// return name for false
		return (do_falsename());
		}

	string_type truename() const
		{	// return name for true
		return (do_truename());
		}

	explicit numpunct(size_t _Refs = 0)
		: locale::facet(_Refs)
		{	// construct from current locale
		{ _Locinfo _Lobj;
			_Init(_Lobj);
			if (_Kseparator == 0)
				_Kseparator =	// NB: differs from "C" locale
					_Maklocchr(',', static_cast<_Elem *>(nullptr), _Lobj._Getcvt());
		}
		}

	numpunct(const _Locinfo& _Lobj, size_t _Refs = 0, bool _Isdef = false)
		: locale::facet(_Refs)
		{	// construct from specified locale
		_Init(_Lobj, _Isdef);
		}

	static size_t _Getcat(const locale::facet **_Ppf = nullptr,
		const locale *_Ploc = nullptr)
		{	// return locale category mask and construct standard facet
		if (_Ppf != nullptr && *_Ppf == nullptr)
			*_Ppf = new numpunct<_Elem>(
				_Locinfo(_Ploc->c_str()), 0, true);
		return (4);
		}

protected:
	virtual  ~numpunct() noexcept
		{	// destroy the object
		_Tidy();
		}

	numpunct(const char *_Locname, size_t _Refs = 0, bool _Isdef = false)
		: locale::facet(_Refs)
		{	// construct from specified locale
		{ _Locinfo _Lobj(_Locname);
			_Init(_Lobj, _Isdef);
		}
		}

	template<class _Elem2>
		void _Getvals(_Elem2, const lconv *_Ptr, _Locinfo::_Cvtvec _Cvt)
		{	// get values
		_Dp = _Maklocchr(_Ptr->decimal_point[0], static_cast<_Elem2 *>(nullptr), _Cvt);
		_Kseparator = _Maklocchr(_Ptr->thousands_sep[0], static_cast<_Elem2 *>(nullptr), _Cvt);
		}

	void _Getvals(wchar_t, const lconv *_Ptr, _Locinfo::_Cvtvec)
		{	// get values
		_Dp = (_Elem)_Ptr->_W_decimal_point[0];
		_Kseparator = (_Elem)_Ptr->_W_thousands_sep[0];
		}

	void _Init(const _Locinfo& _Lobj, bool _Isdef = false)
		{	// initialize from _Lobj
		const lconv *_Ptr = _Lobj._Getlconv();
		_Locinfo::_Cvtvec _Cvt = _Lobj._Getcvt();	// conversion information

		_Grouping = nullptr;
		_Falsename = nullptr;
		_Truename = nullptr;

		try {
		_Grouping = _Maklocstr(_Isdef ? "" : _Ptr->grouping, static_cast<char *>(nullptr), _Lobj._Getcvt());
		_Falsename = _Maklocstr(_Lobj._Getfalse(), static_cast<_Elem *>(nullptr), _Cvt);
		_Truename = _Maklocstr(_Lobj._Gettrue(), static_cast<_Elem *>(nullptr), _Cvt);
		} catch (...) {
		_Tidy();
		throw;
		}

		if (_Isdef)
			{	// apply defaults for required facets
//			_Grouping = _Maklocstr("", static_cast<char *>(nullptr), _Cvt);
			_Dp = _Maklocchr('.', static_cast<_Elem *>(nullptr), _Cvt);
			_Kseparator = _Maklocchr(',', static_cast<_Elem *>(nullptr), _Cvt);
			}
		else
			_Getvals((_Elem)0, _Ptr, _Cvt);
		}

	virtual _Elem  do_decimal_point() const
		{	// return decimal point
		return (_Dp);
		}

	virtual _Elem  do_thousands_sep() const
		{	// return thousands separator
		return (_Kseparator);
		}

	virtual string  do_grouping() const
		{	// return grouping string
		return (string(_Grouping));
		}

	virtual string_type  do_falsename() const
		{	// return name for false
		return (string_type(_Falsename));
		}

	virtual string_type  do_truename() const
		{	// return name for true
		return (string_type(_Truename));
		}

private:
	void _Tidy()
		{	// free all storage
		:: free((void *)_Grouping);
		:: free((void *)_Falsename);
		:: free((void *)_Truename);
		}

	const char *_Grouping;	// grouping string, "" for "C" locale
	_Elem _Dp;	// decimal point, '.' for "C" locale
	_Elem _Kseparator;	// thousands separator, '\0' for "C" locale
	const _Elem *_Falsename;	// name for false, "false" for "C" locale
	const _Elem *_Truename;	// name for true, "true" for "C" locale
	};

		// CLASS TEMPLATE numpunct_byname
template<class _Elem>
	class numpunct_byname
		: public numpunct<_Elem>
	{	// numpunct for named locale
public:
	explicit numpunct_byname(const char *_Locname, size_t _Refs = 0)
		: numpunct<_Elem>(_Locname, _Refs)
		{	// construct for named locale
		}

	explicit numpunct_byname(const string& _Str, size_t _Refs = 0)
		: numpunct<_Elem>(_Str.c_str(), _Refs)
		{	// construct for named locale
		}

protected:
	virtual  ~numpunct_byname() noexcept
		{	// destroy the object
		}
	};

		// STATIC numpunct::id OBJECT






template<class _Elem>
	 locale::id numpunct<_Elem>::id;






		// CLASS TEMPLATE num_get
template<class _Elem,
	class _InIt = istreambuf_iterator<_Elem, char_traits<_Elem> > >
	class num_get
		: public locale::facet
	{	// facet for converting text to encoded numbers
public:
	static size_t __cdecl _Getcat(const locale::facet **_Ppf = nullptr,
		const locale *_Ploc = nullptr)
		{	// return locale category mask and construct standard facet
		if (_Ppf != nullptr && *_Ppf == nullptr)
			*_Ppf = new num_get<_Elem, _InIt>(
				_Locinfo(_Ploc->c_str()));
		return (4);
		}

	 static locale::id id;	// unique facet id

protected:
	virtual  ~num_get() noexcept
		{	// destroy the object
		}

	void _Init(const _Locinfo&)
		{	// initialize from _Locinfo object
		}

public:
	explicit  num_get(size_t _Refs = 0)
		: locale::facet(_Refs)
		{	// construct from current locale
		{ _Locinfo _Lobj;
			_Init(_Lobj);
		}
		}

	 num_get(const _Locinfo& _Lobj, size_t _Refs = 0)
		: locale::facet(_Refs)
		{	// construct from specified locale
		_Init(_Lobj);
		}

	typedef _Elem char_type;
	typedef _InIt iter_type;

	_InIt  get(_InIt _First, _InIt _Last,
		ios_base& _Iosbase, ios_base::iostate& _State,
			bool& _Val) const
		{	// get bool from [_First, _Last) into _Val
		return (do_get(_First, _Last, _Iosbase, _State, _Val));
		}

	_InIt  get(_InIt _First, _InIt _Last,
		ios_base& _Iosbase, ios_base::iostate& _State,
			unsigned short& _Val) const
		{	// get unsigned short from [_First, _Last) into _Val
		return (do_get(_First, _Last, _Iosbase, _State, _Val));
		}

	_InIt  get(_InIt _First, _InIt _Last,
		ios_base& _Iosbase, ios_base::iostate& _State,
			unsigned int& _Val) const
		{	// get unsigned int from [_First, _Last) into _Val
		return (do_get(_First, _Last, _Iosbase, _State, _Val));
		}

	_InIt  get(_InIt _First, _InIt _Last,
		ios_base& _Iosbase, ios_base::iostate& _State,
			long& _Val) const
		{	// get long from [_First, _Last) into _Val
		return (do_get(_First, _Last, _Iosbase, _State, _Val));
		}

	_InIt  get(_InIt _First, _InIt _Last,
		ios_base& _Iosbase, ios_base::iostate& _State,
			unsigned long& _Val) const
		{	// get unsigned long from [_First, _Last) into _Val
		return (do_get(_First, _Last, _Iosbase, _State, _Val));
		}

	_InIt  get(_InIt _First, _InIt _Last,
		ios_base& _Iosbase, ios_base::iostate& _State,
			long long& _Val) const
		{	// get long long from [_First, _Last) into _Val
		return (do_get(_First, _Last, _Iosbase, _State, _Val));
		}

	_InIt  get(_InIt _First, _InIt _Last,
		ios_base& _Iosbase, ios_base::iostate& _State,
			unsigned long long& _Val) const
		{	// get unsigned long long from [_First, _Last) into _Val
		return (do_get(_First, _Last, _Iosbase, _State, _Val));
		}

	_InIt  get(_InIt _First, _InIt _Last,
		ios_base& _Iosbase, ios_base::iostate& _State,
			float& _Val) const
		{	// get float from [_First, _Last) into _Val
		return (do_get(_First, _Last, _Iosbase, _State, _Val));
		}

	_InIt  get(_InIt _First, _InIt _Last,
		ios_base& _Iosbase, ios_base::iostate& _State,
			double& _Val) const
		{	// get double from [_First, _Last) into _Val
		return (do_get(_First, _Last, _Iosbase, _State, _Val));
		}

	_InIt  get(_InIt _First, _InIt _Last,
		ios_base& _Iosbase, ios_base::iostate& _State,
			long double& _Val) const
		{	// get long double from [_First, _Last) into _Val
		return (do_get(_First, _Last, _Iosbase, _State, _Val));
		}

	_InIt  get(_InIt _First, _InIt _Last,
		ios_base& _Iosbase, ios_base::iostate& _State,
			void *& _Val) const
		{	// get void pointer from [_First, _Last) into _Val
		return (do_get(_First, _Last, _Iosbase, _State, _Val));
		}

protected:
	virtual _InIt  do_get(_InIt _First, _InIt _Last,
		ios_base& _Iosbase, ios_base::iostate& _State,
			bool& _Val) const
		{	// get bool from [_First, _Last) into _Val
		_Adl_verify_range(_First, _Last);
		if (_Iosbase.flags() & ios_base::boolalpha)
			{	// get false name or true name
			const auto& _Punct_fac = ::std:: use_facet<numpunct<_Elem>>(_Iosbase.getloc());
			basic_string<_Elem> _Str(static_cast<size_t>(1), _Elem{});
			_Str += _Punct_fac.falsename();
			_Str.push_back(_Elem{});
			_Str += _Punct_fac.truename();	// construct "\0false\0true"
			switch (_Getloctxt(_First, _Last, 2, _Str.c_str()))
				{
				case 0:
					_Val = false;
					break;
				case 1:
					_Val = true;
					break;
				default:
					_Val = false;
					_State = ios_base::failbit;
					break;
				}
			}
		else
			{	// get long value
			char _Ac[32];
			const int _Base = _Getifld(_Ac, _First, _Last, _Iosbase.flags(), _Iosbase.getloc());	// gather field
			if (_Ac[0] == '\0')
				{	// Handle N4727 [facet.num.get.virtuals]/3.6:
					//  "zero, if the conversion function does not convert the entire field."
					// We should still do numeric conversion with bad digit separators, instead of
					// setting 0, but we can't distinguish that from _Getifld's interface, and _Getifld's
					// interface can't be changed as it is an exported function. Fixing that when ABI
					// allows is tracked by VSO#591516.
				_Val = false;
				_State = ios_base::failbit;
				}
			else
				{
				char * _Ep;
				int _Errno;
				const long _Ans = :: _Stolx(_Ac, &_Ep, _Base, &_Errno);	// convert
				if (_Ep == _Ac || _Errno != 0)
					{
					_Val = true;
					_State = ios_base::failbit;
					}
				else
					{
					_Val = _Ans != 0;
					if (_Ans != 0 && _Ans != 1)
						{
						_State = ios_base::failbit;
						}
					}
				}
			}

		if (_First == _Last)
			{
			_State |= ios_base::eofbit;
			}

		return (_First);
		}

	virtual _InIt  do_get(_InIt _First, _InIt _Last,
		ios_base& _Iosbase, ios_base::iostate& _State,
			unsigned short& _Val) const
		{	// get unsigned short from [_First, _Last) into _Val
		_Adl_verify_range(_First, _Last);
		char _Ac[32];
		const int _Base = _Getifld(_Ac, _First, _Last, _Iosbase.flags(), _Iosbase.getloc());	// gather field
		if (_Ac[0] == '\0')
			{	// ditto "fails to convert the entire field" / VSO#591516
			_State = ios_base::failbit;
			_Val = 0;
			}
		else
			{
			const bool _Minus = _Ac[0] == '-';
			const char * _Digits = _Ac;
			// C11 7.22.1.4/5: the sequence of characters starting with the first digit
			// is interpreted as an integer constant according to the rules of 6.4.4.1
			if (_Minus)
				{	// skip over minus to start with the first digit
				++_Digits;
				}

			char * _Ep;
			int _Errno;
			const unsigned long _Tmp = :: _Stoulx(_Digits, &_Ep, _Base, &_Errno);	// convert
			_Val = static_cast<unsigned short>(_Tmp);
			if (_Ep == _Digits || _Errno != 0 || _Tmp > 0xffff)
				{
				_State = ios_base::failbit;
				_Val = 0xffff;
				}
			else if (_Minus)
				{	// C11 7.22.1.4/5:  If the subject sequence begins with a minus sign,
					// the value resulting from the conversion is negated (in the return type).
				_Val = static_cast<unsigned short>(0 - _Val);
				}
			}

		if (_First == _Last)
			{
			_State |= ios_base::eofbit;
			}

		return (_First);
		}

	virtual _InIt  do_get(_InIt _First, _InIt _Last,
		ios_base& _Iosbase, ios_base::iostate& _State,
			unsigned int& _Val) const
		{	// get unsigned int from [_First, _Last) into _Val
		static_assert(sizeof(unsigned int) == sizeof(unsigned long),
			"Bad overflow assumptions due to sizeof(unsigned int) != sizeof(unsigned long)");
		unsigned long _Tmp;
		_First = num_get::do_get(_First, _Last, _Iosbase, _State, _Tmp); // avoid virtual call for perf
		_Val = _Tmp;
		return (_First);
		}

	virtual _InIt  do_get(_InIt _First, _InIt _Last,
		ios_base& _Iosbase, ios_base::iostate& _State,
			long& _Val) const
		{	// get long from [_First, _Last) into _Val
		_Adl_verify_range(_First, _Last);
		char _Ac[32];
		const int _Base = _Getifld(_Ac, _First, _Last, _Iosbase.flags(), _Iosbase.getloc());	// gather field
		if (_Ac[0] == '\0')
			{	// ditto "fails to convert the entire field" / VSO#591516
			_State = ios_base::failbit;
			_Val = 0;
			}
		else
			{
			char * _Ep;
			int _Errno;
			_Val = :: _Stolx(_Ac, &_Ep, _Base, &_Errno);	// convert
			if (_Ep == _Ac || _Errno != 0)
				{
				_State = ios_base::failbit;
				}
			}

		if (_First == _Last)
			{
			_State |= ios_base::eofbit;
			}

		return (_First);
		}

	virtual _InIt  do_get(_InIt _First, _InIt _Last,
		ios_base& _Iosbase, ios_base::iostate& _State,
			unsigned long& _Val) const
		{	// get unsigned long from [_First, _Last) into _Val
		_Adl_verify_range(_First, _Last);
		char _Ac[32];
		const int _Base = _Getifld(_Ac, _First, _Last, _Iosbase.flags(), _Iosbase.getloc()); // gather field
		if (_Ac[0] == '\0')
			{	// ditto "fails to convert the entire field" / VSO#591516
			_State = ios_base::failbit;
			_Val = 0;
			}
		else
			{
			char * _Ep;
			int _Errno;
			_Val = :: _Stoulx(_Ac, &_Ep, _Base, &_Errno);	// convert
			if (_Ep == _Ac || _Errno != 0)
				{
				_State = ios_base::failbit;
				}
			}

		if (_First == _Last)
			{
			_State |= ios_base::eofbit;
			}

		return (_First);
		}

	virtual _InIt  do_get(_InIt _First, _InIt _Last,
		ios_base& _Iosbase, ios_base::iostate& _State,
			long long& _Val) const
		{	// get long long from [_First, _Last) into _Val
		_Adl_verify_range(_First, _Last);
		char _Ac[32];
		const int _Base = _Getifld(_Ac, _First, _Last, _Iosbase.flags(), _Iosbase.getloc());
		if (_Ac[0] == '\0')
			{	// ditto "fails to convert the entire field" / VSO#591516
			_State = ios_base::failbit;
			_Val = 0;
			}
		else
			{
			char * _Ep;
			int _Errno;
			_Val = :: _Stollx(_Ac, &_Ep, _Base, &_Errno);	// convert
			if (_Ep == _Ac || _Errno != 0)
				{
				_State = ios_base::failbit;
				}
			}

		if (_First == _Last)
			{
			_State |= ios_base::eofbit;
			}

		return (_First);
		}

	virtual _InIt  do_get(_InIt _First, _InIt _Last,
		ios_base& _Iosbase, ios_base::iostate& _State,
			unsigned long long& _Val) const
		{	// get unsigned long long from [_First, _Last) into _Val
		_Adl_verify_range(_First, _Last);
		char _Ac[32];
		const int _Base = _Getifld(_Ac, _First, _Last, _Iosbase.flags(), _Iosbase.getloc());
		if (_Ac[0] == '\0')
			{	// ditto "fails to convert the entire field" / VSO#591516
			_State = ios_base::failbit;
			_Val = 0;
			}
		else
			{
			int _Errno;
			char * _Ep;
			_Val = :: _Stoullx(_Ac, &_Ep, _Base, &_Errno);	// convert
			if (_Ep == _Ac || _Errno != 0)
				{
				_State = ios_base::failbit;
				}
			}

		if (_First == _Last)
			{
			_State |= ios_base::eofbit;
			}

		return (_First);
		}

// Sentinel value used by num_get::do_get() to enable correct "V2" behavior in _Getffld() and _Getffldx()


// Size of char buffer used by num_get::do_get() for float/double/long double


	virtual _InIt  do_get(_InIt _First, _InIt _Last,
		ios_base& _Iosbase, ios_base::iostate& _State,
			float& _Val) const
		{	// get float from [_First, _Last) into _Val
		_Adl_verify_range(_First, _Last);
		char _Ac[(8 + 768 + 16)];
		int _Hexexp = 1000000000;
		const int _Base = _Getffld(_Ac, _First, _Last, _Iosbase, &_Hexexp);	// gather field
		if (_Ac[0] == '\0')
			{	// ditto "fails to convert the entire field" / VSO#591516
			_State = ios_base::failbit;
			_Val = 0.0f;
			}
		else
			{
			int _Errno;
			char * _Ep;
			_Val = _Stofx_v2(_Ac, &_Ep, _Base, &_Errno);	// convert
			if (_Ep == _Ac || _Errno != 0)
				{
				_State = ios_base::failbit;
				_Val = 0.0f;
				}
			else if (_Hexexp != 1000000000 && _Hexexp != 0)
				{
				_Val = :: ldexpf(_Val, 4 * _Hexexp);
				}
			}

		if (_First == _Last)
			{
			_State |= ios_base::eofbit;
			}

		return (_First);
		}

	virtual _InIt  do_get(_InIt _First, _InIt _Last,
		ios_base& _Iosbase, ios_base::iostate& _State,
			double& _Val) const
		{	// get double from [_First, _Last) into _Val
		_Adl_verify_range(_First, _Last);
		char _Ac[(8 + 768 + 16)];
		int _Hexexp = 1000000000;
		const int _Base = _Getffld(_Ac, _First, _Last, _Iosbase, &_Hexexp);	// gather field
		if (_Ac[0] == '\0')
			{	// ditto "fails to convert the entire field" / VSO#591516
			_State = ios_base::failbit;
			_Val = 0.0;
			}
		else
			{
			int _Errno;
			char * _Ep;
			_Val = _Stodx_v2(_Ac, &_Ep, _Base, &_Errno);	// convert
			if (_Ep == _Ac || _Errno != 0)
				{
				_State = ios_base::failbit;
				_Val = 0.0;
				}
			else if (_Hexexp != 1000000000 && _Hexexp != 0)
				{
				_Val = :: ldexp(_Val, 4 * _Hexexp);
				}
			}

		if (_First == _Last)
			{
			_State |= ios_base::eofbit;
			}

		return (_First);
		}


	virtual _InIt  do_get(_InIt _First, _InIt _Last,
		ios_base& _Iosbase, ios_base::iostate& _State,
			long double& _Val) const
		{	// get long double from [_First, _Last) into _Val
		static_assert(sizeof(double) == sizeof(long double),
			"Bad assumption: sizeof(double) == sizeof(long double).");
		double _Result;
		_First = num_get::do_get(_First, _Last, _Iosbase, _State, _Result); // avoid virtual call for perf
		_Val = _Result;
		return (_First);
		}

	virtual _InIt  do_get(_InIt _First, _InIt _Last,
		ios_base& _Iosbase, ios_base::iostate& _State,
			void *& _Val) const
		{	// get void pointer from [_First, _Last) into _Val
		_Adl_verify_range(_First, _Last);
		char _Ac[32];
		const int _Base = _Getifld(_Ac, _First, _Last, ios_base::hex, _Iosbase.getloc());	// gather field
		if (_Ac[0] == '\0')
			{	// ditto "fails to convert the entire field" / VSO#591516
			_State = ios_base::failbit;
			_Val = nullptr;
			}
		else
			{
			int _Errno;
			char * _Ep;

			_Val = reinterpret_cast<void *>(:: _Stoullx(_Ac, &_Ep, _Base, &_Errno));



			if (_Ep == _Ac || _Errno != 0)
				{
				_State = ios_base::failbit;
				_Val = nullptr;
				}
			}

		if (_First == _Last)
			{
			_State |= ios_base::eofbit;
			}

		return (_First);
		}

private:
	int __cdecl _Getifld(char *_Ac,
		_InIt& _First, _InIt& _Last, ios_base::fmtflags _Basefield,
			const locale& _Loc) const
		{	// get integer field from [_First, _Last) into _Ac
		const auto& _Punct_fac = ::std:: use_facet<numpunct<_Elem>>(_Loc);
		const string _Grouping = _Punct_fac.grouping();
		const _Elem _Kseparator = _Grouping.size() == 0
			? (_Elem)0 : _Punct_fac.thousands_sep();

		constexpr int _Numget_signoff = 22;
		constexpr int _Numget_xoff = 24;
		static constexpr char _Src[] = {"0123456789ABCDEFabcdef-+Xx"};
		_Elem _Atoms[sizeof (_Src)];
		const ctype<_Elem>& _Ctype_fac = ::std:: use_facet<ctype<_Elem>>(_Loc);
		_Ctype_fac.widen(&_Src[0], &_Src[sizeof (_Src)], _Atoms);

		char *_Ptr = _Ac;

		if (_First != _Last)
			{
			if (*_First == _Atoms[_Numget_signoff + 1])
				{	// gather plus sign
				*_Ptr++ = '+';
				++_First;
				}
			else if (*_First == _Atoms[_Numget_signoff])
				{	// gather minus sign
				*_Ptr++ = '-';
				++_First;
				}
			}

		_Basefield &= ios_base::basefield;
		int _Base = _Basefield == ios_base::oct ? 8
			: _Basefield == ios_base::hex ? 16
			: _Basefield == ios_base::_Fmtzero ? 0 : 10;

		bool _Seendigit = false;	// seen a digit in input
		bool _Nonzero = false;	// seen a nonzero digit in input

		if (_First != _Last && *_First == _Atoms[0])
			{	// leading zero, look for 0x, 0X
			_Seendigit = true;
			++_First;
			if (_First != _Last && (*_First == _Atoms[_Numget_xoff + 1]
					|| *_First == _Atoms[_Numget_xoff])
				&& (_Base == 0 || _Base == 16))
				{
				_Base = 16;
				_Seendigit = false;
				++_First;
				}
			else if (_Base == 0)
				{
				_Base = 8;
				}
			}

		const auto _Dlen = static_cast<size_t>(_Base == 0 || _Base == 10 ? 10
			: _Base == 8 ? 8 : 16 + 6);
		string _Groups((size_t)1, (char)_Seendigit);
		size_t _Group = 0;

		for (char *const _Pe = &_Ac[32 - 1];
			_First != _Last; ++_First)
			{	// look for digits and separators
			size_t _Idx = _Find_elem(_Atoms, *_First);
			if (_Idx < _Dlen)
				{	// got a digit, characterize it and add to group size
				*_Ptr = _Src[_Idx];
				if ((_Nonzero || *_Ptr != '0') && _Ptr < _Pe)
					{
					++_Ptr;
					_Nonzero = true;
					}

				_Seendigit = true;
				if (_Groups[_Group] != 127)
					++_Groups[_Group];
				}
			else if (_Groups[_Group] == '\0'
				|| _Kseparator == (_Elem)0
				|| *_First != _Kseparator)
				break;	// not a group separator, done
			else
				{	// add a new group to _Groups string
				_Groups.push_back('\0');
				++_Group;
				}
			}

		if (_Group != 0)
			{
			if ('\0' < _Groups[_Group])
				{
				++_Group;	// add trailing group to group count
				}
			else
				{
				_Seendigit = false;	// trailing separator, fail
				}
			}

		for (const char *_Pg = &_Grouping[0]; _Seendigit && 0 < _Group; )
			if (*_Pg == 127)
				break;	// end of grouping constraints to check
			else if ((0 < --_Group && *_Pg != _Groups[_Group])
				|| (0 == _Group && *_Pg < _Groups[_Group]))
				_Seendigit = false;	// bad group size, fail
			else if ('\0' < _Pg[1])
				++_Pg;	// group size okay, advance to next test

		if (_Seendigit && !_Nonzero)
			*_Ptr++ = '0';	// zero field, replace stripped zero(s)
		else if (!_Seendigit)
			_Ptr = _Ac;	// roll back pointer to indicate failure
		*_Ptr = '\0';
		return (_Base);
		}

	int __cdecl _Getffld(char *_Ac,
		_InIt& _First, _InIt &_Last,
		ios_base& _Iosbase, int *_Phexexp) const
		{	// get floating-point field from [_First, _Last) into _Ac
		if ((_Iosbase.flags() & ios_base::floatfield) == ios_base::hexfloat)
			return (_Getffldx(_Ac, _First, _Last,
				_Iosbase, _Phexexp));	// hex format

		const auto& _Punct_fac = ::std:: use_facet<numpunct<_Elem>>(_Iosbase.getloc());
		const string _Grouping = _Punct_fac.grouping();
		char *_Ptr = _Ac;
		bool _Bad = false;
		bool _Sticky = false;

		constexpr int _Numget_signoff = 10;
		constexpr int _Numget_eoff = 12;
		static constexpr char _Src[] = {"0123456789-+Ee"};
		_Elem _Atoms[sizeof (_Src)];
		const ctype<_Elem>& _Ctype_fac = ::std:: use_facet<ctype<_Elem>>(_Iosbase.getloc());
		_Ctype_fac.widen(&_Src[0], &_Src[sizeof (_Src)], _Atoms);

		if (_First != _Last)
			{
			if (*_First == _Atoms[_Numget_signoff + 1])
				{	// gather plus sign
				*_Ptr++ = '+';
				++_First;
				}
			else if (*_First == _Atoms[_Numget_signoff])
				{	// gather minus sign
				*_Ptr++ = '-';
				++_First;
				}
			}

		char *_Leading = _Ptr;	// remember backstop
		*_Ptr++ = '0';	// backstop carries from sticky bit

		bool _Seendigit = false;	// seen a digit in input
		int _Significant = 0;	// number of significant digits
		int _Pten = 0;	// power of 10 multiplier
		size_t _Idx;

		const int _Max_sig_dig = (*_Phexexp == 1000000000 ? 768 : 36);

		const char *_Pg = &_Grouping[0];
		if (*_Pg == 127 || *_Pg <= '\0')
			{
			for (; _First != _Last
				&& (_Idx = _Find_elem(_Atoms, *_First)) < 10;
					_Seendigit = true, (void)++_First)
				{
				if (_Max_sig_dig <= _Significant)
					{	// enough digits, scale by 10 and update _Sticky
					++_Pten;
					if (0 < _Idx)
						{
						_Sticky = true;
						}
					}
				else if (_Idx != 0 || _Significant != 0)
					{	// save a significant digit
					*_Ptr++ = _Src[_Idx];
					++_Significant;
					}
				}
			}
		else
			{	// grouping specified, gather digits and group sizes
			const _Elem _Kseparator = _Grouping.size() == 0
				? (_Elem)0 : _Punct_fac.thousands_sep();
			string _Groups((size_t)1, '\0');
			size_t _Group = 0;

			for (; _First != _Last; ++_First)
				{
				if ((_Idx = _Find_elem(_Atoms, *_First)) < 10)
					{	// got a digit, add to group size
					_Seendigit = true;
					if (_Max_sig_dig <= _Significant)
						{	// enough digits, scale by 10 and update _Sticky
						++_Pten;
						if (0 < _Idx)
							{
							_Sticky = true;
							}
						}
					else if (_Idx != 0 || _Significant != 0)
						{	// save a significant digit
						*_Ptr++ = _Src[_Idx];
						++_Significant;
						}

					if (_Groups[_Group] != 127)
						{
						++_Groups[_Group];
						}
					}
				else if (_Groups[_Group] == '\0'
					|| _Kseparator == (_Elem)0
					|| *_First != _Kseparator)
					{
					break;	// not a group separator, done
					}
				else
					{	// add a new group to _Groups string
					_Groups.push_back('\0');
					++_Group;
					}
				}

			if (_Group != 0)
				{
				if ('\0' < _Groups[_Group])
					{
					++_Group;	// add trailing group to group count
					}
				else
					{
					_Bad = true;	// trailing separator, fail
					}
				}

			while (!_Bad && 0 < _Group)
				{
				if (*_Pg == 127)
					{
					break;	// end of grouping constraints to check
					}

				if ((0 < --_Group && *_Pg != _Groups[_Group])
					|| (0 == _Group && *_Pg < _Groups[_Group]))
					{
					_Bad = true;	// bad group size, fail
					}
				else if ('\0' < _Pg[1])
					{
					++_Pg;	// group size okay, advance to next test
					}
				}
			}

		if (_First != _Last && *_First == _Punct_fac.decimal_point())
			{	// add .
			*_Ptr++ = localeconv()->decimal_point[0];
			++_First;
			}

		if (*_Phexexp != 1000000000 && _Significant == 0)
			{	// 0000. so far
			for (; _First != _Last && *_First == _Atoms[0];
				_Seendigit = true, (void)++_First)
				--_Pten;	// just count leading fraction zeros
			if (_Pten < 0)
				{	// put one back
				*_Ptr++ = '0';
				++_Pten;
				}
			}

		for (; _First != _Last
				&& (_Idx = _Find_elem(_Atoms, *_First)) < 10;
				_Seendigit = true, (void)++_First)
			if (_Significant < _Max_sig_dig)
				{	// save a significant fraction digit
				*_Ptr++ = _Src[_Idx];
				++_Significant;
				}
			else if (0 < _Idx)
				_Sticky = true;	// just update _Sticky

		if (_Sticky)
			{	// increment ls digit in memory of those lost
			char *_Px = _Ptr;
			while (--_Px != _Leading)
				{	// add in carry
				if (*_Px != localeconv()->decimal_point[0])
					{	// non decimal point
					if (*_Px != '9')
						{	// carry stops here
						++*_Px;
						break;
						}

					*_Px = '0';	// propagate carry
					}
				}

			if (_Px == _Leading)
				{	// change "999..." to "1000..." and scale _Pten
				*_Px = '1';
				++_Pten;
				}
			}

		if (_Seendigit && _First != _Last
			&& (*_First == _Atoms[_Numget_eoff + 1]
				|| *_First == _Atoms[_Numget_eoff]))
			{	// 'e' or 'E', collect exponent
			*_Ptr++ = 'e';
			++_First;
			_Seendigit = false;
			_Significant = 0;

			if (_First != _Last)
				{
				if (*_First == _Atoms[_Numget_signoff + 1])
					{	// gather plus sign
					*_Ptr++ = '+';
					++_First;
					}
				else if (*_First == _Atoms[_Numget_signoff])
					{	// gather minus sign
					*_Ptr++ = '-';
					++_First;
					}
				}

			for (; _First != _Last && *_First == _Atoms[0]; ++_First)
				{	// strip leading zeros
				_Seendigit = true;
				}

			if (_Seendigit)
				*_Ptr++ = '0';	// put one back
			for (; _First != _Last
				&& (_Idx = _Find_elem(_Atoms, *_First)) < 10;
				_Seendigit = true, (void)++_First)
				if (_Significant < 8)
					{	// save a significant exponent digit
					*_Ptr++ = _Src[_Idx];
					++_Significant;
					}
			}

		if (_Bad || !_Seendigit)
			_Ptr = _Ac;	// roll back pointer to indicate failure
		*_Ptr = '\0';
		return (_Pten);
		}

	int __cdecl _Getffldx(char *_Ac,
		_InIt& _First, _InIt &_Last,
		ios_base& _Iosbase, int *_Phexexp) const
		{	// get hex floating-point field from [_First, _Last) into _Ac
		const auto& _Punct_fac = ::std:: use_facet<numpunct<_Elem>>(_Iosbase.getloc());
		const string _Grouping = _Punct_fac.grouping();

		constexpr int _Numget_signoff = 22;
		constexpr int _Numget_xoff = 24;
		constexpr int _Numget_poff = 26;
		static constexpr char _Src[] = {"0123456789ABCDEFabcdef-+XxPp"};
		_Elem _Atoms[sizeof (_Src)];
		const ctype<_Elem>& _Ctype_fac = ::std:: use_facet<ctype<_Elem>>(_Iosbase.getloc());
		_Ctype_fac.widen(&_Src[0], &_Src[sizeof (_Src)], _Atoms);

		char *_Ptr = _Ac;
		bool _Bad = false;
		size_t _Idx;

		if (_First != _Last)
			{
			if (*_First == _Atoms[_Numget_signoff + 1])
				{	// gather plus sign
				*_Ptr++ = '+';
				++_First;
				}
			else if (*_First == _Atoms[_Numget_signoff])
				{	// gather minus sign
				*_Ptr++ = '-';
				++_First;
				}
			}

		*_Ptr++ = '0';
		*_Ptr++ = 'x';

		bool _Seendigit = false;	// seen a digit in input
		int _Significant = 0;	// number of significant digits
		int _Phex = 0;	// power of 10 multiplier

		if (_First != _Last && *_First == _Atoms[0])
			{
			if (++_First != _Last
				&& (*_First == _Atoms[_Numget_xoff + 1]
					|| *_First == _Atoms[_Numget_xoff]))
				{
				++_First;	// discard any 0x or 0X
				}
			else
				{
				_Seendigit = true;	// '0' not followed by 'x' or 'X'
				}
			}

		const int _Max_sig_dig = (*_Phexexp == 1000000000 ? 768 : 36);

		const char *_Pg = &_Grouping[0];
		if (*_Pg == 127 || *_Pg <= '\0')
			{
			for (; _First != _Last
				&& (_Idx = _Find_elem(_Atoms, *_First)) < _Numget_signoff;
					_Seendigit = true, (void)++_First)
				{
				if (_Max_sig_dig <= _Significant)
					{
					++_Phex;	// just scale by 10
					}
				else if (_Idx != 0 || _Significant != 0)
					{	// save a significant digit
					*_Ptr++ = _Src[_Idx];
					++_Significant;
					}
				}
			}
		else
			{	// grouping specified, gather digits and group sizes
			const _Elem _Kseparator = _Grouping.size() == 0
				? (_Elem)0 : _Punct_fac.thousands_sep();
			string _Groups((size_t)1, '\0');
			size_t _Group = 0;

			for (; _First != _Last; ++_First)
				{
				if ((_Idx = _Find_elem(_Atoms, *_First)) < _Numget_signoff)
					{	// got a digit, add to group size
					_Seendigit = true;
					if (_Max_sig_dig <= _Significant)
						{
						++_Phex;	// just scale by 10
						}
					else if (_Idx != 0 || _Significant != 0)
						{	// save a significant digit
						*_Ptr++ = _Src[_Idx];
						++_Significant;
						}

					if (_Groups[_Group] != 127)
						{
						++_Groups[_Group];
						}
					}
				else if (_Groups[_Group] == '\0'
					|| _Kseparator == (_Elem)0
					|| *_First != _Kseparator)
					{
					break;	// not a group separator, done
					}
				else
					{	// add a new group to _Groups string
					_Groups.push_back('\0');
					++_Group;
					}
				}

			if (_Group != 0)
				{
				if ('\0' < _Groups[_Group])
					{
					++_Group;	// add trailing group to group count
					}
				else
					{
					_Bad = true;	// trailing separator, fail
					}
				}

			while (!_Bad && 0 < _Group)
				{
				if (*_Pg == 127)
					{
					break;	// end of grouping constraints to check
					}

				if ((0 < --_Group && *_Pg != _Groups[_Group])
					|| (0 == _Group && *_Pg < _Groups[_Group]))
					{
					_Bad = true;	// bad group size, fail
					}
				else if ('\0' < _Pg[1])
					{
					++_Pg;	// group size okay, advance to next test
					}
				}
			}

		if (_Seendigit && _Significant == 0)
			*_Ptr++ = '0';	// save at least one leading digit

		if (_First != _Last && *_First == _Punct_fac.decimal_point())
			{	// add .
			*_Ptr++ = localeconv()->decimal_point[0];
			++_First;
			}

		if (_Significant == 0)
			{	// 0000. so far
			for (; _First != _Last && *_First == _Atoms[0];
				_Seendigit = true, (void)++_First)
				--_Phex;	// just count leading fraction zeros
			if (_Phex < 0)
				{	// put one back
				*_Ptr++ = '0';
				++_Phex;
				}
			}

		for (; _First != _Last
				&& (_Idx = _Find_elem(_Atoms, *_First)) < _Numget_signoff;
				_Seendigit = true, (void)++_First)
			if (_Significant < _Max_sig_dig)
				{	// save a significant fraction digit
				*_Ptr++ = _Src[_Idx];
				++_Significant;
				}

		if (_Seendigit && _First != _Last
			&& (*_First == _Atoms[_Numget_poff + 1]
				|| *_First == _Atoms[_Numget_poff]))
			{	// 'p' or 'P', collect exponent
			*_Ptr++ = 'p';
			++_First;
			_Seendigit = false;
			_Significant = 0;

			if (_First != _Last)
				{
				if (*_First == _Atoms[_Numget_signoff + 1])
					{	// gather plus sign
					*_Ptr++ = '+';
					++_First;
					}
				else if (*_First == _Atoms[_Numget_signoff])
					{	// gather minus sign
					*_Ptr++ = '-';
					++_First;
					}
				}

			for (; _First != _Last && *_First == _Atoms[0]; ++_First)
				{	// strip leading zeros
				_Seendigit = true;
				}

			if (_Seendigit)
				*_Ptr++ = '0';	// put one back
			for (; _First != _Last
				&& (_Idx = _Find_elem(_Atoms, *_First)) < _Numget_signoff;
				_Seendigit = true, (void)++_First)
				if (_Significant < 8)
					{	// save a significant exponent digit
					*_Ptr++ = _Src[_Idx];
					++_Significant;
					}
			}

		if (_Bad || !_Seendigit)
			_Ptr = _Ac;	// roll back pointer to indicate failure
		*_Ptr = '\0';
		*_Phexexp = _Phex;	// power of 16 multiplier
		return (0);	// power of 10 multiplier
		}



	};

		// STATIC num_get::id OBJECT





template<class _Elem,
	class _InIt>
	 locale::id num_get<_Elem, _InIt>::id;





		// CLASS TEMPLATE num_put
template<class _Elem,
	class _OutIt = ostreambuf_iterator<_Elem, char_traits<_Elem> > >
	class num_put
		: public locale::facet
	{	// facet for converting encoded numbers to text
public:
	static size_t __cdecl _Getcat(const locale::facet **_Ppf = nullptr,
		const locale *_Ploc = nullptr)
		{	// return locale category mask and construct standard facet
		if (_Ppf != nullptr && *_Ppf == nullptr)
			*_Ppf = new num_put<_Elem, _OutIt>(
				_Locinfo(_Ploc->c_str()));
		return (4);
		}

	 static locale::id id;	// unique facet id

protected:
	virtual  ~num_put() noexcept
		{	// destroy the object
		}

	void  _Init(const _Locinfo&)
		{	// initialize from _Locinfo object
		}

public:
	explicit  num_put(size_t _Refs = 0)
		: locale::facet(_Refs)
		{	// construct from current locale
		{ _Locinfo _Lobj;
			_Init(_Lobj);
		}
		}

	 num_put(const _Locinfo& _Lobj, size_t _Refs = 0)
		: locale::facet(_Refs)
		{	// construct from specified locale
		_Init(_Lobj);
		}

	typedef _Elem char_type;
	typedef _OutIt iter_type;

	_OutIt  put(_OutIt _Dest,
		ios_base& _Iosbase, _Elem _Fill, bool _Val) const
		{	// put formatted bool to _Dest
		return (do_put(_Dest, _Iosbase, _Fill, _Val));
		}

	_OutIt  put(_OutIt _Dest,
		ios_base& _Iosbase, _Elem _Fill, long _Val) const
		{	// put formatted long to _Dest
		return (do_put(_Dest, _Iosbase, _Fill, _Val));
		}

	_OutIt  put(_OutIt _Dest,
		ios_base& _Iosbase, _Elem _Fill, unsigned long _Val) const
		{	// put formatted unsigned long to _Dest
		return (do_put(_Dest, _Iosbase, _Fill, _Val));
		}

	_OutIt  put(_OutIt _Dest,
		ios_base& _Iosbase, _Elem _Fill, long long _Val) const
		{	// put formatted long long to _Dest
		return (do_put(_Dest, _Iosbase, _Fill, _Val));
		}

	_OutIt  put(_OutIt _Dest,
		ios_base& _Iosbase, _Elem _Fill, unsigned long long _Val) const
		{	// put formatted unsigned long long to _Dest
		return (do_put(_Dest, _Iosbase, _Fill, _Val));
		}

	_OutIt  put(_OutIt _Dest,
		ios_base& _Iosbase, _Elem _Fill, double _Val) const
		{	// put formatted double to _Dest
		return (do_put(_Dest, _Iosbase, _Fill, _Val));
		}

	_OutIt  put(_OutIt _Dest,
		ios_base& _Iosbase, _Elem _Fill, long double _Val) const
		{	// put formatted long double to _Dest
		return (do_put(_Dest, _Iosbase, _Fill, _Val));
		}

	_OutIt  put(_OutIt _Dest,
		ios_base& _Iosbase, _Elem _Fill, const void *_Val) const
		{	// put formatted void pointer to _Dest
		return (do_put(_Dest, _Iosbase, _Fill, _Val));
		}

protected:
	virtual _OutIt  do_put(_OutIt _Dest,
		ios_base& _Iosbase, _Elem _Fill, bool _Val) const
		{	// put formatted bool to _Dest
		if (!(_Iosbase.flags() & ios_base::boolalpha))
			return (do_put(_Dest, _Iosbase, _Fill, (long)_Val));
		else
			{	// put "false" or "true"
			const auto& _Punct_fac = ::std:: use_facet<numpunct<_Elem>>(_Iosbase.getloc());
			basic_string<_Elem> _Str;
			if (_Val)
				_Str.assign(_Punct_fac.truename());
			else
				_Str.assign(_Punct_fac.falsename());

			size_t _Fillcount = _Iosbase.width() <= 0
				|| (size_t)_Iosbase.width() <= _Str.size()
					? 0 : (size_t)_Iosbase.width() - _Str.size();

			if ((_Iosbase.flags() & ios_base::adjustfield) != ios_base::left)
				{	// put leading fill
				_Dest = _Rep(_Dest, _Fill, _Fillcount);
				_Fillcount = 0;
				}
			_Dest = _Put(_Dest, _Str.c_str(), _Str.size());	// put field
			_Iosbase.width(0);
			return (_Rep(_Dest, _Fill, _Fillcount));	// put trailing fill
			}
		}

	virtual _OutIt  do_put(_OutIt _Dest,
		ios_base& _Iosbase, _Elem _Fill, long _Val) const
		{	// put formatted long to _Dest
		char _Buf[2 * 32], _Fmt[6];

		return (_Iput(_Dest, _Iosbase, _Fill, _Buf,
			static_cast<size_t>(:: sprintf_s(_Buf, sizeof (_Buf), _Ifmt(_Fmt, "ld",
				_Iosbase.flags()), _Val))));
		}

	virtual _OutIt  do_put(_OutIt _Dest,
		ios_base& _Iosbase, _Elem _Fill, unsigned long _Val) const
		{	// put formatted unsigned long to _Dest
		char _Buf[2 * 32], _Fmt[6];

		return (_Iput(_Dest, _Iosbase, _Fill, _Buf,
			static_cast<size_t>(:: sprintf_s(_Buf, sizeof (_Buf), _Ifmt(_Fmt, "lu",
				_Iosbase.flags()), _Val))));
		}

	virtual _OutIt  do_put(_OutIt _Dest,
		ios_base& _Iosbase, _Elem _Fill, long long _Val) const
		{	// put formatted long long to _Dest
		char _Buf[2 * 32], _Fmt[8];

		return (_Iput(_Dest, _Iosbase, _Fill, _Buf,
			static_cast<size_t>(:: sprintf_s(_Buf, sizeof (_Buf), _Ifmt(_Fmt, "Ld",
				_Iosbase.flags()), _Val))));
		}

	virtual _OutIt  do_put(_OutIt _Dest,
		ios_base& _Iosbase, _Elem _Fill, unsigned long long _Val) const
		{	// put formatted unsigned long long to _Dest
		char _Buf[2 * 32], _Fmt[8];

		return (_Iput(_Dest, _Iosbase, _Fill, _Buf,
			static_cast<size_t>(:: sprintf_s(_Buf, sizeof (_Buf), _Ifmt(_Fmt, "Lu",
				_Iosbase.flags()), _Val))));
		}

	virtual _OutIt  do_put(_OutIt _Dest,
		ios_base& _Iosbase, _Elem _Fill, double _Val) const
		{	// put formatted double to _Dest
		string _Buf;
		char _Fmt[8];
		bool _Isfixed = (_Iosbase.flags() & ios_base::floatfield)
			== ios_base::fixed;
		streamsize _Precision = _Iosbase.precision() <= 0 && !_Isfixed
			? 6 : _Iosbase.precision();	// desired precision
		size_t _Bufsize = (size_t)_Precision;
		if (_Isfixed && 1e10 < :: fabs(_Val))
			{	// f or F format
			int _Ptwo;
			(void):: frexp(_Val, &_Ptwo);
			_Bufsize += :: abs(_Ptwo) * 30103L / 100000L;
			}

		_Buf.resize(_Bufsize + 50);	// add fudge factor
		const auto _Ngen = static_cast<size_t>(:: sprintf_s((char *)_Buf.c_str(), _Buf.size(),
			_Ffmt(_Fmt, 0, _Iosbase.flags()), (int)_Precision, _Val));

		return (_Fput(_Dest, _Iosbase, _Fill, _Buf.c_str(), _Ngen));
		}

	virtual _OutIt  do_put(_OutIt _Dest,
		ios_base& _Iosbase, _Elem _Fill, long double _Val) const
		{	// put formatted long double to _Dest
		string _Buf;
		char _Fmt[8];
		bool _Isfixed = (_Iosbase.flags() & ios_base::floatfield)
			== ios_base::fixed;
		streamsize _Precision = _Iosbase.precision() <= 0 && !_Isfixed
			? 6 : _Iosbase.precision();	// desired precision
		size_t _Bufsize = (size_t)_Precision;
		if (_Isfixed && 1e10 < :: fabsl(_Val))
			{	// f or F format
			int _Ptwo;
			(void):: frexpl(_Val, &_Ptwo);
			_Bufsize += :: abs(_Ptwo) * 30103L / 100000L;
			}

		_Buf.resize(_Bufsize + 50);	// add fudge factor
		const auto _Ngen = static_cast<size_t>(:: sprintf_s((char *)_Buf.c_str(), _Buf.size(),
			_Ffmt(_Fmt, 'L', _Iosbase.flags()), (int)_Precision, _Val));

		return (_Fput(_Dest, _Iosbase, _Fill, _Buf.c_str(), _Ngen));
		}

	virtual _OutIt  do_put(_OutIt _Dest,
		ios_base& _Iosbase, _Elem _Fill, const void *_Val) const
		{	// put formatted void pointer to _Dest
		char _Buf[2 * 32];

		return (_Iput(_Dest, _Iosbase, _Fill, _Buf,
			static_cast<size_t>(:: sprintf_s(_Buf, sizeof (_Buf), "%p", _Val))));
		}

private:
	char *__cdecl _Ffmt(char *_Fmt,
		char _Spec, ios_base::fmtflags _Flags) const
		{	// generate sprintf format for floating-point
		char *_Ptr = _Fmt;
		*_Ptr++ = '%';

		if (_Flags & ios_base::showpos)
			*_Ptr++ = '+';
		if (_Flags & ios_base::showpoint)
			*_Ptr++ = '#';
		*_Ptr++ = '.';
		*_Ptr++ = '*';	// for precision argument
		if (_Spec != '\0')
			*_Ptr++ = _Spec;	// 'L' qualifier for long double only

		ios_base::fmtflags _Ffl = _Flags & ios_base::floatfield;
		if (_Flags & ios_base::uppercase)
			*_Ptr++ = _Ffl == ios_base::fixed ? 'f'
				: _Ffl == ios_base::hexfloat ? 'A'	// added with TR1
				: _Ffl == ios_base::scientific ? 'E' : 'G';	// specifier
		else
			*_Ptr++ = _Ffl == ios_base::fixed ? 'f'
				: _Ffl == ios_base::hexfloat ? 'a'	// added with TR1
				: _Ffl == ios_base::scientific ? 'e' : 'g';	// specifier

		*_Ptr = '\0';
		return (_Fmt);
		}

	_OutIt __cdecl _Fput(_OutIt _Dest,
		ios_base& _Iosbase, _Elem _Fill, const char *_Buf,
			size_t _Count) const
		{	// put formatted floating-point to _Dest
		auto _Prefix = static_cast<size_t>(0 < _Count && (*_Buf == '+' || *_Buf == '-'));
		const char *_Exps;
		if ((_Iosbase.flags() & ios_base::floatfield) != ios_base::hexfloat)
			_Exps = "eE";
		else
			{	// correct for hexadecimal floating-point
			_Exps = "pP";
			if (_Prefix + 2 <= _Count && _Buf[_Prefix] == '0'
				&& (_Buf[_Prefix + 1] == 'x' || _Buf[_Prefix + 1] == 'X'))
				_Prefix += 2;
			}
		const size_t _Eoff =
			:: strcspn(&_Buf[0], _Exps);	// find exponent
		char _Dp[2] = {"."};
		_Dp[0] = :: localeconv()->decimal_point[0];
		const size_t _Poff =
			:: strcspn(&_Buf[0], &_Dp[0]);	// find decimal point

		const ctype<_Elem>& _Ctype_fac = ::std:: use_facet<ctype<_Elem>>(_Iosbase.getloc());
		basic_string<_Elem> _Groupstring(_Count, _Elem(0));	// reserve space
		_Ctype_fac.widen(&_Buf[0], &_Buf[_Count], &_Groupstring[0]);

		const auto& _Punct_fac = ::std:: use_facet<numpunct<_Elem>>(_Iosbase.getloc());
		const string _Grouping = _Punct_fac.grouping();
		const _Elem _Kseparator = _Punct_fac.thousands_sep();

		if (_Poff != _Count)
			_Groupstring[_Poff] = _Punct_fac.decimal_point();

		size_t _Off = _Poff == _Count ? _Eoff : _Poff;
		const char *_Pg = &_Grouping[0];
		while (*_Pg != 127 && '\0' < *_Pg
			&& (size_t)*_Pg < _Off - _Prefix)
			{	// add thousands separator
			_Groupstring.insert(_Off -= *_Pg, (size_t)1, _Kseparator);
			if ('\0' < _Pg[1])
				++_Pg;	// not last group, advance
			}

		_Count = _Groupstring.size();
		size_t _Fillcount = _Iosbase.width() <= 0
			|| (size_t)_Iosbase.width() <= _Count
				? 0 : (size_t)_Iosbase.width() - _Count;

		ios_base::fmtflags _Adjustfield =
			_Iosbase.flags() & ios_base::adjustfield;
		if (_Adjustfield != ios_base::left
			&& _Adjustfield != ios_base::internal)
			{	// put leading fill
			_Dest = _Rep(_Dest, _Fill, _Fillcount);
			_Fillcount = 0;
			_Dest = _Put(_Dest, &_Groupstring[0], _Prefix);
			}
		else if (_Adjustfield == ios_base::internal)
			{	// put internal fill
			_Dest = _Put(_Dest, &_Groupstring[0], _Prefix);
			_Dest = _Rep(_Dest, _Fill, _Fillcount);
			_Fillcount = 0;
			}
		else
			_Dest = _Put(_Dest, &_Groupstring[0], _Prefix);

		_Dest = _Put(_Dest, &_Groupstring[_Prefix], _Count - _Prefix);
		_Iosbase.width(0);
		return (_Rep(_Dest, _Fill, _Fillcount));	// put trailing fill
		}

	char *__cdecl _Ifmt(char *_Fmt,
		const char *_Spec, ios_base::fmtflags _Flags) const
		{	// generate sprintf format for integer
		char *_Ptr = _Fmt;
		*_Ptr++ = '%';

		if (_Flags & ios_base::showpos)
			*_Ptr++ = '+';
		if (_Flags & ios_base::showbase)
			*_Ptr++ = '#';
		if (_Spec[0] != 'L')
			*_Ptr++ = _Spec[0];	// qualifier
		else

			{	/* change L to I64 */
			*_Ptr++ = 'I';
			*_Ptr++ = '6';
			*_Ptr++ = '4';
			}

		ios_base::fmtflags _Basefield = _Flags & ios_base::basefield;
		*_Ptr++ = _Basefield == ios_base::oct ? 'o'
			: _Basefield != ios_base::hex ? _Spec[1]	// 'd' or 'u'
			: _Flags & ios_base::uppercase ? 'X' : 'x';
		*_Ptr = '\0';
		return (_Fmt);
		}

	_OutIt __cdecl _Iput(_OutIt _Dest,
		ios_base& _Iosbase, _Elem _Fill, char *_Buf, size_t _Count) const
		{	// put formatted integer to _Dest
		auto _Prefix = static_cast<size_t>(0 < _Count && (*_Buf == '+' || *_Buf == '-'));
		if ((_Iosbase.flags() & ios_base::basefield) == ios_base::hex
			&& _Prefix + 2 <= _Count && _Buf[_Prefix] == '0'
			&& (_Buf[_Prefix + 1] == 'x' || _Buf[_Prefix + 1] == 'X'))
			{
			_Prefix += 2;
			}

		const ctype<_Elem>& _Ctype_fac = ::std:: use_facet<ctype<_Elem>>(_Iosbase.getloc());
		basic_string<_Elem> _Groupstring(_Count, _Elem(0));	// reserve space
		_Ctype_fac.widen(&_Buf[0], &_Buf[_Count], &_Groupstring[0]);

		const auto& _Punct_fac = ::std:: use_facet<numpunct<_Elem>>(_Iosbase.getloc());
		const string _Grouping = _Punct_fac.grouping();
		const char *_Pg = &_Grouping[0];
		if (*_Pg != 127 && '\0' < *_Pg)
			{	// grouping specified, add thousands separators
			const _Elem _Kseparator = _Punct_fac.thousands_sep();
			while (*_Pg != 127 && '\0' < *_Pg
				&& (size_t)*_Pg < _Count - _Prefix)
				{	// insert thousands separator
				_Count -= *_Pg;
				_Groupstring.insert(_Count, 1, _Kseparator);
				if ('\0' < _Pg[1])
					++_Pg;	// not last group, advance
				}
			}

		_Count = _Groupstring.size();
		size_t _Fillcount = _Iosbase.width() <= 0
			|| (size_t)_Iosbase.width() <= _Count
				? 0 : (size_t)_Iosbase.width() - _Count;

		ios_base::fmtflags _Adjustfield =
			_Iosbase.flags() & ios_base::adjustfield;
		if (_Adjustfield != ios_base::left
			&& _Adjustfield != ios_base::internal)
			{	// put leading fill
			_Dest = _Rep(_Dest, _Fill, _Fillcount);
			_Fillcount = 0;
			_Dest = _Put(_Dest, &_Groupstring[0], _Prefix);
			}
		else if (_Adjustfield == ios_base::internal)
			{	// put internal fill
			_Dest = _Put(_Dest, &_Groupstring[0], _Prefix);
			_Dest = _Rep(_Dest, _Fill, _Fillcount);
			_Fillcount = 0;
			}
		else
			_Dest = _Put(_Dest, &_Groupstring[0], _Prefix);

		_Dest = _Put(_Dest, &_Groupstring[_Prefix], _Count - _Prefix);
		_Iosbase.width(0);
		return (_Rep(_Dest, _Fill, _Fillcount));	// put trailing fill
		}

	_OutIt __cdecl _Put(_OutIt _Dest,
		const _Elem *_Ptr, size_t _Count) const
		{	// put [_Ptr, _Ptr + _Count) to _Dest
		for (; 0 < _Count; --_Count, (void)++_Dest, ++_Ptr)
			*_Dest = *_Ptr;
		return (_Dest);
		}

	_OutIt __cdecl _Rep(_OutIt _Dest,
		_Elem _Ch, size_t _Count) const
		{	// put _Count * _Ch to _Dest
		for (; 0 < _Count; --_Count, (void)++_Dest)
			*_Dest = _Ch;
		return (_Dest);
		}
	};

		// STATIC num_put::id OBJECT





template<class _Elem,
	class _OutIt>
	 locale::id num_put<_Elem, _OutIt>::id;

 

  
template  locale::id numpunct<char>::id;
template class __declspec(dllimport) num_get<char,
	istreambuf_iterator<char, char_traits<char> > >;
template class __declspec(dllimport) num_put<char,
	ostreambuf_iterator<char, char_traits<char> > >;

template  locale::id numpunct<wchar_t>::id;
template class __declspec(dllimport) num_get<wchar_t,
	istreambuf_iterator<wchar_t, char_traits<wchar_t> > >;
template class __declspec(dllimport) num_put<wchar_t,
	ostreambuf_iterator<wchar_t, char_traits<wchar_t> > >;
  

  






 




}
 
 
 #pragma warning(pop)
 #pragma pack(pop)



/*
 * Copyright (c) by P.J. Plauger. All rights reserved.
 * Consult your license regarding permissions and restrictions.
V6.50:0009 */


 #pragma pack(push,8)
 #pragma warning(push,3)
 #pragma warning(disable: 4455 4494  4619 4643 4702 4984 4988 )
 
 
 

namespace std {
		// CLASS TEMPLATE basic_ios
template<class _Elem,
	class _Traits>
	class basic_ios
		: public ios_base
	{	// base class for basic_istream/basic_ostream
public:
	typedef basic_ostream<_Elem, _Traits> _Myos;
	typedef basic_streambuf<_Elem, _Traits> _Mysb;
	typedef ctype<_Elem> _Ctype;
	typedef _Elem char_type;
	typedef _Traits traits_type;
	typedef typename _Traits::int_type int_type;
	typedef typename _Traits::pos_type pos_type;
	typedef typename _Traits::off_type off_type;

	explicit  basic_ios(_Mysb *_Strbuf)
		{	// construct from stream buffer pointer
		init(_Strbuf);
		}

	virtual  ~basic_ios() noexcept
		{	// destroy the object
		}

	void  clear(iostate _State = goodbit, bool _Reraise = false)
		{	// set state, possibly reraise exception
		ios_base::clear(_Mystrbuf == nullptr ? (_State | ios_base::badbit) : _State, _Reraise);
		}

 
	void  clear(io_state _State)
		{	// set state to _State
		clear((iostate)_State);
		}
 

	void  setstate(iostate _State, bool _Reraise = false)
		{	// merge _State into state, possibly reraise exception
		clear(rdstate() | _State, _Reraise);
		}

 
	void  setstate(io_state _State)
		{	// merge _State into state
		setstate((iostate)_State);
		}
 

	basic_ios&  copyfmt(const basic_ios& _Right)
		{	// copy format parameters
		_Tiestr = _Right.tie();
		_Fillch = _Right.fill();
		ios_base::copyfmt(_Right);
		return (*this);
		}

	_Myos * tie() const
		{	// return tie pointer
		return (_Tiestr);
		}

	_Myos * tie(_Myos *_Newtie)
		{	// set tie pointer
		_Myos *_Oldtie = _Tiestr;
		_Tiestr = _Newtie;
		return (_Oldtie);
		}

	 _Mysb * rdbuf() const
		{	// return stream buffer pointer
		return (_Mystrbuf);
		}

	_Mysb * rdbuf(_Mysb *_Strbuf)
		{	// set stream buffer pointer
		_Mysb *_Oldstrbuf = _Mystrbuf;
		_Mystrbuf = _Strbuf;
		clear();
		return (_Oldstrbuf);
		}

	locale  imbue(const locale& _Loc)
		{	// set locale to argument
		locale _Oldlocale = ios_base::imbue(_Loc);
		if (rdbuf() != nullptr)
			rdbuf()->pubimbue(_Loc);
		return (_Oldlocale);
		}

	_Elem  fill() const
		{	// return fill character
		return (_Fillch);
		}

	_Elem  fill(_Elem _Newfill)
		{	// set fill character
		_Elem _Oldfill = _Fillch;
		_Fillch = _Newfill;
		return (_Oldfill);
		}

	char  narrow(_Elem _Ch, char _Dflt = '\0') const
		{	// convert _Ch to byte using imbued locale
		return (::std:: use_facet<_Ctype>(getloc()).narrow(_Ch, _Dflt));
		}

	_Elem  widen(char _Byte) const
		{	// convert _Byte to character using imbued locale
		return (::std:: use_facet<_Ctype>(getloc()).widen(_Byte));
		}

	void  move(basic_ios& _Right)
		{	// assign by moving _Right
		if (this != ::std:: addressof(_Right))
			{	// different, do the move
			_Mystrbuf = nullptr;
			_Tiestr = nullptr;
			this->swap(_Right);
			}
		}

	void  move(basic_ios&& _Right)
		{	// assign by moving _Right
		if (this != ::std:: addressof(_Right))
			{	// different, do the move
			_Mystrbuf = nullptr;
			_Tiestr = nullptr;
			this->swap(_Right);
			}
		}

	void  swap(basic_ios& _Right) noexcept
		{	// swap all but rdbuf() with right
		ios_base::swap(_Right);
		::std:: swap(_Fillch, _Right._Fillch);
		::std:: swap(_Tiestr, _Right._Tiestr);
		}

	void  set_rdbuf(_Mysb *_Strbuf)
		{	// set stream buffer pointer without changing state
		_Mystrbuf = _Strbuf;
		}

protected:
	void  init(_Mysb *_Strbuf = nullptr,
		bool _Isstd = false)
		{	// initialize with stream buffer pointer
		_Init();	// initialize ios_base
		_Mystrbuf = _Strbuf;
		_Tiestr = nullptr;
		_Fillch = widen(' ');

		if (_Mystrbuf == nullptr)
			setstate(badbit);

		if (_Isstd)
			_Addstd(this);	// special handling for standard streams
		}

	 basic_ios()
		{	// default constructor, do nothing
		}

private:
	_Mysb *_Mystrbuf;	// pointer to stream buffer
	_Myos *_Tiestr;	// pointer to tied output stream
	_Elem _Fillch;	// the fill character

public:
	 basic_ios(const basic_ios&) = delete;
	basic_ios&  operator=(const basic_ios&) = delete;
	};

 

  
template class __declspec(dllimport) basic_ios<char,
	char_traits<char> >;
template class __declspec(dllimport) basic_ios<wchar_t,
	char_traits<wchar_t> >;
  

  



 

		// MANIPULATORS
inline ios_base& __cdecl boolalpha(ios_base& _Iosbase)
	{	// set boolalpha
	_Iosbase.setf(ios_base::boolalpha);
	return (_Iosbase);
	}

inline ios_base& __cdecl dec(ios_base& _Iosbase)
	{	// set basefield to dec
	_Iosbase.setf(ios_base::dec, ios_base::basefield);
	return (_Iosbase);
	}

inline ios_base& __cdecl defaultfloat(ios_base& _Iosbase)
	{	// clear floatfield
	_Iosbase.unsetf(ios_base::floatfield);
	return (_Iosbase);
	}

inline ios_base& __cdecl fixed(ios_base& _Iosbase)
	{	// set floatfield to fixed
	_Iosbase.setf(ios_base::fixed, ios_base::floatfield);
	return (_Iosbase);
	}

inline ios_base& __cdecl hex(ios_base& _Iosbase)
	{	// set basefield to hex
	_Iosbase.setf(ios_base::hex, ios_base::basefield);
	return (_Iosbase);
	}

inline ios_base& __cdecl hexfloat(ios_base& _Iosbase)
	{	// set floatfield to hexfloat
	_Iosbase.setf(ios_base::hexfloat, ios_base::floatfield);
	return (_Iosbase);
	}

inline ios_base& __cdecl internal(ios_base& _Iosbase)
	{	// set adjustfield to internal
	_Iosbase.setf(ios_base::internal, ios_base::adjustfield);
	return (_Iosbase);
	}

inline ios_base& __cdecl left(ios_base& _Iosbase)
	{	// set adjustfield to left
	_Iosbase.setf(ios_base::left, ios_base::adjustfield);
	return (_Iosbase);
	}

inline ios_base& __cdecl noboolalpha(ios_base& _Iosbase)
	{	// clear boolalpha
	_Iosbase.unsetf(ios_base::boolalpha);
	return (_Iosbase);
	}

inline ios_base& __cdecl noshowbase(ios_base& _Iosbase)
	{	// clear showbase
	_Iosbase.unsetf(ios_base::showbase);
	return (_Iosbase);
	}

inline ios_base& __cdecl noshowpoint(ios_base& _Iosbase)
	{	// clear showpoint
	_Iosbase.unsetf(ios_base::showpoint);
	return (_Iosbase);
	}

inline ios_base& __cdecl noshowpos(ios_base& _Iosbase)
	{	// clear showpos
	_Iosbase.unsetf(ios_base::showpos);
	return (_Iosbase);
	}

inline ios_base& __cdecl noskipws(ios_base& _Iosbase)
	{	// clear skipws
	_Iosbase.unsetf(ios_base::skipws);
	return (_Iosbase);
	}

inline ios_base& __cdecl nounitbuf(ios_base& _Iosbase)
	{	// clear unitbuf
	_Iosbase.unsetf(ios_base::unitbuf);
	return (_Iosbase);
	}

inline ios_base& __cdecl nouppercase(ios_base& _Iosbase)
	{	// clear uppercase
	_Iosbase.unsetf(ios_base::uppercase);
	return (_Iosbase);
	}

inline ios_base& __cdecl oct(ios_base& _Iosbase)
	{	// set oct in basefield
	_Iosbase.setf(ios_base::oct, ios_base::basefield);
	return (_Iosbase);
	}

inline ios_base& __cdecl right(ios_base& _Iosbase)
	{	// set right in adjustfield
	_Iosbase.setf(ios_base::right, ios_base::adjustfield);
	return (_Iosbase);
	}

inline ios_base& __cdecl scientific(ios_base& _Iosbase)
	{	// set scientific in floatfield
	_Iosbase.setf(ios_base::scientific, ios_base::floatfield);
	return (_Iosbase);
	}

inline ios_base& __cdecl showbase(ios_base& _Iosbase)
	{	// set showbase
	_Iosbase.setf(ios_base::showbase);
	return (_Iosbase);
	}

inline ios_base& __cdecl showpoint(ios_base& _Iosbase)
	{	// set showpoint
	_Iosbase.setf(ios_base::showpoint);
	return (_Iosbase);
	}

inline ios_base& __cdecl showpos(ios_base& _Iosbase)
	{	// set showpos
	_Iosbase.setf(ios_base::showpos);
	return (_Iosbase);
	}

inline ios_base& __cdecl skipws(ios_base& _Iosbase)
	{	// set skipws
	_Iosbase.setf(ios_base::skipws);
	return (_Iosbase);
	}

inline ios_base& __cdecl unitbuf(ios_base& _Iosbase)
	{	// set unitbuf
	_Iosbase.setf(ios_base::unitbuf);
	return (_Iosbase);
	}

inline ios_base& __cdecl uppercase(ios_base& _Iosbase)
	{	// set uppercase
	_Iosbase.setf(ios_base::uppercase);
	return (_Iosbase);
	}


namespace [[deprecated("warning STL4002: " "The non-Standard std::tr1 namespace and TR1-only machinery are deprecated and will be REMOVED. You can " "define _SILENCE_TR1_NAMESPACE_DEPRECATION_WARNING to acknowledge that you have received this warning.")]] tr1 {
using ::std:: hexfloat;
}


}

 
 
 #pragma warning(pop)
 #pragma pack(pop)



/*
 * Copyright (c) by P.J. Plauger. All rights reserved.
 * Consult your license regarding permissions and restrictions.
V6.50:0009 */


 #pragma pack(push,8)
 #pragma warning(push,3)
 #pragma warning(disable: 4455 4494  4619 4643 4702 4984 4988 )
 
 
 

namespace std {
		// I/O EXCEPTION MACROS

 
 

 



 



 





 #pragma vtordisp(push, 2)	

		// CLASS TEMPLATE basic_ostream
template<class _Elem,
	class _Traits>
	class basic_ostream
		: virtual public basic_ios<_Elem, _Traits>
	{	// control insertions into a stream buffer
public:
	typedef basic_ios<_Elem, _Traits> _Myios;
	typedef basic_streambuf<_Elem, _Traits> _Mysb;
	typedef ostreambuf_iterator<_Elem, _Traits> _Iter;
	typedef num_put<_Elem, _Iter> _Nput;

	explicit  basic_ostream(
		basic_streambuf<_Elem, _Traits> *_Strbuf,

		bool _Isstd = false)
		{	// construct from a stream buffer pointer
		_Myios::init(_Strbuf, _Isstd);
		}

	 basic_ostream(_Uninitialized, bool _Addit = true)
		{	// construct uninitialized
		if (_Addit)
			this->_Addstd(this);	// suppress for basic_iostream
		}

protected:
	 basic_ostream(basic_ostream&& _Right)
		{	// construct by moving _Right
		_Myios::init();
		_Myios::move(::std:: move(_Right));
		}

	basic_ostream&  operator=(basic_ostream&& _Right)
		{	// move from _Right
		this->swap(_Right);
		return (*this);
		}

	void  swap(basic_ostream& _Right)
		{	// swap with _Right
		if (this != ::std:: addressof(_Right))
			_Myios::swap(_Right);
		}

public:
	 basic_ostream(const basic_ostream&) = delete;
	basic_ostream&  operator=(const basic_ostream&) = delete;

	virtual  ~basic_ostream() noexcept
		{	// destroy the object
		}

	typedef typename _Traits::int_type int_type;
	typedef typename _Traits::pos_type pos_type;
	typedef typename _Traits::off_type off_type;

	class _Sentry_base
		{	// stores thread lock and reference to output stream
	public:
		 _Sentry_base(basic_ostream& _Ostr)
			: _Myostr(_Ostr)
			{	// lock the stream buffer, if there
			if (_Myostr.rdbuf() != nullptr)
				_Myostr.rdbuf()->_Lock();
			}

		 ~_Sentry_base() noexcept
			{	// destroy after unlocking
			if (_Myostr.rdbuf() != nullptr)
				_Myostr.rdbuf()->_Unlock();
			}

		basic_ostream& _Myostr;	// the output stream, for _Unlock call at destruction

		_Sentry_base& operator=(const _Sentry_base&) = delete;
		};

	class sentry
		: public _Sentry_base
		{	// stores thread lock and state of stream
	public:
		explicit  sentry(basic_ostream& _Ostr)
			: _Sentry_base(_Ostr)
			{	// construct locking and testing stream
			if (_Ostr.good() && _Ostr.tie() != nullptr && _Ostr.tie() != &_Ostr)
				_Ostr.tie()->flush();
			_Ok = _Ostr.good();	// store test only after flushing tie
			}

 



  #pragma warning(push)
  #pragma warning(disable: 4996)	
 
		 ~sentry() noexcept
			{	// destroy the object
 
			if (!::std:: uncaught_exception())	// TRANSITION, OS#15518458
				{
				this->_Myostr._Osfx();
				}
 


			}
 


  #pragma warning(pop)
 

		explicit  operator bool() const
			{	// test if stream state okay
			return (_Ok);
			}

		 sentry(const sentry&) = delete;
		sentry&  operator=(const sentry&) = delete;

	private:
		bool _Ok;	// true if stream state okay at construction
		};

	bool  opfx()
		{	// test stream state and flush tie stream as needed (retained)
		if (this->good() && _Myios::tie() != nullptr && _Myios::tie() != this)
			_Myios::tie()->flush();
		return (this->good());
		}

	void  osfx()
		{	// perform any wrapup (retained)
		_Osfx();
		}

	void  _Osfx()
		{	// perform any wrapup
		try {
		if (this->good() && this->flags() & ios_base::unitbuf)
			if (_Myios::rdbuf()->pubsync() == -1)	// flush stream as needed
				_Myios::setstate(ios_base::badbit);
		} catch (...) {
		}
		}

  


















	basic_ostream&  operator<<(basic_ostream& (__cdecl *_Pfn)(basic_ostream&))
		{	// call basic_ostream manipulator
		return ((*_Pfn)(*this));
		}

	basic_ostream&  operator<<(_Myios& (__cdecl *_Pfn)(_Myios&))
		{	// call basic_ios manipulator
		(*_Pfn)(*(_Myios *)this);
		return (*this);
		}

	basic_ostream&  operator<<(ios_base& (__cdecl *_Pfn)(ios_base&))
		{	// call ios_base manipulator
		(*_Pfn)(*(ios_base *)this);
		return (*this);
		}

	basic_ostream&  operator<<(bool _Val)
		{	// insert a boolean
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);

		if (_Ok)
			{	// state okay, use facet to insert
			const _Nput& _Nput_fac = ::std:: use_facet<_Nput>(this->getloc());

			try {
			if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this,
				_Myios::fill(), _Val).failed())
				_State |= ios_base::badbit;
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (*this);
		}

	basic_ostream&  operator<<(short _Val)
		{	// insert a short
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);

		if (_Ok)
			{	// state okay, use facet to insert
			const _Nput& _Nput_fac = ::std:: use_facet<_Nput>(this->getloc());
			ios_base::fmtflags _Bfl =
				this->flags() & ios_base::basefield;
			long _Tmp = (_Bfl == ios_base::oct
				|| _Bfl == ios_base::hex)
				? (long)(unsigned short)_Val : (long)_Val;

			try {
			if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this,
				_Myios::fill(), _Tmp).failed())
				_State |= ios_base::badbit;
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (*this);
		}

/* NOTE:
	If you are not using native wchar_t, the unsigned short inserter
	is masked by an explicit specialization that treats an unsigned
	short as a wide character.

	To read or write unsigned shorts as integers with wchar_t streams,
	make wchar_t a native type with the command line option /Zc:wchar_t.
 */

	basic_ostream&  operator<<(unsigned short _Val)
		{	// insert an unsigned short
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);

		if (_Ok)
			{	// state okay, use facet to insert
			const _Nput& _Nput_fac = ::std:: use_facet<_Nput>(this->getloc());

			try {
			if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this,
				_Myios::fill(), (unsigned long)_Val).failed())
				_State |= ios_base::badbit;
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (*this);
		}

	basic_ostream&  operator<<(int _Val)
		{	// insert an int
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);

		if (_Ok)
			{	// state okay, use facet to insert
			const _Nput& _Nput_fac = ::std:: use_facet<_Nput>(this->getloc());
			ios_base::fmtflags _Bfl =
				this->flags() & ios_base::basefield;
			long _Tmp = (_Bfl == ios_base::oct
				|| _Bfl == ios_base::hex)
				? (long)(unsigned int)_Val : (long)_Val;

			try {
			if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this,
				_Myios::fill(), _Tmp).failed())
				_State |= ios_base::badbit;
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (*this);
		}

	basic_ostream&  operator<<(unsigned int _Val)
		{	// insert an unsigned int
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);

		if (_Ok)
			{	// state okay, use facet to insert
			const _Nput& _Nput_fac = ::std:: use_facet<_Nput>(this->getloc());

			try {
			if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this,
				_Myios::fill(), (unsigned long)_Val).failed())
				_State |= ios_base::badbit;
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (*this);
		}

	basic_ostream&  operator<<(long _Val)
		{	// insert a long
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);

		if (_Ok)
			{	// state okay, use facet to insert
			const _Nput& _Nput_fac = ::std:: use_facet<_Nput>(this->getloc());

			try {
			if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this,
				_Myios::fill(), _Val).failed())
				_State |= ios_base::badbit;
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (*this);
		}

	basic_ostream&  operator<<(unsigned long _Val)
		{	// insert an unsigned long
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);

		if (_Ok)
			{	// state okay, use facet to insert
			const _Nput& _Nput_fac = ::std:: use_facet<_Nput>(this->getloc());

			try {
			if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this,
				_Myios::fill(), _Val).failed())
				_State |= ios_base::badbit;
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (*this);
		}

	basic_ostream&  operator<<(long long _Val)
		{	// insert a long long
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);

		if (_Ok)
			{	// state okay, use facet to insert
			const _Nput& _Nput_fac = ::std:: use_facet<_Nput>(this->getloc());

			try {
			if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this,
				_Myios::fill(), _Val).failed())
				_State |= ios_base::badbit;
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (*this);
		}

	basic_ostream&  operator<<(unsigned long long _Val)
		{	// insert an unsigned long long
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);

		if (_Ok)
			{	// state okay, use facet to insert
			const _Nput& _Nput_fac = ::std:: use_facet<_Nput>(this->getloc());

			try {
			if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this,
				_Myios::fill(), _Val).failed())
				_State |= ios_base::badbit;
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (*this);
		}

	basic_ostream&  operator<<(float _Val)
		{	// insert a float
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);

		if (_Ok)
			{	// state okay, use facet to insert
			const _Nput& _Nput_fac = ::std:: use_facet<_Nput>(this->getloc());

			try {
			if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this,
				_Myios::fill(), (double)_Val).failed())
				_State |= ios_base::badbit;
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (*this);
		}

	basic_ostream&  operator<<(double _Val)
		{	// insert a double
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);

		if (_Ok)
			{	// state okay, use facet to insert
			const _Nput& _Nput_fac = ::std:: use_facet<_Nput>(this->getloc());

			try {
			if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this,
				_Myios::fill(), _Val).failed())
				_State |= ios_base::badbit;
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (*this);
		}

	basic_ostream&  operator<<(long double _Val)
		{	// insert a long double
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);

		if (_Ok)
			{	// state okay, use facet to insert
			const _Nput& _Nput_fac = ::std:: use_facet<_Nput>(this->getloc());

			try {
			if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this,
				_Myios::fill(), _Val).failed())
				_State |= ios_base::badbit;
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (*this);
		}

	basic_ostream&  operator<<(const void *_Val)
		{	// insert a void pointer
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);

		if (_Ok)
			{	// state okay, use facet to insert
			const _Nput& _Nput_fac = ::std:: use_facet<_Nput>(this->getloc());

			try {
			if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this,
				_Myios::fill(), _Val).failed())
				_State |= ios_base::badbit;
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (*this);
		}









	basic_ostream&  operator<<(_Mysb *_Strbuf)
		{	// insert until end-of-file from a stream buffer
		ios_base::iostate _State = ios_base::goodbit;
		bool _Copied = false;
		const sentry _Ok(*this);

		if (_Ok && _Strbuf != nullptr)
			for (int_type _Meta = _Traits::eof(); ; _Copied = true)
				{	// extract another character from stream buffer
				try {
				_Meta = _Traits::eq_int_type(_Traits::eof(), _Meta)
					? _Strbuf->sgetc() : _Strbuf->snextc();
				} catch (...) {
					_Myios::setstate(ios_base::failbit);
					throw;
				}

				if (_Traits::eq_int_type(_Traits::eof(), _Meta))
					break;	// end of file, quit

				try {
					if (_Traits::eq_int_type(_Traits::eof(),
						_Myios::rdbuf()->sputc(
							_Traits::to_char_type(_Meta))))
						{	// insertion failed, quit
						_State |= ios_base::badbit;
						break;
						}
				} catch (...) { _Myios::setstate(ios_base::badbit, true); }
				}

		this->width(0);
		_Myios::setstate(_Strbuf == nullptr ? ios_base::badbit
			: !_Copied ? _State | ios_base::failbit : _State);
		return (*this);
		}

	basic_ostream&  put(_Elem _Ch)
		{	// insert a character
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);

		if (!_Ok)
			_State |= ios_base::badbit;
		else
			{	// state okay, insert character
			try {
			if (_Traits::eq_int_type(_Traits::eof(),
				_Myios::rdbuf()->sputc(_Ch)))
				_State |= ios_base::badbit;
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (*this);
		}

	basic_ostream&  write(const _Elem *_Str,
		streamsize _Count)
		{	// insert _Count characters from array _Str
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);

		if (!_Ok)
			_State |= ios_base::badbit;
		else if (0 < _Count)
			{	// state okay, insert characters
			try {
			if (_Myios::rdbuf()->sputn(_Str, _Count) != _Count)
				_State |= ios_base::badbit;
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (*this);
		}

	basic_ostream&  flush()
		{	// flush output stream
		if (_Myios::rdbuf() != nullptr)
			{	// buffer exists, flush it
			const sentry _Ok(*this);

			if (_Ok && _Myios::rdbuf()->pubsync() == -1)
				_Myios::setstate(ios_base::badbit);	// sync failed
			}
		return (*this);
		}

	basic_ostream&  seekp(pos_type _Pos)
		{	// set output stream position to _Pos
		const sentry _Ok(*this);

		if (!this->fail()
			&& (off_type)_Myios::rdbuf()->pubseekpos(_Pos,
				ios_base::out) == -1)
			_Myios::setstate(ios_base::failbit);
		return (*this);
		}

	basic_ostream&  seekp(off_type _Off, ios_base::seekdir _Way)
		{	// change output stream position by _Off, according to _Way
		const sentry _Ok(*this);

		if (!this->fail()
			&& (off_type)_Myios::rdbuf()->pubseekoff(_Off, _Way,
				ios_base::out) == -1)
			_Myios::setstate(ios_base::failbit);
		return (*this);
		}

	pos_type  tellp()
		{	// return output stream position
		const sentry _Ok(*this);

		if (!this->fail())
			return (_Myios::rdbuf()->pubseekoff(0,
				ios_base::cur, ios_base::out));
		else
			return (pos_type(-1));
		}
	};

 #pragma vtordisp(pop)	

  

















































 

  
template class __declspec(dllimport) basic_ostream<char,
	char_traits<char> >;
template class __declspec(dllimport) basic_ostream<wchar_t,
	char_traits<wchar_t> >;
  

  



 

		// INSERTERS

template<class _Elem,
	class _Traits> inline
	basic_ostream<_Elem, _Traits>& operator<<(
		basic_ostream<_Elem, _Traits>& _Ostr, const char *_Val)
	{	// insert NTBS
	ios_base::iostate _State = ios_base::goodbit;
	streamsize _Count = (streamsize):: strlen(_Val);	// may overflow
	streamsize _Pad = _Ostr.width() <= 0 || _Ostr.width() <= _Count
		? 0 : _Ostr.width() - _Count;
	const typename basic_ostream<_Elem, _Traits>::sentry _Ok(_Ostr);

	if (!_Ok)
		_State |= ios_base::badbit;
	else
		{	// state okay, insert characters
		try {
		const ctype<_Elem>& _Ctype_fac = ::std:: use_facet<ctype<_Elem>>(_Ostr.getloc());
		if ((_Ostr.flags() & ios_base::adjustfield) != ios_base::left)
			for (; 0 < _Pad; --_Pad)	// pad on left
				if (_Traits::eq_int_type(_Traits::eof(),
					_Ostr.rdbuf()->sputc(_Ostr.fill())))
					{	// insertion failed, quit
					_State |= ios_base::badbit;
					break;
					}

		for (; _State == ios_base::goodbit && 0 < _Count; --_Count, ++_Val)
			if (_Traits::eq_int_type(_Traits::eof(),
				_Ostr.rdbuf()->sputc(_Ctype_fac.widen(*_Val))))
					_State |= ios_base::badbit;

		if (_State == ios_base::goodbit)
			for (; 0 < _Pad; --_Pad)	// pad on right
				if (_Traits::eq_int_type(_Traits::eof(),
					_Ostr.rdbuf()->sputc(_Ostr.fill())))
					{	// insertion failed, quit
					_State |= ios_base::badbit;
					break;
					}
		_Ostr.width(0);
		} catch (...) { (_Ostr).setstate(ios_base::badbit, true); }
		}

	_Ostr.setstate(_State);
	return (_Ostr);
	}

template<class _Elem,
	class _Traits> inline
	basic_ostream<_Elem, _Traits>& operator<<(
		basic_ostream<_Elem, _Traits>& _Ostr, char _Ch)
	{	// insert a character
	ios_base::iostate _State = ios_base::goodbit;
	const typename basic_ostream<_Elem, _Traits>::sentry _Ok(_Ostr);

	if (_Ok)
		{	// state okay, insert
		const ctype<_Elem>& _Ctype_fac = ::std:: use_facet<ctype<_Elem>>(_Ostr.getloc());
		streamsize _Pad = _Ostr.width() <= 1 ? 0 : _Ostr.width() - 1;

		try {
		if ((_Ostr.flags() & ios_base::adjustfield) != ios_base::left)
			for (; _State == ios_base::goodbit && 0 < _Pad;
				--_Pad)	// pad on left
				if (_Traits::eq_int_type(_Traits::eof(),
					_Ostr.rdbuf()->sputc(_Ostr.fill())))
					_State |= ios_base::badbit;

		if (_State == ios_base::goodbit
			&& _Traits::eq_int_type(_Traits::eof(),
				_Ostr.rdbuf()->sputc(_Ctype_fac.widen(_Ch))))
			_State |= ios_base::badbit;

		for (; _State == ios_base::goodbit && 0 < _Pad;
			--_Pad)	// pad on right
			if (_Traits::eq_int_type(_Traits::eof(),
				_Ostr.rdbuf()->sputc(_Ostr.fill())))
				_State |= ios_base::badbit;
		} catch (...) { (_Ostr).setstate(ios_base::badbit, true); }
		}

	_Ostr.width(0);
	_Ostr.setstate(_State);
	return (_Ostr);
	}

template<class _Traits> inline
	basic_ostream<char, _Traits>& operator<<(
		basic_ostream<char, _Traits>& _Ostr,
		const char *_Val)
	{	// insert NTBS into char stream
	typedef char _Elem;
	typedef basic_ostream<_Elem, _Traits> _Myos;
	ios_base::iostate _State = ios_base::goodbit;
	streamsize _Count = (streamsize)_Traits::length(_Val);	// may overflow
	streamsize _Pad = _Ostr.width() <= 0 || _Ostr.width() <= _Count
		? 0 : _Ostr.width() - _Count;
	const typename _Myos::sentry _Ok(_Ostr);

	if (!_Ok)
		_State |= ios_base::badbit;
	else
		{	// state okay, insert
		try {
		if ((_Ostr.flags() & ios_base::adjustfield) != ios_base::left)
			for (; 0 < _Pad; --_Pad)	// pad on left
				if (_Traits::eq_int_type(_Traits::eof(),
					_Ostr.rdbuf()->sputc(_Ostr.fill())))
					{	// insertion failed, quit
					_State |= ios_base::badbit;
					break;
					}

		if (_State == ios_base::goodbit
			&& _Ostr.rdbuf()->sputn(_Val, _Count) != _Count)
			_State |= ios_base::badbit;

		if (_State == ios_base::goodbit)
			for (; 0 < _Pad; --_Pad)	// pad on right
				if (_Traits::eq_int_type(_Traits::eof(),
					_Ostr.rdbuf()->sputc(_Ostr.fill())))
					{	// insertion failed, quit
					_State |= ios_base::badbit;
					break;
					}
		_Ostr.width(0);
		} catch (...) { (_Ostr).setstate(ios_base::badbit, true); }
		}

	_Ostr.setstate(_State);
	return (_Ostr);
	}

template<class _Traits> inline
	basic_ostream<char, _Traits>& operator<<(
		basic_ostream<char, _Traits>& _Ostr, char _Ch)
	{	// insert a char into char stream
	typedef char _Elem;
	typedef basic_ostream<_Elem, _Traits> _Myos;
	ios_base::iostate _State = ios_base::goodbit;
	const typename _Myos::sentry _Ok(_Ostr);

	if (_Ok)
		{	// state okay, insert
		streamsize _Pad = _Ostr.width() <= 1 ? 0 : _Ostr.width() - 1;

		try {
		if ((_Ostr.flags() & ios_base::adjustfield) != ios_base::left)
			for (; _State == ios_base::goodbit && 0 < _Pad;
				--_Pad)	// pad on left
				if (_Traits::eq_int_type(_Traits::eof(),
					_Ostr.rdbuf()->sputc(_Ostr.fill())))
					_State |= ios_base::badbit;

		if (_State == ios_base::goodbit
			&& _Traits::eq_int_type(_Traits::eof(),
				_Ostr.rdbuf()->sputc(_Ch)))
			_State |= ios_base::badbit;

		for (; _State == ios_base::goodbit && 0 < _Pad;
			--_Pad)	// pad on right
			if (_Traits::eq_int_type(_Traits::eof(),
				_Ostr.rdbuf()->sputc(_Ostr.fill())))
				_State |= ios_base::badbit;
		} catch (...) { (_Ostr).setstate(ios_base::badbit, true); }
		}

	_Ostr.width(0);
	_Ostr.setstate(_State);
	return (_Ostr);
	}

template<class _Elem,
	class _Traits> inline
	basic_ostream<_Elem, _Traits>& operator<<(
		basic_ostream<_Elem, _Traits>& _Ostr, const _Elem *_Val)
	{	// insert NTCS
	typedef basic_ostream<_Elem, _Traits> _Myos;

	ios_base::iostate _State = ios_base::goodbit;
	streamsize _Count = (streamsize)_Traits::length(_Val);	// may overflow
	streamsize _Pad = _Ostr.width() <= 0 || _Ostr.width() <= _Count
		? 0 : _Ostr.width() - _Count;
	const typename _Myos::sentry _Ok(_Ostr);

	if (!_Ok)
		_State |= ios_base::badbit;
	else
		{	// state okay, insert
		try {
		if ((_Ostr.flags() & ios_base::adjustfield) != ios_base::left)
			for (; 0 < _Pad; --_Pad)	// pad on left
				if (_Traits::eq_int_type(_Traits::eof(),
					_Ostr.rdbuf()->sputc(_Ostr.fill())))
					{	// insertion failed, quit
					_State |= ios_base::badbit;
					break;
					}

		if (_State == ios_base::goodbit
			&& _Ostr.rdbuf()->sputn(_Val, _Count) != _Count)
			_State |= ios_base::badbit;

		if (_State == ios_base::goodbit)
			for (; 0 < _Pad; --_Pad)	// pad on right
				if (_Traits::eq_int_type(_Traits::eof(),
					_Ostr.rdbuf()->sputc(_Ostr.fill())))
					{	// insertion failed, quit
					_State |= ios_base::badbit;
					break;
					}
		_Ostr.width(0);
		} catch (...) { (_Ostr).setstate(ios_base::badbit, true); }
		}

	_Ostr.setstate(_State);
	return (_Ostr);
	}

template<class _Elem,
	class _Traits> inline
	basic_ostream<_Elem, _Traits>& operator<<(
		basic_ostream<_Elem, _Traits>& _Ostr, _Elem _Ch)
	{	// insert a character
	typedef basic_ostream<_Elem, _Traits> _Myos;

	ios_base::iostate _State = ios_base::goodbit;
	const typename _Myos::sentry _Ok(_Ostr);

	if (_Ok)
		{	// state okay, insert
		streamsize _Pad = _Ostr.width() <= 1 ? 0 : _Ostr.width() - 1;

		try {
		if ((_Ostr.flags() & ios_base::adjustfield) != ios_base::left)
			for (; _State == ios_base::goodbit && 0 < _Pad;
				--_Pad)	// pad on left
				if (_Traits::eq_int_type(_Traits::eof(),
					_Ostr.rdbuf()->sputc(_Ostr.fill())))
					_State |= ios_base::badbit;

		if (_State == ios_base::goodbit
			&& _Traits::eq_int_type(_Traits::eof(),
				_Ostr.rdbuf()->sputc(_Ch)))
			_State |= ios_base::badbit;

		for (; _State == ios_base::goodbit && 0 < _Pad;
			--_Pad)	// pad on right
			if (_Traits::eq_int_type(_Traits::eof(),
				_Ostr.rdbuf()->sputc(_Ostr.fill())))
				_State |= ios_base::badbit;
		} catch (...) { (_Ostr).setstate(ios_base::badbit, true); }
		}

	_Ostr.width(0);
	_Ostr.setstate(_State);
	return (_Ostr);
	}

template<class _Traits> inline
	basic_ostream<char, _Traits>& operator<<(
		basic_ostream<char, _Traits>& _Ostr, const signed char *_Val)
	{	// insert a signed char NTBS
	return (_Ostr << (const char *)_Val);
	}

template<class _Traits> inline
	basic_ostream<char, _Traits>& operator<<(
		basic_ostream<char, _Traits>& _Ostr, signed char _Ch)
	{	// insert a signed char
	return (_Ostr << (char)_Ch);
	}

template<class _Traits> inline
	basic_ostream<char, _Traits>& operator<<(
		basic_ostream<char, _Traits>& _Ostr, const unsigned char *_Val)
	{	// insert an unsigned char NTBS
	return (_Ostr << (const char *)_Val);
	}

template<class _Traits> inline
	basic_ostream<char, _Traits>& operator<<(
		basic_ostream<char, _Traits>& _Ostr, unsigned char _Ch)
	{	// insert an unsigned char
	return (_Ostr << (char)_Ch);
	}

template<class _Ostr,
	class _Ty,
	class = void>
	struct _Can_stream_out
		: false_type
	{
	};

template<class _Ostr,
	class _Ty>
	struct _Can_stream_out<_Ostr, _Ty, void_t<decltype(::std:: declval<_Ostr&>() << ::std:: declval<const _Ty&>())>>
		: true_type
	{
	};

template<class _Ostr,
	class _Ty,
	enable_if_t<conjunction_v< // prevent infinite recursion
		negation<is_lvalue_reference<_Ostr>>,
		is_base_of<ios_base, _Ostr>,
		_Can_stream_out<_Ostr, _Ty>>, int> = 0> inline
	_Ostr&& operator<<(_Ostr&& _Os, const _Ty& _Val)
	{	// insert to rvalue stream
	_Os << _Val;
	return (::std:: move(_Os));
	}

		// MANIPULATORS
template<class _Elem,
	class _Traits> inline
	basic_ostream<_Elem, _Traits>&
		__cdecl endl(basic_ostream<_Elem, _Traits>& _Ostr)
	{	// insert newline and flush stream
	_Ostr.put(_Ostr.widen('\n'));
	_Ostr.flush();
	return (_Ostr);
	}

template<class _Elem,
	class _Traits> inline
	basic_ostream<_Elem, _Traits>&
		__cdecl ends(basic_ostream<_Elem, _Traits>& _Ostr)
	{	// insert null character
	_Ostr.put(_Elem());
	return (_Ostr);
	}

template<class _Elem,
	class _Traits> inline
	basic_ostream<_Elem, _Traits>&
		__cdecl flush(basic_ostream<_Elem, _Traits>& _Ostr)
	{	// flush stream
	_Ostr.flush();
	return (_Ostr);
	}

		// INSERTER FOR error_category
template<class _Elem,
	class _Traits> inline
	basic_ostream<_Elem, _Traits>&
		operator<<(basic_ostream<_Elem, _Traits>& _Ostr,
			const error_code& _Errcode)
	{	// display error code
	return (_Ostr << _Errcode.category().name() << ':' << _Errcode.value());
	}
}

 
 
 #pragma warning(pop)
 #pragma pack(pop)



/*
 * Copyright (c) by P.J. Plauger. All rights reserved.
 * Consult your license regarding permissions and restrictions.
V6.50:0009 */


 #pragma pack(push,8)
 #pragma warning(push,3)
 #pragma warning(disable: 4455 4494  4619 4643 4702 4984 4988 )
 
 
 

namespace std {
 #pragma vtordisp(push, 2)	

		// CLASS TEMPLATE basic_istream
template<class _Elem,
	class _Traits>
	class basic_istream
		: virtual public basic_ios<_Elem, _Traits>
	{	// control extractions from a stream buffer
public:
	typedef basic_ios<_Elem, _Traits> _Myios;
	typedef basic_streambuf<_Elem, _Traits> _Mysb;
	typedef istreambuf_iterator<_Elem, _Traits> _Iter;
	typedef ctype<_Elem> _Ctype;
	typedef num_get<_Elem, _Iter> _Nget;

  









	explicit  basic_istream(_Mysb *_Strbuf,
		bool _Isstd = false)

		: _Chcount(0)
		{	// construct from stream buffer pointer
		_Myios::init(_Strbuf, _Isstd);
		}

	 basic_istream(_Uninitialized)
		{	// construct uninitialized
		this->_Addstd(this);
		}

protected:
	 basic_istream(basic_istream&& _Right)
		: _Chcount(_Right._Chcount)
		{	// construct by moving _Right
		_Myios::init();
		_Myios::move(::std:: move(_Right));
		_Right._Chcount = 0;
		}

	basic_istream&  operator=(basic_istream&& _Right)
		{	// move from _Right
		this->swap(_Right);
		return (*this);
		}

	void  swap(basic_istream& _Right)
		{	// swap with _Right
		_Myios::swap(_Right);
		::std:: swap(_Chcount, _Right._Chcount);
		}

public:
	 basic_istream(const basic_istream&) = delete;
	basic_istream&  operator=(const basic_istream&) = delete;

	virtual  ~basic_istream() noexcept
		{	// destroy the object
		}

	typedef typename _Traits::int_type int_type;
	typedef typename _Traits::pos_type pos_type;
	typedef typename _Traits::off_type off_type;

		// CLASS TEMPLATE sentry
	class _Sentry_base
		{	// stores thread lock and reference to input stream
	public:
		 _Sentry_base(basic_istream& _Istr)
			: _Myistr(_Istr)
			{	// lock the stream buffer, if there
			if (_Myistr.rdbuf() != nullptr)
				_Myistr.rdbuf()->_Lock();
			}

		 ~_Sentry_base() noexcept
			{	// destroy after unlocking
			if (_Myistr.rdbuf() != nullptr)
				_Myistr.rdbuf()->_Unlock();
			}

		basic_istream& _Myistr;	// the input stream, for _Unlock call at destruction

		_Sentry_base& operator=(const _Sentry_base&) = delete;
		};

	class sentry
		: public _Sentry_base
		{	// stores thread lock and result of _Ipfx call
	public:
		explicit  sentry(basic_istream& _Istr, bool _Noskip = false)
			: _Sentry_base(_Istr)
			{	// construct locking and calling _Ipfx
			_Ok = this->_Myistr._Ipfx(_Noskip);
			}

		explicit  operator bool() const
			{	// test if _Ipfx succeeded
			return (_Ok);
			}

		 sentry(const sentry&) = delete;
		sentry&  operator=(const sentry&) = delete;

	private:
		bool _Ok;	// true if _Ipfx succeeded at construction
		};

	bool  _Ipfx(bool _Noskip = false)
		{	// test stream state and skip whitespace as needed
		if (this->good())
			{	// state okay, flush tied stream and skip whitespace
			if (_Myios::tie() != nullptr)
				_Myios::tie()->flush();

			if (!_Noskip && this->flags() & ios_base::skipws)
				{	// skip whitespace
				const _Ctype& _Ctype_fac = ::std:: use_facet<_Ctype>(this->getloc());

				try {
				int_type _Meta = _Myios::rdbuf()->sgetc();

				for (; ; _Meta = _Myios::rdbuf()->snextc())
					if (_Traits::eq_int_type(_Traits::eof(), _Meta))
						{	// end of file, quit
						_Myios::setstate(ios_base::eofbit);
						break;
						}
					else if (!_Ctype_fac.is(_Ctype::space,
						_Traits::to_char_type(_Meta)))
						break;	// not whitespace, quit
				} catch (...) { _Myios::setstate(ios_base::badbit, true); }
				}

			if (this->good())
				return (true);
			}
		_Myios::setstate(ios_base::failbit);
		return (false);
		}

	bool  ipfx(bool _Noskip = false)
		{	// test stream state and skip whitespace as needed (retained)
		return (_Ipfx(_Noskip));
		}

	void  isfx()
		{	// perform any wrapup (retained)
		}

  


















	basic_istream&  operator>>(basic_istream& (__cdecl *_Pfn)(basic_istream&))
		{	// call basic_istream manipulator
		return ((*_Pfn)(*this));
		}

	basic_istream&  operator>>(_Myios& (__cdecl *_Pfn)(_Myios&))
		{	// call basic_ios manipulator
		(*_Pfn)(*(_Myios *)this);
		return (*this);
		}

	basic_istream&  operator>>(ios_base& (__cdecl *_Pfn)(ios_base&))
		{	// call ios_base manipulator
		(*_Pfn)(*(ios_base *)this);
		return (*this);
		}

private:
	template<class _Ty>
		basic_istream& _Common_extract_with_num_get(_Ty& _Val)
		{	// formatted extract with num_get
		ios_base::iostate _Err = ios_base::goodbit;
		const sentry _Ok(*this);

		if (_Ok)
			{	// state okay, use facet to extract
			try {
			::std:: use_facet<_Nget>(this->getloc()).get(*this, {}, *this, _Err, _Val);
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_Err);
		return (*this);
		}

public:
	basic_istream&  operator>>(bool& _Val)
		{	// extract a boolean
		return (_Common_extract_with_num_get(_Val));
		}

	basic_istream&  operator>>(short& _Val)
		{	// extract a short
		ios_base::iostate _Err = ios_base::goodbit;
		const sentry _Ok(*this);

		if (_Ok)
			{	// state okay, use facet to extract
			try {
			long _Lval;
			::std:: use_facet<_Nget>(this->getloc()).get(*this, {}, *this, _Err, _Lval);
			if (_Lval < (-32768))
				{
				_Err |= ios_base::failbit;
				_Val = (-32768);
				}
			else if (_Lval > 32767)
				{
				_Err |= ios_base::failbit;
				_Val = 32767;
				}
			else
				{
				_Val = static_cast<short>(_Lval);
				}
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_Err);
		return (*this);
		}

/* NOTE:
	If you are not using native wchar_t, the unsigned short extractor
	is masked by an explicit specialization that treats an unsigned
	short as a wide character.

	To read or write unsigned shorts as integers with wchar_t streams,
	make wchar_t a native type with the command line option /Zc:wchar_t.
 */

	basic_istream&  operator>>(unsigned short& _Val)
		{	// extract an unsigned short
		return (_Common_extract_with_num_get(_Val));
		}

	basic_istream&  operator>>(int& _Val)
		{	// extract an int
		static_assert(sizeof(int) == sizeof(long),
			"Bad overflow assumptions due to sizeof(int) != sizeof(long)");
		long _Result = _Val;
		_Common_extract_with_num_get(_Result);
		_Val = _Result;
		return (*this);
		}

	basic_istream&  operator>>(unsigned int& _Val)
		{	// extract an unsigned int
		return (_Common_extract_with_num_get(_Val));
		}

	basic_istream&  operator>>(long& _Val)
		{	// extract a long
		return (_Common_extract_with_num_get(_Val));
		}

	basic_istream&  operator>>(unsigned long& _Val)
		{	// extract an unsigned long
		return (_Common_extract_with_num_get(_Val));
		}

	basic_istream&  operator>>(long long& _Val)
		{	// extract a long long
		return (_Common_extract_with_num_get(_Val));
		}

	basic_istream&  operator>>(unsigned long long& _Val)
		{	// extract an unsigned long long
		return (_Common_extract_with_num_get(_Val));
		}

	basic_istream&  operator>>(float& _Val)
		{	// extract a float
		return (_Common_extract_with_num_get(_Val));
		}

	basic_istream&  operator>>(double& _Val)
		{	// extract a double
		return (_Common_extract_with_num_get(_Val));
		}

	basic_istream&  operator>>(long double& _Val)
		{	// extract a long double
		return (_Common_extract_with_num_get(_Val));
		}

	basic_istream&  operator>>(void *& _Val)
		{	// extract a void pointer
		return (_Common_extract_with_num_get(_Val));
		}

	basic_istream&  operator>>(_Mysb * _Strbuf)
		{	// extract until end-of-file into a stream buffer
		_Chcount = 0;	// behaves as an unformatted input function
		const sentry _Ok(*this, true);
		ios_base::iostate _State = ios_base::goodbit;
		if (_Ok && _Strbuf != nullptr)
			{	// state okay, extract characters
			try {
			for (int_type _Meta = _Myios::rdbuf()->sgetc(); ; _Meta = _Myios::rdbuf()->snextc())
				{
				if (_Traits::eq_int_type(_Traits::eof(), _Meta))
					{	// end of file, quit
					_State |= ios_base::eofbit;
					break;
					}
				// got a character, insert it into buffer
				try {
					if (_Traits::eq_int_type(_Traits::eof(), _Strbuf->sputc(_Traits::to_char_type(_Meta))))
						{
						break;
						}

				} catch (...) {
					break;
				}

				++_Chcount;
				}
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		if (_Chcount == 0)
			{	// If the function inserts no characters, it calls setstate(failbit)
			_State = ios_base::failbit;
			}

		_Myios::setstate(_State);
		return (*this);
		}

	int_type  get()
		{	// extract a metacharacter
		int_type _Meta = 0;
		ios_base::iostate _State = ios_base::goodbit;
		_Chcount = 0;
		const sentry _Ok(*this, true);

		if (!_Ok)
			_Meta = _Traits::eof();	// state not okay, return EOF
		else
			{	// state okay, extract a character
			try {
			_Meta = _Myios::rdbuf()->sgetc();

			if (_Traits::eq_int_type(_Traits::eof(), _Meta))
				_State |= ios_base::eofbit | ios_base::failbit;	// end of file
			else
				{	// got a character, count it
				_Myios::rdbuf()->sbumpc();
				++_Chcount;
				}
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (_Meta);
		}

	basic_istream&  get(_Elem *_Str, streamsize _Count)
		{	// get up to _Count characters into NTCS
		return (get(_Str, _Count, _Myios::widen('\n')));
		}

	basic_istream&  get(_Elem *_Str,
		streamsize _Count, _Elem _Delim)
		{	// get up to _Count characters into NTCS, stop before _Delim
		ios_base::iostate _State = ios_base::goodbit;
		_Chcount = 0;
		const sentry _Ok(*this, true);

		if (_Ok && 0 < _Count)
			{	// state okay, extract characters
			try {
			int_type _Meta = _Myios::rdbuf()->sgetc();

			for (; 0 < --_Count; _Meta = _Myios::rdbuf()->snextc())
				if (_Traits::eq_int_type(_Traits::eof(), _Meta))
					{	// end of file, quit
					_State |= ios_base::eofbit;
					break;
					}
				else if (_Traits::to_char_type(_Meta) == _Delim)
					break;	// got a delimiter, quit
				else
					{	// got a character, add it to string
					*_Str++ = _Traits::to_char_type(_Meta);
					++_Chcount;
					}
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_Chcount == 0
			? _State | ios_base::failbit : _State);
		*_Str = _Elem();	// add terminating null character
		return (*this);
		}

	basic_istream&  get(_Elem& _Ch)
		{	// get a character
		int_type _Meta = get();
		if (!_Traits::eq_int_type(_Traits::eof(), _Meta))
			_Ch = _Traits::to_char_type(_Meta);
		return (*this);
		}

	basic_istream&  get(_Mysb& _Strbuf)
		{	// extract up to newline and insert into stream buffer
		return (get(_Strbuf, _Myios::widen('\n')));
		}

	basic_istream&  get(_Mysb& _Strbuf, _Elem _Delim)
		{	// extract up to delimiter and insert into stream buffer
		ios_base::iostate _State = ios_base::goodbit;
		_Chcount = 0;
		const sentry _Ok(*this, true);

		if (_Ok)
			{	// state okay, use facet to extract
			try {
			int_type _Meta = _Myios::rdbuf()->sgetc();

			for (; ; _Meta = _Myios::rdbuf()->snextc())
				if (_Traits::eq_int_type(_Traits::eof(), _Meta))
					{	// end of file, quit
					_State |= ios_base::eofbit;
					break;
					}
				else
					{	// got a character, insert it into stream buffer
					try {
						_Elem _Ch = _Traits::to_char_type(_Meta);
						if (_Ch == _Delim
							|| _Traits::eq_int_type(_Traits::eof(),
								_Strbuf.sputc(_Ch)))
							break;
					} catch (...) {
						break;
					}
					++_Chcount;
					}
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		if (_Chcount == 0)
			_State |= ios_base::failbit;
		_Myios::setstate(_State);
		return (*this);
		}

	basic_istream&  getline(_Elem *_Str, streamsize _Count)
		{	// get up to _Count characters into NTCS, discard newline
		return (getline(_Str, _Count, _Myios::widen('\n')));
		}

	basic_istream&  getline(_Elem *_Str,
		streamsize _Count, _Elem _Delim)
		{	// get up to _Count characters into NTCS, discard _Delim
		ios_base::iostate _State = ios_base::goodbit;
		_Chcount = 0;
		const sentry _Ok(*this, true);

		if (_Ok && 0 < _Count)
			{	// state okay, use facet to extract
			int_type _Metadelim = _Traits::to_int_type(_Delim);

			try {
			int_type _Meta = _Myios::rdbuf()->sgetc();

			for (; ; _Meta = _Myios::rdbuf()->snextc())
				if (_Traits::eq_int_type(_Traits::eof(), _Meta))
					{	// end of file, quit
					_State |= ios_base::eofbit;
					break;
					}
				else if (_Meta == _Metadelim)
					{	// got a delimiter, discard it and quit
					++_Chcount;
					_Myios::rdbuf()->sbumpc();
					break;
					}
				else if (--_Count <= 0)
					{	// buffer full, quit
					_State |= ios_base::failbit;
					break;
					}
				else
					{	// got a character, add it to string
					*_Str++ = _Traits::to_char_type(_Meta);
					++_Chcount;
					}
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		*_Str = _Elem();	// add terminating null character
		_Myios::setstate(_Chcount == 0 ? _State | ios_base::failbit : _State);
		return (*this);
		}

	basic_istream&  ignore(streamsize _Count = 1,
		int_type _Metadelim = _Traits::eof())
		{	// ignore up to _Count characters, discarding delimiter
		ios_base::iostate _State = ios_base::goodbit;
		_Chcount = 0;
		const sentry _Ok(*this, true);

		if (_Ok && 0 < _Count)
			{	// state okay, use facet to extract
			try {
			for (;;)
				{	// get a metacharacter if more room in buffer
				int_type _Meta;
				if (_Count != (numeric_limits<streamsize>::max)()
					&& --_Count < 0)
					break;	// buffer full, quit
				else if (_Traits::eq_int_type(_Traits::eof(),
					_Meta = _Myios::rdbuf()->sbumpc()))
					{	// end of file, quit
					_State |= ios_base::eofbit;
					break;
					}
				else
					{	// got a character, count it
					++_Chcount;
					if (_Meta == _Metadelim)
						break;	// got a delimiter, quit
					}
				}
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (*this);
		}

	basic_istream&  read(_Elem *_Str, streamsize _Count)
		{	// read up to _Count characters into buffer
		ios_base::iostate _State = ios_base::goodbit;
		_Chcount = 0;
		const sentry _Ok(*this, true);

		if (_Ok && 0 < _Count)
			{	// state okay, use facet to extract
			try {
			const streamsize _Num = _Myios::rdbuf()->sgetn(_Str, _Count);
			_Chcount += _Num;
			if (_Num != _Count)
				_State |= ios_base::eofbit | ios_base::failbit;	// short read
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (*this);
		}

	streamsize  readsome(_Elem *_Str,
		streamsize _Count)
		{	// read up to _Count characters into buffer, without blocking
		ios_base::iostate _State = ios_base::goodbit;
		_Chcount = 0;
		const sentry _Ok(*this, true);
		streamsize _Num;

		if (!_Ok)
			_State |= ios_base::failbit;	// no buffer, fail
		else if ((_Num = _Myios::rdbuf()->in_avail()) < 0)
			_State |= ios_base::eofbit;	// no characters available
		else if (0 < _Count && 0 < _Num)
			{	// read available
			read(_Str, _Num < _Count ? _Num : _Count);
			}

		_Myios::setstate(_State);
		return (gcount());
		}

	int_type  peek()
		{	// return next character, unconsumed
		ios_base::iostate _State = ios_base::goodbit;
		_Chcount = 0;
		int_type _Meta = 0;
		const sentry _Ok(*this, true);

		if (!_Ok)
			_Meta = _Traits::eof();	// state not okay, return EOF
		else
			{	// state okay, read a character
			try {
			if (_Traits::eq_int_type(_Traits::eof(),
				_Meta = _Myios::rdbuf()->sgetc()))
				_State |= ios_base::eofbit;
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (_Meta);
		}

	basic_istream&  putback(_Elem _Ch)
		{	// put back a character
		_Chcount = 0;
		ios_base::iostate _State = ios_base::goodbit;
		ios_base::iostate _Oldstate = _Myios::rdstate();
		_Myios::clear(_Oldstate & ~ios_base::eofbit);
		const sentry _Ok(*this, true);

		if (_Ok)
			{	// state okay, put character back
			try {
			if (_Traits::eq_int_type(_Traits::eof(),
				_Myios::rdbuf()->sputbackc(_Ch)))
				_State |= ios_base::badbit | _Oldstate;
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (*this);
		}

	basic_istream&  unget()
		{	// put back last read character
		_Chcount = 0;
		ios_base::iostate _State = ios_base::goodbit;
		ios_base::iostate _Oldstate = _Myios::rdstate();
		_Myios::clear(_Oldstate & ~ios_base::eofbit);
		const sentry _Ok(*this, true);

		if (_Ok)
			{	// state okay, put character back
			try {
			if (_Traits::eq_int_type(_Traits::eof(),
				_Myios::rdbuf()->sungetc()))
				_State |= ios_base::badbit | _Oldstate;
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (*this);
		}

	 streamsize  gcount() const
		{	// get count from last extraction
		return (_Chcount);
		}

	int  sync()
		{	// synchronize with input source
		const sentry _Ok(*this, true);

		if (_Myios::rdbuf() == nullptr)
			return (-1);
		else if (_Myios::rdbuf()->pubsync() == -1)
			{	// sync failed
			_Myios::setstate(ios_base::badbit);
			return (-1);
			}
		else
			return (0);
		}

	basic_istream&  seekg(pos_type _Pos)
		{	// set input stream position to _Pos
		ios_base::iostate _State = ios_base::goodbit;
		ios_base::iostate _Oldstate = _Myios::rdstate();
		_Myios::clear(_Oldstate & ~ios_base::eofbit);
		const sentry _Ok(*this, true);

		if (!this->fail()
			&& (off_type)_Myios::rdbuf()->pubseekpos(_Pos,
				ios_base::in) == -1)
			_Myios::setstate(_State | ios_base::failbit);
		return (*this);
		}

	basic_istream&  seekg(off_type _Off, ios_base::seekdir _Way)
		{	// change input stream position by _Off, according to _Way
		ios_base::iostate _State = ios_base::goodbit;
		ios_base::iostate _Oldstate = _Myios::rdstate();
		_Myios::clear(_Oldstate & ~ios_base::eofbit);
		const sentry _Ok(*this, true);

		if (!this->fail()
			&& (off_type)_Myios::rdbuf()->pubseekoff(_Off, _Way,
				ios_base::in) == -1)
			_Myios::setstate(_State | ios_base::failbit);
		return (*this);
		}

	pos_type  tellg()
		{	// return input stream position
		const sentry _Ok(*this, true);

		if (!this->fail())
			return (_Myios::rdbuf()->pubseekoff(0,
				ios_base::cur, ios_base::in));
		else
			return (pos_type(-1));
		}

private:
	streamsize _Chcount;	// the character count
	};

 #pragma vtordisp(pop)	

  






















 

  
template class __declspec(dllimport) basic_istream<char, char_traits<char> >;
template class __declspec(dllimport) basic_istream<wchar_t, char_traits<wchar_t> >;
  

  



 

		// CLASS TEMPLATE basic_iostream
template<class _Elem,
	class _Traits>
	class basic_iostream
	: public basic_istream<_Elem, _Traits>,
		public basic_ostream<_Elem, _Traits>
	{	// control insertions and extractions from a stream buffer
public:
	typedef basic_istream<_Elem, _Traits> _Myis;
	typedef basic_ostream<_Elem, _Traits> _Myos;
	typedef basic_ios<_Elem, _Traits> _Myios;
	typedef _Elem char_type;
	typedef _Traits traits_type;
	typedef typename _Traits::int_type int_type;
	typedef typename _Traits::pos_type pos_type;
	typedef typename _Traits::off_type off_type;

	explicit  basic_iostream(basic_streambuf<_Elem, _Traits> *_Strbuf)
		: _Myis(_Strbuf, false),
			_Myos(_Noinit, false)
		{	// construct from stream buffer pointer
		}

protected:
	 basic_iostream(basic_iostream&& _Right)
		: _Myis(_Right.rdbuf(), false),
			_Myos(_Noinit, false)
		{	// construct by moving _Right
		_Myios::init();
		_Myios::move(::std:: move(_Right));
		}

	basic_iostream&  operator=(basic_iostream&& _Right)
		{	// move from _Right
		this->swap(_Right);
		return (*this);
		}

	void  swap(basic_iostream& _Right)
		{	// swap with _Right
		if (this != ::std:: addressof(_Right))
			_Myios::swap(_Right);
		}

public:
	 basic_iostream(const basic_iostream&) = delete;
	basic_iostream&  operator=(const basic_iostream&) = delete;

	virtual  ~basic_iostream() noexcept
		{	// destroy the object
		}
	};

 

  
template class __declspec(dllimport) basic_iostream<char, char_traits<char> >;
template class __declspec(dllimport) basic_iostream<wchar_t, char_traits<wchar_t> >;
  

  



 

		// EXTRACTORS

template<class _Elem,
	class _Traits> inline
	basic_istream<_Elem, _Traits>& operator>>(
		basic_istream<_Elem, _Traits>& _Istr, _Elem *_Str)
	{	// extract NTBS
	typedef basic_istream<_Elem, _Traits> _Myis;
	typedef ctype<_Elem> _Ctype;
	ios_base::iostate _State = ios_base::goodbit;
	_Elem *_Str0 = _Str;
	const typename _Myis::sentry _Ok(_Istr);

	if (_Ok)
		{	// state okay, extract characters
		const _Ctype& _Ctype_fac = ::std:: use_facet<_Ctype>(_Istr.getloc());

		try {
		streamsize _Count = 0 < _Istr.width() ? _Istr.width()
			: (numeric_limits<streamsize>::max)();
		typename _Myis::int_type _Meta = _Istr.rdbuf()->sgetc();
		_Elem _Ch;
		for (; 0 < --_Count; _Meta = _Istr.rdbuf()->snextc())
			if (_Traits::eq_int_type(_Traits::eof(), _Meta))
				{	// end of file, quit
				_State |= ios_base::eofbit;
				break;
				}
			else if (_Ctype_fac.is(_Ctype::space,
				_Ch = _Traits::to_char_type(_Meta))
					|| _Ch == _Elem())
				break;	// whitespace or nul, quit
			else
				*_Str++ = _Traits::to_char_type(_Meta);	// add it to string
		} catch (...) { (_Istr).setstate(ios_base::badbit, true); }
		}

	*_Str = _Elem();	// add terminating null character
	_Istr.width(0);
	_Istr.setstate(_Str == _Str0 ? _State | ios_base::failbit : _State);
	return (_Istr);
	}

template<class _Elem,
	class _Traits> inline
	basic_istream<_Elem, _Traits>& operator>>(
		basic_istream<_Elem, _Traits>& _Istr, _Elem& _Ch)
	{	// extract a character
	typedef basic_istream<_Elem, _Traits> _Myis;

	typename _Myis::int_type _Meta;
	ios_base::iostate _State = ios_base::goodbit;
	const typename _Myis::sentry _Ok(_Istr);

	if (_Ok)
		{	// state okay, extract characters
		try {
		_Meta = _Istr.rdbuf()->sbumpc();
		if (_Traits::eq_int_type(_Traits::eof(), _Meta))
			_State |= ios_base::eofbit | ios_base::failbit;	// end of file
		else
			_Ch = _Traits::to_char_type(_Meta);	// got a character
		} catch (...) { (_Istr).setstate(ios_base::badbit, true); }
		}

	_Istr.setstate(_State);
	return (_Istr);
	}

template<class _Traits> inline
	basic_istream<char, _Traits>& operator>>(
		basic_istream<char, _Traits>& _Istr, signed char *_Str)
	{	// extract a signed char NTBS
	return (_Istr >> (char *)_Str);
	}

template<class _Traits> inline
	basic_istream<char, _Traits>& operator>>(
		basic_istream<char, _Traits>& _Istr, signed char& _Ch)
	{	// extract a signed char
	return (_Istr >> (char&)_Ch);
	}

template<class _Traits> inline
	basic_istream<char, _Traits>& operator>>(
		basic_istream<char, _Traits>& _Istr, unsigned char *_Str)
	{	// extract an unsigned char NTBS
	return (_Istr >> (char *)_Str);
	}

template<class _Traits> inline
	basic_istream<char, _Traits>& operator>>(
		basic_istream<char, _Traits>& _Istr, unsigned char& _Ch)
	{	// extract an unsigned char
	return (_Istr >> (char&)_Ch);
	}

template<class _Istr,
	class _Ty,
	class = void>
	struct _Can_stream_in
		: false_type
	{
	};

template<class _Istr,
	class _Ty>
	struct _Can_stream_in<_Istr, _Ty, void_t<decltype(::std:: declval<_Istr&>() >> ::std:: declval<_Ty>())>>
		: true_type
	{
	};

template<class _Istr,
	class _Ty,
	enable_if_t<conjunction_v<	// avoid infinite recursion
		negation<is_lvalue_reference<_Istr>>,
		is_base_of<ios_base, _Istr>,
		_Can_stream_in<_Istr, _Ty>>, int> = 0> inline
	_Istr&& operator>>(_Istr&& _Is, _Ty&& _Val)
	{	// extract from rvalue stream
	_Is >> ::std:: forward<_Ty>(_Val);
	return (::std:: move(_Is));
	}

		// MANIPULATORS
template<class _Elem,
	class _Traits> inline
	basic_istream<_Elem, _Traits>&
		__cdecl ws(basic_istream<_Elem, _Traits>& _Istr)
	{	// consume whitespace
	const typename basic_istream<_Elem, _Traits>::sentry _Ok(_Istr, true);

	if (_Ok)
		{	// state okay, extract characters
		ios_base::iostate _State = ios_base::goodbit;
		const auto& _Ctype_fac = ::std:: use_facet<ctype<_Elem>>(_Istr.getloc());

		try {
		for (typename _Traits::int_type _Meta = _Istr.rdbuf()->sgetc(); ; _Meta = _Istr.rdbuf()->snextc())
			{
			if (_Traits::eq_int_type(_Traits::eof(), _Meta))
				{	// end of file, quit
				_State |= ios_base::eofbit;
				break;
				}
			else if (!_Ctype_fac.is(ctype<_Elem>::space, _Traits::to_char_type(_Meta)))
				{
				break;	// not whitespace, quit
				}
			}
		} catch (...) { (_Istr).setstate(ios_base::badbit, true); }
		_Istr.setstate(_State);
		}

	return (_Istr);
	}
}

 
 
 #pragma warning(pop)
 #pragma pack(pop)



/*
 * Copyright (c) by P.J. Plauger. All rights reserved.
 * Consult your license regarding permissions and restrictions.
V6.50:0009 */


// xstring_insert.h internal header
// Copyright (c) Microsoft Corporation. All rights reserved.
#pragma once






#pragma pack(push,8)
#pragma warning(push,3)
#pragma warning(disable: 4455 4494  4619 4643 4702 4984 4988 )




namespace std {

template<class _Elem,
	class _Traits,
	class _SizeT> inline
	basic_ostream<_Elem, _Traits>& _Insert_string(
		basic_ostream<_Elem, _Traits>& _Ostr,
		const _Elem * const _Data, const _SizeT _Size)
	{	// insert a character-type sequence into _Ostr as if through a basic_string copy
	ios_base::iostate _State = ios_base::goodbit;
	_SizeT _Pad = _Ostr.width() <= 0 || static_cast<_SizeT>(_Ostr.width()) <= _Size
		? 0 : static_cast<_SizeT>(_Ostr.width()) - _Size;
	const typename basic_ostream<_Elem, _Traits>::sentry _Ok(_Ostr);

	if (!_Ok)
		_State |= ios_base::badbit;
	else
		{	// state okay, insert characters
		try {
		if ((_Ostr.flags() & ios_base::adjustfield) != ios_base::left)
			for (; 0 < _Pad; --_Pad)	// pad on left
				if (_Traits::eq_int_type(_Traits::eof(),
					_Ostr.rdbuf()->sputc(_Ostr.fill())))
					{	// insertion failed, quit
					_State |= ios_base::badbit;
					break;
					}

		if (_State == ios_base::goodbit
			&& _Ostr.rdbuf()->sputn(_Data, (streamsize)_Size)
				!= (streamsize)_Size)
				_State |= ios_base::badbit;
		else
			for (; 0 < _Pad; --_Pad)	// pad on right
				if (_Traits::eq_int_type(_Traits::eof(),
					_Ostr.rdbuf()->sputc(_Ostr.fill())))
					{	// insertion failed, quit
					_State |= ios_base::badbit;
					break;
					}
		_Ostr.width(0);
		} catch (...) { (_Ostr).setstate(ios_base::badbit, true); }
		}

	_Ostr.setstate(_State);
	return (_Ostr);
	}

}



#pragma warning(pop)
#pragma pack(pop)








 #pragma pack(push,8)
 #pragma warning(push,3)
 #pragma warning(disable: 4455 4494  4619 4643 4702 4984 4988 )
 
 
 

namespace std {
		// basic_string INSERTERS AND EXTRACTORS
template<class _Elem,
	class _Traits,
	class _Alloc> inline
	basic_istream<_Elem, _Traits>& operator>>(
		basic_istream<_Elem, _Traits>&& _Istr,
		basic_string<_Elem, _Traits, _Alloc>& _Str)
	{	// extract a string
	typedef ctype<_Elem> _Ctype;
	typedef basic_istream<_Elem, _Traits> _Myis;
	typedef basic_string<_Elem, _Traits, _Alloc> _Mystr;
	typedef typename _Mystr::size_type _Mysizt;

	ios_base::iostate _State = ios_base::goodbit;
	bool _Changed = false;
	const typename _Myis::sentry _Ok(_Istr);

	if (_Ok)
		{	// state okay, extract characters
		const _Ctype& _Ctype_fac = ::std:: use_facet<_Ctype>(_Istr.getloc());
		_Str.erase();

		try {
		_Mysizt _Size = 0 < _Istr.width()
			&& (_Mysizt)_Istr.width() < _Str.max_size()
				? (_Mysizt)_Istr.width() : _Str.max_size();
		typename _Traits::int_type _Meta = _Istr.rdbuf()->sgetc();

		for (; 0 < _Size; --_Size, _Meta = _Istr.rdbuf()->snextc())
			if (_Traits::eq_int_type(_Traits::eof(), _Meta))
				{	// end of file, quit
				_State |= ios_base::eofbit;
				break;
				}
			else if (_Ctype_fac.is(_Ctype::space,
				_Traits::to_char_type(_Meta)))
				break;	// whitespace, quit
			else
				{	// add character to string
				_Str.push_back(_Traits::to_char_type(_Meta));
				_Changed = true;
				}
		} catch (...) { (_Istr).setstate(ios_base::badbit, true); }
		}

	_Istr.width(0);
	if (!_Changed)
		_State |= ios_base::failbit;
	_Istr.setstate(_State);
	return (_Istr);
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	basic_istream<_Elem, _Traits>& getline(
		basic_istream<_Elem, _Traits>&& _Istr,
		basic_string<_Elem, _Traits, _Alloc>& _Str,
		const _Elem _Delim)
	{	// get characters into string, discard delimiter
	typedef basic_istream<_Elem, _Traits> _Myis;

	ios_base::iostate _State = ios_base::goodbit;
	bool _Changed = false;
	const typename _Myis::sentry _Ok(_Istr, true);

	if (_Ok)
		{	// state okay, extract characters
		try {
		_Str.erase();
		const typename _Traits::int_type _Metadelim =
			_Traits::to_int_type(_Delim);
		typename _Traits::int_type _Meta = _Istr.rdbuf()->sgetc();

		for (; ; _Meta = _Istr.rdbuf()->snextc())
			if (_Traits::eq_int_type(_Traits::eof(), _Meta))
				{	// end of file, quit
				_State |= ios_base::eofbit;
				break;
				}
			else if (_Traits::eq_int_type(_Meta, _Metadelim))
				{	// got a delimiter, discard it and quit
				_Changed = true;
				_Istr.rdbuf()->sbumpc();
				break;
				}
			else if (_Str.max_size() <= _Str.size())
				{	// string too large, quit
				_State |= ios_base::failbit;
				break;
				}
			else
				{	// got a character, add it to string
				_Str += _Traits::to_char_type(_Meta);
				_Changed = true;
				}
		} catch (...) { (_Istr).setstate(ios_base::badbit, true); }
		}

	if (!_Changed)
		_State |= ios_base::failbit;
	_Istr.setstate(_State);
	return (_Istr);
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	basic_istream<_Elem, _Traits>& getline(
		basic_istream<_Elem, _Traits>&& _Istr,
		basic_string<_Elem, _Traits, _Alloc>& _Str)
	{	// get characters into string, discard newline
	return (getline(_Istr, _Str, _Istr.widen('\n')));
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	basic_istream<_Elem, _Traits>& operator>>(
		basic_istream<_Elem, _Traits>& _Istr,
		basic_string<_Elem, _Traits, _Alloc>& _Str)
	{	// extract a string
	return (::std:: move(_Istr) >> _Str);
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	basic_istream<_Elem, _Traits>& getline(
		basic_istream<_Elem, _Traits>& _Istr,
		basic_string<_Elem, _Traits, _Alloc>& _Str,
		const _Elem _Delim)
	{	// get characters into string, discard delimiter
	return (getline(::std:: move(_Istr), _Str, _Delim));
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	basic_istream<_Elem, _Traits>& getline(
		basic_istream<_Elem, _Traits>& _Istr,
		basic_string<_Elem, _Traits, _Alloc>& _Str)
	{	// get characters into string, discard newline
	return (getline(::std:: move(_Istr), _Str, _Istr.widen('\n')));
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	basic_ostream<_Elem, _Traits>& operator<<(
		basic_ostream<_Elem, _Traits>& _Ostr,
		const basic_string<_Elem, _Traits, _Alloc>& _Str)
	{	// insert a string
	return (_Insert_string(_Ostr, _Str.data(), _Str.size()));
	}

		// sto* NARROW CONVERSIONS

inline int stoi(const string& _Str, size_t *_Idx = nullptr,
	int _Base = 10)
	{	// convert string to int
	int& _Errno_ref = (*_errno());	// Nonzero cost, pay it once
	const char *_Ptr = _Str.c_str();
	char *_Eptr;
	_Errno_ref = 0;
	const long _Ans = :: strtol(_Ptr, &_Eptr, _Base);

	if (_Ptr == _Eptr)
		_Xinvalid_argument("invalid stoi argument");
	if (_Errno_ref == 34 || _Ans < (-2147483647 - 1) || 2147483647 < _Ans)
		_Xout_of_range("stoi argument out of range");
	if (_Idx != nullptr)
		*_Idx = (size_t)(_Eptr - _Ptr);
	return ((int)_Ans);
	}

inline long stol(const string& _Str, size_t *_Idx = nullptr,
	int _Base = 10)
	{	// convert string to long
	int& _Errno_ref = (*_errno());	// Nonzero cost, pay it once
	const char *_Ptr = _Str.c_str();
	char *_Eptr;
	_Errno_ref = 0;
	const long _Ans = :: strtol(_Ptr, &_Eptr, _Base);

	if (_Ptr == _Eptr)
		_Xinvalid_argument("invalid stol argument");
	if (_Errno_ref == 34)
		_Xout_of_range("stol argument out of range");
	if (_Idx != nullptr)
		*_Idx = (size_t)(_Eptr - _Ptr);
	return (_Ans);
	}

inline unsigned long stoul(const string& _Str, size_t *_Idx = nullptr,
	int _Base = 10)
	{	// convert string to unsigned long
	int& _Errno_ref = (*_errno());	// Nonzero cost, pay it once
	const char *_Ptr = _Str.c_str();
	char *_Eptr;
	_Errno_ref = 0;
	const unsigned long _Ans = :: strtoul(_Ptr, &_Eptr, _Base);

	if (_Ptr == _Eptr)
		_Xinvalid_argument("invalid stoul argument");
	if (_Errno_ref == 34)
		_Xout_of_range("stoul argument out of range");
	if (_Idx != nullptr)
		*_Idx = (size_t)(_Eptr - _Ptr);
	return (_Ans);
	}

inline long long stoll(const string& _Str, size_t *_Idx = nullptr,
	int _Base = 10)
	{	// convert string to long long
	int& _Errno_ref = (*_errno());	// Nonzero cost, pay it once
	const char *_Ptr = _Str.c_str();
	char *_Eptr;
	_Errno_ref = 0;
	const long long _Ans = :: strtoll(_Ptr, &_Eptr, _Base);

	if (_Ptr == _Eptr)
		_Xinvalid_argument("invalid stoll argument");
	if (_Errno_ref == 34)
		_Xout_of_range("stoll argument out of range");
	if (_Idx != nullptr)
		*_Idx = (size_t)(_Eptr - _Ptr);
	return (_Ans);
	}

inline unsigned long long stoull(const string& _Str, size_t *_Idx = nullptr,
	int _Base = 10)
	{	// convert string to unsigned long long
	int& _Errno_ref = (*_errno());	// Nonzero cost, pay it once
	const char *_Ptr = _Str.c_str();
	char *_Eptr;
	_Errno_ref = 0;
	const unsigned long long _Ans = :: strtoull(_Ptr, &_Eptr, _Base);

	if (_Ptr == _Eptr)
		_Xinvalid_argument("invalid stoull argument");
	if (_Errno_ref == 34)
		_Xout_of_range("stoull argument out of range");
	if (_Idx != nullptr)
		*_Idx = (size_t)(_Eptr - _Ptr);
	return (_Ans);
	}

inline float stof(const string& _Str, size_t *_Idx = nullptr)
	{	// convert string to float
	int& _Errno_ref = (*_errno());	// Nonzero cost, pay it once
	const char *_Ptr = _Str.c_str();
	char *_Eptr;
	_Errno_ref = 0;
	const float _Ans = :: strtof(_Ptr, &_Eptr);

	if (_Ptr == _Eptr)
		_Xinvalid_argument("invalid stof argument");
	if (_Errno_ref == 34)
		_Xout_of_range("stof argument out of range");
	if (_Idx != nullptr)
		*_Idx = (size_t)(_Eptr - _Ptr);
	return (_Ans);
	}

inline double stod(const string& _Str, size_t *_Idx = nullptr)
	{	// convert string to double
	int& _Errno_ref = (*_errno());	// Nonzero cost, pay it once
	const char *_Ptr = _Str.c_str();
	char *_Eptr;
	_Errno_ref = 0;
	const double _Ans = :: strtod(_Ptr, &_Eptr);

	if (_Ptr == _Eptr)
		_Xinvalid_argument("invalid stod argument");
	if (_Errno_ref == 34)
		_Xout_of_range("stod argument out of range");
	if (_Idx != nullptr)
		*_Idx = (size_t)(_Eptr - _Ptr);
	return (_Ans);
	}

inline long double stold(const string& _Str, size_t *_Idx = nullptr)
	{	// convert string to long double
	int& _Errno_ref = (*_errno());	// Nonzero cost, pay it once
	const char *_Ptr = _Str.c_str();
	char *_Eptr;
	_Errno_ref = 0;
	const long double _Ans = :: strtold(_Ptr, &_Eptr);

	if (_Ptr == _Eptr)
		_Xinvalid_argument("invalid stold argument");
	if (_Errno_ref == 34)
		_Xout_of_range("stold argument out of range");
	if (_Idx != nullptr)
		*_Idx = (size_t)(_Eptr - _Ptr);
	return (_Ans);
	}

		// sto* WIDE CONVERSIONS
inline int stoi(const wstring& _Str, size_t *_Idx = nullptr,
	int _Base = 10)
	{	// convert wstring to int
	int& _Errno_ref = (*_errno());	// Nonzero cost, pay it once
	const wchar_t *_Ptr = _Str.c_str();
	wchar_t *_Eptr;
	_Errno_ref = 0;
	const long _Ans = :: wcstol(_Ptr, &_Eptr, _Base);

	if (_Ptr == _Eptr)
		_Xinvalid_argument("invalid stoi argument");
	if (_Errno_ref == 34 || _Ans < (-2147483647 - 1) || 2147483647 < _Ans)
		_Xout_of_range("stoi argument out of range");
	if (_Idx != nullptr)
		*_Idx = (size_t)(_Eptr - _Ptr);
	return ((int)_Ans);
	}

inline long stol(const wstring& _Str, size_t *_Idx = nullptr,
	int _Base = 10)
	{	// convert wstring to long
	int& _Errno_ref = (*_errno());	// Nonzero cost, pay it once
	const wchar_t *_Ptr = _Str.c_str();
	wchar_t *_Eptr;
	_Errno_ref = 0;
	const long _Ans = :: wcstol(_Ptr, &_Eptr, _Base);

	if (_Ptr == _Eptr)
		_Xinvalid_argument("invalid stol argument");
	if (_Errno_ref == 34)
		_Xout_of_range("stol argument out of range");
	if (_Idx != nullptr)
		*_Idx = (size_t)(_Eptr - _Ptr);
	return (_Ans);
	}

inline unsigned long stoul(const wstring& _Str, size_t *_Idx = nullptr,
	int _Base = 10)
	{	// convert wstring to unsigned long
	int& _Errno_ref = (*_errno());	// Nonzero cost, pay it once
	const wchar_t *_Ptr = _Str.c_str();
	wchar_t *_Eptr;
	_Errno_ref = 0;
	const unsigned long _Ans = :: wcstoul(_Ptr, &_Eptr, _Base);

	if (_Ptr == _Eptr)
		_Xinvalid_argument("invalid stoul argument");
	if (_Errno_ref == 34)
		_Xout_of_range("stoul argument out of range");
	if (_Idx != nullptr)
		*_Idx = (size_t)(_Eptr - _Ptr);
	return (_Ans);
	}

inline long long stoll(const wstring& _Str, size_t *_Idx = nullptr,
	int _Base = 10)
	{	// convert wstring to long long
	int& _Errno_ref = (*_errno());	// Nonzero cost, pay it once
	const wchar_t *_Ptr = _Str.c_str();
	wchar_t *_Eptr;
	_Errno_ref = 0;
	const long long _Ans = :: wcstoll(_Ptr, &_Eptr, _Base);

	if (_Ptr == _Eptr)
		_Xinvalid_argument("invalid stoll argument");
	if (_Errno_ref == 34)
		_Xout_of_range("stoll argument out of range");
	if (_Idx != nullptr)
		*_Idx = (size_t)(_Eptr - _Ptr);
	return (_Ans);
	}

inline unsigned long long stoull(const wstring& _Str, size_t *_Idx = nullptr,
	int _Base = 10)
	{	// convert wstring to unsigned long long
	int& _Errno_ref = (*_errno());	// Nonzero cost, pay it once
	const wchar_t *_Ptr = _Str.c_str();
	wchar_t *_Eptr;
	_Errno_ref = 0;
	const unsigned long long _Ans = :: wcstoull(_Ptr, &_Eptr, _Base);

	if (_Ptr == _Eptr)
		_Xinvalid_argument("invalid stoull argument");
	if (_Errno_ref == 34)
		_Xout_of_range("stoull argument out of range");
	if (_Idx != nullptr)
		*_Idx = (size_t)(_Eptr - _Ptr);
	return (_Ans);
	}

inline float stof(const wstring& _Str, size_t *_Idx = nullptr)
	{	// convert wstring to float
	int& _Errno_ref = (*_errno());	// Nonzero cost, pay it once
	const wchar_t *_Ptr = _Str.c_str();
	wchar_t *_Eptr;
	_Errno_ref = 0;
	const float _Ans = :: wcstof(_Ptr, &_Eptr);

	if (_Ptr == _Eptr)
		_Xinvalid_argument("invalid stof argument");
	if (_Errno_ref == 34)
		_Xout_of_range("stof argument out of range");
	if (_Idx != nullptr)
		*_Idx = (size_t)(_Eptr - _Ptr);
	return (_Ans);
	}

inline double stod(const wstring& _Str, size_t *_Idx = nullptr)
	{	// convert wstring to double
	int& _Errno_ref = (*_errno());	// Nonzero cost, pay it once
	const wchar_t *_Ptr = _Str.c_str();
	wchar_t *_Eptr;
	_Errno_ref = 0;
	const double _Ans = :: wcstod(_Ptr, &_Eptr);

	if (_Ptr == _Eptr)
		_Xinvalid_argument("invalid stod argument");
	if (_Errno_ref == 34)
		_Xout_of_range("stod argument out of range");
	if (_Idx != nullptr)
		*_Idx = (size_t)(_Eptr - _Ptr);
	return (_Ans);
	}

inline long double stold(const wstring& _Str, size_t *_Idx = nullptr)
	{	// convert wstring to long double
	int& _Errno_ref = (*_errno());	// Nonzero cost, pay it once
	const wchar_t *_Ptr = _Str.c_str();
	wchar_t *_Eptr;
	_Errno_ref = 0;
	const long double _Ans = :: wcstold(_Ptr, &_Eptr);

	if (_Ptr == _Eptr)
		_Xinvalid_argument("invalid stold argument");
	if (_Errno_ref == 34)
		_Xout_of_range("stold argument out of range");
	if (_Idx != nullptr)
		*_Idx = (size_t)(_Eptr - _Ptr);
	return (_Ans);
	}

		// HELPERS FOR to_string AND to_wstring
template<class _Elem,
	class _UTy> inline
	_Elem* _UIntegral_to_buff(_Elem* _RNext, _UTy _UVal)
	{	// format _UVal into buffer *ending at* _RNext
	static_assert(is_unsigned_v<_UTy>, "_UTy must be unsigned");


	auto _UVal_trunc = _UVal;























	do
		{
		*--_RNext = static_cast<_Elem>('0' + _UVal_trunc % 10);
		_UVal_trunc /= 10;
		}
	while (_UVal_trunc != 0);
	return (_RNext);
	}

template<class _Elem,
	class _Ty> inline
	basic_string<_Elem> _Integral_to_string(const _Ty _Val)
	{	// convert _Val to string
	static_assert(is_integral_v<_Ty>, "_Ty must be integral");
	using _UTy = make_unsigned_t<_Ty>;
	_Elem _Buff[21]; // can hold -2^63 and 2^64 - 1, plus NUL
	_Elem* const _Buff_end = ::std:: end(_Buff);
	_Elem* _RNext = _Buff_end;
	const auto _UVal = static_cast<_UTy>(_Val);
	if (_Val < 0)
		{
		_RNext = _UIntegral_to_buff(_RNext, 0 - _UVal);
		*--_RNext = '-';
		}
	else
		_RNext = _UIntegral_to_buff(_RNext, _UVal);

	return (basic_string<_Elem>(_RNext, _Buff_end));
	}

template<class _Ty> inline
	string _Floating_to_string(const char *_Fmt, _Ty _Val)
	{	// convert _Val to string
	static_assert(is_floating_point_v<_Ty>,
		"_Ty must be floating point");

	const auto _Len = static_cast<size_t>(:: _scprintf(_Fmt, _Val));
	string _Str(_Len, '\0');
	:: sprintf_s(&_Str[0], _Len + 1, _Fmt, _Val);
	return (_Str);
	}

template<class _Ty> inline
	wstring _Floating_to_wstring(const wchar_t *_Fmt, _Ty _Val)
	{	// convert _Val to wstring
	static_assert(is_floating_point_v<_Ty>,
		"_Ty must be floating point");

	const auto _Len = static_cast<size_t>(:: _scwprintf(_Fmt, _Val));
	wstring _Str(_Len, L'\0');
	:: swprintf_s(&_Str[0], _Len + 1, _Fmt, _Val);
	return (_Str);
	}



		// to_string NARROW CONVERSIONS
 inline string to_string(int _Val)
	{	// convert int to string
	return (_Integral_to_string<char>(_Val));
	}

 inline string to_string(unsigned int _Val)
	{	// convert unsigned int to string
	return (_Integral_to_string<char>(_Val));
	}

 inline string to_string(long _Val)
	{	// convert long to string
	return (_Integral_to_string<char>(_Val));
	}

 inline string to_string(unsigned long _Val)
	{	// convert unsigned long to string
	return (_Integral_to_string<char>(_Val));
	}

 inline string to_string(long long _Val)
	{	// convert long long to string
	return (_Integral_to_string<char>(_Val));
	}

 inline string to_string(unsigned long long _Val)
	{	// convert unsigned long long to string
	return (_Integral_to_string<char>(_Val));
	}

 inline string to_string(float _Val)
	{	// convert float to string
	return (_Floating_to_string("%f", _Val));
	}

 inline string to_string(double _Val)
	{	// convert double to string
	return (_Floating_to_string("%f", _Val));
	}

 inline string to_string(long double _Val)
	{	// convert long double to string
	return (_Floating_to_string("%Lf", _Val));
	}

		// to_wstring WIDE CONVERSIONS
 inline wstring to_wstring(int _Val)
	{	// convert int to wstring
	return (_Integral_to_string<wchar_t>(_Val));
	}

 inline wstring to_wstring(unsigned int _Val)
	{	// convert unsigned int to wstring
	return (_Integral_to_string<wchar_t>(_Val));
	}

 inline wstring to_wstring(long _Val)
	{	// convert long to wstring
	return (_Integral_to_string<wchar_t>(_Val));
	}

 inline wstring to_wstring(unsigned long _Val)
	{	// convert unsigned long to wstring
	return (_Integral_to_string<wchar_t>(_Val));
	}

 inline wstring to_wstring(long long _Val)
	{	// convert long long to wstring
	return (_Integral_to_string<wchar_t>(_Val));
	}

 inline wstring to_wstring(unsigned long long _Val)
	{	// convert unsigned long long to wstring
	return (_Integral_to_string<wchar_t>(_Val));
	}

 inline wstring to_wstring(float _Val)
	{	// convert float to wstring
	return (_Floating_to_wstring(L"%f", _Val));
	}

 inline wstring to_wstring(double _Val)
	{	// convert double to wstring
	return (_Floating_to_wstring(L"%f", _Val));
	}

 inline wstring to_wstring(long double _Val)
	{	// convert long double to wstring
	return (_Floating_to_wstring(L"%Lf", _Val));
	}

	// basic_string LITERALS
inline namespace literals {
inline namespace string_literals {
 inline string operator "" s(const char *_Str, size_t _Len)
	{	// construct literal from [_Str, _Str + _Len)
	return (string(_Str, _Len));
	}

 inline wstring operator "" s(const wchar_t *_Str, size_t _Len)
	{	// construct literal from [_Str, _Str + _Len)
	return (wstring(_Str, _Len));
	}

 inline u16string operator "" s(const char16_t *_Str, size_t _Len)
	{	// construct literal from [_Str, _Str + _Len)
	return (u16string(_Str, _Len));
	}

 inline u32string operator "" s(const char32_t *_Str, size_t _Len)
	{	// construct literal from [_Str, _Str + _Len)
	return (u32string(_Str, _Len));
	}
}	// inline namespace string_literals
}	// inline namespace literals














}

 
 
 #pragma warning(pop)
 #pragma pack(pop)



/*
 * Copyright (c) by P.J. Plauger. All rights reserved.
 * Consult your license regarding permissions and restrictions.
V6.50:0009 */


class Console
{
public:
	static void hideCursor();
	static void fixEncoding();
	static void sayGoodbye();
private:
	Console() = delete;
	static std::string goodbyeMessage;
};


#pragma once

#pragma once

// stack standard header
#pragma once




// deque standard header
#pragma once










 #pragma pack(push,8)
 #pragma warning(push,3)
 #pragma warning(disable: 4455 4494  4619 4643 4702 4984 4988 )
 
 
 

namespace std {
	// DEQUE PARAMETERS







		// CLASS TEMPLATE _Deque_unchecked_const_iterator
template<class _Mydeque>
	class _Deque_unchecked_const_iterator
	{	// iterator for nonmutable deque
private:
	using _Size_type = typename _Mydeque::size_type;
public:
	using iterator_category = random_access_iterator_tag;

	using value_type = typename _Mydeque::value_type;
	using difference_type = typename _Mydeque::difference_type;
	using pointer = typename _Mydeque::const_pointer;
	using reference = const value_type&;

	_Deque_unchecked_const_iterator()
		: _Mycont(),
		_Myoff(0)
		{	// construct with null pointer
		}

	_Deque_unchecked_const_iterator(_Size_type _Off,
		const _Container_base12 *_Pdeque)
		: _Mycont(static_cast<const _Mydeque *>(_Pdeque)),
		_Myoff(_Off)
		{	// construct with offset _Off
		}

	 reference operator*() const
		{	// return designated object
		_Size_type _Block = _Mycont->_Getblock(_Myoff);
		_Size_type _Off = _Myoff % (sizeof (value_type) <= 1 ? 16 : sizeof (value_type) <= 2 ? 8 : sizeof (value_type) <= 4 ? 4 : sizeof (value_type) <= 8 ? 2 : 1);
		return (_Mycont->_Map[_Block][_Off]);
		}

	 pointer operator->() const
		{	// return pointer to class object
		return (pointer_traits<pointer>::pointer_to(**this));
		}

	_Deque_unchecked_const_iterator& operator++()
		{	// preincrement
		++_Myoff;
		return (*this);
		}

	_Deque_unchecked_const_iterator operator++(int)
		{	// postincrement
		_Deque_unchecked_const_iterator _Tmp = *this;
		++*this;
		return (_Tmp);
		}

	_Deque_unchecked_const_iterator& operator--()
		{	// predecrement
		--_Myoff;
		return (*this);
		}

	_Deque_unchecked_const_iterator operator--(int)
		{	// postdecrement
		_Deque_unchecked_const_iterator _Tmp = *this;
		--*this;
		return (_Tmp);
		}

	_Deque_unchecked_const_iterator& operator+=(const difference_type _Off)
		{	// increment by integer
		_Myoff += _Off;
		return (*this);
		}

	 _Deque_unchecked_const_iterator operator+(const difference_type _Off) const
		{	// return this + integer
		_Deque_unchecked_const_iterator _Tmp = *this;
		return (_Tmp += _Off);
		}

	_Deque_unchecked_const_iterator& operator-=(const difference_type _Off)
		{	// decrement by integer
		return (*this += -_Off);
		}

	 _Deque_unchecked_const_iterator operator-(const difference_type _Off) const
		{	// return this - integer
		_Deque_unchecked_const_iterator _Tmp = *this;
		return (_Tmp -= _Off);
		}

	 difference_type operator-(const _Deque_unchecked_const_iterator& _Right) const
		{	// return difference of iterators
		return (static_cast<difference_type>(_Myoff - _Right._Myoff));
		}

	 reference operator[](const difference_type _Off) const
		{	// subscript
		return (*(*this + _Off));
		}

	 bool operator==(const _Deque_unchecked_const_iterator& _Right) const
		{	// test for iterator equality
		return (_Myoff == _Right._Myoff);
		}

	 bool operator!=(const _Deque_unchecked_const_iterator& _Right) const
		{	// test for iterator inequality
		return (!(*this == _Right));
		}

	 bool operator<(const _Deque_unchecked_const_iterator& _Right) const
		{	// test if this < _Right
		return (_Myoff < _Right._Myoff);
		}

	 bool operator>(const _Deque_unchecked_const_iterator& _Right) const
		{	// test if this > _Right
		return (_Right < *this);
		}

	 bool operator<=(const _Deque_unchecked_const_iterator& _Right) const
		{	// test if this <= _Right
		return (!(_Right < *this));
		}

	 bool operator>=(const _Deque_unchecked_const_iterator& _Right) const
		{	// test if this >= _Right
		return (!(*this < _Right));
		}

	const _Container_base12 *_Getcont() const
		{	// get container pointer
		return (_Mycont);
		}

	const _Mydeque *_Mycont;	// pointer to deque
	_Size_type _Myoff;	// offset of element in deque
	};

template<class _Mydeque>
	 inline _Deque_unchecked_const_iterator<_Mydeque> operator+(
		typename _Deque_unchecked_const_iterator<_Mydeque>
			::difference_type _Off,
		_Deque_unchecked_const_iterator<_Mydeque> _Next)
	{	// add offset to iterator
	return (_Next += _Off);
	}

		// CLASS TEMPLATE _Deque_unchecked_iterator
template<class _Mydeque>
	class _Deque_unchecked_iterator
		: public _Deque_unchecked_const_iterator<_Mydeque>
	{	// iterator for mutable deque
private:
	using _Size_type = typename _Mydeque::size_type;
	using _Mybase = _Deque_unchecked_const_iterator<_Mydeque>;

public:
	using iterator_category = random_access_iterator_tag;

	using value_type = typename _Mydeque::value_type;
	using difference_type = typename _Mydeque::difference_type;
	using pointer = typename _Mydeque::pointer;
	using reference = value_type&;

	_Deque_unchecked_iterator()
		{	// construct with null pointer
		}

	_Deque_unchecked_iterator(_Size_type _Off,
		const _Container_base12 *_Pdeque)
		: _Mybase(_Off, _Pdeque)
		{	// construct with offset _Off
		}

	 reference operator*() const
		{	// return designated object
		return ((reference)**(_Mybase *)this);
		}

	 pointer operator->() const
		{	// return pointer to class object
		return (pointer_traits<pointer>::pointer_to(**this));
		}

	_Deque_unchecked_iterator& operator++()
		{	// preincrement
		++*(_Mybase *)this;
		return (*this);
		}

	_Deque_unchecked_iterator operator++(int)
		{	// postincrement
		_Deque_unchecked_iterator _Tmp = *this;
		++*this;
		return (_Tmp);
		}

	_Deque_unchecked_iterator& operator--()
		{	// predecrement
		--*(_Mybase *)this;
		return (*this);
		}

	_Deque_unchecked_iterator operator--(int)
		{	// postdecrement
		_Deque_unchecked_iterator _Tmp = *this;
		--*this;
		return (_Tmp);
		}

	_Deque_unchecked_iterator& operator+=(const difference_type _Off)
		{	// increment by integer
		*(_Mybase *)this += _Off;
		return (*this);
		}

	 _Deque_unchecked_iterator operator+(const difference_type _Off) const
		{	// return this + integer
		_Deque_unchecked_iterator _Tmp = *this;
		return (_Tmp += _Off);
		}

	_Deque_unchecked_iterator& operator-=(const difference_type _Off)
		{	// decrement by integer
		return (*this += -_Off);
		}

	 _Deque_unchecked_iterator operator-(const difference_type _Off) const
		{	// return this - integer
		_Deque_unchecked_iterator _Tmp = *this;
		return (_Tmp -= _Off);
		}

	 difference_type operator-(const _Mybase& _Right) const
		{	// return difference of iterators
		return (*(_Mybase *)this - _Right);
		}

	 reference operator[](const difference_type _Off) const
		{	// subscript
		return (*(*this + _Off));
		}
	};

template<class _Mydeque>
	 inline _Deque_unchecked_iterator<_Mydeque> operator+(
		typename _Deque_unchecked_iterator<_Mydeque>
			::difference_type _Off,
		_Deque_unchecked_iterator<_Mydeque> _Next)
	{	// add offset to iterator
	return (_Next += _Off);
	}

		// CLASS TEMPLATE _Deque_const_iterator
template<class _Mydeque>
	class _Deque_const_iterator
		: public _Iterator_base12
	{	// iterator for nonmutable deque
private:
	using _Size_type = typename _Mydeque::size_type;

public:
	using iterator_category = random_access_iterator_tag;

	using value_type = typename _Mydeque::value_type;
	using difference_type = typename _Mydeque::difference_type;
	using pointer = typename _Mydeque::const_pointer;
	using reference = const value_type&;

	using _Mydeque_t = _Mydeque;	// helper for expression evaluator
	enum {_EEN_DS = (sizeof (value_type) <= 1 ? 16 : sizeof (value_type) <= 2 ? 8 : sizeof (value_type) <= 4 ? 4 : sizeof (value_type) <= 8 ? 2 : 1)};	// helper for expression evaluator
	_Deque_const_iterator()
		: _Myoff(0)
		{	// construct with null pointer
		_Setcont(nullptr);
		}

	_Deque_const_iterator(_Size_type _Off, const _Container_base12 *_Pdeque)
		: _Myoff(_Off)
		{	// construct with offset _Off in *_Pdeque
		_Setcont((_Mydeque *)_Pdeque);
		}

	 reference operator*() const
		{	// return designated object
		const auto _Mycont = static_cast<const _Mydeque *>(this->_Getcont());
 
		do { if (_Mycont) { } else { do { (void) ((1 != _CrtDbgReport(2, "c:\\visual studio\\vc\\tools\\msvc\\14.16.27023\\include\\deque", 315, 0, "%s", "cannot dereference value-initialized deque iterator")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"cannot dereference value-initialized deque iterator\"", __LPREFIX( __FUNCTION__), L"c:\\visual studio\\vc\\tools\\msvc\\14.16.27023\\include\\deque", 315, 0); } while (false); } ; } while (false);
		do { if (_Mycont->_Myoff <= this->_Myoff && this->_Myoff < _Mycont->_Myoff + _Mycont->_Mysize) { } else { do { (void) ((1 != _CrtDbgReport(2, "c:\\visual studio\\vc\\tools\\msvc\\14.16.27023\\include\\deque", 318, 0, "%s", "cannot deference out of range deque iterator")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"cannot deference out of range deque iterator\"", __LPREFIX( __FUNCTION__), L"c:\\visual studio\\vc\\tools\\msvc\\14.16.27023\\include\\deque", 318, 0); } while (false); } ; } while (false);
 

		_Size_type _Block = _Mycont->_Getblock(_Myoff);
		_Size_type _Off = _Myoff % (sizeof (value_type) <= 1 ? 16 : sizeof (value_type) <= 2 ? 8 : sizeof (value_type) <= 4 ? 4 : sizeof (value_type) <= 8 ? 2 : 1);
		return (_Mycont->_Map[_Block][_Off]);
		}

	 pointer operator->() const
		{	// return pointer to class object
		return (pointer_traits<pointer>::pointer_to(**this));
		}

	_Deque_const_iterator& operator++()
		{	// preincrement
 
		const auto _Mycont = static_cast<const _Mydeque *>(this->_Getcont());
		do { if (_Mycont) { } else { do { (void) ((1 != _CrtDbgReport(2, "c:\\visual studio\\vc\\tools\\msvc\\14.16.27023\\include\\deque", 335, 0, "%s", "cannot increment value-initialized deque iterator")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"cannot increment value-initialized deque iterator\"", __LPREFIX( __FUNCTION__), L"c:\\visual studio\\vc\\tools\\msvc\\14.16.27023\\include\\deque", 335, 0); } while (false); } ; } while (false);
		do { if (this->_Myoff < _Mycont->_Myoff + _Mycont->_Mysize) { } else { do { (void) ((1 != _CrtDbgReport(2, "c:\\visual studio\\vc\\tools\\msvc\\14.16.27023\\include\\deque", 337, 0, "%s", "cannot increment deque iterator past end")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"cannot increment deque iterator past end\"", __LPREFIX( __FUNCTION__), L"c:\\visual studio\\vc\\tools\\msvc\\14.16.27023\\include\\deque", 337, 0); } while (false); } ; } while (false);
 

		++_Myoff;
		return (*this);
		}

	_Deque_const_iterator operator++(int)
		{	// postincrement
		_Deque_const_iterator _Tmp = *this;
		++*this;
		return (_Tmp);
		}

	_Deque_const_iterator& operator--()
		{	// predecrement
 
		const auto _Mycont = static_cast<const _Mydeque *>(this->_Getcont());
		do { if (_Mycont) { } else { do { (void) ((1 != _CrtDbgReport(2, "c:\\visual studio\\vc\\tools\\msvc\\14.16.27023\\include\\deque", 355, 0, "%s", "cannot decrement value-initialized deque iterator")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"cannot decrement value-initialized deque iterator\"", __LPREFIX( __FUNCTION__), L"c:\\visual studio\\vc\\tools\\msvc\\14.16.27023\\include\\deque", 355, 0); } while (false); } ; } while (false);
		do { if (_Mycont->_Myoff < this->_Myoff) { } else { do { (void) ((1 != _CrtDbgReport(2, "c:\\visual studio\\vc\\tools\\msvc\\14.16.27023\\include\\deque", 356, 0, "%s", "cannot decrement deque iterator before begin")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"cannot decrement deque iterator before begin\"", __LPREFIX( __FUNCTION__), L"c:\\visual studio\\vc\\tools\\msvc\\14.16.27023\\include\\deque", 356, 0); } while (false); } ; } while (false);
 

		--_Myoff;
		return (*this);
		}

	_Deque_const_iterator operator--(int)
		{	// postdecrement
		_Deque_const_iterator _Tmp = *this;
		--*this;
		return (_Tmp);
		}

	_Deque_const_iterator& operator+=(const difference_type _Off)
		{	// increment by integer
 
		if (_Off != 0)
			{
			const auto _Mycont = static_cast<const _Mydeque *>(this->_Getcont());
			do { if (_Mycont) { } else { do { (void) ((1 != _CrtDbgReport(2, "c:\\visual studio\\vc\\tools\\msvc\\14.16.27023\\include\\deque", 376, 0, "%s", "cannot seek value-initialized deque iterator")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"cannot seek value-initialized deque iterator\"", __LPREFIX( __FUNCTION__), L"c:\\visual studio\\vc\\tools\\msvc\\14.16.27023\\include\\deque", 376, 0); } while (false); } ; } while (false);
			do { if (_Mycont->_Myoff <= this->_Myoff + _Off && this->_Myoff + _Off <= _Mycont->_Myoff + _Mycont->_Mysize) { } else { do { (void) ((1 != _CrtDbgReport(2, "c:\\visual studio\\vc\\tools\\msvc\\14.16.27023\\include\\deque", 379, 0, "%s", "cannot seek deque iterator out of range")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"cannot seek deque iterator out of range\"", __LPREFIX( __FUNCTION__), L"c:\\visual studio\\vc\\tools\\msvc\\14.16.27023\\include\\deque", 379, 0); } while (false); } ; } while (false);
			}
 

		_Myoff += _Off;
		return (*this);
		}

	 _Deque_const_iterator operator+(const difference_type _Off) const
		{	// return this + integer
		_Deque_const_iterator _Tmp = *this;
		return (_Tmp += _Off);
		}

	_Deque_const_iterator& operator-=(const difference_type _Off)
		{	// decrement by integer
		return (*this += -_Off);
		}

	 _Deque_const_iterator operator-(const difference_type _Off) const
		{	// return this - integer
		_Deque_const_iterator _Tmp = *this;
		return (_Tmp -= _Off);
		}

	 difference_type operator-(const _Deque_const_iterator& _Right) const
		{	// return difference of iterators
		_Compat(_Right);
		return (static_cast<difference_type>(this->_Myoff - _Right._Myoff));
		}

	 reference operator[](const difference_type _Off) const
		{	// subscript
		return (*(*this + _Off));
		}

	 bool operator==(const _Deque_const_iterator& _Right) const
		{	// test for iterator equality
		_Compat(_Right);
		return (this->_Myoff == _Right._Myoff);
		}

	 bool operator!=(const _Deque_const_iterator& _Right) const
		{	// test for iterator inequality
		return (!(*this == _Right));
		}

	 bool operator<(const _Deque_const_iterator& _Right) const
		{	// test if this < _Right
		_Compat(_Right);
		return (this->_Myoff < _Right._Myoff);
		}

	 bool operator>(const _Deque_const_iterator& _Right) const
		{	// test if this > _Right
		return (_Right < *this);
		}

	 bool operator<=(const _Deque_const_iterator& _Right) const
		{	// test if this <= _Right
		return (!(_Right < *this));
		}

	 bool operator>=(const _Deque_const_iterator& _Right) const
		{	// test if this >= _Right
		return (!(*this < _Right));
		}

	void _Compat(const _Deque_const_iterator& _Right) const
		{	// test for compatible iterator pair
 


		do { if (this->_Getcont() == _Right._Getcont()) { } else { do { (void) ((1 != _CrtDbgReport(2, "c:\\visual studio\\vc\\tools\\msvc\\14.16.27023\\include\\deque", 452, 0, "%s", "deque iterators incompatible")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"deque iterators incompatible\"", __LPREFIX( __FUNCTION__), L"c:\\visual studio\\vc\\tools\\msvc\\14.16.27023\\include\\deque", 452, 0); } while (false); } ; } while (false);
 
		}

	void _Setcont(const _Mydeque *_Pdeque)
		{	// set container pointer
		this->_Adopt(_Pdeque);
		}

	 _Deque_unchecked_const_iterator<_Mydeque> _Unwrapped() const
		{
		return {this->_Myoff, this->_Getcont()};
		}

	void _Verify_offset(const difference_type _Off) const noexcept
		{
 


		if (_Off != 0)
			{
			const auto _Mycont = static_cast<const _Mydeque *>(this->_Getcont());
			do { if (_Mycont) { } else { do { (void) ((1 != _CrtDbgReport(2, "c:\\visual studio\\vc\\tools\\msvc\\14.16.27023\\include\\deque", 474, 0, "%s", "cannot use value-initialized deque iterator")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"cannot use value-initialized deque iterator\"", __LPREFIX( __FUNCTION__), L"c:\\visual studio\\vc\\tools\\msvc\\14.16.27023\\include\\deque", 474, 0); } while (false); } ; } while (false);
			do { if (_Mycont->_Myoff <= this->_Myoff + _Off && this->_Myoff + _Off <= _Mycont->_Myoff + _Mycont->_Mysize) { } else { do { (void) ((1 != _CrtDbgReport(2, "c:\\visual studio\\vc\\tools\\msvc\\14.16.27023\\include\\deque", 477, 0, "%s", "cannot seek deque iterator out of range")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"cannot seek deque iterator out of range\"", __LPREFIX( __FUNCTION__), L"c:\\visual studio\\vc\\tools\\msvc\\14.16.27023\\include\\deque", 477, 0); } while (false); } ; } while (false);
			}
 
		}

 
	friend void _Verify_range(const _Deque_const_iterator& _First, const _Deque_const_iterator& _Last)
		{
		// note _Compat check inside operator<=
		do { if (_First <= _Last) { } else { do { (void) ((1 != _CrtDbgReport(2, "c:\\visual studio\\vc\\tools\\msvc\\14.16.27023\\include\\deque", 486, 0, "%s", "deque iterators transposed")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"deque iterators transposed\"", __LPREFIX( __FUNCTION__), L"c:\\visual studio\\vc\\tools\\msvc\\14.16.27023\\include\\deque", 486, 0); } while (false); } ; } while (false);
		}
 

	void _Seek_to(const _Deque_unchecked_const_iterator<_Mydeque>& _UIt)
		{
		_Myoff = _UIt._Myoff;
		}

	_Size_type _Myoff;	// offset of element in deque
	};

template<class _Mydeque>
	 inline _Deque_const_iterator<_Mydeque> operator+(
		typename _Deque_const_iterator<_Mydeque>::difference_type _Off,
		_Deque_const_iterator<_Mydeque> _Next)
	{	// add offset to iterator
	return (_Next += _Off);
	}

		// CLASS TEMPLATE _Deque_iterator
template<class _Mydeque>
	class _Deque_iterator
		: public _Deque_const_iterator<_Mydeque>
		{	// iterator for mutable deque
private:
	using _Size_type = typename _Mydeque::size_type;
	using _Mybase = _Deque_const_iterator<_Mydeque>;

public:
	using _Deque_unchecked_type = _Deque_unchecked_iterator<_Mydeque>;
	using iterator_category = random_access_iterator_tag;

	using value_type = typename _Mydeque::value_type;
	using difference_type = typename _Mydeque::difference_type;
	using pointer = typename _Mydeque::pointer;
	using reference = value_type&;

	_Deque_iterator()
		{	// construct with null deque pointer
		}

	_Deque_iterator(_Size_type _Off, const _Container_base12 *_Pdeque)
		: _Mybase(_Off, _Pdeque)
		{	// construct with offset _Off in *_Pdeque
		}

	 reference operator*() const
		{	// return designated object
		return ((reference)**(_Mybase *)this);
		}

	 pointer operator->() const
		{	// return pointer to class object
		return (pointer_traits<pointer>::pointer_to(**this));
		}

	_Deque_iterator& operator++()
		{	// preincrement
		++*(_Mybase *)this;
		return (*this);
		}

	_Deque_iterator operator++(int)
		{	// postincrement
		_Deque_iterator _Tmp = *this;
		++*this;
		return (_Tmp);
		}

	_Deque_iterator& operator--()
		{	// predecrement
		--*(_Mybase *)this;
		return (*this);
		}

	_Deque_iterator operator--(int)
		{	// postdecrement
		_Deque_iterator _Tmp = *this;
		--*this;
		return (_Tmp);
		}

	_Deque_iterator& operator+=(const difference_type _Off)
		{	// increment by integer
		this->_Myoff += _Off;
		return (*this);
		}

	 _Deque_iterator operator+(const difference_type _Off) const
		{	// return this + integer
		_Deque_iterator _Tmp = *this;
		return (_Tmp += _Off);
		}

	_Deque_iterator& operator-=(const difference_type _Off)
		{	// decrement by integer
		return (*this += -_Off);
		}

	 _Deque_iterator operator-(const difference_type _Off) const
		{	// return this - integer
		_Deque_iterator _Tmp = *this;
		return (_Tmp -= _Off);
		}

	 difference_type operator-(const _Mybase& _Right) const
		{	// return difference of iterators
		return (*(_Mybase *)this - _Right);
		}

	 reference operator[](const difference_type _Off) const
		{	// subscript
		return (*(*this + _Off));
		}

	 _Deque_unchecked_iterator<_Mydeque> _Unwrapped() const
		{
		return {this->_Myoff, this->_Getcont()};
		}
	};

template<class _Mydeque>
	 inline _Deque_iterator<_Mydeque> operator+(
		typename _Deque_iterator<_Mydeque>::difference_type _Off,
		_Deque_iterator<_Mydeque> _Next)
	{	// add offset to iterator
	return (_Next += _Off);
	}

		// deque TYPE WRAPPERS
template<class _Value_type,
	class _Size_type,
	class _Difference_type,
	class _Pointer,
	class _Const_pointer,
	class _Reference,
	class _Const_reference,
	class _Mapptr_type>
	struct _Deque_iter_types
	{	// wraps types needed by iterators
	using value_type = _Value_type;
	using size_type = _Size_type;
	using difference_type = _Difference_type;
	using pointer = _Pointer;
	using const_pointer = _Const_pointer;
	using _Mapptr = _Mapptr_type;
	};

template<class _Ty>
	struct _Deque_simple_types
		: public _Simple_types<_Ty>
	{	// wraps types needed by iterators
	using _Mapptr = _Ty **;
	};

template<class _Ty,
	class _Alloc>
	struct _Deque_base_types
	{	// types needed for a container base
	using _Alty = _Rebind_alloc_t<_Alloc, _Ty>;
	using _Alty_traits = allocator_traits<_Alty>;
	using _Alpty = _Rebind_alloc_t<_Alloc, typename _Alty_traits::pointer>;
	using _Alpty_traits = allocator_traits<_Alpty>;
	using _Mapptr = typename _Alpty_traits::pointer;

	using _Val_types = conditional_t<_Is_simple_alloc_v<_Alty>,
		_Deque_simple_types<_Ty>,
		_Deque_iter_types<_Ty,
			typename _Alty_traits::size_type,
			typename _Alty_traits::difference_type,
			typename _Alty_traits::pointer,
			typename _Alty_traits::const_pointer,
			_Ty&,
			const _Ty&,
			_Mapptr>>;
	};

		// CLASS TEMPLATE _Deque_val
template<class _Val_types>
	class _Deque_val
		: public _Container_base12
	{	// base class for deque to hold data
public:
	using value_type = typename _Val_types::value_type;
	using size_type = typename _Val_types::size_type;
	using difference_type = typename _Val_types::difference_type;
	using pointer = typename _Val_types::pointer;
	using const_pointer = typename _Val_types::const_pointer;
	using reference = value_type&;
	using const_reference = const value_type&;
	using _Mapptr = typename _Val_types::_Mapptr;

	_Deque_val()
		: _Map(),
		_Mapsize(0),
		_Myoff(0),
		_Mysize(0)
		{	// initialize values
		}

	size_type _Getblock(size_type _Off) const
		{	// determine block from offset
			// NB: _Mapsize and _DEQUESIZ are guaranteed to be powers of 2
		return ((_Off / (sizeof (value_type) <= 1 ? 16 : sizeof (value_type) <= 2 ? 8 : sizeof (value_type) <= 4 ? 4 : sizeof (value_type) <= 8 ? 2 : 1)) & (_Mapsize - 1));
		}

	_Mapptr _Map;		// pointer to array of pointers to blocks
	size_type _Mapsize;	// size of map array, zero or 2^N
	size_type _Myoff;	// offset of initial element
	size_type _Mysize;	// current length of sequence
	};

		// CLASS TEMPLATE _Deque_alloc
template<class _Alloc_types>
	class _Deque_alloc
	{	// base class for deque to hold allocator
public:
	using _Alty = typename _Alloc_types::_Alty;
	using _Alty_traits = typename _Alloc_types::_Alty_traits;
	using _Alpty = typename _Alloc_types::_Alpty;
	using _Alpty_traits = typename _Alloc_types::_Alpty_traits;
	using _Alproxy = _Rebind_alloc_t<_Alty, _Container_proxy>;
	using _Alproxy_traits = allocator_traits<_Alproxy>;
	using _Val_types = typename _Alloc_types::_Val_types;

	using size_type = typename _Val_types::size_type;
	using difference_type = typename _Val_types::difference_type;
	using pointer = typename _Val_types::pointer;
	using const_pointer = typename _Val_types::const_pointer;
	using _Mapptr = typename _Val_types::_Mapptr;

	using iterator = _Deque_iterator<_Deque_val<_Val_types>>;
	using const_iterator = _Deque_const_iterator<_Deque_val<_Val_types>>;
	using _Unchecked_iterator = _Deque_unchecked_iterator<_Deque_val<_Val_types>>;
	using _Unchecked_const_iterator = _Deque_unchecked_const_iterator<_Deque_val<_Val_types>>;

	size_type _Getblock(size_type _Off) const
		{	// determine block from offset
		return (_Get_data()._Getblock(_Off));
		}

	_Deque_alloc()
		: _Mypair(_Zero_then_variadic_args_t())
		{	// default construct allocator
		_Alloc_proxy();
		}

	template<class _Any_alloc,
		class = enable_if_t<!is_same_v<remove_cv_t<remove_reference_t<_Any_alloc>>, _Deque_alloc>>>
		_Deque_alloc(_Any_alloc&& _Al)
		: _Mypair(_One_then_variadic_args_t(),
			::std:: forward<_Any_alloc>(_Al))
		{	// construct allocator from _Al
		_Alloc_proxy();
		}

	~_Deque_alloc() noexcept
		{	// destroy proxy
		_Free_proxy();
		}

	void _Copy_alloc(const _Alty& _Al)
		{	// replace old allocator
		const bool _Reload = _Alty_traits::propagate_on_container_copy_assignment::value
			&& _Getal() != _Al;

		if (_Reload)
			{
			_Free_proxy();
			}

		_Pocca(_Getal(), _Al);

		if (_Reload)
			{
			_Alloc_proxy();
			}
		}

	void _Move_alloc(_Alty& _Al)
		{	// replace old allocator
		const bool _Reload = _Alty_traits::propagate_on_container_move_assignment::value
			&& _Getal() != _Al;

		if (_Reload)
			{
			_Free_proxy();
			}

		_Pocma(_Getal(), _Al);

		if (_Reload)
			{
			_Alloc_proxy();
			}
		}

	void _Alloc_proxy()
		{	// construct proxy
		_Alproxy _Proxy_allocator(_Getal());
		_Myproxy() = _Unfancy(_Proxy_allocator.allocate(1));
		_Alproxy_traits::construct(_Proxy_allocator, _Myproxy(), _Container_proxy());
		_Myproxy()->_Mycont = ::std:: addressof(_Get_data());
		}

	void _Free_proxy()
		{	// destroy proxy
		_Alproxy _Proxy_allocator(_Getal());
		_Orphan_all();
		_Alproxy_traits::destroy(_Proxy_allocator, _Myproxy());
		_Deallocate_plain(_Proxy_allocator, _Myproxy());
		_Myproxy() = nullptr;
		}

	_Iterator_base12 **_Getpfirst() const
		{	// get address of iterator chain
		return (_Get_data()._Getpfirst());
		}

	_Container_proxy * & _Myproxy() noexcept
		{	// return reference to _Myproxy
		return (_Get_data()._Myproxy);
		}

	_Container_proxy * const & _Myproxy() const noexcept
		{	// return const reference to _Myproxy
		return (_Get_data()._Myproxy);
		}

	void _Orphan_all()
		{	// orphan all iterators
		_Get_data()._Orphan_all();
		}

	void _Swap_all(_Deque_alloc& _Right)
		{	// swap all iterators
		_Get_data()._Swap_all(_Right._Get_data());
		}

	_Alty& _Getal() noexcept
		{	// return reference to allocator
		return (_Mypair._Get_first());
		}

	const _Alty& _Getal() const noexcept
		{	// return const reference to allocator
		return (_Mypair._Get_first());
		}

	_Deque_val<_Val_types>& _Get_data() noexcept
		{	// return reference to _Deque_val
		return (_Mypair._Get_second());
		}

	const _Deque_val<_Val_types>& _Get_data() const noexcept
		{	// return const reference to _Deque_val
		return (_Mypair._Get_second());
		}

	_Mapptr& _Map() noexcept
		{	// return reference to _Map
		return (_Get_data()._Map);
		}

	const _Mapptr& _Map() const noexcept
		{	// return const reference to _Map
		return (_Get_data()._Map);
		}

	size_type& _Mapsize() noexcept
		{	// return reference to _Mapsize
		return (_Get_data()._Mapsize);
		}

	const size_type& _Mapsize() const noexcept
		{	// return const reference to _Mapsize
		return (_Get_data()._Mapsize);
		}

	size_type& _Myoff() noexcept
		{	// return reference to _Myoff
		return (_Get_data()._Myoff);
		}

	const size_type& _Myoff() const noexcept
		{	// return const reference to _Myoff
		return (_Get_data()._Myoff);
		}

	size_type& _Mysize() noexcept
		{	// return reference to _Mysize
		return (_Get_data()._Mysize);
		}

	const size_type& _Mysize() const noexcept
		{	// return const reference to _Mysize
		return (_Get_data()._Mysize);
		}

private:
	_Compressed_pair<_Alty, _Deque_val<_Val_types>> _Mypair;
	};

		// CLASS TEMPLATE deque
template<class _Ty,
	class _Alloc = allocator<_Ty>>
	class deque
		: public _Deque_alloc<_Deque_base_types<_Ty, _Alloc>>
	{	// circular queue of pointers to blocks
private:
	using _Mybase = _Deque_alloc<_Deque_base_types<_Ty, _Alloc>>;

public:
	static_assert(!0 || is_same_v<_Ty, typename _Alloc::value_type>,
		"deque<T, Allocator>" " requires that Allocator's value_type match " "T" " (See N4659 26.2.1 [container.requirements.general]/16 allocator_type)" " Either fix the allocator value_type or define _ENFORCE_MATCHING_ALLOCATORS=0" " to suppress this diagnostic.");

	using allocator_type = _Alloc;

	using _Alty = typename _Mybase::_Alty;
	using _Alty_traits = typename _Mybase::_Alty_traits;
	using _Alpty = typename _Mybase::_Alpty;
	using _Alpty_traits = typename _Mybase::_Alpty_traits;
	using _Mapptr = typename _Mybase::_Mapptr;

	using value_type = _Ty;
	using size_type = typename _Mybase::size_type;
	using difference_type = typename _Mybase::difference_type;
	using pointer = typename _Mybase::pointer;
	using const_pointer = typename _Mybase::const_pointer;
	using reference = _Ty&;
	using const_reference = const _Ty&;

	using iterator = typename _Mybase::iterator;
	using const_iterator = typename _Mybase::const_iterator;
	using _Unchecked_iterator = typename _Mybase::_Unchecked_iterator;
	using _Unchecked_const_iterator = typename _Mybase::_Unchecked_const_iterator;

	using reverse_iterator = ::std:: reverse_iterator<iterator>;
	using const_reverse_iterator = ::std:: reverse_iterator<const_iterator>;
	enum {_EEN_DS = (sizeof (value_type) <= 1 ? 16 : sizeof (value_type) <= 2 ? 8 : sizeof (value_type) <= 4 ? 4 : sizeof (value_type) <= 8 ? 2 : 1)};	// helper for expression evaluator

	deque()
		: _Mybase()
		{	// construct empty deque
		}

	explicit deque(const _Alloc& _Al)
		: _Mybase(_Al)
		{	// construct empty deque with allocator
		}

	explicit deque(__declspec(guard(overflow)) size_type _Count, const _Alloc& _Al = _Alloc())
		: _Mybase(_Al)
		{	// construct from _Count * _Ty(), optional allocator
		resize(_Count);
		}

	deque(__declspec(guard(overflow)) size_type _Count, const _Ty& _Val)
		: _Mybase()
		{	// construct from _Count * _Val
		_Construct_n(_Count, _Val);
		}

	deque(__declspec(guard(overflow)) size_type _Count, const _Ty& _Val, const _Alloc& _Al)
		: _Mybase(_Al)
		{	// construct from _Count * _Val with allocator
		_Construct_n(_Count, _Val);
		}

	deque(const deque& _Right)
		: _Mybase(_Alty_traits::select_on_container_copy_construction(_Right._Getal()))
		{	// construct by copying _Right
		_Construct(_Right.begin(), _Right.end());
		}

	deque(const deque& _Right, const _Alloc& _Al)
		: _Mybase(_Al)
		{	// construct by copying _Right
		_Construct(_Right.begin(), _Right.end());
		}

	template<class _Iter,
		class = enable_if_t<_Is_iterator_v<_Iter>>>
		deque(_Iter _First, _Iter _Last)
		: _Mybase()
		{	// construct from [_First, _Last)
		_Construct(_First, _Last);
		}

	template<class _Iter,
		class = enable_if_t<_Is_iterator_v<_Iter>>>
		deque(_Iter _First, _Iter _Last, const _Alloc& _Al)
		: _Mybase(_Al)
		{	// construct from [_First, _Last) with allocator
		_Construct(_First, _Last);
		}

	template<class _Iter>
		void _Construct(_Iter _First, _Iter _Last)
		{	// initialize from [_First, _Last), input iterators
		try {
		for (; _First != _Last; ++_First)
			{
			emplace_back(*_First);
			}

		} catch (...) {
		_Tidy();
		throw;
		}
		}

	void _Construct_n(size_type _Count, const _Ty& _Val)
		{	// construct from _Count * _Val
		try {
		for (; 0 < _Count; --_Count)
			{
			push_back(_Val);
			}

		} catch (...) {
		_Tidy();
		throw;
		}
		}





























	deque(deque&& _Right)
		: _Mybase(::std:: move(_Right._Getal()))
		{	// construct by moving _Right
		_Assign_rv(::std:: move(_Right), true_type());
		}

	deque(deque&& _Right, const _Alloc& _Al)
		: _Mybase(_Al)
		{	// construct by moving _Right
		_Assign_rv(::std:: move(_Right), typename _Alty_traits::is_always_equal());
		}

	deque& operator=(deque&& _Right)
		noexcept(_Alty_traits::is_always_equal::value)
		{	// assign by moving _Right
		if (this != ::std:: addressof(_Right))
			{	// different, assign it
			_Tidy();
			this->_Move_alloc(_Right._Getal());
			_Assign_rv(::std:: move(_Right), bool_constant<_Always_equal_after_move<_Alty>>{});
			}
		return (*this);
		}

	void _Assign_rv(deque&& _Right, true_type) noexcept
		{	// move from _Right, stealing its contents
		this->_Swap_all(_Right);
		this->_Map() = _Right._Map();
		this->_Mapsize() = _Right._Mapsize();
		this->_Myoff() = _Right._Myoff();
		this->_Mysize() = _Right._Mysize();

		_Right._Map() = _Mapptr();
		_Right._Mapsize() = 0;
		_Right._Myoff() = 0;
		_Right._Mysize() = 0;
		}

	void _Assign_rv(deque&& _Right, false_type)
		{	// move from _Right, possibly moving its contents
		if (this->_Getal() == _Right._Getal())
			{
			_Assign_rv(::std:: move(_Right), true_type());
			}
		else
			{
			_Construct(::std:: make_move_iterator(_Right.begin()),
				::std:: make_move_iterator(_Right.end()));
			}
		}

	void push_front(_Ty&& _Val)
		{	// insert element at beginning
		this->_Orphan_all();
		if (this->_Myoff() % (sizeof (value_type) <= 1 ? 16 : sizeof (value_type) <= 2 ? 8 : sizeof (value_type) <= 4 ? 4 : sizeof (value_type) <= 8 ? 2 : 1) == 0 && this->_Mapsize() <= (this->_Mysize() + (sizeof (value_type) <= 1 ? 16 : sizeof (value_type) <= 2 ? 8 : sizeof (value_type) <= 4 ? 4 : sizeof (value_type) <= 8 ? 2 : 1)) / (sizeof (value_type) <= 1 ? 16 : sizeof (value_type) <= 2 ? 8 : sizeof (value_type) <= 4 ? 4 : sizeof (value_type) <= 8 ? 2 : 1)) _Growmap(1); this->_Myoff() &= this->_Mapsize() * (sizeof (value_type) <= 1 ? 16 : sizeof (value_type) <= 2 ? 8 : sizeof (value_type) <= 4 ? 4 : sizeof (value_type) <= 8 ? 2 : 1) - 1; size_type _Newoff = this->_Myoff() != 0 ? this->_Myoff() : this->_Mapsize() * (sizeof (value_type) <= 1 ? 16 : sizeof (value_type) <= 2 ? 8 : sizeof (value_type) <= 4 ? 4 : sizeof (value_type) <= 8 ? 2 : 1); size_type _Block = this->_Getblock(--_Newoff); if (this->_Map()[_Block] == pointer()) this->_Map()[_Block] = this->_Getal().allocate((sizeof (value_type) <= 1 ? 16 : sizeof (value_type) <= 2 ? 8 : sizeof (value_type) <= 4 ? 4 : sizeof (value_type) <= 8 ? 2 : 1));
		_Alty_traits::construct(this->_Getal(),
			_Unfancy(this->_Map()[_Block] + _Newoff % (sizeof (value_type) <= 1 ? 16 : sizeof (value_type) <= 2 ? 8 : sizeof (value_type) <= 4 ? 4 : sizeof (value_type) <= 8 ? 2 : 1)),
			::std:: move(_Val));
		this->_Myoff() = _Newoff; ++this->_Mysize();
		}

	void push_back(_Ty&& _Val)
		{	// insert element at end
		this->_Orphan_all();
		if ((this->_Myoff() + this->_Mysize()) % (sizeof (value_type) <= 1 ? 16 : sizeof (value_type) <= 2 ? 8 : sizeof (value_type) <= 4 ? 4 : sizeof (value_type) <= 8 ? 2 : 1) == 0 && this->_Mapsize() <= (this->_Mysize() + (sizeof (value_type) <= 1 ? 16 : sizeof (value_type) <= 2 ? 8 : sizeof (value_type) <= 4 ? 4 : sizeof (value_type) <= 8 ? 2 : 1)) / (sizeof (value_type) <= 1 ? 16 : sizeof (value_type) <= 2 ? 8 : sizeof (value_type) <= 4 ? 4 : sizeof (value_type) <= 8 ? 2 : 1)) _Growmap(1); this->_Myoff() &= this->_Mapsize() * (sizeof (value_type) <= 1 ? 16 : sizeof (value_type) <= 2 ? 8 : sizeof (value_type) <= 4 ? 4 : sizeof (value_type) <= 8 ? 2 : 1) - 1; size_type _Newoff = this->_Myoff() + this->_Mysize(); size_type _Block = this->_Getblock(_Newoff); if (this->_Map()[_Block] == pointer()) this->_Map()[_Block] = this->_Getal().allocate((sizeof (value_type) <= 1 ? 16 : sizeof (value_type) <= 2 ? 8 : sizeof (value_type) <= 4 ? 4 : sizeof (value_type) <= 8 ? 2 : 1));
		_Alty_traits::construct(this->_Getal(),
			_Unfancy(this->_Map()[_Block] + _Newoff % (sizeof (value_type) <= 1 ? 16 : sizeof (value_type) <= 2 ? 8 : sizeof (value_type) <= 4 ? 4 : sizeof (value_type) <= 8 ? 2 : 1)),
			::std:: move(_Val));
		++this->_Mysize();
		}

	iterator insert(const_iterator _Where, _Ty&& _Val)
		{	// insert _Val at _Where
		return (emplace(_Where, ::std:: move(_Val)));
		}

	template<class... _Valty>
		decltype(auto) emplace_front(_Valty&&... _Val)
		{	// insert element at beginning
		this->_Orphan_all();
		if (this->_Myoff() % (sizeof (value_type) <= 1 ? 16 : sizeof (value_type) <= 2 ? 8 : sizeof (value_type) <= 4 ? 4 : sizeof (value_type) <= 8 ? 2 : 1) == 0 && this->_Mapsize() <= (this->_Mysize() + (sizeof (value_type) <= 1 ? 16 : sizeof (value_type) <= 2 ? 8 : sizeof (value_type) <= 4 ? 4 : sizeof (value_type) <= 8 ? 2 : 1)) / (sizeof (value_type) <= 1 ? 16 : sizeof (value_type) <= 2 ? 8 : sizeof (value_type) <= 4 ? 4 : sizeof (value_type) <= 8 ? 2 : 1)) _Growmap(1); this->_Myoff() &= this->_Mapsize() * (sizeof (value_type) <= 1 ? 16 : sizeof (value_type) <= 2 ? 8 : sizeof (value_type) <= 4 ? 4 : sizeof (value_type) <= 8 ? 2 : 1) - 1; size_type _Newoff = this->_Myoff() != 0 ? this->_Myoff() : this->_Mapsize() * (sizeof (value_type) <= 1 ? 16 : sizeof (value_type) <= 2 ? 8 : sizeof (value_type) <= 4 ? 4 : sizeof (value_type) <= 8 ? 2 : 1); size_type _Block = this->_Getblock(--_Newoff); if (this->_Map()[_Block] == pointer()) this->_Map()[_Block] = this->_Getal().allocate((sizeof (value_type) <= 1 ? 16 : sizeof (value_type) <= 2 ? 8 : sizeof (value_type) <= 4 ? 4 : sizeof (value_type) <= 8 ? 2 : 1));
		_Alty_traits::construct(this->_Getal(),
			_Unfancy(this->_Map()[_Block] + _Newoff % (sizeof (value_type) <= 1 ? 16 : sizeof (value_type) <= 2 ? 8 : sizeof (value_type) <= 4 ? 4 : sizeof (value_type) <= 8 ? 2 : 1)),
			::std:: forward<_Valty>(_Val)...);
		this->_Myoff() = _Newoff; ++this->_Mysize();




		}

	template<class... _Valty>
		decltype(auto) emplace_back(_Valty&&... _Val)
		{	// insert element at end
		this->_Orphan_all();
		if ((this->_Myoff() + this->_Mysize()) % (sizeof (value_type) <= 1 ? 16 : sizeof (value_type) <= 2 ? 8 : sizeof (value_type) <= 4 ? 4 : sizeof (value_type) <= 8 ? 2 : 1) == 0 && this->_Mapsize() <= (this->_Mysize() + (sizeof (value_type) <= 1 ? 16 : sizeof (value_type) <= 2 ? 8 : sizeof (value_type) <= 4 ? 4 : sizeof (value_type) <= 8 ? 2 : 1)) / (sizeof (value_type) <= 1 ? 16 : sizeof (value_type) <= 2 ? 8 : sizeof (value_type) <= 4 ? 4 : sizeof (value_type) <= 8 ? 2 : 1)) _Growmap(1); this->_Myoff() &= this->_Mapsize() * (sizeof (value_type) <= 1 ? 16 : sizeof (value_type) <= 2 ? 8 : sizeof (value_type) <= 4 ? 4 : sizeof (value_type) <= 8 ? 2 : 1) - 1; size_type _Newoff = this->_Myoff() + this->_Mysize(); size_type _Block = this->_Getblock(_Newoff); if (this->_Map()[_Block] == pointer()) this->_Map()[_Block] = this->_Getal().allocate((sizeof (value_type) <= 1 ? 16 : sizeof (value_type) <= 2 ? 8 : sizeof (value_type) <= 4 ? 4 : sizeof (value_type) <= 8 ? 2 : 1));
		_Alty_traits::construct(this->_Getal(),
			_Unfancy(this->_Map()[_Block] + _Newoff % (sizeof (value_type) <= 1 ? 16 : sizeof (value_type) <= 2 ? 8 : sizeof (value_type) <= 4 ? 4 : sizeof (value_type) <= 8 ? 2 : 1)),
			::std:: forward<_Valty>(_Val)...);
		++this->_Mysize();




		}

	template<class... _Valty>
		iterator emplace(const_iterator _Where, _Valty&&... _Val)
		{	// insert element at _Where
		const auto _Off = static_cast<size_type>(_Where - begin());

 
		do { if (_Off <= this->_Mysize()) { } else { do { (void) ((1 != _CrtDbgReport(2, "c:\\visual studio\\vc\\tools\\msvc\\14.16.27023\\include\\deque", 1153, 0, "%s", "deque emplace iterator outside range")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"deque emplace iterator outside range\"", __LPREFIX( __FUNCTION__), L"c:\\visual studio\\vc\\tools\\msvc\\14.16.27023\\include\\deque", 1153, 0); } while (false); } ; } while (false);
 

		if (_Off <= this->_Mysize() / 2)
			{	// closer to front, push to front then rotate
			emplace_front(::std:: forward<_Valty>(_Val)...);
			::std:: rotate(begin(), begin() + 1, begin() + static_cast<difference_type>(1 + _Off));
			}
		else
			{	// closer to back, push to back then rotate
			emplace_back(::std:: forward<_Valty>(_Val)...);
			::std:: rotate(begin() + static_cast<difference_type>(_Off), end() - 1, end());
			}
		return (begin() + static_cast<difference_type>(_Off));
		}

	deque(initializer_list<_Ty> _Ilist, const _Alloc& _Al = allocator_type())
		: _Mybase(_Al)
		{	// construct from initializer_list
		_Construct(_Ilist.begin(), _Ilist.end());
		}

	deque& operator=(initializer_list<_Ty> _Ilist)
		{	// assign initializer_list
		assign(_Ilist.begin(), _Ilist.end());
		return (*this);
		}

	void assign(initializer_list<_Ty> _Ilist)
		{	// assign initializer_list
		assign(_Ilist.begin(), _Ilist.end());
		}

	iterator insert(const_iterator _Where, initializer_list<_Ty> _Ilist)
		{	// insert initializer_list
		return (insert(_Where, _Ilist.begin(), _Ilist.end()));
		}

	~deque() noexcept
		{	// destroy the deque
		_Tidy();
		}

	deque& operator=(const deque& _Right)
		{	// assign _Right
		if (this != ::std:: addressof(_Right))
			{	// different, assign it
#pragma warning(push)
#pragma warning(disable: 4127)	
			if (_Alty_traits::propagate_on_container_copy_assignment::value
				&& this->_Getal() != _Right._Getal())
				{	// change allocator before copying
				_Tidy();
				}
#pragma warning(pop)

			this->_Copy_alloc(_Right._Getal());

			this->_Orphan_all();

			if (_Right._Mysize() == 0)
				{
				clear();
				}
			else if (_Right._Mysize() <= this->_Mysize())
				{	// enough elements, copy new and destroy old
				iterator _Mid = ::std:: copy(_Right.begin(), _Right.end(), begin());
				erase(_Mid, end());
				}
			else
				{	// new sequence longer, copy and construct new
				const_iterator _Mid = _Right.begin() + static_cast<difference_type>(this->_Mysize());
				::std:: copy(_Right.begin(), _Mid, begin());
				insert(end(), _Mid, _Right.end());
				}
			}
		return (*this);
		}

	 iterator begin() noexcept
		{	// return iterator for beginning of mutable sequence
		return (iterator(this->_Myoff(), ::std:: addressof(this->_Get_data())));
		}

	 const_iterator begin() const noexcept
		{	// return iterator for beginning of nonmutable sequence
		return (const_iterator(this->_Myoff(), ::std:: addressof(this->_Get_data())));
		}

	 iterator end() noexcept
		{	// return iterator for end of mutable sequence
		return (iterator(this->_Myoff() + this->_Mysize(),
			::std:: addressof(this->_Get_data())));
		}

	 const_iterator end() const noexcept
		{	// return iterator for end of nonmutable sequence
		return (const_iterator(this->_Myoff() + this->_Mysize(),
			::std:: addressof(this->_Get_data())));
		}

	_Unchecked_iterator _Unchecked_begin() noexcept
		{	// return unchecked iterator for beginning of mutable sequence
		return (_Unchecked_iterator(this->_Myoff(), ::std:: addressof(this->_Get_data())));
		}

	_Unchecked_const_iterator _Unchecked_begin() const noexcept
		{	// return unchecked iterator for beginning of nonmutable sequence
		return (_Unchecked_const_iterator(this->_Myoff(), ::std:: addressof(this->_Get_data())));
		}

	_Unchecked_iterator _Unchecked_end() noexcept
		{	// return unchecked iterator for end of mutable sequence
		return (_Unchecked_iterator(this->_Myoff() + this->_Mysize(),
			::std:: addressof(this->_Get_data())));
		}

	_Unchecked_const_iterator _Unchecked_end() const noexcept
		{	// return unchecked iterator for end of nonmutable sequence
		return (_Unchecked_const_iterator(this->_Myoff() + this->_Mysize(),
			::std:: addressof(this->_Get_data())));
		}

	iterator _Make_iter(const_iterator _Where) const
		{	// make iterator from const_iterator
		return (iterator(_Where._Myoff, ::std:: addressof(this->_Get_data())));
		}

	 reverse_iterator rbegin() noexcept
		{	// return iterator for beginning of reversed mutable sequence
		return (reverse_iterator(end()));
		}

	 const_reverse_iterator rbegin() const noexcept
		{	// return iterator for beginning of reversed nonmutable sequence
		return (const_reverse_iterator(end()));
		}

	 reverse_iterator rend() noexcept
		{	// return iterator for end of reversed mutable sequence
		return (reverse_iterator(begin()));
		}

	 const_reverse_iterator rend() const noexcept
		{	// return iterator for end of reversed nonmutable sequence
		return (const_reverse_iterator(begin()));
		}

	 const_iterator cbegin() const noexcept
		{	// return iterator for beginning of nonmutable sequence
		return (begin());
		}

	 const_iterator cend() const noexcept
		{	// return iterator for end of nonmutable sequence
		return (end());
		}

	 const_reverse_iterator crbegin() const noexcept
		{	// return iterator for beginning of reversed nonmutable sequence
		return (rbegin());
		}

	 const_reverse_iterator crend() const noexcept
		{	// return iterator for end of reversed nonmutable sequence
		return (rend());
		}

	void shrink_to_fit()
		{	// reduce capacity
		size_type _Oldcapacity = (sizeof (value_type) <= 1 ? 16 : sizeof (value_type) <= 2 ? 8 : sizeof (value_type) <= 4 ? 4 : sizeof (value_type) <= 8 ? 2 : 1) * this->_Mapsize();
		size_type _Newcapacity = _Oldcapacity / 2;

		if (_Newcapacity < (sizeof (value_type) <= 1 ? 16 : sizeof (value_type) <= 2 ? 8 : sizeof (value_type) <= 4 ? 4 : sizeof (value_type) <= 8 ? 2 : 1) * 8)
			_Newcapacity = (sizeof (value_type) <= 1 ? 16 : sizeof (value_type) <= 2 ? 8 : sizeof (value_type) <= 4 ? 4 : sizeof (value_type) <= 8 ? 2 : 1) * 8;

		if ((empty() && 0 < this->_Mapsize())
			|| (!empty()
				&& size() <= _Newcapacity
				&& _Newcapacity < _Oldcapacity))
			{	// worth shrinking, do it
			deque _Tmp(::std:: make_move_iterator(begin()), ::std:: make_move_iterator(end()));
			swap(_Tmp);
			}
		}

	void resize(__declspec(guard(overflow)) size_type _Newsize)
		{	// determine new length, padding as needed
		while (this->_Mysize() < _Newsize)
			{
			emplace_back();
			}

		while (_Newsize < this->_Mysize())
			{
			pop_back();
			}
		}

	void resize(__declspec(guard(overflow)) size_type _Newsize, const _Ty& _Val)
		{	// determine new length, padding with _Val elements as needed
		while (this->_Mysize() < _Newsize)
			{
			push_back(_Val);
			}

		while (_Newsize < this->_Mysize())
			{
			pop_back();
			}
		}

	 size_type size() const noexcept
		{	// return length of sequence
		return (this->_Mysize());
		}

	 size_type max_size() const noexcept
		{	// return maximum possible length of sequence
		return (_Alty_traits::max_size(this->_Getal()));
		}

	 bool empty() const noexcept
		{	// test if sequence is empty
		return (this->_Mysize() == 0);
		}

	 allocator_type get_allocator() const noexcept
		{	// return allocator object for values
		return (static_cast<allocator_type>(this->_Getal()));
		}

	 const_reference at(size_type _Pos) const
		{	// subscript nonmutable sequence with checking
		if (this->_Mysize() <= _Pos)
			_Xran();
		return (*(begin() + static_cast<difference_type>(_Pos)));
		}

	 reference at(size_type _Pos)
		{	// subscript mutable sequence with checking
		if (this->_Mysize() <= _Pos)
			_Xran();
		return (*(begin() + static_cast<difference_type>(_Pos)));
		}

	 const_reference operator[](size_type _Pos) const
		{	// subscript nonmutable sequence
 
		do { if (_Pos < this->_Mysize()) { } else { do { (void) ((1 != _CrtDbgReport(2, "c:\\visual studio\\vc\\tools\\msvc\\14.16.27023\\include\\deque", 1402, 0, "%s", "deque subscript out of range")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"deque subscript out of range\"", __LPREFIX( __FUNCTION__), L"c:\\visual studio\\vc\\tools\\msvc\\14.16.27023\\include\\deque", 1402, 0); } while (false); } ; } while (false);
 

		return (*(begin() + static_cast<difference_type>(_Pos)));
		}

	 reference operator[](size_type _Pos)
		{	// subscript mutable sequence
 
		do { if (_Pos < this->_Mysize()) { } else { do { (void) ((1 != _CrtDbgReport(2, "c:\\visual studio\\vc\\tools\\msvc\\14.16.27023\\include\\deque", 1411, 0, "%s", "deque subscript out of range")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"deque subscript out of range\"", __LPREFIX( __FUNCTION__), L"c:\\visual studio\\vc\\tools\\msvc\\14.16.27023\\include\\deque", 1411, 0); } while (false); } ; } while (false);
 

		return (*(begin() + static_cast<difference_type>(_Pos)));
		}

	 reference front()
		{	// return first element of mutable sequence
		return (*begin());
		}

	 const_reference front() const
		{	// return first element of nonmutable sequence
		return (*begin());
		}

	 reference back()
		{	// return last element of mutable sequence
		return (*(end() - 1));
		}

	 const_reference back() const
		{	// return last element of nonmutable sequence
		return (*(end() - 1));
		}

	void push_front(const _Ty& _Val)
		{	// insert element at beginning
		this->_Orphan_all();
		if (this->_Myoff() % (sizeof (value_type) <= 1 ? 16 : sizeof (value_type) <= 2 ? 8 : sizeof (value_type) <= 4 ? 4 : sizeof (value_type) <= 8 ? 2 : 1) == 0 && this->_Mapsize() <= (this->_Mysize() + (sizeof (value_type) <= 1 ? 16 : sizeof (value_type) <= 2 ? 8 : sizeof (value_type) <= 4 ? 4 : sizeof (value_type) <= 8 ? 2 : 1)) / (sizeof (value_type) <= 1 ? 16 : sizeof (value_type) <= 2 ? 8 : sizeof (value_type) <= 4 ? 4 : sizeof (value_type) <= 8 ? 2 : 1)) _Growmap(1); this->_Myoff() &= this->_Mapsize() * (sizeof (value_type) <= 1 ? 16 : sizeof (value_type) <= 2 ? 8 : sizeof (value_type) <= 4 ? 4 : sizeof (value_type) <= 8 ? 2 : 1) - 1; size_type _Newoff = this->_Myoff() != 0 ? this->_Myoff() : this->_Mapsize() * (sizeof (value_type) <= 1 ? 16 : sizeof (value_type) <= 2 ? 8 : sizeof (value_type) <= 4 ? 4 : sizeof (value_type) <= 8 ? 2 : 1); size_type _Block = this->_Getblock(--_Newoff); if (this->_Map()[_Block] == pointer()) this->_Map()[_Block] = this->_Getal().allocate((sizeof (value_type) <= 1 ? 16 : sizeof (value_type) <= 2 ? 8 : sizeof (value_type) <= 4 ? 4 : sizeof (value_type) <= 8 ? 2 : 1));
		_Alty_traits::construct(this->_Getal(),
			_Unfancy(this->_Map()[_Block] + _Newoff % (sizeof (value_type) <= 1 ? 16 : sizeof (value_type) <= 2 ? 8 : sizeof (value_type) <= 4 ? 4 : sizeof (value_type) <= 8 ? 2 : 1)), _Val);
		this->_Myoff() = _Newoff; ++this->_Mysize();
		}

	void pop_front()
		{	// erase element at beginning
 
		if (empty())
			{
			do { (void) ((1 != _CrtDbgReport(2, "c:\\visual studio\\vc\\tools\\msvc\\14.16.27023\\include\\deque", 1451, 0, "%s", "deque empty before pop")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"deque empty before pop\"", __LPREFIX( __FUNCTION__), L"c:\\visual studio\\vc\\tools\\msvc\\14.16.27023\\include\\deque", 1451, 0); } while (false);
			}
		else
			{	// something to erase, do it
			_Orphan_off(this->_Myoff());
			size_type _Block = this->_Getblock(this->_Myoff());
			_Alty_traits::destroy(this->_Getal(),
				_Unfancy(this->_Map()[_Block] + this->_Myoff() % (sizeof (value_type) <= 1 ? 16 : sizeof (value_type) <= 2 ? 8 : sizeof (value_type) <= 4 ? 4 : sizeof (value_type) <= 8 ? 2 : 1)));
			if (--this->_Mysize() == 0)
				{
				this->_Myoff() = 0;
				}
			else
				{
				++this->_Myoff();
				}
			}

 












		}

	void push_back(const _Ty& _Val)
		{	// insert element at end
		this->_Orphan_all();
		if ((this->_Myoff() + this->_Mysize()) % (sizeof (value_type) <= 1 ? 16 : sizeof (value_type) <= 2 ? 8 : sizeof (value_type) <= 4 ? 4 : sizeof (value_type) <= 8 ? 2 : 1) == 0 && this->_Mapsize() <= (this->_Mysize() + (sizeof (value_type) <= 1 ? 16 : sizeof (value_type) <= 2 ? 8 : sizeof (value_type) <= 4 ? 4 : sizeof (value_type) <= 8 ? 2 : 1)) / (sizeof (value_type) <= 1 ? 16 : sizeof (value_type) <= 2 ? 8 : sizeof (value_type) <= 4 ? 4 : sizeof (value_type) <= 8 ? 2 : 1)) _Growmap(1); this->_Myoff() &= this->_Mapsize() * (sizeof (value_type) <= 1 ? 16 : sizeof (value_type) <= 2 ? 8 : sizeof (value_type) <= 4 ? 4 : sizeof (value_type) <= 8 ? 2 : 1) - 1; size_type _Newoff = this->_Myoff() + this->_Mysize(); size_type _Block = this->_Getblock(_Newoff); if (this->_Map()[_Block] == pointer()) this->_Map()[_Block] = this->_Getal().allocate((sizeof (value_type) <= 1 ? 16 : sizeof (value_type) <= 2 ? 8 : sizeof (value_type) <= 4 ? 4 : sizeof (value_type) <= 8 ? 2 : 1));
		_Alty_traits::construct(this->_Getal(),
			_Unfancy(this->_Map()[_Block] + _Newoff % (sizeof (value_type) <= 1 ? 16 : sizeof (value_type) <= 2 ? 8 : sizeof (value_type) <= 4 ? 4 : sizeof (value_type) <= 8 ? 2 : 1)), _Val);
		++this->_Mysize();
		}

	void pop_back()
		{	// erase element at end
 
		if (empty())
			{
			do { (void) ((1 != _CrtDbgReport(2, "c:\\visual studio\\vc\\tools\\msvc\\14.16.27023\\include\\deque", 1498, 0, "%s", "deque empty before pop")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"deque empty before pop\"", __LPREFIX( __FUNCTION__), L"c:\\visual studio\\vc\\tools\\msvc\\14.16.27023\\include\\deque", 1498, 0); } while (false);
			}
		else
			{	// something to erase, do it
			size_type _Newoff = this->_Myoff() + this->_Mysize() - 1;
			_Orphan_off(_Newoff);
			size_type _Block = this->_Getblock(_Newoff);
			_Alty_traits::destroy(this->_Getal(),
				_Unfancy(this->_Map()[_Block] + _Newoff % (sizeof (value_type) <= 1 ? 16 : sizeof (value_type) <= 2 ? 8 : sizeof (value_type) <= 4 ? 4 : sizeof (value_type) <= 8 ? 2 : 1)));
			if (--this->_Mysize() == 0)
				{
				this->_Myoff() = 0;
				}
			}

 









		}

	template<class _Iter,
		class = enable_if_t<_Is_iterator_v<_Iter>>>
		void assign(_Iter _First, _Iter _Last)
		{	// assign [_First, _Last), input iterators
		clear();
		for (; _First != _Last; ++_First)
			{
			emplace_back(*_First);
			}
		}

	void assign(__declspec(guard(overflow)) size_type _Count, const _Ty& _Val)
		{	// assign _Count * _Val
		erase(begin(), end());
		_Insert_n(begin(), _Count, _Val);
		}

	iterator insert(const_iterator _Where,
		const _Ty& _Val)
		{	// insert _Val at _Where
		size_type _Off = static_cast<size_type>(_Where - begin());

 
		do { if (_Off <= this->_Mysize()) { } else { do { (void) ((1 != _CrtDbgReport(2, "c:\\visual studio\\vc\\tools\\msvc\\14.16.27023\\include\\deque", 1548, 0, "%s", "deque insert iterator outside range")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"deque insert iterator outside range\"", __LPREFIX( __FUNCTION__), L"c:\\visual studio\\vc\\tools\\msvc\\14.16.27023\\include\\deque", 1548, 0); } while (false); } ; } while (false);
 

		if (_Off <= this->_Mysize() / 2)
			{	// closer to front, push to front then copy
			push_front(_Val);
			::std:: rotate(begin(), begin() + 1, begin() + static_cast<difference_type>(1 + _Off));
			}
		else
			{	// closer to back, push to back then copy
			push_back(_Val);
			::std:: rotate(begin() + static_cast<difference_type>(_Off), end() - 1, end());
			}

		return (begin() + static_cast<difference_type>(_Off));
		}

	iterator insert(const_iterator _Where, __declspec(guard(overflow)) size_type _Count,
		const _Ty& _Val)
		{	// insert _Count * _Val at _Where
		size_type _Off = static_cast<size_type>(_Where - begin());
		_Insert_n(_Where, _Count, _Val);
		return (begin() + static_cast<difference_type>(_Off));
		}

	template<class _Iter,
		class = enable_if_t<_Is_iterator_v<_Iter>>>
		iterator insert(const_iterator _Where, _Iter _First, _Iter _Last)
		{	// insert [_First, _Last) at _Where, input iterators
		size_type _Off = static_cast<size_type>(_Where - begin());

 
		do { if (this->_Mysize() >= _Off) { } else { do { (void) ((1 != _CrtDbgReport(2, "c:\\visual studio\\vc\\tools\\msvc\\14.16.27023\\include\\deque", 1580, 0, "%s", "deque insert iterator outside range")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"deque insert iterator outside range\"", __LPREFIX( __FUNCTION__), L"c:\\visual studio\\vc\\tools\\msvc\\14.16.27023\\include\\deque", 1580, 0); } while (false); } ; } while (false);
 

		_Adl_verify_range(_First, _Last);
		auto _UFirst = _Get_unwrapped(_First);
		const auto _ULast = _Get_unwrapped(_Last);

		size_type _Oldsize = this->_Mysize();

		if (_UFirst != _ULast)
			{
			if (_Off <= this->_Mysize() / 2)
				{	// closer to front, push to front then rotate
				try {
				for (; _UFirst != _ULast; ++_UFirst)
					{
					push_front(*_UFirst);	// prepend flipped
					}

				} catch (...) {
				while (_Oldsize < this->_Mysize())
					{
					pop_front();	// restore old size, at least
					}

				throw;
				}

				size_type _Num = this->_Mysize() - _Oldsize;
				::std:: reverse(begin(), begin() + static_cast<difference_type>(_Num));	// flip new stuff in place
				::std:: rotate(begin(), begin() + static_cast<difference_type>(_Num),
					begin() + static_cast<difference_type>(_Num + _Off));
				}
			else
				{	// closer to back
				try {
				for (; _UFirst != _ULast; ++_UFirst)
					{
					push_back(*_UFirst);	// append
					}

				} catch (...) {
				while (_Oldsize < this->_Mysize())
					{
					pop_back();	// restore old size, at least
					}

				throw;
				}

				::std:: rotate(begin() + static_cast<difference_type>(_Off),
					begin() + static_cast<difference_type>(_Oldsize), end());
				}
			}

		return (begin() + static_cast<difference_type>(_Off));
		}

	iterator erase(const_iterator _Where)
		{	// erase element at _Where
		return (erase(_Where, _Where + 1));
		}

	iterator erase(const_iterator _First_arg, const_iterator _Last_arg)
		{	// erase [_First, _Last)
		iterator _First = _Make_iter(_First_arg);
		iterator _Last = _Make_iter(_Last_arg);

 
		do { if (_First <= _Last && begin() <= _First && _Last <= end()) { } else { do { (void) ((1 != _CrtDbgReport(2, "c:\\visual studio\\vc\\tools\\msvc\\14.16.27023\\include\\deque", 1649, 0, "%s", "deque erase iterator outside range")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"deque erase iterator outside range\"", __LPREFIX( __FUNCTION__), L"c:\\visual studio\\vc\\tools\\msvc\\14.16.27023\\include\\deque", 1649, 0); } while (false); } ; } while (false);
		_Adl_verify_range(_First, _Last);

		auto _Off = static_cast<size_type>(_First - begin());
		auto _Count = static_cast<size_type>(_Last - _First);
		bool _Moved = 0 < _Off && _Off + _Count < this->_Mysize();

 




		if (_Off < static_cast<size_type>(end() - _Last))
			{	// closer to front
			::std:: move_backward(begin(), _First, _Last);	// copy over hole
			for (; 0 < _Count; --_Count)
				{
				pop_front();	// pop copied elements
				}
			}
		else
			{	// closer to back
			::std:: move(_Last, end(), _First);	// copy over hole
			for (; 0 < _Count; --_Count)
				{
				pop_back();	// pop copied elements
				}
			}

 
		if (_Moved)
			{
			this->_Orphan_all();
			}
 

		return (begin() + static_cast<difference_type>(_Off));
		}

	void clear() noexcept
		{	// erase all
		_Tidy();
		}

	void swap(deque& _Right) noexcept // strengthened
		{	// exchange contents with _Right
		if (this != ::std:: addressof(_Right))
			{	// (maybe) swap allocators, swap control information
			_Pocs(this->_Getal(), _Right._Getal());
			this->_Swap_all(_Right);
			_Swap_adl(this->_Map(), _Right._Map());
			::std:: swap(this->_Mapsize(), _Right._Mapsize());
			::std:: swap(this->_Myoff(), _Right._Myoff());
			::std:: swap(this->_Mysize(), _Right._Mysize());
			}
		}

protected:
	void _Insert_n(const_iterator _Where, size_type _Count, const _Ty& _Val)
		{	// insert _Count * _Val at _Where
		iterator _Mid;
		size_type _Num;
		size_type _Off = static_cast<size_type>(_Where - begin());
		size_type _Oldsize = this->_Mysize();
		size_type _Rem = _Oldsize - _Off;

 
		do { if (_Off <= _Oldsize) { } else { do { (void) ((1 != _CrtDbgReport(2, "c:\\visual studio\\vc\\tools\\msvc\\14.16.27023\\include\\deque", 1716, 0, "%s", "deque insert iterator outside range")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"deque insert iterator outside range\"", __LPREFIX( __FUNCTION__), L"c:\\visual studio\\vc\\tools\\msvc\\14.16.27023\\include\\deque", 1716, 0); } while (false); } ; } while (false);
 

		if (_Off < _Rem)
			{	// closer to front
			try {
			if (_Off < _Count)
				{	// insert longer than prefix
				for (_Num = _Count - _Off; 0 < _Num; --_Num)
					{
					push_front(_Val);	// push excess values
					}
				for (_Num = _Off; 0 < _Num; --_Num)
					{
					push_front(begin()[static_cast<difference_type>(_Count - 1)]);	// push prefix
					}

				_Mid = begin() + static_cast<difference_type>(_Count);
				::std:: fill(_Mid, _Mid + static_cast<difference_type>(_Off), _Val);	// fill in rest of values
				}
			else
				{	// insert not longer than prefix
				for (_Num = _Count; 0 < _Num; --_Num)
					{
					push_front(begin()[static_cast<difference_type>(_Count - 1)]);	// push part of prefix
					}

				_Mid = begin() + static_cast<difference_type>(_Count);
				_Ty _Tmp = _Val;	// in case _Val is in sequence
				::std:: move(_Mid + static_cast<difference_type>(_Count),
					_Mid + static_cast<difference_type>(_Off), _Mid);	// copy rest of prefix
				::std:: fill(begin() + static_cast<difference_type>(_Off),
					_Mid + static_cast<difference_type>(_Off), _Tmp);	// fill in values
				}
			} catch (...) {
			while (_Oldsize < this->_Mysize())
				{
				pop_front();	// restore old size, at least
				}

			throw;
			}
			}
		else
			{		// closer to back
			try {
			if (_Rem < _Count)
				{	// insert longer than suffix
				for (_Num = _Count - _Rem; 0 < _Num; --_Num)
					{
					push_back(_Val);	// push excess values
					}
				for (_Num = 0; _Num < _Rem; ++_Num)
					{
					push_back(begin()[static_cast<difference_type>(_Off + _Num)]);	// push suffix
					}

				_Mid = begin() + static_cast<difference_type>(_Off);
				::std:: fill(_Mid, _Mid + static_cast<difference_type>(_Rem), _Val);	// fill in rest of values
				}
			else
				{	// insert not longer than prefix
				for (_Num = 0; _Num < _Count; ++_Num)
					{
					push_back(begin()[static_cast<difference_type>(_Off + _Rem - _Count + _Num)]);	// push part of prefix
					}

				_Mid = begin() + static_cast<difference_type>(_Off);
				_Ty _Tmp = _Val;	// in case _Val is in sequence
				::std:: move_backward(_Mid, _Mid + static_cast<difference_type>(_Rem - _Count),
					_Mid + static_cast<difference_type>(_Rem));	// copy rest of prefix
				::std:: fill(_Mid, _Mid + static_cast<difference_type>(_Count), _Tmp);	// fill in values
				}
			} catch (...) {
			while (_Oldsize < this->_Mysize())
				{
				pop_back();	// restore old size, at least
				}

			throw;
			}
			}
		}

	[[noreturn]] void _Xlen() const
		{	// report a length_error
		_Xlength_error("deque<T> too long");
		}

	[[noreturn]] void _Xran() const
		{	// report an out_of_range error
		_Xout_of_range("invalid deque<T> subscript");
		}

	void _Growmap(size_type _Count)
		{	// grow map by at least _Count pointers, _Mapsize() a power of 2
		static_assert(1 < 8,
			"The _Xlen() test should always be performed.");

		_Alpty _Almap(this->_Getal());
		size_type _Newsize = 0 < this->_Mapsize() ? this->_Mapsize() : 1;
		while (_Newsize - this->_Mapsize() < _Count
			|| _Newsize < 8)
			{	// scale _Newsize to 2^N >= _Mapsize() + _Count
			if (max_size() / (sizeof (value_type) <= 1 ? 16 : sizeof (value_type) <= 2 ? 8 : sizeof (value_type) <= 4 ? 4 : sizeof (value_type) <= 8 ? 2 : 1) - _Newsize < _Newsize)
				{
				_Xlen();	// result too long
				}

			_Newsize *= 2;
			}
		_Count = _Newsize - this->_Mapsize();

		size_type _Myboff = this->_Myoff() / (sizeof (value_type) <= 1 ? 16 : sizeof (value_type) <= 2 ? 8 : sizeof (value_type) <= 4 ? 4 : sizeof (value_type) <= 8 ? 2 : 1);
		_Mapptr _Newmap = _Almap.allocate(this->_Mapsize() + _Count);
		_Mapptr _Myptr = _Newmap + _Myboff;

		_Myptr = _Uninitialized_copy(this->_Map() + _Myboff,
			this->_Map() + this->_Mapsize(),
			_Myptr, _Almap);	// copy initial to end
		if (_Myboff <= _Count)
			{	// increment greater than offset of initial block
			_Myptr = _Uninitialized_copy(this->_Map(),
				this->_Map() + _Myboff,
				_Myptr, _Almap);	// copy rest of old
			_Uninitialized_value_construct_n(_Myptr, _Count - _Myboff,
				_Almap);	// clear suffix of new
			_Uninitialized_value_construct_n(_Newmap, _Myboff,
				_Almap);	// clear prefix of new
			}
		else
			{	// increment not greater than offset of initial block
			_Uninitialized_copy(this->_Map(),
				this->_Map() + _Count,
				_Myptr, _Almap);	// copy more old
			_Myptr = _Uninitialized_copy(this->_Map() + _Count,
				this->_Map() + _Myboff,
				_Newmap, _Almap);	// copy rest of old
			_Uninitialized_value_construct_n(_Myptr, _Count,
				_Almap);	// clear rest to initial block
			}

		_Destroy_range(this->_Map() + _Myboff, this->_Map() + this->_Mapsize(), _Almap);
		if (this->_Map() != _Mapptr())
			{
			_Almap.deallocate(this->_Map(), this->_Mapsize());	// free storage for old
			}

		this->_Map() = _Newmap;	// point at new
		this->_Mapsize() += _Count;
		}

	void _Tidy()
		{	// free all storage
		_Alpty _Almap(this->_Getal());
		while (!empty())
			{
			pop_back();
			}

		for (size_type _Block = this->_Mapsize(); 0 < _Block; )
			{	// free storage for a block and destroy pointer
			if (this->_Map()[--_Block] != pointer())
				{	// free block and destroy its pointer
				this->_Getal().deallocate(this->_Map()[_Block], (sizeof (value_type) <= 1 ? 16 : sizeof (value_type) <= 2 ? 8 : sizeof (value_type) <= 4 ? 4 : sizeof (value_type) <= 8 ? 2 : 1));
				_Alpty_traits::destroy(_Almap, ::std:: addressof(this->_Map()[_Block]));
				}
			}

		if (this->_Map() != _Mapptr())
			{
			_Almap.deallocate(this->_Map(), this->_Mapsize());	// free storage for map
			}

		this->_Mapsize() = 0;
		this->_Map() = _Mapptr();
		}

 
	void _Orphan_off(size_type _Offlo) const
		{	// orphan iterators with specified offset(s)
		size_type _Offhigh = this->_Myoff() + this->_Mysize() <= _Offlo + 1
			? (size_type)(-1) : _Offlo;
		if (_Offlo == this->_Myoff())
			{
			_Offlo = 0;
			}

		_Lockit _Lock(3);
		const_iterator **_Pnext = (const_iterator **)this->_Getpfirst();
		if (_Pnext != nullptr)
			{
			while (*_Pnext != nullptr)
				{
				if ((*_Pnext)->_Myoff < _Offlo
					|| _Offhigh < (*_Pnext)->_Myoff)
					{
					_Pnext = (const_iterator **)(*_Pnext)->_Getpnext();
					}
				else
					{	// orphan the iterator
					(*_Pnext)->_Clrcont();
					*_Pnext = *(const_iterator **)(*_Pnext)->_Getpnext();
					}
				}
			}
		}
 
	};












template<class _Ty,
	class _Alloc> inline
	void swap(deque<_Ty, _Alloc>& _Left, deque<_Ty, _Alloc>& _Right) noexcept // strengthened
	{	// swap _Left and _Right deques
	_Left.swap(_Right);
	}

template<class _Ty,
	class _Alloc>
	 inline bool operator==(const deque<_Ty, _Alloc>& _Left,
		const deque<_Ty, _Alloc>& _Right)
	{	// test for deque equality
	return (_Left.size() == _Right.size()
		&& ::std:: equal(_Left.begin(), _Left.end(), _Right.begin()));
	}

template<class _Ty,
	class _Alloc>
	 inline bool operator!=(const deque<_Ty, _Alloc>& _Left,
		const deque<_Ty, _Alloc>& _Right)
	{	// test for deque inequality
	return (!(_Left == _Right));
	}

template<class _Ty,
	class _Alloc>
	 inline bool operator<(const deque<_Ty, _Alloc>& _Left,
		const deque<_Ty, _Alloc>& _Right)
	{	// test if _Left < _Right for deques
	return (::std:: lexicographical_compare(_Left.begin(), _Left.end(),
		_Right.begin(), _Right.end()));
	}

template<class _Ty,
	class _Alloc>
	 inline bool operator<=(const deque<_Ty, _Alloc>& _Left,
		const deque<_Ty, _Alloc>& _Right)
	{	// test if _Left <= _Right for deques
	return (!(_Right < _Left));
	}

template<class _Ty,
	class _Alloc>
	 inline bool operator>(const deque<_Ty, _Alloc>& _Left,
		const deque<_Ty, _Alloc>& _Right)
	{	// test if _Left > _Right for deques
	return (_Right < _Left);
	}

template<class _Ty,
	class _Alloc>
	 inline bool operator>=(const deque<_Ty, _Alloc>& _Left,
		const deque<_Ty, _Alloc>& _Right)
	{	// test if _Left >= _Right for deques
	return (!(_Left < _Right));
	}







}

 
 
 #pragma warning(pop)
 #pragma pack(pop)



/*
 * Copyright (c) by P.J. Plauger. All rights reserved.
 * Consult your license regarding permissions and restrictions.
V6.50:0009 */


 #pragma pack(push,8)
 #pragma warning(push,3)
 #pragma warning(disable: 4455 4494  4619 4643 4702 4984 4988 )
 
 
 
namespace std {
		// CLASS TEMPLATE stack
template<class _Ty,
	class _Container = deque<_Ty> >
	class stack
	{	// LIFO queue implemented with a container
public:
	typedef _Container container_type;
	typedef typename _Container::value_type value_type;
	typedef typename _Container::size_type size_type;
	typedef typename _Container::reference reference;
	typedef typename _Container::const_reference const_reference;

	static_assert(is_same_v<_Ty, value_type>, "container adaptors require consistent types");

	stack() noexcept(is_nothrow_default_constructible_v<_Container>) // strengthened
		: c()
		{	// construct with empty container
		}

	explicit stack(const _Container& _Cont)
		: c(_Cont)
		{	// construct by copying specified container
		}

	template<class _Alloc,
		class = enable_if_t<uses_allocator_v<_Container, _Alloc>>>
		explicit stack(const _Alloc& _Al)
			noexcept(is_nothrow_constructible_v<_Container, const _Alloc&>) // strengthened
		: c(_Al)
		{	// construct with allocator
		}

	template<class _Alloc,
		class = enable_if_t<uses_allocator_v<_Container, _Alloc>>>
		stack(const stack& _Right, const _Alloc& _Al)
		: c(_Right.c, _Al)
		{	// construct by copying specified container
		}

	template<class _Alloc,
		class = enable_if_t<uses_allocator_v<_Container, _Alloc>>>
		stack(const _Container& _Cont, const _Alloc& _Al)
		: c(_Cont, _Al)
		{	// construct by copying specified container
		}

	explicit stack(_Container&& _Cont)
			noexcept(is_nothrow_move_constructible_v<_Container>) // strengthened
		: c(::std:: move(_Cont))
		{	// construct by moving specified container
		}

	template<class _Alloc,
		class = enable_if_t<uses_allocator_v<_Container, _Alloc>>>
		stack(stack&& _Right, const _Alloc& _Al)
			noexcept(is_nothrow_constructible_v<_Container, _Container, const _Alloc&>) // strengthened
		: c(::std:: move(_Right.c), _Al)
		{	// construct by moving specified container
		}

	template<class _Alloc,
		class = enable_if_t<uses_allocator_v<_Container, _Alloc>>>
		stack(_Container&& _Cont, const _Alloc& _Al)
			noexcept(is_nothrow_constructible_v<_Container, _Container, const _Alloc&>) // strengthened
		: c(::std:: move(_Cont), _Al)
		{	// construct by moving specified container
		}

	void push(value_type&& _Val)
		{	// insert element at beginning
		c.push_back(::std:: move(_Val));
		}

	template<class... _Valty>
		decltype(auto) emplace(_Valty&&... _Val)
		{	// insert element at beginning



		c.emplace_back(::std:: forward<_Valty>(_Val)...);

		}

	 bool empty() const
		{	// test if stack is empty
		return (c.empty());
		}

	 size_type size() const
		{	// test length of stack
		return (c.size());
		}

	 reference top()
		{	// return last element of mutable stack
		return (c.back());
		}

	 const_reference top() const
		{	// return last element of nonmutable stack
		return (c.back());
		}

	void push(const value_type& _Val)
		{	// insert element at end
		c.push_back(_Val);
		}

	void pop()
		{	// erase last element
		c.pop_back();
		}

	const _Container& _Get_container() const
		{	// get reference to container
		return (c);
		}

	void swap(stack& _Right) noexcept(_Is_nothrow_swappable<_Container>::value)
		{	// exchange contents with _Right
		_Swap_adl(c, _Right.c);
		}

protected:
	_Container c;	// the underlying container
	};


















template<class _Ty,
	class _Container,
	class = enable_if_t<_Is_swappable<_Container>::value>> inline
	void swap(stack<_Ty, _Container>& _Left,
		stack<_Ty, _Container>& _Right)
			noexcept(noexcept(_Left.swap(_Right)))
	{	// swap _Left and _Right stacks
	_Left.swap(_Right);
	}

template<class _Ty,
	class _Container>
	 inline bool operator==(const stack<_Ty, _Container>& _Left,
		const stack<_Ty, _Container>& _Right)
	{	// test for stack equality
	return (_Left._Get_container() == _Right._Get_container());
	}

template<class _Ty,
	class _Container>
	 inline bool operator!=(const stack<_Ty, _Container>& _Left,
		const stack<_Ty, _Container>& _Right)
	{	// test for stack inequality
	return (!(_Left == _Right));
	}

template<class _Ty,
	class _Container>
	 inline bool operator<(const stack<_Ty, _Container>& _Left,
		const stack<_Ty, _Container>& _Right)
	{	// test if _Left < _Right for stacks
	return (_Left._Get_container() < _Right._Get_container());
	}

template<class _Ty,
	class _Container>
	 inline bool operator>(const stack<_Ty, _Container>& _Left,
		const stack<_Ty, _Container>& _Right)
	{	// test if _Left > _Right for stacks
	return (_Right < _Left);
	}

template<class _Ty,
	class _Container>
	 inline bool operator<=(const stack<_Ty, _Container>& _Left,
		const stack<_Ty, _Container>& _Right)
	{	// test if _Left <= _Right for stacks
	return (!(_Right < _Left));
	}

template<class _Ty,
	class _Container>
	 inline bool operator>=(const stack<_Ty, _Container>& _Left,
		const stack<_Ty, _Container>& _Right)
	{	// test if _Left >= _Right for stacks
	return (!(_Left < _Right));
	}
}

namespace std {
template<class _Ty,
	class _Container,
	class _Alloc>
	struct uses_allocator<stack<_Ty, _Container>, _Alloc>
		: uses_allocator<_Container, _Alloc>::type
	{	// true_type if container allocator enabled
	};
}	// namespace std

 
 
 #pragma warning(pop)
 #pragma pack(pop)



/*
 * Copyright (c) by P.J. Plauger. All rights reserved.
 * Consult your license regarding permissions and restrictions.
V6.50:0009 */


// vector standard header
#pragma once










 #pragma pack(push,8)
 #pragma warning(push,3)
 #pragma warning(disable: 4455 4494  4619 4643 4702 4984 4988 )
 
 
 

namespace std {
		// CLASS TEMPLATE _Vector_const_iterator
template<class _Myvec>
	class _Vector_const_iterator
		: public _Iterator_base
	{	// iterator for nonmutable vector
public:
	using iterator_category = random_access_iterator_tag;

	using value_type = typename _Myvec::value_type;
	using difference_type = typename _Myvec::difference_type;
	using pointer = typename _Myvec::const_pointer;
	using reference = const value_type&;
	using _Tptr = typename _Myvec::pointer;

	_Vector_const_iterator()
		: _Ptr()
		{	// construct with null pointer
		}

	_Vector_const_iterator(_Tptr _Parg, const _Container_base *_Pvector)
		: _Ptr(_Parg)
		{	// construct with pointer _Parg
		this->_Adopt(_Pvector);
		}

	 reference operator*() const
		{	// return designated object
 
		const auto _Mycont = static_cast<const _Myvec *>(this->_Getcont());
		do { if (_Ptr) { } else { do { (void) ((1 != _CrtDbgReport(2, "c:\\visual studio\\vc\\tools\\msvc\\14.16.27023\\include\\vector", 50, 0, "%s", "can't dereference value-initialized vector iterator")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"can't dereference value-initialized vector iterator\"", __LPREFIX( __FUNCTION__), L"c:\\visual studio\\vc\\tools\\msvc\\14.16.27023\\include\\vector", 50, 0); } while (false); } ; } while (false);
		do { if (_Mycont->_Myfirst <= _Ptr && _Ptr < _Mycont->_Mylast) { } else { do { (void) ((1 != _CrtDbgReport(2, "c:\\visual studio\\vc\\tools\\msvc\\14.16.27023\\include\\vector", 52, 0, "%s", "can't dereference out of range vector iterator")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"can't dereference out of range vector iterator\"", __LPREFIX( __FUNCTION__), L"c:\\visual studio\\vc\\tools\\msvc\\14.16.27023\\include\\vector", 52, 0); } while (false); } ; } while (false);
 

		return (*_Ptr);
		}

	 pointer operator->() const
		{	// return pointer to class object
 
		const auto _Mycont = static_cast<const _Myvec *>(this->_Getcont());
		do { if (_Ptr) { } else { do { (void) ((1 != _CrtDbgReport(2, "c:\\visual studio\\vc\\tools\\msvc\\14.16.27023\\include\\vector", 62, 0, "%s", "can't dereference value-initialized vector iterator")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"can't dereference value-initialized vector iterator\"", __LPREFIX( __FUNCTION__), L"c:\\visual studio\\vc\\tools\\msvc\\14.16.27023\\include\\vector", 62, 0); } while (false); } ; } while (false);
		do { if (_Mycont->_Myfirst <= _Ptr && _Ptr < _Mycont->_Mylast) { } else { do { (void) ((1 != _CrtDbgReport(2, "c:\\visual studio\\vc\\tools\\msvc\\14.16.27023\\include\\vector", 64, 0, "%s", "can't dereference out of range vector iterator")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"can't dereference out of range vector iterator\"", __LPREFIX( __FUNCTION__), L"c:\\visual studio\\vc\\tools\\msvc\\14.16.27023\\include\\vector", 64, 0); } while (false); } ; } while (false);
 

		return (_Ptr);
		}

	_Vector_const_iterator& operator++()
		{	// preincrement
 
		const auto _Mycont = static_cast<const _Myvec *>(this->_Getcont());
		do { if (_Ptr) { } else { do { (void) ((1 != _CrtDbgReport(2, "c:\\visual studio\\vc\\tools\\msvc\\14.16.27023\\include\\vector", 74, 0, "%s", "can't increment value-initialized vector iterator")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"can't increment value-initialized vector iterator\"", __LPREFIX( __FUNCTION__), L"c:\\visual studio\\vc\\tools\\msvc\\14.16.27023\\include\\vector", 74, 0); } while (false); } ; } while (false);
		do { if (_Ptr < _Mycont->_Mylast) { } else { do { (void) ((1 != _CrtDbgReport(2, "c:\\visual studio\\vc\\tools\\msvc\\14.16.27023\\include\\vector", 75, 0, "%s", "can't increment vector iterator past end")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"can't increment vector iterator past end\"", __LPREFIX( __FUNCTION__), L"c:\\visual studio\\vc\\tools\\msvc\\14.16.27023\\include\\vector", 75, 0); } while (false); } ; } while (false);
 

		++_Ptr;
		return (*this);
		}

	_Vector_const_iterator operator++(int)
		{	// postincrement
		_Vector_const_iterator _Tmp = *this;
		++*this;
		return (_Tmp);
		}

	_Vector_const_iterator& operator--()
		{	// predecrement
 
		const auto _Mycont = static_cast<const _Myvec *>(this->_Getcont());
		do { if (_Ptr) { } else { do { (void) ((1 != _CrtDbgReport(2, "c:\\visual studio\\vc\\tools\\msvc\\14.16.27023\\include\\vector", 93, 0, "%s", "can't decrement value-initialized vector iterator")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"can't decrement value-initialized vector iterator\"", __LPREFIX( __FUNCTION__), L"c:\\visual studio\\vc\\tools\\msvc\\14.16.27023\\include\\vector", 93, 0); } while (false); } ; } while (false);
		do { if (_Mycont->_Myfirst < _Ptr) { } else { do { (void) ((1 != _CrtDbgReport(2, "c:\\visual studio\\vc\\tools\\msvc\\14.16.27023\\include\\vector", 94, 0, "%s", "can't decrement vector iterator before begin")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"can't decrement vector iterator before begin\"", __LPREFIX( __FUNCTION__), L"c:\\visual studio\\vc\\tools\\msvc\\14.16.27023\\include\\vector", 94, 0); } while (false); } ; } while (false);
 

		--_Ptr;
		return (*this);
		}

	_Vector_const_iterator operator--(int)
		{	// postdecrement
		_Vector_const_iterator _Tmp = *this;
		--*this;
		return (_Tmp);
		}

	void _Verify_offset(const difference_type _Off) const
		{
 


		const auto _Mycont = static_cast<const _Myvec *>(this->_Getcont());
		do { if (_Off == 0 || _Ptr) { } else { do { (void) ((1 != _CrtDbgReport(2, "c:\\visual studio\\vc\\tools\\msvc\\14.16.27023\\include\\vector", 114, 0, "%s", "cannot seek value-initialized vector iterator")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"cannot seek value-initialized vector iterator\"", __LPREFIX( __FUNCTION__), L"c:\\visual studio\\vc\\tools\\msvc\\14.16.27023\\include\\vector", 114, 0); } while (false); } ; } while (false);
		if (_Off < 0)
			{
			do { if (_Off >= _Mycont->_Myfirst - _Ptr) { } else { do { (void) ((1 != _CrtDbgReport(2, "c:\\visual studio\\vc\\tools\\msvc\\14.16.27023\\include\\vector", 117, 0, "%s", "cannot seek vector iterator before begin")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"cannot seek vector iterator before begin\"", __LPREFIX( __FUNCTION__), L"c:\\visual studio\\vc\\tools\\msvc\\14.16.27023\\include\\vector", 117, 0); } while (false); } ; } while (false);
			}

		if (_Off > 0)
			{
			do { if (_Off <= _Mycont->_Mylast - _Ptr) { } else { do { (void) ((1 != _CrtDbgReport(2, "c:\\visual studio\\vc\\tools\\msvc\\14.16.27023\\include\\vector", 122, 0, "%s", "cannot seek vector iterator after end")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"cannot seek vector iterator after end\"", __LPREFIX( __FUNCTION__), L"c:\\visual studio\\vc\\tools\\msvc\\14.16.27023\\include\\vector", 122, 0); } while (false); } ; } while (false);
			}
 
		}

	_Vector_const_iterator& operator+=(const difference_type _Off)
		{	// increment by integer
		_Verify_offset(_Off);
		_Ptr += _Off;
		return (*this);
		}

	 _Vector_const_iterator operator+(const difference_type _Off) const
		{	// return this + integer
		_Vector_const_iterator _Tmp = *this;
		return (_Tmp += _Off);
		}

	_Vector_const_iterator& operator-=(const difference_type _Off)
		{	// decrement by integer
		return (*this += -_Off);
		}

	 _Vector_const_iterator operator-(const difference_type _Off) const
		{	// return this - integer
		_Vector_const_iterator _Tmp = *this;
		return (_Tmp -= _Off);
		}

	 difference_type operator-(const _Vector_const_iterator& _Right) const
		{	// return difference of iterators
		_Compat(_Right);
		return (_Ptr - _Right._Ptr);
		}

	 reference operator[](const difference_type _Off) const
		{	// subscript
		return (*(*this + _Off));
		}

	 bool operator==(const _Vector_const_iterator& _Right) const
		{	// test for iterator equality
		_Compat(_Right);
		return (_Ptr == _Right._Ptr);
		}

	 bool operator!=(const _Vector_const_iterator& _Right) const
		{	// test for iterator inequality
		return (!(*this == _Right));
		}

	 bool operator<(const _Vector_const_iterator& _Right) const
		{	// test if this < _Right
		_Compat(_Right);
		return (_Ptr < _Right._Ptr);
		}

	 bool operator>(const _Vector_const_iterator& _Right) const
		{	// test if this > _Right
		return (_Right < *this);
		}

	 bool operator<=(const _Vector_const_iterator& _Right) const
		{	// test if this <= _Right
		return (!(_Right < *this));
		}

	 bool operator>=(const _Vector_const_iterator& _Right) const
		{	// test if this >= _Right
		return (!(*this < _Right));
		}

	void _Compat(const _Vector_const_iterator& _Right) const
		{	// test for compatible iterator pair
 


		do { if (this->_Getcont() == _Right._Getcont()) { } else { do { (void) ((1 != _CrtDbgReport(2, "c:\\visual studio\\vc\\tools\\msvc\\14.16.27023\\include\\vector", 199, 0, "%s", "vector iterators incompatible")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"vector iterators incompatible\"", __LPREFIX( __FUNCTION__), L"c:\\visual studio\\vc\\tools\\msvc\\14.16.27023\\include\\vector", 199, 0); } while (false); } ; } while (false);
 
		}

 
	friend void _Verify_range(const _Vector_const_iterator& _First, const _Vector_const_iterator& _Last)
		{
		do { if (_First._Getcont() == _Last._Getcont()) { } else { do { (void) ((1 != _CrtDbgReport(2, "c:\\visual studio\\vc\\tools\\msvc\\14.16.27023\\include\\vector", 207, 0, "%s", "vector iterators in range are from different containers")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"vector iterators in range are from different containers\"", __LPREFIX( __FUNCTION__), L"c:\\visual studio\\vc\\tools\\msvc\\14.16.27023\\include\\vector", 207, 0); } while (false); } ; } while (false);
		do { if (_First._Ptr <= _Last._Ptr) { } else { do { (void) ((1 != _CrtDbgReport(2, "c:\\visual studio\\vc\\tools\\msvc\\14.16.27023\\include\\vector", 208, 0, "%s", "vector iterator range transposed")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"vector iterator range transposed\"", __LPREFIX( __FUNCTION__), L"c:\\visual studio\\vc\\tools\\msvc\\14.16.27023\\include\\vector", 208, 0); } while (false); } ; } while (false);
		}
 

	 pointer _Unwrapped() const
		{
		return (_Ptr);
		}

	void _Seek_to(pointer _It)
		{
		_Ptr = _Const_cast(_It);
		}

	_Tptr _Ptr;	// pointer to element in vector
	};

template<class _Myvec>
	 inline _Vector_const_iterator<_Myvec> operator+(
		typename _Vector_const_iterator<_Myvec>::difference_type _Off,
		_Vector_const_iterator<_Myvec> _Next)
	{	// add offset to iterator
	return (_Next += _Off);
	}

		// CLASS TEMPLATE _Vector_iterator
template<class _Myvec>
	class _Vector_iterator
		: public _Vector_const_iterator<_Myvec>
	{	// iterator for mutable vector
public:
	using _Mybase = _Vector_const_iterator<_Myvec>;
	using iterator_category = random_access_iterator_tag;

	using value_type = typename _Myvec::value_type;
	using difference_type = typename _Myvec::difference_type;
	using pointer = typename _Myvec::pointer;
	using reference = value_type&;

	_Vector_iterator()
		{	// construct with null vector pointer
		}

	_Vector_iterator(pointer _Parg, const _Container_base *_Pvector)
		: _Mybase(_Parg, _Pvector)
		{	// construct with pointer _Parg
		}

	 reference operator*() const
		{	// return designated object
		return (const_cast<reference>(_Mybase::operator*()));
		}

	 pointer operator->() const
		{	// return pointer to class object
		return (_Const_cast(_Mybase::operator->()));
		}

	_Vector_iterator& operator++()
		{	// preincrement
		++*(_Mybase *)this;
		return (*this);
		}

	_Vector_iterator operator++(int)
		{	// postincrement
		_Vector_iterator _Tmp = *this;
		++*this;
		return (_Tmp);
		}

	_Vector_iterator& operator--()
		{	// predecrement
		--*(_Mybase *)this;
		return (*this);
		}

	_Vector_iterator operator--(int)
		{	// postdecrement
		_Vector_iterator _Tmp = *this;
		--*this;
		return (_Tmp);
		}

	_Vector_iterator& operator+=(const difference_type _Off)
		{	// increment by integer
		*(_Mybase *)this += _Off;
		return (*this);
		}

	 _Vector_iterator operator+(const difference_type _Off) const
		{	// return this + integer
		_Vector_iterator _Tmp = *this;
		return (_Tmp += _Off);
		}

	_Vector_iterator& operator-=(const difference_type _Off)
		{	// decrement by integer
		return (*this += -_Off);
		}

	 _Vector_iterator operator-(const difference_type _Off) const
		{	// return this - integer
		_Vector_iterator _Tmp = *this;
		return (_Tmp -= _Off);
		}

	 difference_type operator-(const _Mybase& _Right) const
		{	// return difference of iterators
		return (*(_Mybase *)this - _Right);
		}

	 reference operator[](const difference_type _Off) const
		{	// subscript
		return (*(*this + _Off));
		}

	 pointer _Unwrapped() const
		{
		return (this->_Ptr);
		}
	};

template<class _Myvec>
	 inline _Vector_iterator<_Myvec> operator+(
		typename _Vector_iterator<_Myvec>::difference_type _Off,
		_Vector_iterator<_Myvec> _Next)
	{	// add offset to iterator
	return (_Next += _Off);
	}

		// vector TYPE WRAPPERS
template<class _Value_type,
	class _Size_type,
	class _Difference_type,
	class _Pointer,
	class _Const_pointer,
	class _Reference,
	class _Const_reference>
	struct _Vec_iter_types
	{	// wraps types needed by iterators
	using value_type = _Value_type;
	using size_type = _Size_type;
	using difference_type = _Difference_type;
	using pointer = _Pointer;
	using const_pointer = _Const_pointer;
	};

template<class _Ty,
	class _Alloc>
	struct _Vec_base_types
	{	// types needed for a container base
	using _Alty = _Rebind_alloc_t<_Alloc, _Ty>;
	using _Alty_traits = allocator_traits<_Alty>;

	using _Val_types = conditional_t<_Is_simple_alloc_v<_Alty>,
		_Simple_types<_Ty>,
		_Vec_iter_types<_Ty,
			typename _Alty_traits::size_type,
			typename _Alty_traits::difference_type,
			typename _Alty_traits::pointer,
			typename _Alty_traits::const_pointer,
			_Ty&,
			const _Ty&>>;
	};

		// CLASS TEMPLATE _Vector_val
template<class _Val_types>
	class _Vector_val
		: public _Container_base
	{	// base class for vector to hold data
public:
	using value_type = typename _Val_types::value_type;
	using size_type = typename _Val_types::size_type;
	using difference_type = typename _Val_types::difference_type;
	using pointer = typename _Val_types::pointer;
	using const_pointer = typename _Val_types::const_pointer;
	using reference = value_type&;
	using const_reference = const value_type&;

	_Vector_val()
		: _Myfirst(),
		_Mylast(),
		_Myend()
		{	// initialize values
		}

	pointer _Myfirst;	// pointer to beginning of array
	pointer _Mylast;	// pointer to current end of sequence
	pointer _Myend;	// pointer to end of array
	};

		// CLASS TEMPLATE _Vector_alloc
template<class _Alloc_types>
	class _Vector_alloc
	{	// base class for vector to hold allocator
public:
	using _Alty = typename _Alloc_types::_Alty;
	using _Alty_traits = typename _Alloc_types::_Alty_traits;
	using _Alproxy = _Rebind_alloc_t<_Alty, _Container_proxy>;
	using _Alproxy_traits = allocator_traits<_Alproxy>;
	using _Val_types = typename _Alloc_types::_Val_types;

	using size_type = typename _Val_types::size_type;
	using difference_type = typename _Val_types::difference_type;
	using pointer = typename _Val_types::pointer;
	using const_pointer = typename _Val_types::const_pointer;

	using iterator = _Vector_iterator<_Vector_val<_Val_types>>;
	using const_iterator = _Vector_const_iterator<_Vector_val<_Val_types>>;

 
























	_Vector_alloc()
		: _Mypair(_Zero_then_variadic_args_t())
		{	// default construct allocator
		_Alloc_proxy();
		}

	template<class _Any_alloc,
		class = enable_if_t<!is_same_v<remove_cv_t<remove_reference_t<_Any_alloc>>, _Vector_alloc>>>
		_Vector_alloc(_Any_alloc&& _Al)
		: _Mypair(_One_then_variadic_args_t(),
			::std:: forward<_Any_alloc>(_Al))
		{	// construct allocator from _Al
		_Alloc_proxy();
		}

	~_Vector_alloc() noexcept
		{	// destroy proxy
		_Free_proxy();
		}

	void _Copy_alloc(const _Alty& _Al)
		{	// replace old allocator
		const bool _Reload = _Alty_traits::propagate_on_container_copy_assignment::value
			&& _Getal() != _Al;

		if (_Reload)
			{
			_Free_proxy();
			}

		_Pocca(_Getal(), _Al);

		if (_Reload)
			{
			_Alloc_proxy();
			}
		}

	void _Move_alloc(_Alty& _Al)
		{	// replace old allocator
		const bool _Reload = _Alty_traits::propagate_on_container_move_assignment::value
			&& _Getal() != _Al;

		if (_Reload)
			{
			_Free_proxy();
			}

		_Pocma(_Getal(), _Al);

		if (_Reload)
			{
			_Alloc_proxy();
			}
		}

	void _Alloc_proxy()
		{	// construct proxy
		_Alproxy _Proxy_allocator(_Getal());
		_Myproxy() = _Unfancy(_Proxy_allocator.allocate(1));
		_Alproxy_traits::construct(_Proxy_allocator, _Myproxy(), _Container_proxy());
		_Myproxy()->_Mycont = ::std:: addressof(_Get_data());
		}

	void _Free_proxy()
		{	// destroy proxy
		_Alproxy _Proxy_allocator(_Getal());
		_Orphan_all();
		_Alproxy_traits::destroy(_Proxy_allocator, _Myproxy());
		_Deallocate_plain(_Proxy_allocator, _Myproxy());
		_Myproxy() = nullptr;
		}

	_Iterator_base12 **_Getpfirst() const
		{	// get address of iterator chain
		return (_Get_data()._Getpfirst());
		}

	_Container_proxy * & _Myproxy() noexcept
		{	// return reference to _Myproxy
		return (_Get_data()._Myproxy);
		}

	_Container_proxy * const & _Myproxy() const noexcept
		{	// return const reference to _Myproxy
		return (_Get_data()._Myproxy);
		}
 

	void _Orphan_all()
		{	// orphan all iterators
		_Get_data()._Orphan_all();
		}

	void _Swap_all(_Vector_alloc& _Right)
		{	// swap all iterators
		_Get_data()._Swap_all(_Right._Get_data());
		}

	_Alty& _Getal() noexcept
		{	// return reference to allocator
		return (_Mypair._Get_first());
		}

	const _Alty& _Getal() const noexcept
		{	// return const reference to allocator
		return (_Mypair._Get_first());
		}

	_Vector_val<_Val_types>& _Get_data() noexcept
		{	// return reference to _Vector_val
		return (_Mypair._Get_second());
		}

	const _Vector_val<_Val_types>& _Get_data() const noexcept
		{	// return const reference to _Vector_val
		return (_Mypair._Get_second());
		}

	iterator _Make_iterator(const pointer _Ptr) noexcept
		{	// return an iterator for pointer _Ptr
		return (iterator(_Ptr, ::std:: addressof(_Mypair._Get_second())));
		}

	iterator _Make_iterator_offset(const size_type _Offset) noexcept
		{	// return the iterator begin() + _Offset without a debugging check
		auto& _My_data = _Mypair._Get_second();
		return (iterator(_My_data._Myfirst + _Offset, ::std:: addressof(_My_data)));
		}

	pointer& _Myfirst() noexcept
		{	// return reference to _Myfirst
		return (_Get_data()._Myfirst);
		}

	const pointer& _Myfirst() const noexcept
		{	// return const reference to _Myfirst
		return (_Get_data()._Myfirst);
		}

	pointer& _Mylast() noexcept
		{	// return reference to _Mylast
		return (_Get_data()._Mylast);
		}

	const pointer& _Mylast() const noexcept
		{	// return const reference to _Mylast
		return (_Get_data()._Mylast);
		}

	pointer& _Myend() noexcept
		{	// return reference to _Myend
		return (_Get_data()._Myend);
		}

	const pointer& _Myend() const noexcept
		{	// return const reference to _Myend
		return (_Get_data()._Myend);
		}

private:
	_Compressed_pair<_Alty, _Vector_val<_Val_types>> _Mypair;
	};

		// FUNCTION TEMPLATE _Unfancy_maybe_null
template<class _Ptrty> inline
	auto _Unfancy_maybe_null(_Ptrty _Ptr)
	{	// converts from a (potentially null) fancy pointer to a plain pointer
	return (_Ptr ? ::std:: addressof(*_Ptr) : nullptr);
	}

template<class _Ty> inline
	_Ty * _Unfancy_maybe_null(_Ty * _Ptr)
	{	// do nothing for plain pointers
	return (_Ptr);
	}

		// CLASS TEMPLATE vector
template<class _Ty,
	class _Alloc = allocator<_Ty>>
	class vector
		: public _Vector_alloc<_Vec_base_types<_Ty, _Alloc>>
	{	// varying size array of values
private:
	using _Mybase = _Vector_alloc<_Vec_base_types<_Ty, _Alloc>>;
	using _Alty = typename _Mybase::_Alty;
	using _Alty_traits = typename _Mybase::_Alty_traits;

public:
	static_assert(!0 || is_same_v<_Ty, typename _Alloc::value_type>,
		"vector<T, Allocator>" " requires that Allocator's value_type match " "T" " (See N4659 26.2.1 [container.requirements.general]/16 allocator_type)" " Either fix the allocator value_type or define _ENFORCE_MATCHING_ALLOCATORS=0" " to suppress this diagnostic.");

	using value_type = _Ty;
	using allocator_type = _Alloc;
	using pointer = typename _Mybase::pointer;
	using const_pointer = typename _Mybase::const_pointer;
	using reference = _Ty&;
	using const_reference = const _Ty&;
	using size_type = typename _Mybase::size_type;
	using difference_type = typename _Mybase::difference_type;
	using iterator = typename _Mybase::iterator;
	using const_iterator = typename _Mybase::const_iterator;
	using reverse_iterator = ::std:: reverse_iterator<iterator>;
	using const_reverse_iterator = ::std:: reverse_iterator<const_iterator>;

	vector() noexcept(is_nothrow_default_constructible_v<_Alty>)
		: _Mybase()
		{	// construct empty vector
		}

	explicit vector(const _Alloc& _Al) noexcept
		: _Mybase(_Al)
		{	// construct empty vector, allocator
		}

	explicit vector(__declspec(guard(overflow)) const size_type _Count, const _Alloc& _Al = _Alloc())
		: _Mybase(_Al)
		{	// construct from _Count * _Ty(), optional allocator
		if (_Buy(_Count))
			{	// nonzero, fill it
			try {
			this->_Mylast() = _Udefault(this->_Myfirst(), _Count);
			} catch (...) {
			_Tidy();
			throw;
			}
			}
		}

	vector(__declspec(guard(overflow)) const size_type _Count, const _Ty& _Val, const _Alloc& _Al = _Alloc())
		: _Mybase(_Al)
		{	// construct from _Count * _Val, optional allocator
		if (_Buy(_Count))
			{	// nonzero, fill it
			try {
			this->_Mylast() = _Ufill(this->_Myfirst(), _Count, _Val);
			} catch (...) {
			_Tidy();
			throw;
			}
			}
		}

private:
	template<class _Iter>
		void _Range_construct_or_tidy(_Iter _First, _Iter _Last, input_iterator_tag)
		{	// initialize with [_First, _Last), avoid leaking, input iterators
		try {
		for (; _First != _Last; ++_First)
			{
			emplace_back(*_First);	// performance note: emplace_back()'s strong guarantee is unnecessary here
			}
		} catch (...) {
		_Tidy();
		throw;
		}
		}

	template<class _Iter>
		void _Range_construct_or_tidy(_Iter _First, _Iter _Last, forward_iterator_tag)
		{	// initialize with [_First, _Last), avoid leaking, forward iterators
		if (_Buy(_Convert_size<size_type>(static_cast<size_t>(::std:: distance(_First, _Last)))))
			{	// nonzero, fill it
			try {
			this->_Mylast() = _Ucopy(_First, _Last, this->_Myfirst());
			} catch (...) {
			_Tidy();
			throw;
			}
			}
		}

public:
	template<class _Iter,
		class = enable_if_t<_Is_iterator_v<_Iter>>>
		vector(_Iter _First, _Iter _Last, const _Alloc& _Al = _Alloc())
		: _Mybase(_Al)
		{	// construct from [_First, _Last) with optional allocator
		_Adl_verify_range(_First, _Last);
		_Range_construct_or_tidy(_Get_unwrapped(_First), _Get_unwrapped(_Last), _Iter_cat_t<_Iter>{});
		}

	vector(initializer_list<_Ty> _Ilist, const _Alloc& _Al = _Alloc())
		: _Mybase(_Al)
		{	// construct from initializer_list, optional allocator
		_Range_construct_or_tidy(_Ilist.begin(), _Ilist.end(), random_access_iterator_tag{});
		}

	vector(const vector& _Right)
		: _Mybase(_Alty_traits::select_on_container_copy_construction(_Right._Getal()))
		{	// construct by copying _Right
		if (_Buy(_Right.size()))
			{	// nonzero, fill it
			try {
			this->_Mylast() = _Ucopy(_Right._Myfirst(), _Right._Mylast(), this->_Myfirst());
			} catch (...) {
			_Tidy();
			throw;
			}
			}
		}

	vector(const vector& _Right, const _Alloc& _Al)
		: _Mybase(_Al)
		{	// construct by copying _Right, allocator
		if (_Buy(_Right.size()))
			{	// nonzero, fill it
			try {
			this->_Mylast() = _Ucopy(_Right._Myfirst(), _Right._Mylast(), this->_Myfirst());
			} catch (...) {
			_Tidy();
			throw;
			}
			}
		}

private:
	void _Move_from(vector&& _Right, true_type) noexcept
		{	// move from _Right, stealing its contents
		this->_Swap_all(_Right);

		this->_Myfirst() = _Right._Myfirst();
		this->_Mylast() = _Right._Mylast();
		this->_Myend() = _Right._Myend();

		_Right._Myfirst() = pointer();
		_Right._Mylast() = pointer();
		_Right._Myend() = pointer();
		}

	void _Move_from(vector&& _Right, false_type)
		{	// move from _Right, possibly moving its contents
		if (this->_Getal() == _Right._Getal())
			{
			_Move_from(::std:: move(_Right), true_type{});
			}
		else if (_Buy(_Right.size()))
			{	// nonzero, fill it
			this->_Mylast() = _Umove(_Right._Myfirst(), _Right._Mylast(), this->_Myfirst());
			}
		}

public:
	vector(vector&& _Right) noexcept
		: _Mybase(::std:: move(_Right._Getal()))
		{	// construct by moving _Right
		_Move_from(::std:: move(_Right), true_type{});
		}

	vector(vector&& _Right, const _Alloc& _Al)
		noexcept(_Alty_traits::is_always_equal::value) // strengthened
		: _Mybase(_Al)
		{	// construct by moving _Right, allocator
		if /* constexpr */ (_Alty_traits::is_always_equal::value)
			{
			_Move_from(::std:: move(_Right), true_type{});
			}
		else
			{
#pragma warning(push) 
#pragma warning(disable: 4297) 
			try {
			_Move_from(::std:: move(_Right), false_type{});
			} catch (...) {
			_Tidy();
			throw;
			}
#pragma warning(pop)
			}
		}

private:
	void _Move_assign_from(vector&& _Right, true_type) noexcept
		{	// move from _Right, stealing its contents
		_Move_from(::std:: move(_Right), true_type{});
		}

	void _Move_assign_from(vector&& _Right, false_type)
		{	// move from _Right, possibly moving its contents
		if (this->_Getal() == _Right._Getal())
			{
			_Move_from(::std:: move(_Right), true_type{});
			return;
			}

		const pointer _First = _Right._Myfirst();
		const pointer _Last = _Right._Mylast();
		const size_type _Newsize = _Right.size();

		this->_Orphan_all();

		const size_type _Oldsize = size();
		const size_type _Oldcapacity = capacity();

		if (_Newsize > _Oldcapacity)
			{	// reallocate
			if (_Newsize > max_size())
				{
				_Xlength();
				}

			const size_type _Newcapacity = _Calculate_growth(_Newsize);

			if (this->_Myfirst() != pointer())
				{	// destroy and deallocate old array
				_Destroy(this->_Myfirst(), this->_Mylast());
				this->_Getal().deallocate(this->_Myfirst(), _Oldcapacity);
				}

			_Buy(_Newcapacity);

			this->_Mylast() = _Umove(_First, _Last, this->_Myfirst());
			}
		else if (_Newsize > _Oldsize)
			{
			const pointer _Mid = _First + _Oldsize;
			_Move_unchecked(_First, _Mid, this->_Myfirst());
			this->_Mylast() = _Umove(_Mid, _Last, this->_Mylast());
			}
		else
			{
			const pointer _Newlast = this->_Myfirst() + _Newsize;
			_Move_unchecked(_First, _Last, this->_Myfirst());
			_Destroy(_Newlast, this->_Mylast());
			this->_Mylast() = _Newlast;
			}
		}

public:
	vector& operator=(vector&& _Right)
		noexcept(_Always_equal_after_move<_Alty>)
		{	// assign by moving _Right
		if (this != ::std:: addressof(_Right))
			{	// different, assign it
#pragma warning(push)
#pragma warning(disable: 4127)	
			if (_Always_equal_after_move<_Alty>
				|| this->_Getal() == _Right._Getal())
				{	// will steal _Right's contents (also, POCMA non-equal must reload array)
				_Tidy();
				}
#pragma warning(pop)
			this->_Move_alloc(_Right._Getal());
			_Move_assign_from(::std:: move(_Right), bool_constant<_Always_equal_after_move<_Alty>>{});
			}
		return (*this);
		}

	~vector() noexcept
		{	// destroy the object
		_Tidy();
		}

private:
	template<class... _Valty>
		decltype(auto) _Emplace_back_with_unused_capacity(_Valty&&... _Val)
		{	// insert by perfectly forwarding into element at end, provide strong guarantee
			// pre: _Has_unused_capacity()
		_Alty_traits::construct(this->_Getal(), _Unfancy(this->_Mylast()), ::std:: forward<_Valty>(_Val)...);
		_Orphan_range(this->_Mylast(), this->_Mylast());
		_Ty& _Result = *this->_Mylast();
		++this->_Mylast();



		(void)_Result;

		}

public:
	template<class... _Valty>
		decltype(auto) emplace_back(_Valty&&... _Val)
		{	// insert by perfectly forwarding into element at end, provide strong guarantee
		if (_Has_unused_capacity())
			{
			return (_Emplace_back_with_unused_capacity(::std:: forward<_Valty>(_Val)...));
			}

		_Ty& _Result = *_Emplace_reallocate(this->_Mylast(), ::std:: forward<_Valty>(_Val)...);



		(void)_Result;

		}

	void push_back(const _Ty& _Val)
		{	// insert element at end, provide strong guarantee
		emplace_back(_Val);
		}

	void push_back(_Ty&& _Val)
		{	// insert by moving into element at end, provide strong guarantee
		emplace_back(::std:: move(_Val));
		}

	template<class... _Valty>
		pointer _Emplace_reallocate(const pointer _Whereptr, _Valty&&... _Val)
		{	// reallocate and insert by perfectly forwarding _Val at _Whereptr
			// pre: !_Has_unused_capacity()
		const size_type _Whereoff = static_cast<size_type>(_Whereptr - this->_Myfirst());
		_Alty& _Al = this->_Getal();
		const size_type _Oldsize = size();

		if (_Oldsize == max_size())
			{
			_Xlength();
			}

		const size_type _Newsize = _Oldsize + 1;
		const size_type _Newcapacity = _Calculate_growth(_Newsize);

		const pointer _Newvec = _Al.allocate(_Newcapacity);
		const pointer _Constructed_last = _Newvec + _Whereoff + 1;
		pointer _Constructed_first = _Constructed_last;

		try {
		_Alty_traits::construct(_Al, _Unfancy(_Newvec + _Whereoff), ::std:: forward<_Valty>(_Val)...);
		_Constructed_first = _Newvec + _Whereoff;

		if (_Whereptr == this->_Mylast())
			{	// at back, provide strong guarantee
			_Umove_if_noexcept(this->_Myfirst(), this->_Mylast(), _Newvec);
			}
		else
			{	// provide basic guarantee
			_Umove(this->_Myfirst(), _Whereptr, _Newvec);
			_Constructed_first = _Newvec;
			_Umove(_Whereptr, this->_Mylast(), _Newvec + _Whereoff + 1);
			}
		} catch (...) {
		_Destroy(_Constructed_first, _Constructed_last);
		_Al.deallocate(_Newvec, _Newcapacity);
		throw;
		}

		_Change_array(_Newvec, _Newsize, _Newcapacity);
		return (this->_Myfirst() + _Whereoff);
		}

	template<class... _Valty>
		iterator emplace(const_iterator _Where, _Valty&&... _Val)
		{	// insert by perfectly forwarding _Val at _Where
		const pointer _Whereptr = _Where._Ptr;
		const pointer _Oldlast = this->_Mylast();
 
		do { if (_Where._Getcont() == ::std:: addressof(this->_Get_data()) && _Whereptr >= this->_Myfirst() && _Oldlast >= _Whereptr) { } else { do { (void) ((1 != _CrtDbgReport(2, "c:\\visual studio\\vc\\tools\\msvc\\14.16.27023\\include\\vector", 992, 0, "%s", "vector emplace iterator outside range")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"vector emplace iterator outside range\"", __LPREFIX( __FUNCTION__), L"c:\\visual studio\\vc\\tools\\msvc\\14.16.27023\\include\\vector", 992, 0); } while (false); } ; } while (false);
 

		if (_Has_unused_capacity())
			{
			if (_Whereptr == _Oldlast)
				{	// at back, provide strong guarantee
				_Emplace_back_with_unused_capacity(::std:: forward<_Valty>(_Val)...);
				}
			else
				{
				_Ty _Obj(::std:: forward<_Valty>(_Val)...);	// handle aliasing
				// after constructing _Obj, provide basic guarantee
				_Orphan_range(_Whereptr, _Oldlast);
				_Alty_traits::construct(this->_Getal(), _Unfancy(_Oldlast), ::std:: move(_Oldlast[-1]));
				++this->_Mylast();
				_Move_backward_unchecked(_Whereptr, _Oldlast - 1, _Oldlast);
				*_Whereptr = ::std:: move(_Obj);
				}

			return (this->_Make_iterator(_Whereptr));
			}

		return (this->_Make_iterator(_Emplace_reallocate(_Whereptr, ::std:: forward<_Valty>(_Val)...)));
		}

	iterator insert(const_iterator _Where, const _Ty& _Val)
		{	// insert _Val at _Where
		return (emplace(_Where, _Val));
		}

	iterator insert(const_iterator _Where, _Ty&& _Val)
		{	// insert by moving _Val at _Where
		return (emplace(_Where, ::std:: move(_Val)));
		}

	iterator insert(const_iterator _Where, __declspec(guard(overflow)) const size_type _Count, const _Ty& _Val)
		{	// insert _Count * _Val at _Where
 
		do { if (_Where._Getcont() == ::std:: addressof(this->_Get_data()) && _Where._Ptr >= this->_Myfirst() && this->_Mylast() >= _Where._Ptr) { } else { do { (void) ((1 != _CrtDbgReport(2, "c:\\visual studio\\vc\\tools\\msvc\\14.16.27023\\include\\vector", 1033, 0, "%s", "vector insert iterator outside range")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"vector insert iterator outside range\"", __LPREFIX( __FUNCTION__), L"c:\\visual studio\\vc\\tools\\msvc\\14.16.27023\\include\\vector", 1033, 0); } while (false); } ; } while (false);
 

		const size_type _Whereoff = static_cast<size_type>(_Where._Ptr - this->_Myfirst());
		const bool _One_at_back = _Count == 1 && _Where._Ptr == this->_Mylast();

		if (_Count == 0)
			{	// nothing to do, avoid invalidating iterators
			}
		else if (_Count > _Unused_capacity())
			{	// reallocate
			const size_type _Oldsize = size();

			if (_Count > max_size() - _Oldsize)
				{
				_Xlength();
				}

			const size_type _Newsize = _Oldsize + _Count;
			const size_type _Newcapacity = _Calculate_growth(_Newsize);

			const pointer _Newvec = this->_Getal().allocate(_Newcapacity);
			const pointer _Constructed_last = _Newvec + _Whereoff + _Count;
			pointer _Constructed_first = _Constructed_last;

			try {
			_Ufill(_Newvec + _Whereoff, _Count, _Val);
			_Constructed_first = _Newvec + _Whereoff;

			if (_One_at_back)
				{	// provide strong guarantee
				_Umove_if_noexcept(this->_Myfirst(), this->_Mylast(), _Newvec);
				}
			else
				{	// provide basic guarantee
				_Umove(this->_Myfirst(), _Where._Ptr, _Newvec);
				_Constructed_first = _Newvec;
				_Umove(_Where._Ptr, this->_Mylast(), _Newvec + _Whereoff + _Count);
				}
			} catch (...) {
			_Destroy(_Constructed_first, _Constructed_last);
			this->_Getal().deallocate(_Newvec, _Newcapacity);
			throw;
			}

			_Change_array(_Newvec, _Newsize, _Newcapacity);
			}
		else if (_One_at_back)
			{	// provide strong guarantee
			_Emplace_back_with_unused_capacity(_Val);
			}
		else
			{	// provide basic guarantee
			const _Ty _Tmp = _Val;	// handle aliasing
			const pointer _Oldlast = this->_Mylast();
			const size_type _Affected_elements = static_cast<size_type>(_Oldlast - _Where._Ptr);
			_Orphan_range(_Where._Ptr, _Oldlast);

			if (_Count > _Affected_elements)
				{	// new stuff spills off end
				this->_Mylast() = _Ufill(_Oldlast, _Count - _Affected_elements, _Tmp);
				this->_Mylast() = _Umove(_Where._Ptr, _Oldlast, this->_Mylast());
				_Fill_unchecked(_Where._Ptr, _Oldlast, _Tmp);
				}
			else
				{	// new stuff can all be assigned
				this->_Mylast() = _Umove(_Oldlast - _Count, _Oldlast, _Oldlast);
				_Move_backward_unchecked(_Where._Ptr, _Oldlast - _Count, _Oldlast);
				_Fill_unchecked(_Where._Ptr, _Where._Ptr + _Count, _Tmp);
				}
			}

		return (this->_Make_iterator_offset(_Whereoff));
		}

private:
	template<class _Iter>
		void _Insert_range(const_iterator _Where, _Iter _First, _Iter _Last, input_iterator_tag)
		{	// insert [_First, _Last) at _Where, input iterators
		if (_First == _Last)
			{
			return;	// nothing to do, avoid invalidating iterators
			}

		const size_type _Whereoff = static_cast<size_type>(_Where._Ptr - this->_Myfirst());
		const size_type _Oldsize = size();

		// For one-at-back, provide strong guarantee.
		// Otherwise, provide basic guarantee (despite N4659 26.3.11.5 [vector.modifiers]/1).
		// Performance note: except for one-at-back, emplace_back()'s strong guarantee is unnecessary here.

		for (; _First != _Last; ++_First)
			{
			emplace_back(*_First);
			}

		_Orphan_range(this->_Myfirst() + _Whereoff, this->_Myfirst() + _Oldsize);

		_Rotate_unchecked(this->_Myfirst() + _Whereoff, this->_Myfirst() + _Oldsize, this->_Mylast());
		}

	template<class _Iter>
		void _Insert_range(const_iterator _Where, _Iter _First, _Iter _Last, forward_iterator_tag)
		{	// insert [_First, _Last) at _Where, forward iterators
		const size_type _Count = _Convert_size<size_type>(static_cast<size_t>(::std:: distance(_First, _Last)));
		const size_type _Whereoff = static_cast<size_type>(_Where._Ptr - this->_Myfirst());
		const bool _One_at_back = _Count == 1 && _Where._Ptr == this->_Mylast();

		if (_Count == 0)
			{	// nothing to do, avoid invalidating iterators
			}
		else if (_Count > _Unused_capacity())
			{	// reallocate
			const size_type _Oldsize = size();

			if (_Count > max_size() - _Oldsize)
				{
				_Xlength();
				}

			const size_type _Newsize = _Oldsize + _Count;
			const size_type _Newcapacity = _Calculate_growth(_Newsize);

			const pointer _Newvec = this->_Getal().allocate(_Newcapacity);
			const pointer _Constructed_last = _Newvec + _Whereoff + _Count;
			pointer _Constructed_first = _Constructed_last;

			try {
			_Ucopy(_First, _Last, _Newvec + _Whereoff);
			_Constructed_first = _Newvec + _Whereoff;

			if (_One_at_back)
				{	// provide strong guarantee
				_Umove_if_noexcept(this->_Myfirst(), this->_Mylast(), _Newvec);
				}
			else
				{	// provide basic guarantee
				_Umove(this->_Myfirst(), _Where._Ptr, _Newvec);
				_Constructed_first = _Newvec;
				_Umove(_Where._Ptr, this->_Mylast(), _Newvec + _Whereoff + _Count);
				}
			} catch (...) {
			_Destroy(_Constructed_first, _Constructed_last);
			this->_Getal().deallocate(_Newvec, _Newcapacity);
			throw;
			}

			_Change_array(_Newvec, _Newsize, _Newcapacity);
			}
		else
			{	// Attempt to provide the strong guarantee for EmplaceConstructible failure.
				// If we encounter copy/move construction/assignment failure, provide the basic guarantee.
				// (For one-at-back, this provides the strong guarantee.)

			const pointer _Oldlast = this->_Mylast();
			const size_type _Affected_elements = static_cast<size_type>(_Oldlast - _Where._Ptr);

			if (_Count < _Affected_elements)
				{	// some affected elements must be assigned
				this->_Mylast() = _Umove(_Oldlast - _Count, _Oldlast, _Oldlast);
				_Move_backward_unchecked(_Where._Ptr, _Oldlast - _Count, _Oldlast);
				_Destroy(_Where._Ptr, _Where._Ptr + _Count);

				try {
				_Ucopy(_First, _Last, _Where._Ptr);
				} catch (...) {
				// glue the broken pieces back together

					try {
					_Umove(_Where._Ptr + _Count, _Where._Ptr + 2 * _Count, _Where._Ptr);
					} catch (...) {
					// vaporize the detached piece
					_Orphan_range(_Where._Ptr, _Oldlast);
					_Destroy(_Where._Ptr + _Count, this->_Mylast());
					this->_Mylast() = _Where._Ptr;
					throw;
					}

					_Move_unchecked(_Where._Ptr + 2 * _Count, this->_Mylast(), _Where._Ptr + _Count);
					_Destroy(_Oldlast, this->_Mylast());
					this->_Mylast() = _Oldlast;
				throw;
				}
				}
			else
				{	// affected elements don't overlap before/after
				const pointer _Relocated = _Where._Ptr + _Count;
				this->_Mylast() = _Umove(_Where._Ptr, _Oldlast, _Relocated);
				_Destroy(_Where._Ptr, _Oldlast);

				try {
				_Ucopy(_First, _Last, _Where._Ptr);
				} catch (...) {
				// glue the broken pieces back together

					try {
					_Umove(_Relocated, this->_Mylast(), _Where._Ptr);
					} catch (...) {
					// vaporize the detached piece
					_Orphan_range(_Where._Ptr, _Oldlast);
					_Destroy(_Relocated, this->_Mylast());
					this->_Mylast() = _Where._Ptr;
					throw;
					}

					_Destroy(_Relocated, this->_Mylast());
					this->_Mylast() = _Oldlast;
				throw;
				}
				}

			_Orphan_range(_Where._Ptr, _Oldlast);
			}
		}

public:
	template<class _Iter,
		class = enable_if_t<_Is_iterator_v<_Iter>>>
		iterator insert(const_iterator _Where, _Iter _First, _Iter _Last)
		{	// insert [_First, _Last) at _Where
 
		do { if (_Where._Getcont() == ::std:: addressof(this->_Get_data()) && _Where._Ptr >= this->_Myfirst() && this->_Mylast() >= _Where._Ptr) { } else { do { (void) ((1 != _CrtDbgReport(2, "c:\\visual studio\\vc\\tools\\msvc\\14.16.27023\\include\\vector", 1256, 0, "%s", "vector insert iterator outside range")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"vector insert iterator outside range\"", __LPREFIX( __FUNCTION__), L"c:\\visual studio\\vc\\tools\\msvc\\14.16.27023\\include\\vector", 1256, 0); } while (false); } ; } while (false);
 

		_Adl_verify_range(_First, _Last);
		const size_type _Whereoff = static_cast<size_type>(_Where._Ptr - this->_Myfirst());
		_Insert_range(_Where, _Get_unwrapped(_First), _Get_unwrapped(_Last), _Iter_cat_t<_Iter>{});
		return (this->_Make_iterator_offset(_Whereoff));
		}

	iterator insert(const_iterator _Where, initializer_list<_Ty> _Ilist)
		{	// insert initializer_list at _Where
		return (insert(_Where, _Ilist.begin(), _Ilist.end()));
		}

	void assign(__declspec(guard(overflow)) const size_type _Newsize, const _Ty& _Val)
		{	// assign _Newsize * _Val
		this->_Orphan_all();

		const size_type _Oldsize = size();
		const size_type _Oldcapacity = capacity();

		if (_Newsize > _Oldcapacity)
			{	// reallocate
			if (_Newsize > max_size())
				{
				_Xlength();
				}

			const size_type _Newcapacity = _Calculate_growth(_Newsize);

			if (this->_Myfirst() != pointer())
				{	// destroy and deallocate old array
				_Destroy(this->_Myfirst(), this->_Mylast());
				this->_Getal().deallocate(this->_Myfirst(), _Oldcapacity);
				}

			_Buy(_Newcapacity);

			this->_Mylast() = _Ufill(this->_Myfirst(), _Newsize, _Val);
			}
		else if (_Newsize > _Oldsize)
			{
			_Fill_unchecked(this->_Myfirst(), this->_Mylast(), _Val);
			this->_Mylast() = _Ufill(this->_Mylast(), _Newsize - _Oldsize, _Val);
			}
		else
			{
			const pointer _Newlast = this->_Myfirst() + _Newsize;
			_Fill_unchecked(this->_Myfirst(), _Newlast, _Val);
			_Destroy(_Newlast, this->_Mylast());
			this->_Mylast() = _Newlast;
			}
		}

private:
	template<class _Iter>
		void _Assign_range(_Iter _First, _Iter _Last, input_iterator_tag)
		{	// assign [_First, _Last), input iterators
		this->_Orphan_all();

		pointer _Next = this->_Myfirst();

		for (; _First != _Last && _Next != this->_Mylast(); ++_First, (void)++_Next)
			{
			*_Next = *_First;
			}

		// Code size optimization: we've exhausted only the source, only the dest, or both.
		// If we've exhausted only the source: we Trim, then Append does nothing.
		// If we've exhausted only the dest: Trim does nothing, then we Append.
		// If we've exhausted both: Trim does nothing, then Append does nothing.

		// Trim.
		_Destroy(_Next, this->_Mylast());
		this->_Mylast() = _Next;

		// Append.
		for (; _First != _Last; ++_First)
			{
			emplace_back(*_First);	// performance note: emplace_back()'s strong guarantee is unnecessary here
			}
		}

	template<class _Iter>
		void _Assign_range(_Iter _First, _Iter _Last, forward_iterator_tag)
		{	// assign [_First, _Last), forward iterators
		const size_type _Newsize = _Convert_size<size_type>(static_cast<size_t>(::std:: distance(_First, _Last)));

		this->_Orphan_all();

		const size_type _Oldsize = size();
		const size_type _Oldcapacity = capacity();

		if (_Newsize > _Oldcapacity)
			{	// reallocate
			if (_Newsize > max_size())
				{
				_Xlength();
				}

			const size_type _Newcapacity = _Calculate_growth(_Newsize);

			if (this->_Myfirst() != pointer())
				{	// destroy and deallocate old array
				_Destroy(this->_Myfirst(), this->_Mylast());
				this->_Getal().deallocate(this->_Myfirst(), _Oldcapacity);
				}

			_Buy(_Newcapacity);

			this->_Mylast() = _Ucopy(_First, _Last, this->_Myfirst());
			}
		else if (_Newsize > _Oldsize)
			{
			// performance note: traversing [_First, _Mid) twice
			const _Iter _Mid = ::std:: next(_First, static_cast<difference_type>(_Oldsize));
			_Copy_unchecked(_First, _Mid, this->_Myfirst());
			this->_Mylast() = _Ucopy(_Mid, _Last, this->_Mylast());
			}
		else
			{
			const pointer _Newlast = this->_Myfirst() + _Newsize;
			_Copy_unchecked(_First, _Last, this->_Myfirst());
			_Destroy(_Newlast, this->_Mylast());
			this->_Mylast() = _Newlast;
			}
		}

public:
	template<class _Iter,
		class = enable_if_t<_Is_iterator_v<_Iter>>>
		void assign(_Iter _First, _Iter _Last)
		{	// assign [_First, _Last)
		_Adl_verify_range(_First, _Last);
		_Assign_range(_Get_unwrapped(_First), _Get_unwrapped(_Last), _Iter_cat_t<_Iter>{});
		}

	void assign(initializer_list<_Ty> _Ilist)
		{	// assign initializer_list
		_Assign_range(_Ilist.begin(), _Ilist.end(), random_access_iterator_tag{});
		}

	vector& operator=(const vector& _Right)
		{	// assign _Right
		if (this != ::std:: addressof(_Right))
			{	// different, assign it
#pragma warning(push)
#pragma warning(disable: 4127)	
			if (_Alty_traits::propagate_on_container_copy_assignment::value
				&& this->_Getal() != _Right._Getal())
				{	// reload array
				_Tidy();
				}
#pragma warning(pop)

			this->_Copy_alloc(_Right._Getal());

			assign(_Right._Myfirst(), _Right._Mylast());
			}

		return (*this);
		}

	vector& operator=(initializer_list<_Ty> _Ilist)
		{	// assign initializer_list
		_Assign_range(_Ilist.begin(), _Ilist.end(), random_access_iterator_tag{});
		return (*this);
		}

private:
	template<class _Lambda>
		void _Resize(const size_type _Newsize, _Lambda _Udefault_or_fill)
		{	// trim or append elements, provide strong guarantee
		const size_type _Oldsize = size();
		const size_type _Oldcapacity = capacity();

		if (_Newsize > _Oldcapacity)
			{	// reallocate
			if (_Newsize > max_size())
				{
				_Xlength();
				}

			const size_type _Newcapacity = _Calculate_growth(_Newsize);

			const pointer _Newvec = this->_Getal().allocate(_Newcapacity);
			const pointer _Appended_first = _Newvec + _Oldsize;
			pointer _Appended_last = _Appended_first;

			try {
			_Appended_last = _Udefault_or_fill(_Appended_first, _Newsize - _Oldsize);
			_Umove_if_noexcept(this->_Myfirst(), this->_Mylast(), _Newvec);
			} catch (...) {
			_Destroy(_Appended_first, _Appended_last);
			this->_Getal().deallocate(_Newvec, _Newcapacity);
			throw;
			}

			_Change_array(_Newvec, _Newsize, _Newcapacity);
			}
		else if (_Newsize > _Oldsize)
			{	// append
			const pointer _Oldlast = this->_Mylast();
			this->_Mylast() = _Udefault_or_fill(_Oldlast, _Newsize - _Oldsize);
			_Orphan_range(_Oldlast, _Oldlast);
			}
		else if (_Newsize == _Oldsize)
			{	// nothing to do, avoid invalidating iterators
			}
		else
			{	// trim
			const pointer _Newlast = this->_Myfirst() + _Newsize;
			_Orphan_range(_Newlast, this->_Mylast());
			_Destroy(_Newlast, this->_Mylast());
			this->_Mylast() = _Newlast;
			}
		}

public:
	void resize(__declspec(guard(overflow)) const size_type _Newsize)
		{	// trim or append value-initialized elements, provide strong guarantee
		const auto _Lambda_default = [this](pointer _Dest, const size_type _Count)
			{
			return (_Udefault(_Dest, _Count));
			};

		_Resize(_Newsize, _Lambda_default);
		}

	void resize(__declspec(guard(overflow)) const size_type _Newsize, const _Ty& _Val)
		{	// trim or append copies of _Val, provide strong guarantee
		auto _Lambda_fill = [this, &_Val](pointer _Dest, const size_type _Count)
			{
			return (_Ufill(_Dest, _Count, _Val));
			};

		_Resize(_Newsize, _Lambda_fill);
		}

private:
	void _Reallocate_exactly(const size_type _Newcapacity)
		{	// set capacity to _Newcapacity (without geometric growth), provide strong guarantee
		const size_type _Size = size();

		const pointer _Newvec = this->_Getal().allocate(_Newcapacity);

		try {
		_Umove_if_noexcept(this->_Myfirst(), this->_Mylast(), _Newvec);
		} catch (...) {
		this->_Getal().deallocate(_Newvec, _Newcapacity);
		throw;
		}

		_Change_array(_Newvec, _Size, _Newcapacity);
		}

public:
	void reserve(__declspec(guard(overflow)) const size_type _Newcapacity)
		{	// increase capacity to _Newcapacity (without geometric growth), provide strong guarantee
		if (_Newcapacity > capacity())
			{	// something to do (reserve() never shrinks)
			if (_Newcapacity > max_size())
				{
				_Xlength();
				}

			_Reallocate_exactly(_Newcapacity);
			}
		}

	void shrink_to_fit()
		{	// reduce capacity to size, provide strong guarantee
		if (_Has_unused_capacity())
			{	// something to do
			if (empty())
				{
				_Tidy();
				}
			else
				{
				_Reallocate_exactly(size());
				}
			}
		}

	void pop_back()
		{	// erase element at end
 
		do { if (!empty()) { } else { do { (void) ((1 != _CrtDbgReport(2, "c:\\visual studio\\vc\\tools\\msvc\\14.16.27023\\include\\vector", 1544, 0, "%s", "vector empty before pop")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"vector empty before pop\"", __LPREFIX( __FUNCTION__), L"c:\\visual studio\\vc\\tools\\msvc\\14.16.27023\\include\\vector", 1544, 0); } while (false); } ; } while (false);
		_Orphan_range(this->_Mylast() - 1, this->_Mylast());
 

		_Alty_traits::destroy(this->_Getal(), _Unfancy(this->_Mylast() - 1));
		--this->_Mylast();
		}

	iterator erase(const_iterator _Where)
		{	// erase element at _Where
 
		do { if (_Where._Getcont() == ::std:: addressof(this->_Get_data()) && _Where._Ptr >= this->_Myfirst() && this->_Mylast() > _Where._Ptr) { } else { do { (void) ((1 != _CrtDbgReport(2, "c:\\visual studio\\vc\\tools\\msvc\\14.16.27023\\include\\vector", 1557, 0, "%s", "vector erase iterator outside range")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"vector erase iterator outside range\"", __LPREFIX( __FUNCTION__), L"c:\\visual studio\\vc\\tools\\msvc\\14.16.27023\\include\\vector", 1557, 0); } while (false); } ; } while (false);
		_Orphan_range(_Where._Ptr, this->_Mylast());
 

		_Move_unchecked(_Where._Ptr + 1, this->_Mylast(), _Where._Ptr);
		_Alty_traits::destroy(this->_Getal(), _Unfancy(this->_Mylast() - 1));
		--this->_Mylast();
		return (iterator(_Where._Ptr, ::std:: addressof(this->_Get_data())));
		}

	iterator erase(const_iterator _First, const_iterator _Last)
		{	// erase [_First, _Last)
 
		do { if (_First._Getcont() == ::std:: addressof(this->_Get_data()) && _Last._Getcont() == ::std:: addressof(this->_Get_data()) && _First._Ptr >= this->_Myfirst() && _Last._Ptr >= _First._Ptr && this->_Mylast() >= _Last._Ptr) { } else { do { (void) ((1 != _CrtDbgReport(2, "c:\\visual studio\\vc\\tools\\msvc\\14.16.27023\\include\\vector", 1574, 0, "%s", "vector erase iterator outside range")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"vector erase iterator outside range\"", __LPREFIX( __FUNCTION__), L"c:\\visual studio\\vc\\tools\\msvc\\14.16.27023\\include\\vector", 1574, 0); } while (false); } ; } while (false);
 

		if (_First._Ptr != _Last._Ptr)
			{	// something to do, invalidate iterators
			_Orphan_range(_First._Ptr, this->_Mylast());
			const pointer _Newlast = _Move_unchecked(_Last._Ptr, this->_Mylast(), _First._Ptr);
			_Destroy(_Newlast, this->_Mylast());
			this->_Mylast() = _Newlast;
			}

		return (iterator(_First._Ptr, ::std:: addressof(this->_Get_data())));
		}

	void clear() noexcept
		{	// erase all
		this->_Orphan_all();
		_Destroy(this->_Myfirst(), this->_Mylast());
		this->_Mylast() = this->_Myfirst();
		}

	void swap(vector& _Right) noexcept // strengthened
		{	// exchange contents with _Right
		if (this != ::std:: addressof(_Right))
			{	// (maybe) swap allocators, swap control information
			_Pocs(this->_Getal(), _Right._Getal());
			this->_Swap_all(_Right);
			_Swap_adl(this->_Myfirst(), _Right._Myfirst());
			_Swap_adl(this->_Mylast(), _Right._Mylast());
			_Swap_adl(this->_Myend(), _Right._Myend());
			}
		}

	 _Ty * data() noexcept
		{	// return address of first element
		return (_Unfancy_maybe_null(this->_Myfirst()));
		}

	 const _Ty * data() const noexcept
		{	// return address of first element
		return (_Unfancy_maybe_null(this->_Myfirst()));
		}

	 iterator begin() noexcept
		{	// return iterator for beginning of mutable sequence
		return (iterator(this->_Myfirst(), ::std:: addressof(this->_Get_data())));
		}

	 const_iterator begin() const noexcept
		{	// return iterator for beginning of nonmutable sequence
		return (const_iterator(this->_Myfirst(), ::std:: addressof(this->_Get_data())));
		}

	 iterator end() noexcept
		{	// return iterator for end of mutable sequence
		return (iterator(this->_Mylast(), ::std:: addressof(this->_Get_data())));
		}

	 const_iterator end() const noexcept
		{	// return iterator for end of nonmutable sequence
		return (const_iterator(this->_Mylast(), ::std:: addressof(this->_Get_data())));
		}

	 reverse_iterator rbegin() noexcept
		{	// return iterator for beginning of reversed mutable sequence
		return (reverse_iterator(end()));
		}

	 const_reverse_iterator rbegin() const noexcept
		{	// return iterator for beginning of reversed nonmutable sequence
		return (const_reverse_iterator(end()));
		}

	 reverse_iterator rend() noexcept
		{	// return iterator for end of reversed mutable sequence
		return (reverse_iterator(begin()));
		}

	 const_reverse_iterator rend() const noexcept
		{	// return iterator for end of reversed nonmutable sequence
		return (const_reverse_iterator(begin()));
		}

	 const_iterator cbegin() const noexcept
		{	// return iterator for beginning of nonmutable sequence
		return (begin());
		}

	 const_iterator cend() const noexcept
		{	// return iterator for end of nonmutable sequence
		return (end());
		}

	 const_reverse_iterator crbegin() const noexcept
		{	// return iterator for beginning of reversed nonmutable sequence
		return (rbegin());
		}

	 const_reverse_iterator crend() const noexcept
		{	// return iterator for end of reversed nonmutable sequence
		return (rend());
		}

	pointer _Unchecked_begin() noexcept
		{	// return pointer for beginning of mutable sequence
		return (this->_Myfirst());
		}

	const_pointer _Unchecked_begin() const noexcept
		{	// return pointer for beginning of nonmutable sequence
		return (this->_Myfirst());
		}

	pointer _Unchecked_end() noexcept
		{	// return pointer for end of mutable sequence
		return (this->_Mylast());
		}

	const_pointer _Unchecked_end() const noexcept
		{	// return pointer for end of nonmutable sequence
		return (this->_Mylast());
		}

	 bool empty() const noexcept
		{	// test if sequence is empty
		return (this->_Myfirst() == this->_Mylast());
		}

	 size_type size() const noexcept
		{	// return length of sequence
		return (static_cast<size_type>(this->_Mylast() - this->_Myfirst()));
		}

	 size_type max_size() const noexcept
		{	// return maximum possible length of sequence
		return (_Min_value(static_cast<size_type>((numeric_limits<difference_type>::max)()),
			_Alty_traits::max_size(this->_Getal())));
		}

	 size_type capacity() const noexcept
		{	// return current length of allocated storage
		return (static_cast<size_type>(this->_Myend() - this->_Myfirst()));
		}

private:
	size_type _Unused_capacity() const noexcept
		{	// micro-optimization for capacity() - size()
		return (static_cast<size_type>(this->_Myend() - this->_Mylast()));
		}

	bool _Has_unused_capacity() const noexcept
		{	// micro-optimization for capacity() != size()
		return (this->_Myend() != this->_Mylast());
		}

public:
	 _Ty& operator[](const size_type _Pos)
		{	// subscript mutable sequence
 
		do { if (_Pos < size()) { } else { do { (void) ((1 != _CrtDbgReport(2, "c:\\visual studio\\vc\\tools\\msvc\\14.16.27023\\include\\vector", 1733, 0, "%s", "vector subscript out of range")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"vector subscript out of range\"", __LPREFIX( __FUNCTION__), L"c:\\visual studio\\vc\\tools\\msvc\\14.16.27023\\include\\vector", 1733, 0); } while (false); } ; } while (false);
 

		return (this->_Myfirst()[_Pos]);
		}

	 const _Ty& operator[](const size_type _Pos) const
		{	// subscript nonmutable sequence
 
		do { if (_Pos < size()) { } else { do { (void) ((1 != _CrtDbgReport(2, "c:\\visual studio\\vc\\tools\\msvc\\14.16.27023\\include\\vector", 1742, 0, "%s", "vector subscript out of range")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"vector subscript out of range\"", __LPREFIX( __FUNCTION__), L"c:\\visual studio\\vc\\tools\\msvc\\14.16.27023\\include\\vector", 1742, 0); } while (false); } ; } while (false);
 

		return (this->_Myfirst()[_Pos]);
		}

	 _Ty& at(const size_type _Pos)
		{	// subscript mutable sequence with checking
		if (size() <= _Pos)
			{
			_Xrange();
			}

		return (this->_Myfirst()[_Pos]);
		}

	 const _Ty& at(const size_type _Pos) const
		{	// subscript nonmutable sequence with checking
		if (size() <= _Pos)
			{
			_Xrange();
			}

		return (this->_Myfirst()[_Pos]);
		}

	 _Ty& front()
		{	// return first element of mutable sequence
 
		do { if (!empty()) { } else { do { (void) ((1 != _CrtDbgReport(2, "c:\\visual studio\\vc\\tools\\msvc\\14.16.27023\\include\\vector", 1771, 0, "%s", "front() called on empty vector")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"front() called on empty vector\"", __LPREFIX( __FUNCTION__), L"c:\\visual studio\\vc\\tools\\msvc\\14.16.27023\\include\\vector", 1771, 0); } while (false); } ; } while (false);
 

		return (*this->_Myfirst());
		}

	 const _Ty& front() const
		{	// return first element of nonmutable sequence
 
		do { if (!empty()) { } else { do { (void) ((1 != _CrtDbgReport(2, "c:\\visual studio\\vc\\tools\\msvc\\14.16.27023\\include\\vector", 1780, 0, "%s", "front() called on empty vector")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"front() called on empty vector\"", __LPREFIX( __FUNCTION__), L"c:\\visual studio\\vc\\tools\\msvc\\14.16.27023\\include\\vector", 1780, 0); } while (false); } ; } while (false);
 

		return (*this->_Myfirst());
		}

	 _Ty& back()
		{	// return last element of mutable sequence
 
		do { if (!empty()) { } else { do { (void) ((1 != _CrtDbgReport(2, "c:\\visual studio\\vc\\tools\\msvc\\14.16.27023\\include\\vector", 1789, 0, "%s", "back() called on empty vector")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"back() called on empty vector\"", __LPREFIX( __FUNCTION__), L"c:\\visual studio\\vc\\tools\\msvc\\14.16.27023\\include\\vector", 1789, 0); } while (false); } ; } while (false);
 

		return (this->_Mylast()[-1]);
		}

	 const _Ty& back() const
		{	// return last element of nonmutable sequence
 
		do { if (!empty()) { } else { do { (void) ((1 != _CrtDbgReport(2, "c:\\visual studio\\vc\\tools\\msvc\\14.16.27023\\include\\vector", 1798, 0, "%s", "back() called on empty vector")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"back() called on empty vector\"", __LPREFIX( __FUNCTION__), L"c:\\visual studio\\vc\\tools\\msvc\\14.16.27023\\include\\vector", 1798, 0); } while (false); } ; } while (false);
 

		return (this->_Mylast()[-1]);
		}

	 allocator_type get_allocator() const noexcept
		{	// return allocator object for values
		return (static_cast<allocator_type>(this->_Getal()));
		}

private:
	pointer _Udefault(pointer _Dest, const size_type _Count)
		{	// fill raw _Dest with _Count value-initialized objects, using allocator
		return (_Uninitialized_value_construct_n(_Dest, _Count, this->_Getal()));
		}

	pointer _Ufill(pointer _Dest, const size_type _Count, const _Ty& _Val)
		{	// fill raw _Dest with _Count copies of _Val, using allocator
		return (_Uninitialized_fill_n(_Dest, _Count, _Val, this->_Getal()));
		}

	template<class _Iter>
		pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Dest)
		{	// copy [_First, _Last) to raw _Dest, using allocator
		return (_Uninitialized_copy(_First, _Last, _Dest, this->_Getal()));
		}

	pointer _Umove(pointer _First, pointer _Last, pointer _Dest)
		{	// move [_First, _Last) to raw _Dest, using allocator
		return (_Uninitialized_move(_First, _Last, _Dest, this->_Getal()));
		}

	void _Umove_if_noexcept1(pointer _First, pointer _Last, pointer _Dest, true_type)
		{	// move [_First, _Last) to raw _Dest, using allocator
		_Uninitialized_move(_First, _Last, _Dest, this->_Getal());
		}

	void _Umove_if_noexcept1(pointer _First, pointer _Last, pointer _Dest, false_type)
		{	// copy [_First, _Last) to raw _Dest, using allocator
		_Uninitialized_copy(_First, _Last, _Dest, this->_Getal());
		}

	void _Umove_if_noexcept(pointer _First, pointer _Last, pointer _Dest)
		{	// move_if_noexcept [_First, _Last) to raw _Dest, using allocator
		_Umove_if_noexcept1(_First, _Last, _Dest,
			bool_constant<disjunction_v<is_nothrow_move_constructible<_Ty>, negation<is_copy_constructible<_Ty>>>>{});
		}

	void _Destroy(pointer _First, pointer _Last)
		{	// destroy [_First, _Last) using allocator
		_Destroy_range(_First, _Last, this->_Getal());
		}

	size_type _Calculate_growth(const size_type _Newsize) const
		{	// given _Oldcapacity and _Newsize, calculate geometric growth
		const size_type _Oldcapacity = capacity();

		if (_Oldcapacity > max_size() - _Oldcapacity / 2)
			{
			return (_Newsize);	// geometric growth would overflow
			}

		const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

		if (_Geometric < _Newsize)
			{
			return (_Newsize);	// geometric growth would be insufficient
			}

		return (_Geometric);	// geometric growth is sufficient
		}

	bool _Buy(const size_type _Newcapacity)
		{	// allocate array with _Newcapacity elements
		this->_Myfirst() = pointer();
		this->_Mylast() = pointer();
		this->_Myend() = pointer();

		if (_Newcapacity == 0)
			{
			return (false);
			}

		if (_Newcapacity > max_size())
			{
			_Xlength();
			}

		this->_Myfirst() = this->_Getal().allocate(_Newcapacity);
		this->_Mylast() = this->_Myfirst();
		this->_Myend() = this->_Myfirst() + _Newcapacity;

		return (true);
		}

	void _Change_array(const pointer _Newvec, const size_type _Newsize, const size_type _Newcapacity)
		{	// orphan all iterators, discard old array, acquire new array
		this->_Orphan_all();

		if (this->_Myfirst() != pointer())
			{	// destroy and deallocate old array
			_Destroy(this->_Myfirst(), this->_Mylast());
			this->_Getal().deallocate(this->_Myfirst(), capacity());
			}

		this->_Myfirst() = _Newvec;
		this->_Mylast() = _Newvec + _Newsize;
		this->_Myend() = _Newvec + _Newcapacity;
		}

	void _Tidy()
		{	// free all storage
		this->_Orphan_all();

		if (this->_Myfirst() != pointer())
			{	// destroy and deallocate old array
			_Destroy(this->_Myfirst(), this->_Mylast());
			this->_Getal().deallocate(this->_Myfirst(), capacity());

			this->_Myfirst() = pointer();
			this->_Mylast() = pointer();
			this->_Myend() = pointer();
			}
		}

	[[noreturn]] static void _Xlength()
		{	// report a length_error
		_Xlength_error("vector<T> too long");
		}

	[[noreturn]] static void _Xrange()
		{	// report an out_of_range error
		_Xout_of_range("invalid vector<T> subscript");
		}

 
	void _Orphan_range(pointer _First, pointer _Last) const
		{	// orphan iterators within specified (inclusive) range
		_Lockit _Lock(3);

		const_iterator ** _Pnext = reinterpret_cast<const_iterator **>(this->_Getpfirst());

		if (_Pnext)
			{
			while (*_Pnext)
				{
				if ((*_Pnext)->_Ptr < _First || _Last < (*_Pnext)->_Ptr)
					{	// skip the iterator
					_Pnext = reinterpret_cast<const_iterator **>((*_Pnext)->_Getpnext());
					}
				else
					{	// orphan the iterator
					(*_Pnext)->_Clrcont();
					*_Pnext = *reinterpret_cast<const_iterator **>((*_Pnext)->_Getpnext());
					}
				}
			}
		}
 




	};












template<class _Ty,
	class _Alloc> inline
	void swap(vector<_Ty, _Alloc>& _Left, vector<_Ty, _Alloc>& _Right) noexcept // strengthened
	{	// swap _Left and _Right vectors
	_Left.swap(_Right);
	}

template<class _Ty,
	class _Alloc>
	 inline bool operator==(const vector<_Ty, _Alloc>& _Left,
		const vector<_Ty, _Alloc>& _Right)
	{	// test for vector equality
	return (_Left.size() == _Right.size()
		&& ::std:: equal(_Left.begin(), _Left.end(), _Right.begin()));
	}

template<class _Ty,
	class _Alloc>
	 inline bool operator!=(const vector<_Ty, _Alloc>& _Left,
		const vector<_Ty, _Alloc>& _Right)
	{	// test for vector inequality
	return (!(_Left == _Right));
	}

template<class _Ty,
	class _Alloc>
	 inline bool operator<(const vector<_Ty, _Alloc>& _Left,
		const vector<_Ty, _Alloc>& _Right)
	{	// test if _Left < _Right for vectors
	return (::std:: lexicographical_compare(_Left.begin(), _Left.end(),
		_Right.begin(), _Right.end()));
	}

template<class _Ty,
	class _Alloc>
	 inline bool operator>(const vector<_Ty, _Alloc>& _Left,
		const vector<_Ty, _Alloc>& _Right)
	{	// test if _Left > _Right for vectors
	return (_Right < _Left);
	}

template<class _Ty,
	class _Alloc>
	 inline bool operator<=(const vector<_Ty, _Alloc>& _Left,
		const vector<_Ty, _Alloc>& _Right)
	{	// test if _Left <= _Right for vectors
	return (!(_Right < _Left));
	}

template<class _Ty,
	class _Alloc>
	 inline bool operator>=(const vector<_Ty, _Alloc>& _Left,
		const vector<_Ty, _Alloc>& _Right)
	{	// test if _Left >= _Right for vectors
	return (!(_Left < _Right));
	}

		// CLASS TEMPLATE vector<bool, Alloc> AND FRIENDS
using _Vbase = unsigned int;	// word type for vector<bool> representation
constexpr int _VBITS = 8 * sizeof (_Vbase);	// at least CHAR_BITS bits per word

template<class _Alloc0>
	struct _Wrap_alloc
	{	// TRANSITION, ABI compat, preserves symbol names of vector<bool>::iterator
	using _Alloc = _Alloc0;
	};

		// CLASS _Vb_iter_base
template<class _Alvbase_wrapped>
	class _Vb_iter_base
		: public _Iterator_base
	{	// store information common to reference and iterators
public:
	using _Alvbase = typename _Alvbase_wrapped::_Alloc;
	using _Sizet = typename allocator_traits<_Alvbase>::size_type;
	using _Difft = typename allocator_traits<_Alvbase>::difference_type;
	using _Mycont = vector<bool, _Rebind_alloc_t<_Alvbase, bool>>;

	_Vb_iter_base()
		: _Myptr(nullptr), _Myoff(0)
		{	// construct with null pointer
		}

	_Vb_iter_base(const _Vbase *_Ptr, _Sizet _Off,
		const _Container_base *_Mypvbool)
		: _Myptr(_Ptr), _Myoff(_Off)
		{	// construct with offset and pointer
		this->_Adopt(_Mypvbool);
		}

	void _Advance(_Sizet _Off)
		{	// advance iterator by _Off
		_Myoff += _Off;
		_Myptr += _Myoff / _VBITS;
		_Myoff %= _VBITS;
		}

	int _Valid(_Sizet _Inc) const
		{	// test for valid incremented offset
 
		const auto _Cont = static_cast<const _Mycont *>(this->_Getcont());
		_Sizet _Mysize = _Cont->_Mysize;

		_Inc += _Myoff;
		_Inc += static_cast<_Sizet>(_VBITS * (_Myptr - _Cont->_Myvec.data()));
		return (_Inc < _Mysize ? -1 : _Inc == _Mysize ? 0 : +1);

 



		}

	const _Vbase *_Myptr;
	_Sizet _Myoff;
	};

		// CLASS _Vb_reference
template<class _Alvbase_wrapped>
	class _Vb_reference
		: public _Vb_iter_base<_Alvbase_wrapped>
	{	// reference to a bit within a base word
	using _Mybase = _Vb_iter_base<_Alvbase_wrapped>;

	_Vb_reference() noexcept
		{	// construct with null pointer (private)
		}

public:
	_Vb_reference(const _Mybase& _Right)
		: _Mybase(_Right._Myptr, _Right._Myoff, _Right._Getcont())
		{	// construct with base
		}

	_Vb_reference& operator=(const _Vb_reference& _Right) noexcept
		{	// assign _Vb_reference _Right to bit
		return (*this = bool(_Right));
		}

	_Vb_reference& operator=(bool _Val) noexcept
		{	// assign _Val to bit
		if (_Val)
			*const_cast<_Vbase *>(_Getptr()) |= _Mask();
		else
			*const_cast<_Vbase *>(_Getptr()) &= ~_Mask();
		return (*this);
		}

	void flip() noexcept
		{	// toggle the bit
		*const_cast<_Vbase *>(_Getptr()) ^= _Mask();
		}

	operator bool() const noexcept
		{	// test if bit is set
		return ((*_Getptr() & _Mask()) != 0);
		}

	const _Vbase *_Getptr() const
		{	// get pointer to base word
 
		do { if (this->_Getcont() && this->_Myptr && this->_Valid(0) < 0) { } else { do { (void) ((1 != _CrtDbgReport(2, "c:\\visual studio\\vc\\tools\\msvc\\14.16.27023\\include\\vector", 2137, 0, "%s", "vector<bool> iterator not dereferencable")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"vector<bool> iterator not dereferencable\"", __LPREFIX( __FUNCTION__), L"c:\\visual studio\\vc\\tools\\msvc\\14.16.27023\\include\\vector", 2137, 0); } while (false); } ; } while (false);
 

		return (this->_Myptr);
		}

protected:
	_Vbase _Mask() const
		{	// convert offset to mask
		return (static_cast<_Vbase>(1) << this->_Myoff);
		}
	};

template<class _Alvbase_wrapped> inline
	void swap(_Vb_reference<_Alvbase_wrapped> _Left, _Vb_reference<_Alvbase_wrapped> _Right) noexcept
	{	// swap _Left and _Right vector<bool> elements
	bool _Val = _Left;	// NOT _STD swap
	_Left = _Right;
	_Right = _Val;
	}

		// CLASS _Vb_const_iterator
template<class _Alvbase_wrapped>
	class _Vb_const_iterator
		: public _Vb_iter_base<_Alvbase_wrapped>
	{	// iterator for nonmutable vector<bool>
private:
	using _Mybase = _Vb_iter_base<_Alvbase_wrapped>;
	using _Size_type = typename _Mybase::_Sizet;

public:
	using _Reft = _Vb_reference<_Alvbase_wrapped>;
	using const_reference = bool;

	using iterator_category = random_access_iterator_tag;
	using value_type = bool;
	using difference_type = typename _Mybase::_Difft;
	using pointer = const_reference *;
	using reference = const_reference;

	_Vb_const_iterator()
		{	// construct with null reference
		}

	_Vb_const_iterator(const _Vbase *_Ptr, const _Container_base *_Mypvbool)
		: _Mybase(_Ptr, 0, _Mypvbool)
		{	// construct with offset and pointer
		}

	 const_reference operator*() const
		{	// return (reference to) designated object
		return (_Reft(*this));
		}

	_Vb_const_iterator& operator++()
		{	// preincrement
		_Inc();
		return (*this);
		}

	_Vb_const_iterator operator++(int)
		{	// postincrement
		_Vb_const_iterator _Tmp = *this;
		++*this;
		return (_Tmp);
		}

	_Vb_const_iterator& operator--()
		{	// predecrement
		_Dec();
		return (*this);
		}

	_Vb_const_iterator operator--(int)
		{	// postdecrement
		_Vb_const_iterator _Tmp = *this;
		--*this;
		return (_Tmp);
		}

	_Vb_const_iterator& operator+=(const difference_type _Off)
		{	// increment by integer
		if (_Off < 0 && this->_Myoff < 0 - static_cast<_Size_type>(_Off))
			{	/* add negative increment */
			this->_Myoff += _Off;
			this->_Myptr -= 1 + (static_cast<_Size_type>(-1) - this->_Myoff) / _VBITS;
			this->_Myoff %= _VBITS;
			}
		else
			{	/* add non-negative increment */
			this->_Myoff += _Off;
			this->_Myptr += this->_Myoff / _VBITS;
			this->_Myoff %= _VBITS;
			}
		return (*this);
		}

	 _Vb_const_iterator operator+(const difference_type _Off) const
		{	// return this + integer
		_Vb_const_iterator _Tmp = *this;
		return (_Tmp += _Off);
		}

	_Vb_const_iterator& operator-=(const difference_type _Off)
		{	// decrement by integer
		return (*this += -_Off);
		}

	 _Vb_const_iterator operator-(const difference_type _Off) const
		{	// return this - integer
		_Vb_const_iterator _Tmp = *this;
		return (_Tmp -= _Off);
		}

	 difference_type operator-(const _Vb_const_iterator& _Right) const
		{	// return difference of iterators
		_Compat(_Right);
		return (static_cast<difference_type>(_VBITS * (this->_Myptr - _Right._Myptr))
			+ static_cast<difference_type>(this->_Myoff)
			- static_cast<difference_type>(_Right._Myoff));
		}

	 const_reference operator[](const difference_type _Off) const
		{	// subscript
		return (*(*this + _Off));
		}

	 bool operator==(const _Vb_const_iterator& _Right) const
		{	// test for iterator equality
		_Compat(_Right);
		return (this->_Myptr == _Right._Myptr
			&& this->_Myoff == _Right._Myoff);
		}

	 bool operator!=(const _Vb_const_iterator& _Right) const
		{	// test for iterator inequality
		return (!(*this == _Right));
		}

	 bool operator<(const _Vb_const_iterator& _Right) const
		{	// test if this < _Right
		_Compat(_Right);
		return (this->_Myptr < _Right._Myptr
			|| (this->_Myptr == _Right._Myptr
				&& this->_Myoff < _Right._Myoff));
		}

	 bool operator>(const _Vb_const_iterator& _Right) const
		{	// test if this > _Right
		return (_Right < *this);
		}

	 bool operator<=(const _Vb_const_iterator& _Right) const
		{	// test if this <= _Right
		return (!(_Right < *this));
		}

	 bool operator>=(const _Vb_const_iterator& _Right) const
		{	// test if this >= _Right
		return (!(*this < _Right));
		}

	void _Compat(const _Vb_const_iterator& _Right) const
		{	// test for compatible iterator pair
 


		do { if (this->_Getcont() == _Right._Getcont()) { } else { do { (void) ((1 != _CrtDbgReport(2, "c:\\visual studio\\vc\\tools\\msvc\\14.16.27023\\include\\vector", 2304, 0, "%s", "vector<bool> iterators incompatible")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"vector<bool> iterators incompatible\"", __LPREFIX( __FUNCTION__), L"c:\\visual studio\\vc\\tools\\msvc\\14.16.27023\\include\\vector", 2304, 0); } while (false); } ; } while (false);
 
		}

 
	friend void _Verify_range(const _Vb_const_iterator& _First, const _Vb_const_iterator& _Last)
		{
		// note _Compat check inside <=
		do { if (_First <= _Last) { } else { do { (void) ((1 != _CrtDbgReport(2, "c:\\visual studio\\vc\\tools\\msvc\\14.16.27023\\include\\vector", 2312, 0, "%s", "vector<bool> iterator range transposed")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"vector<bool> iterator range transposed\"", __LPREFIX( __FUNCTION__), L"c:\\visual studio\\vc\\tools\\msvc\\14.16.27023\\include\\vector", 2312, 0); } while (false); } ; } while (false);
		}
 

	void _Dec()
		{	// decrement bit position
		if (this->_Myoff != 0)
			--this->_Myoff;
		else
			{	// move to previous word
 
			do { if (this->_Getcont()) { } else { do { (void) ((1 != _CrtDbgReport(2, "c:\\visual studio\\vc\\tools\\msvc\\14.16.27023\\include\\vector", 2323, 0, "%s", "cannot decrement value-initialized vector<bool> iterator")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"cannot decrement value-initialized vector<bool> iterator\"", __LPREFIX( __FUNCTION__), L"c:\\visual studio\\vc\\tools\\msvc\\14.16.27023\\include\\vector", 2323, 0); } while (false); } ; } while (false);
			do { if (this->_Valid(static_cast<_Size_type>(-1)) <= 0) { } else { do { (void) ((1 != _CrtDbgReport(2, "c:\\visual studio\\vc\\tools\\msvc\\14.16.27023\\include\\vector", 2325, 0, "%s", "cannot decrement invalid vector<bool> iterator")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"cannot decrement invalid vector<bool> iterator\"", __LPREFIX( __FUNCTION__), L"c:\\visual studio\\vc\\tools\\msvc\\14.16.27023\\include\\vector", 2325, 0); } while (false); } ; } while (false);
 

			this->_Myoff = _VBITS - 1;
			--this->_Myptr;
			}
		}

	void _Inc()
		{	// increment bit position
		if (this->_Myoff < _VBITS - 1)
			++this->_Myoff;
		else
			{	// move to next word
 
			do { if (this->_Getcont()) { } else { do { (void) ((1 != _CrtDbgReport(2, "c:\\visual studio\\vc\\tools\\msvc\\14.16.27023\\include\\vector", 2340, 0, "%s", "cannot increment value-initialized vector<bool> iterator")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"cannot increment value-initialized vector<bool> iterator\"", __LPREFIX( __FUNCTION__), L"c:\\visual studio\\vc\\tools\\msvc\\14.16.27023\\include\\vector", 2340, 0); } while (false); } ; } while (false);
			do { if (this->_Valid(1) <= 0) { } else { do { (void) ((1 != _CrtDbgReport(2, "c:\\visual studio\\vc\\tools\\msvc\\14.16.27023\\include\\vector", 2342, 0, "%s", "cannot increment invalid vector<bool> iterator")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"cannot increment invalid vector<bool> iterator\"", __LPREFIX( __FUNCTION__), L"c:\\visual studio\\vc\\tools\\msvc\\14.16.27023\\include\\vector", 2342, 0); } while (false); } ; } while (false);
 

			this->_Myoff = 0;
			++this->_Myptr;
			}
		}
	};

template<class _Alvbase_wrapped>
	 _Vb_const_iterator<_Alvbase_wrapped> operator+(
		typename _Vb_const_iterator<_Alvbase_wrapped>::difference_type _Off,
		_Vb_const_iterator<_Alvbase_wrapped> _Right)
		{	// return _Right + integer
		return (_Right += _Off);
		}

	// CLASS _Vb_iterator
template<class _Alvbase_wrapped>
	class _Vb_iterator
		: public _Vb_const_iterator<_Alvbase_wrapped>
	{	// iterator for mutable vector<bool>
public:
	using _Mybase = _Vb_const_iterator<_Alvbase_wrapped>;

	using _Reft = _Vb_reference<_Alvbase_wrapped>;
	using const_reference = bool;

	using iterator_category = random_access_iterator_tag;
	using value_type = bool;
	using difference_type = typename _Mybase::difference_type;
	using pointer = _Reft *;
	using reference = _Reft;

	_Vb_iterator()
		{	// construct with null reference
		}

	_Vb_iterator(_Vbase *_Ptr, _Container_base *_Mypvbool)
		: _Mybase(_Ptr, _Mypvbool)
		{	// construct with offset and pointer
		}

	 reference operator*() const
		{	// return (reference to) designated object
		return (_Reft(*this));
		}

	_Vb_iterator& operator++()
		{	// preincrement
		++*(_Mybase *)this;
		return (*this);
		}

	_Vb_iterator operator++(int)
		{	// postincrement
		_Vb_iterator _Tmp = *this;
		++*this;
		return (_Tmp);
		}

	_Vb_iterator& operator--()
		{	// predecrement
		--*(_Mybase *)this;
		return (*this);
		}

	_Vb_iterator operator--(int)
		{	// postdecrement
		_Vb_iterator _Tmp = *this;
		--*this;
		return (_Tmp);
		}

	_Vb_iterator& operator+=(const difference_type _Off)
		{	// increment by integer
		*(_Mybase *)this += _Off;
		return (*this);
		}

	 _Vb_iterator operator+(const difference_type _Off) const
		{	// return this + integer
		_Vb_iterator _Tmp = *this;
		return (_Tmp += _Off);
		}

	_Vb_iterator& operator-=(const difference_type _Off)
		{	// decrement by integer
		return (*this += -_Off);
		}

	 _Vb_iterator operator-(const difference_type _Off) const
		{	// return this - integer
		_Vb_iterator _Tmp = *this;
		return (_Tmp -= _Off);
		}

	 difference_type operator-(const _Mybase& _Right) const
		{	// return difference of iterators
		return (*(_Mybase *)this - _Right);
		}

	 reference operator[](const difference_type _Off) const
		{	// subscript
		return (*(*this + _Off));
		}
	};

template<class _Alvbase_wrapped>
	 inline _Vb_iterator<_Alvbase_wrapped> operator+(
		typename _Vb_iterator<_Alvbase_wrapped>::difference_type _Off,
		_Vb_iterator<_Alvbase_wrapped> _Right)
		{	// return _Right + integer
		return (_Right += _Off);
		}

		// CLASS TEMPLATE _Vb_val
template<class _Alloc>
	class _Vb_val
		: public _Container_base
	{	// base class for vector<bool> to hold data
public:
	using _Alproxy = _Rebind_alloc_t<_Alloc, _Container_proxy>;
	using _Alproxy_traits = allocator_traits<_Alproxy>;
	using _Alvbase = _Rebind_alloc_t<_Alloc, _Vbase>;
	using _Alvbase_traits = allocator_traits<_Alvbase>;
	using _Vectype = vector<_Vbase, _Alvbase>;
	using _Alvbase_wrapped = _Wrap_alloc<_Alvbase>;
	using size_type = typename _Alvbase_traits::size_type;

	_Vb_val() noexcept(is_nothrow_default_constructible_v<_Vectype>)
		: _Myvec()
		{	// construct empty vector
		_Alloc_proxy();
		_Mysize = 0;
		}

	_Vb_val(const _Alloc& _Al) noexcept(is_nothrow_constructible_v<_Vectype, _Alvbase>)
		: _Myvec(static_cast<_Alvbase>(_Al))
		{	// construct empty vector, allocator
		_Alloc_proxy();
		_Mysize = 0;
		}

	_Vb_val(size_type _Count, const bool& _Val)
		: _Myvec(_Nw(_Count), static_cast<_Vbase>(_Val ? -1 : 0))
		{	// construct _Count * _Val elements
		_Alloc_proxy();
		_Mysize = 0;
		}

	_Vb_val(size_type _Count, const bool& _Val, const _Alloc& _Al)
		: _Myvec(_Nw(_Count), static_cast<_Vbase>(_Val ? -1 : 0), static_cast<_Alvbase>(_Al))
		{	// construct _Count * _Val elements with allocator _Al
		_Alloc_proxy();
		_Mysize = 0;
		}

	_Vb_val(const _Vb_val& _Right)
		: _Myvec(_Right._Myvec),
			_Mysize(_Right._Mysize)
		{	// copy construct
		_Alloc_proxy();
		}

	_Vb_val(const _Vb_val& _Right, const _Alloc& _Al)
		: _Myvec(_Right._Myvec, static_cast<_Alvbase>(_Al)),
			_Mysize(_Right._Mysize)
		{	// copy construct, allocator
		_Alloc_proxy();
		}

	_Vb_val(_Vb_val&& _Right) noexcept(is_nothrow_move_constructible_v<_Vectype>)
		: _Myvec(::std:: move(_Right._Myvec)),
			_Mysize(_Right._Mysize)
		{	// move construct
		_Right._Mysize = 0;
		_Alloc_proxy();
		}

	_Vb_val(_Vb_val&& _Right, const _Alloc& _Al)
		noexcept(is_nothrow_constructible_v<_Vectype, _Vectype, _Alvbase>)
		: _Myvec(::std:: move(_Right._Myvec), static_cast<_Alvbase>(_Al)),
			_Mysize(_Right._Mysize)
		{	// move construct, allocator
		_Right._Mysize = 0;
		_Alloc_proxy();
		}

	~_Vb_val() noexcept
		{	// destroy proxy
		_Free_proxy();
		}

 









	void _Alloc_proxy()
		{	// allocate a proxy
		_Alproxy _Proxy_allocator(_Myvec._Getal());
		this->_Myproxy = _Unfancy(_Proxy_allocator.allocate(1));
		_Alproxy_traits::construct(_Proxy_allocator, this->_Myproxy, _Container_proxy());
		this->_Myproxy->_Mycont = this;
		}

	void _Free_proxy()
		{	// destroy proxy
		_Alproxy _Proxy_allocator(_Myvec._Getal());
		this->_Orphan_all();
		_Alproxy_traits::destroy(_Proxy_allocator, this->_Myproxy);
		_Deallocate_plain(_Proxy_allocator, this->_Myproxy);
		this->_Myproxy = nullptr;
		}
 

	static size_type _Nw(size_type _Count)
		{	// return number of base words from number of bits
		return ((_Count + _VBITS - 1) / _VBITS);
		}

	_Vectype _Myvec;	// base vector of words
	size_type _Mysize;	// current length of sequence
	};

		// CLASS vector<bool>
template<class _Alloc>
	class vector<bool, _Alloc>
		: public _Vb_val<_Alloc>
	{	// varying size array of bits
public:
	static_assert(!0 || is_same_v<bool, typename _Alloc::value_type>,
		"vector<bool, Allocator>" " requires that Allocator's value_type match " "bool" " (See N4659 26.2.1 [container.requirements.general]/16 allocator_type)" " Either fix the allocator value_type or define _ENFORCE_MATCHING_ALLOCATORS=0" " to suppress this diagnostic.");

	using _Mybase = _Vb_val<_Alloc>;
	using _Alvbase_wrapped = typename _Mybase::_Alvbase_wrapped;
	using _Alvbase = typename _Mybase::_Alvbase;
	using _Alvbase_traits = typename _Mybase::_Alvbase_traits;

	using size_type = typename _Alvbase_traits::size_type;
	using difference_type = typename _Alvbase_traits::difference_type;
	using allocator_type = _Alloc;

	using reference = _Vb_reference<_Alvbase_wrapped>;
	using const_reference = bool;
	using value_type = bool;

	using _Reft = reference;
	using iterator = _Vb_iterator<_Alvbase_wrapped>;
	using const_iterator = _Vb_const_iterator<_Alvbase_wrapped>;

	using pointer = iterator;
	using const_pointer = const_iterator;
	using reverse_iterator = ::std:: reverse_iterator<iterator>;
	using const_reverse_iterator = ::std:: reverse_iterator<const_iterator>;

	static const int _VBITS = ::std:: _VBITS;
	enum {_EEN_VBITS = _VBITS};	// helper for expression evaluator

	vector() noexcept(is_nothrow_default_constructible_v<_Mybase>) // strengthened
		: _Mybase()
		{	// construct empty vector
		}

	explicit vector(const _Alloc& _Al)
		noexcept(is_nothrow_constructible_v<_Mybase, const _Alloc&>) // strengthened
		: _Mybase(_Al)
		{	// construct empty vector, allocator
		}

	explicit vector(__declspec(guard(overflow)) size_type _Count, const _Alloc& _Al = _Alloc())
		: _Mybase(_Count, false, _Al)
		{	// construct from _Count * false, optional allocator
		_Trim(_Count);
		}

	vector(__declspec(guard(overflow)) size_type _Count, const bool& _Val, const _Alloc& _Al = _Alloc())
		: _Mybase(_Count, _Val, _Al)
		{	// construct from _Count * _Val, optional allocator
		_Trim(_Count);
		}

	vector(const vector& _Right)
		: _Mybase(_Right)
		{	// construct by copying _Right
		}

	vector(const vector& _Right, const _Alloc& _Al)
		: _Mybase(_Right, _Al)
		{	// construct by copying _Right, allocator
		}

	template<class _Iter,
		class = enable_if_t<_Is_iterator_v<_Iter>>>
		vector(_Iter _First, _Iter _Last, const _Alloc& _Al = _Alloc())
		: _Mybase(_Al)
		{	// construct from [_First, _Last), optional allocator
		_BConstruct(_First, _Last);
		}

	template<class _Iter>
		void _BConstruct(_Iter _First, _Iter _Last)
		{	// initialize from [_First, _Last), input iterators
		insert(begin(), _First, _Last);
		}

	vector(vector&& _Right)
		noexcept(is_nothrow_move_constructible_v<_Mybase>) // strengthened
		: _Mybase(::std:: move(_Right))
		{	// move construct by moving _Right
		this->_Swap_all(_Right);
		}

	vector(vector&& _Right, const _Alloc& _Al)
		noexcept(is_nothrow_constructible_v<_Mybase, _Mybase, const _Alloc&>)
		: _Mybase(::std:: move(_Right), _Al)
		{	// move construct by moving _Right, allocator
		const bool _Swap_iterators = _Alvbase_traits::is_always_equal::value
			|| this->_Myvec._Getal() == _Right._Myvec._Getal();
		if (_Swap_iterators)
			{
			this->_Swap_all(_Right);
			}
		}

	vector& operator=(vector&& _Right)
		noexcept(is_nothrow_move_assignable_v<_Mybase>) // strengthened
		{	// assign by moving _Right
		if (this != ::std:: addressof(_Right))
			{	// different, assign it
			clear();

			const bool _Reload = _Alvbase_traits::propagate_on_container_move_assignment::value
				&& !_Alvbase_traits::is_always_equal::value
				&& this->_Myvec._Getal() != _Right._Myvec._Getal();

			if (_Reload)
				{
				this->_Free_proxy();
				}

			this->_Myvec = ::std:: move(_Right._Myvec);

			if (_Reload)
				{
				this->_Alloc_proxy();
				}

			this->_Mysize = _Right._Mysize;
			_Right._Mysize = 0;

			const bool _Swap_iterators = _Alvbase_traits::is_always_equal::value
				|| this->_Myvec._Getal() == _Right._Myvec._Getal();
			if (_Swap_iterators)
				{
				this->_Swap_all(_Right);
				}
			}
		return (*this);
		}

	template<class... _Valty>
		decltype(auto) emplace_back(_Valty&&... _Val)
		{	// insert bool at end
		bool _Tmp(::std:: forward<_Valty>(_Val)...);
		push_back(_Tmp);




		}

	template<class... _Valty>
		iterator emplace(const_iterator _Where, _Valty&&... _Val)
		{	// insert bool at _Where
		bool _Tmp(::std:: forward<_Valty>(_Val)...);
		return (insert(_Where, _Tmp));
		}

	vector(initializer_list<bool> _Ilist,
			const _Alloc& _Al = allocator_type())
		: _Mybase(0, false, _Al)
		{	// construct from initializer_list
		insert(begin(), _Ilist.begin(), _Ilist.end());
		}

	vector& operator=(initializer_list<bool> _Ilist)
		{	// assign initializer_list
		assign(_Ilist.begin(), _Ilist.end());
		return (*this);
		}

	void assign(initializer_list<bool> _Ilist)
		{	// assign initializer_list
		assign(_Ilist.begin(), _Ilist.end());
		}

	iterator insert(const_iterator _Where,
			initializer_list<bool> _Ilist)
		{	// insert initializer_list
		return (insert(_Where, _Ilist.begin(), _Ilist.end()));
		}

	~vector() noexcept
		{	// destroy the object
		}

	vector& operator=(const vector& _Right)
		{	// assign from _Right
		if (this != ::std:: addressof(_Right))
			{	// different, assign it
			this->_Orphan_all();

			const bool _Reload = _Alvbase_traits::propagate_on_container_copy_assignment::value
				&& this->_Myvec._Getal() != _Right._Myvec._Getal();

			if (_Reload)
				{
				this->_Free_proxy();
				}

			this->_Myvec = _Right._Myvec;

			if (_Reload)
				{
				this->_Alloc_proxy();
				}

			this->_Mysize = _Right._Mysize;
			}

		return (*this);
		}

	void reserve(__declspec(guard(overflow)) size_type _Count)
		{	// determine new minimum length of allocated storage
		this->_Myvec.reserve(this->_Nw(_Count));
		}

	 size_type capacity() const noexcept
		{	// return current length of allocated storage
		return (this->_Myvec.capacity() * _VBITS);
		}

	 iterator begin() noexcept
		{	// return iterator for beginning of mutable sequence
		return (iterator(this->_Myvec.data(), this));
		}

	 const_iterator begin() const noexcept
		{	// return iterator for beginning of nonmutable sequence
		return (const_iterator(this->_Myvec.data(), this));
		}

	 iterator end() noexcept
		{	// return iterator for end of mutable sequence
		return (begin() + static_cast<difference_type>(this->_Mysize));
		}

	 const_iterator end() const noexcept
		{	// return iterator for end of nonmutable sequence
		return (begin() + static_cast<difference_type>(this->_Mysize));
		}

	 const_iterator cbegin() const noexcept
		{	// return iterator for beginning of nonmutable sequence
		return (begin());
		}

	 const_iterator cend() const noexcept
		{	// return iterator for end of nonmutable sequence
		return (end());
		}

	 const_reverse_iterator crbegin() const noexcept
		{	// return iterator for beginning of reversed nonmutable sequence
		return (rbegin());
		}

	 const_reverse_iterator crend() const noexcept
		{	// return iterator for end of reversed nonmutable sequence
		return (rend());
		}

	void shrink_to_fit()
		{	// reduce capacity
		if (this->_Myvec.capacity() != this->_Myvec.size())
			{	// worth shrinking, do it
			this->_Orphan_all();
			this->_Myvec.shrink_to_fit();
			}
		}

	iterator _Make_iter(const_iterator _Where)
		{	// make iterator from const_iterator
		iterator _Tmp = begin();
		if (0 < this->_Mysize)
			_Tmp += _Where - begin();
		return (_Tmp);
		}

	 reverse_iterator rbegin() noexcept
		{	// return iterator for beginning of reversed mutable sequence
		return (reverse_iterator(end()));
		}

	 const_reverse_iterator rbegin() const noexcept
		{	// return iterator for beginning of reversed nonmutable sequence
		return (const_reverse_iterator(end()));
		}

	 reverse_iterator rend() noexcept
		{	// return iterator for end of reversed mutable sequence
		return (reverse_iterator(begin()));
		}

	 const_reverse_iterator rend() const noexcept
		{	// return iterator for end of reversed nonmutable sequence
		return (const_reverse_iterator(begin()));
		}

	void resize(__declspec(guard(overflow)) size_type _Newsize, bool _Val = false)
		{	// determine new length, padding with _Val elements as needed
		if (size() < _Newsize)
			_Insert_n(end(), _Newsize - size(), _Val);
		else if (_Newsize < size())
			erase(begin() + static_cast<difference_type>(_Newsize), end());
		}

	 size_type size() const noexcept
		{	// return length of sequence
		return (this->_Mysize);
		}

	 size_type max_size() const noexcept
		{	// return maximum possible length of sequence
		constexpr size_type _Diff_max = static_cast<size_type>((numeric_limits<difference_type>::max)());
		const size_type _Ints_max = this->_Myvec.max_size();
		if (_Ints_max > _Diff_max / _VBITS)
			{	// max_size bound by difference_type limits
			return (_Diff_max);
			}

		// max_size bound by underlying storage limits
		return (_Ints_max * _VBITS);
		}

	 bool empty() const noexcept
		{	// test if sequence is empty
		return (size() == 0);
		}

	 allocator_type get_allocator() const noexcept
		{	// return allocator object for values
		return (static_cast<allocator_type>(this->_Myvec.get_allocator()));
		}

	 const_reference at(size_type _Off) const
		{	// subscript nonmutable sequence with checking
		if (size() <= _Off)
			_Xran();
		return ((*this)[_Off]);
		}

	 reference at(size_type _Off)
		{	// subscript mutable sequence with checking
		if (size() <= _Off)
			_Xran();
		return ((*this)[_Off]);
		}

	 const_reference operator[](size_type _Off) const
		{	// subscript nonmutable sequence
		const_iterator _It = begin();
		_It._Advance(_Off);
		return (*_It);
		}

	 reference operator[](size_type _Off)
		{	// subscript mutable sequence
		iterator _It = begin();
		_It._Advance(_Off);
		return (*_It);
		}

	 reference front()
		{	// return first element of mutable sequence
		return (*begin());
		}

	 const_reference front() const
		{	// return first element of nonmutable sequence
		return (*begin());
		}

	 reference back()
		{	// return last element of mutable sequence
		return (*(end() - 1));
		}

	 const_reference back() const
		{	// return last element of nonmutable sequence
		return (*(end() - 1));
		}

	void push_back(const bool& _Val)
		{	// insert element at end
		insert(end(), _Val);
		}

	void pop_back()
		{	// erase element at end
		erase(end() - 1);
		}

	template<class _Iter,
		class = enable_if_t<_Is_iterator_v<_Iter>>>
		void assign(_Iter _First, _Iter _Last)
		{	// assign [_First, _Last), input iterators
		erase(begin(), end());
		insert(begin(), _First, _Last);
		}

	void assign(__declspec(guard(overflow)) size_type _Count, const bool& _Val)
		{	// assign _Count * _Val
		erase(begin(), end());
		_Insert_n(begin(), _Count, _Val);
		}

	iterator insert(const_iterator _Where, const bool& _Val)
		{	// insert _Val at _Where
		return (_Insert_n(_Where, static_cast<size_type>(1), _Val));
		}

	iterator insert(const_iterator _Where, __declspec(guard(overflow)) size_type _Count,
		const bool& _Val)
		{	// insert _Count * _Val at _Where
		return (_Insert_n(_Where, _Count, _Val));
		}

	template<class _Iter,
		class = enable_if_t<_Is_iterator_v<_Iter>>>
		iterator insert(const_iterator _Where, _Iter _First, _Iter _Last)
		{	// insert [_First, _Last) at _Where
		difference_type _Off = _Where - begin();
		_Insert(_Where, _First, _Last, _Iter_cat_t<_Iter>());
		return (begin() + _Off);
		}

	template<class _Iter>
		void _Insert(const_iterator _Where,
			_Iter _First, _Iter _Last,
				input_iterator_tag)
		{	// insert [_First, _Last) at _Where, input iterators
		difference_type _Off = _Where - begin();

		for (; _First != _Last; ++_First, (void)++_Off)
			insert(begin() + _Off, *_First);
		}

	template<class _Iter>
		void _Insert(const_iterator _Where,
			_Iter _First, _Iter _Last,
			forward_iterator_tag)
		{	// insert [_First, _Last) at _Where, forward iterators
		_Adl_verify_range(_First, _Last);
		size_type _Count = _Convert_size<size_type>(static_cast<size_t>(::std:: distance(_First, _Last)));
		size_type _Off = _Insert_x(_Where, _Count);
		_Copy_unchecked(_Get_unwrapped(_First), _Get_unwrapped(_Last),
			begin() + static_cast<difference_type>(_Off));
		}

	iterator erase(const_iterator _Where_arg)
		{	// erase element at _Where
		iterator _Where = _Make_iter(_Where_arg);
		difference_type _Off = _Where - begin();

 
		do { if (end() > _Where) { } else { do { (void) ((1 != _CrtDbgReport(2, "c:\\visual studio\\vc\\tools\\msvc\\14.16.27023\\include\\vector", 3026, 0, "%s", "vector<bool> erase iterator outside range")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"vector<bool> erase iterator outside range\"", __LPREFIX( __FUNCTION__), L"c:\\visual studio\\vc\\tools\\msvc\\14.16.27023\\include\\vector", 3026, 0); } while (false); } ; } while (false);
		::std:: copy(_Where + 1, end(), _Where);
		_Orphan_range(static_cast<size_type>(_Off), this->_Mysize);

 



		_Trim(this->_Mysize - 1);
		return (begin() + _Off);
		}

	iterator erase(const_iterator _First_arg,
		const_iterator _Last_arg)
		{	// erase [_First, _Last)
		iterator _First = _Make_iter(_First_arg);
		iterator _Last = _Make_iter(_Last_arg);
		difference_type _Off = _First - begin();

		if (_First != _Last)
			{	// worth doing, copy down over hole
 
			do { if (_Last >= _First && end() >= _Last) { } else { do { (void) ((1 != _CrtDbgReport(2, "c:\\visual studio\\vc\\tools\\msvc\\14.16.27023\\include\\vector", 3048, 0, "%s", "vector<bool> erase iterator outside range")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"vector<bool> erase iterator outside range\"", __LPREFIX( __FUNCTION__), L"c:\\visual studio\\vc\\tools\\msvc\\14.16.27023\\include\\vector", 3048, 0); } while (false); } ; } while (false);
			iterator _Next = ::std:: copy(_Last, end(), _First);
			const auto _Newsize = static_cast<size_type>(_Next - begin());
			_Orphan_range(_Newsize, this->_Mysize);
			_Trim(_Newsize);

 



			}
		return (begin() + _Off);
		}

	void clear() noexcept
		{	// erase all elements
		erase(begin(), end());
		}

	void flip() noexcept
		{	// toggle all elements
		for (auto& _Elem : this->_Myvec)
			{
			_Elem = ~_Elem;
			}

		_Trim(this->_Mysize);
		}

	void swap(vector& _Right) noexcept // strengthened
		{	// exchange contents with _Right
		if (this != ::std:: addressof(_Right))
			{	// (maybe) swap allocators, swap control information
			this->_Swap_all(_Right);
			this->_Myvec.swap(_Right._Myvec);
			::std:: swap(this->_Mysize, _Right._Mysize);
			}
		}

	static void swap(reference _Left, reference _Right) noexcept
		{	// swap _Left and _Right vector<bool> elements
		bool _Val = _Left;	// NOT _STD swap
		_Left = _Right;
		_Right = _Val;
		}

	friend hash<vector<bool, _Alloc>>;

	iterator _Insert_n(const_iterator _Where,
		size_type _Count, const bool& _Val)
		{	// insert _Count * _Val at _Where
		size_type _Off = _Insert_x(_Where, _Count);
		const auto _Result = begin() + static_cast<difference_type>(_Off);
		::std:: fill(_Result, _Result + static_cast<difference_type>(_Count), _Val);
		return (_Result);
		}

	size_type _Insert_x(const_iterator _Where, size_type _Count)
		{	// make room to insert _Count elements at _Where
		difference_type _Off = _Where - begin();

 
		do { if (end() >= _Where) { } else { do { (void) ((1 != _CrtDbgReport(2, "c:\\visual studio\\vc\\tools\\msvc\\14.16.27023\\include\\vector", 3110, 0, "%s", "vector<bool> insert iterator outside range")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"vector<bool> insert iterator outside range\"", __LPREFIX( __FUNCTION__), L"c:\\visual studio\\vc\\tools\\msvc\\14.16.27023\\include\\vector", 3110, 0); } while (false); } ; } while (false);
		bool _Realloc = capacity() - size() < _Count;
 

		if (_Count != 0)
			{
			if (max_size() - size() < _Count)
				{
				_Xlen();	// result too long
				}

			// worth doing
			this->_Myvec.resize(this->_Nw(size() + _Count), 0);
			if (empty())
				{
				this->_Mysize += _Count;
				}
			else
				{	// make room and copy down suffix
				iterator _Oldend = end();
				this->_Mysize += _Count;
				::std:: copy_backward(begin() + _Off, _Oldend, end());
				}


			_Orphan_range(static_cast<size_type>(_Realloc ? 0 : _Off), this->_Mysize);

			}

		return (static_cast<size_type>(_Off));
		}

 
	void _Orphan_range(size_type _Offlo, size_type _Offhi) const
		{	// orphan iterators within specified (inclusive) range
		_Lockit _Lock(3);
		auto _Base = const_cast<_Vbase *>(this->_Myvec.data());

		const_iterator **_Pnext = (const_iterator **)this->_Getpfirst();
		if (_Pnext != nullptr)
			while (*_Pnext != nullptr)
				{	// test offset from beginning of vector
				size_type _Off = static_cast<size_type>(_VBITS * ((*_Pnext)->_Myptr - _Base))
					+ (*_Pnext)->_Myoff;
				if (_Off < _Offlo || _Offhi < _Off)
					_Pnext = (const_iterator **)(*_Pnext)->_Getpnext();
				else
					{	// orphan the iterator
					(*_Pnext)->_Clrcont();
					*_Pnext = *(const_iterator **)(*_Pnext)->_Getpnext();
					}
				}
		}

 





	void _Trim(size_type _Size)
		{	// trim base vector to exact length in bits
		if (max_size() < _Size)
			_Xlen();	// result too long
		const size_type _Words = this->_Nw(_Size);

		if (_Words < this->_Myvec.size())
			this->_Myvec.erase(this->_Myvec.begin() + static_cast<difference_type>(_Words),
				this->_Myvec.end());
		this->_Mysize = _Size;
		_Size %= _VBITS;
		if (0 < _Size)
			this->_Myvec[_Words - 1] &= (static_cast<_Vbase>(1) << _Size) - 1;
		}

	[[noreturn]] void _Xlen() const
		{	// report a length_error
		_Xlength_error("vector<bool> too long");
		}

	[[noreturn]] void _Xran() const
		{	// report an out_of_range error
		_Xout_of_range("invalid vector<bool> subscript");
		}
	};

template<class _Alloc>
	 inline bool operator==(const vector<bool, _Alloc>& _Left,
		const vector<bool, _Alloc>& _Right)
	{	// test for vector equality
	return (_Left.size() == _Right.size()
		&& _Left._Myvec == _Right._Myvec);
	}

template<class _Alloc>
	 inline bool operator!=(const vector<bool, _Alloc>& _Left,
		const vector<bool, _Alloc>& _Right)
	{	// test for vector inequality
	return (!(_Left == _Right));
	}

	// STRUCT TEMPLATE SPECIALIZATION hash
template<class _Alloc>
	struct hash<vector<bool, _Alloc>>
	{	// hash functor
	 typedef vector<bool, _Alloc> argument_type;
	 typedef size_t result_type;

	 size_t operator()(const vector<bool, _Alloc>& _Keyval) const noexcept
		{	// hash _Keyval to size_t value by pseudorandomizing transform
		return (_Hash_array_representation(_Keyval._Myvec.data(), _Keyval._Myvec.size()));
		}
	};







}

 
 
 #pragma warning(pop)
 #pragma pack(pop)



/*
 * Copyright (c) by P.J. Plauger. All rights reserved.
 * Consult your license regarding permissions and restrictions.
V6.50:0009 */


// mutex standard header
#pragma once




 




// chrono standard header
#pragma once





// ratio standard header (core)
#pragma once






 #pragma pack(push,8)
 #pragma warning(push,3)
 #pragma warning(disable: 4455 4494  4619 4643 4702 4984 4988 )
 
 
 

namespace std {
	// STRUCT TEMPLATE _Abs
template<intmax_t _Val>
	struct _Abs
		: integral_constant<intmax_t, (_Val < 0 ? -_Val : _Val)>
	{	// computes absolute value of _Val
	};

	// STRUCT TEMPLATE _Safe_mult
template<intmax_t _Ax,
	intmax_t _Bx,
	bool _Sfinae = false,
	bool _Good = (_Abs<_Ax>::value <= 9223372036854775807i64 / (_Bx == 0 ? 1 : _Abs<_Bx>::value))>
	struct _Safe_mult
		: integral_constant<intmax_t, _Ax * _Bx>
	{	// computes _Ax * _Bx without overflow
	};

template<intmax_t _Ax,
	intmax_t _Bx,
	bool _Sfinae>
	struct _Safe_mult<_Ax, _Bx, _Sfinae, false>
	{	// _Ax * _Bx would overflow
	static_assert(_Sfinae,
		"integer arithmetic overflow");
	};

	// STRUCT TEMPLATE _Sign_of
template<intmax_t _Val>
	struct _Sign_of
		: integral_constant<intmax_t, (_Val < 0 ? -1 : 1)>
	{	// computes sign of _Val
	};

	// STRUCT TEMPLATE _Safe_add
template<intmax_t _Ax,
	intmax_t _Bx,
	bool _Good,
	bool _Also_good>
	struct _Safe_addX
		: integral_constant<intmax_t, _Ax + _Bx>
	{	// computes _Ax + _Bx without overflow
	};

template<intmax_t _Ax,
	intmax_t _Bx>
	struct _Safe_addX<_Ax, _Bx, false, false>
	{	// _Ax + _Bx would overflow
	static_assert(_Always_false<_Safe_addX>,
		"integer arithmetic overflow");
	};

template<intmax_t _Ax,
	intmax_t _Bx>
	struct _Safe_add
		: _Safe_addX<_Ax, _Bx,
			_Sign_of<_Ax>::value != _Sign_of<_Bx>::value,
			(_Abs<_Ax>::value <= 9223372036854775807i64 - _Abs<_Bx>::value)>::type
	{	// computes _Ax + _Bx, forbids overflow
	};

	// STRUCT TEMPLATE _Gcd
template<intmax_t _Ax,
	intmax_t _Bx>
	struct _GcdX
		: _GcdX<_Bx, _Ax % _Bx>::type
	{	// computes greatest common divisor of _Ax and _Bx
	};

template<intmax_t _Ax>
	struct _GcdX<_Ax, 0>
		: integral_constant<intmax_t, _Ax>
	{	// computes greatest common divisor of _Ax and 0
	};

template<intmax_t _Ax,
	intmax_t _Bx>
	struct _Gcd
		: _GcdX<_Abs<_Ax>::value, _Abs<_Bx>::value>::type
	{	// computes greatest common divisor of abs(_Ax) and abs(_Bx)
	};

template<>
	struct _Gcd<0, 0>
		: integral_constant<intmax_t, 1>	// contrary to mathematical convention
	{	// avoids division by 0 in ratio_less
	};

	// STRUCT TEMPLATE ratio
template<intmax_t _Nx,
	intmax_t _Dx = 1>
	struct ratio
	{	// holds the ratio of _Nx to _Dx
	static_assert(_Dx != 0,
		"zero denominator");
	static_assert(-9223372036854775807i64 <= _Nx,
		"numerator too negative");
	static_assert(-9223372036854775807i64 <= _Dx,
		"denominator too negative");

	static constexpr intmax_t num = _Sign_of<_Nx>::value
		* _Sign_of<_Dx>::value * _Abs<_Nx>::value / _Gcd<_Nx, _Dx>::value;

	static constexpr intmax_t den = _Abs<_Dx>::value / _Gcd<_Nx, _Dx>::value;

	typedef ratio<num, den> type;
	};

	// VARIABLE TEMPLATE _Is_ratio_v
template<class _Ty>
	 constexpr bool _Is_ratio_v = false;	// test for ratio type

template<intmax_t _R1,
	intmax_t _R2>
	 constexpr bool _Is_ratio_v<ratio<_R1, _R2>> = true;

	// ALIAS TEMPLATE ratio_add
template<class _R1,
	class _R2>
	struct _Ratio_add
	{	// add two ratios
	static_assert(_Is_ratio_v<_R1> && _Is_ratio_v<_R2>,
		"ratio_add<R1, R2> requires R1 and R2 to be ratio<>s.");

	static constexpr intmax_t _N1 = _R1::num;
	static constexpr intmax_t _D1 = _R1::den;
	static constexpr intmax_t _N2 = _R2::num;
	static constexpr intmax_t _D2 = _R2::den;

	static constexpr intmax_t _Gx = _Gcd<_D1, _D2>::value;

	// typename ratio<>::type is necessary here
	typedef typename ratio<
		_Safe_add<
			_Safe_mult<_N1, _D2 / _Gx>::value,
			_Safe_mult<_N2, _D1 / _Gx>::value
			>::value,
		_Safe_mult<_D1, _D2 / _Gx>::value
		>::type type;
	};

template<class _R1,
	class _R2>
	using ratio_add = typename _Ratio_add<_R1, _R2>::type;

	// ALIAS TEMPLATE ratio_subtract
template<class _R1,
	class _R2>
	struct _Ratio_subtract
	{	// subtract two ratios
	static_assert(_Is_ratio_v<_R1> && _Is_ratio_v<_R2>,
		"ratio_subtract<R1, R2> requires R1 and R2 to be ratio<>s.");

	static constexpr intmax_t _N2 = _R2::num;
	static constexpr intmax_t _D2 = _R2::den;

	typedef ratio_add<_R1, ratio<-_N2, _D2>> type;
	};

template<class _R1,
	class _R2>
	using ratio_subtract = typename _Ratio_subtract<_R1, _R2>::type;

	// ALIAS TEMPLATE ratio_multiply
template<class _R1,
	class _R2>
	struct _Ratio_multiply
	{	// multiply two ratios
	static_assert(_Is_ratio_v<_R1> && _Is_ratio_v<_R2>,
		"ratio_multiply<R1, R2> requires R1 and R2 to be ratio<>s.");

	static constexpr intmax_t _N1 = _R1::num;
	static constexpr intmax_t _D1 = _R1::den;
	static constexpr intmax_t _N2 = _R2::num;
	static constexpr intmax_t _D2 = _R2::den;

	static constexpr intmax_t _Gx = _Gcd<_N1, _D2>::value;
	static constexpr intmax_t _Gy = _Gcd<_N2, _D1>::value;

	typedef _Safe_mult<_N1 / _Gx, _N2 / _Gy, true> _Num;
	typedef _Safe_mult<_D1 / _Gy, _D2 / _Gx, true> _Den;
	};

template<class _R1,
	class _R2,
	bool _Sfinae = true,
	class = void>
	struct _Ratio_multiply_sfinae
	{	// detect overflow during multiplication
	static_assert(_Sfinae,
		"integer arithmetic overflow");
	};

template<class _R1,
	class _R2,
	bool _Sfinae>
	struct _Ratio_multiply_sfinae<_R1, _R2, _Sfinae, void_t<
		typename _Ratio_multiply<_R1, _R2>::_Num::type,
		typename _Ratio_multiply<_R1, _R2>::_Den::type>>
	{	// typename ratio<>::type is unnecessary here
	typedef ratio<
		_Ratio_multiply<_R1, _R2>::_Num::value,
		_Ratio_multiply<_R1, _R2>::_Den::value> type;
	};

template<class _R1,
	class _R2>
	using ratio_multiply = typename _Ratio_multiply_sfinae<_R1, _R2, false>::type;

	// ALIAS TEMPLATE ratio_divide
template<class _R1,
	class _R2>
	struct _Ratio_divide
	{	// divide two ratios
	static_assert(_Is_ratio_v<_R1> && _Is_ratio_v<_R2>,
		"ratio_divide<R1, R2> requires R1 and R2 to be ratio<>s.");

	static constexpr intmax_t _N2 = _R2::num;
	static constexpr intmax_t _D2 = _R2::den;

	typedef ratio<_D2, _N2> _R2_inverse;
	};

template<class _R1,
	class _R2,
	bool _Sfinae = true>
	using _Ratio_divide_sfinae = typename _Ratio_multiply_sfinae<
		_R1, typename _Ratio_divide<_R1, _R2>::_R2_inverse, _Sfinae>::type;

template<class _R1,
	class _R2>
	using ratio_divide = _Ratio_divide_sfinae<_R1, _R2, false>;

	// STRUCT TEMPLATE ratio_equal
template<class _R1,
	class _R2>
	struct ratio_equal
		: bool_constant<_R1::num == _R2::num && _R1::den == _R2::den>
	{	// tests if ratio == ratio
	static_assert(_Is_ratio_v<_R1> && _Is_ratio_v<_R2>,
		"ratio_equal<R1, R2> requires R1 and R2 to be ratio<>s.");
	};

template<class _R1,
	class _R2>
	 constexpr bool ratio_equal_v = ratio_equal<_R1, _R2>::value;

	// STRUCT TEMPLATE ratio_not_equal
template<class _R1,
	class _R2>
	struct ratio_not_equal
		: bool_constant<!ratio_equal_v<_R1, _R2>>
	{	// tests if ratio != ratio
	static_assert(_Is_ratio_v<_R1> && _Is_ratio_v<_R2>,
		"ratio_not_equal<R1, R2> requires R1 and R2 to be ratio<>s.");
	};

template<class _R1,
	class _R2>
	 constexpr bool ratio_not_equal_v = ratio_not_equal<_R1, _R2>::value;

	// STRUCT TEMPLATE ratio_less
struct _Big_uint128
	{
	uint64_t _Upper;
	uint64_t _Lower;

	constexpr bool operator<(const _Big_uint128 _Rhs) const noexcept
		{
		if (_Upper != _Rhs._Upper)
			{
			return (_Upper < _Rhs._Upper);
			}

		return (_Lower < _Rhs._Lower);
		}
	};

constexpr _Big_uint128 _Big_multiply(const uint64_t _Lfactor, const uint64_t _Rfactor) noexcept
	{	// multiply two 64-bit integers into a 128-bit integer, Knuth's algorithm M
	const uint64_t _Llow = _Lfactor & 0xFFFF'FFFFULL;
	const uint64_t _Lhigh = _Lfactor >> 32;
	const uint64_t _Rlow = _Rfactor & 0xFFFF'FFFFULL;
	const uint64_t _Rhigh = _Rfactor >> 32;

	uint64_t _Temp = _Llow * _Rlow;
	const uint64_t _Lower32 = _Temp & 0xFFFF'FFFFULL;
	uint64_t _Carry = _Temp >> 32;

	_Temp = _Llow * _Rhigh + _Carry;
	const uint64_t _Mid_lower = _Temp & 0xFFFF'FFFFULL;
	const uint64_t _Mid_upper = _Temp >> 32;

	_Temp = _Lhigh * _Rlow + _Mid_lower;
	_Carry = _Temp >> 32;

	return {_Lhigh * _Rhigh + _Mid_upper + _Carry, (_Temp << 32) + _Lower32};
	}

constexpr bool _Ratio_less(const int64_t _N1, const int64_t _D1,
		const int64_t _N2, const int64_t _D2) noexcept
	{
	if (_N1 >= 0 && _N2 >= 0)
		{
		return (_Big_multiply(static_cast<uint64_t>(_N1), static_cast<uint64_t>(_D2))
			< _Big_multiply(static_cast<uint64_t>(_N2), static_cast<uint64_t>(_D1)));
		}

	if (_N1 < 0 && _N2 < 0)
		{
		return (_Big_multiply(static_cast<uint64_t>(-_N2), static_cast<uint64_t>(_D1))
			< _Big_multiply(static_cast<uint64_t>(-_N1), static_cast<uint64_t>(_D2)));
		}

	return (_N1 < _N2);
	}

template<class _R1,
	class _R2>
	struct ratio_less
		: bool_constant<_Ratio_less(_R1::num, _R1::den, _R2::num, _R2::den)>
	{	// tests if ratio < ratio
	static_assert(_Is_ratio_v<_R1> && _Is_ratio_v<_R2>,
		"ratio_less<R1, R2> requires R1 and R2 to be ratio<>s.");
	};

template<class _R1,
	class _R2>
	 constexpr bool ratio_less_v = ratio_less<_R1, _R2>::value;

	// STRUCT TEMPLATE ratio_less_equal
template<class _R1,
	class _R2>
	struct ratio_less_equal
		: bool_constant<!ratio_less_v<_R2, _R1>>
	{	// tests if ratio <= ratio
	static_assert(_Is_ratio_v<_R1> && _Is_ratio_v<_R2>,
		"ratio_less_equal<R1, R2> requires R1 and R2 to be ratio<>s.");
	};

template<class _R1,
	class _R2>
	 constexpr bool ratio_less_equal_v = ratio_less_equal<_R1, _R2>::value;

	// STRUCT TEMPLATE ratio_greater
template<class _R1,
	class _R2>
	struct ratio_greater
		: ratio_less<_R2, _R1>::type
	{	// tests if ratio > ratio
	static_assert(_Is_ratio_v<_R1> && _Is_ratio_v<_R2>,
		"ratio_greater<R1, R2> requires R1 and R2 to be ratio<>s.");
	};

template<class _R1,
	class _R2>
	 constexpr bool ratio_greater_v = ratio_greater<_R1, _R2>::value;

	// STRUCT TEMPLATE ratio_greater_equal
template<class _R1,
	class _R2>
	struct ratio_greater_equal
		: bool_constant<!ratio_less_v<_R1, _R2>>
	{	// tests if ratio >= ratio
	static_assert(_Is_ratio_v<_R1> && _Is_ratio_v<_R2>,
		"ratio_greater_equal<R1, R2> requires R1 and R2 to be ratio<>s.");
	};

template<class _R1,
	class _R2>
	 constexpr bool ratio_greater_equal_v = ratio_greater_equal<_R1, _R2>::value;

	// SI TYPEDEFS
typedef ratio<1, 1000000000000000000LL> atto;
typedef ratio<1, 1000000000000000LL> femto;
typedef ratio<1, 1000000000000LL> pico;
typedef ratio<1, 1000000000> nano;
typedef ratio<1, 1000000> micro;
typedef ratio<1, 1000> milli;
typedef ratio<1, 100> centi;
typedef ratio<1, 10> deci;
typedef ratio<10, 1> deca;
typedef ratio<100, 1> hecto;
typedef ratio<1000, 1> kilo;
typedef ratio<1000000, 1> mega;
typedef ratio<1000000000, 1> giga;
typedef ratio<1000000000000LL, 1> tera;
typedef ratio<1000000000000000LL, 1> peta;
typedef ratio<1000000000000000000LL, 1> exa;
}
 
 
 #pragma warning(pop)
 #pragma pack(pop)



/*
 * Copyright (c) by P.J. Plauger. All rights reserved.
 * Consult your license regarding permissions and restrictions.
V6.50:0009 */



//
// time.h
//
//      Copyright (c) Microsoft Corporation. All rights reserved.
//
// The C Standard Library <time.h> header.
//
#pragma once






__pragma(pack(push, 8)) extern "C" {



//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// Types
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
typedef long clock_t;

struct _timespec32
{
    __time32_t tv_sec;
    long       tv_nsec;
};

struct _timespec64
{
    __time64_t tv_sec;
    long       tv_nsec;
};


    struct timespec
    {
        time_t tv_sec;  // Seconds - >= 0
        long   tv_nsec; // Nanoseconds - [0, 999999999]
    };




// The number of clock ticks per second






//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// Time Zone and Daylight Savings Time Data and Accessors
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
// Nonzero if Daylight Savings Time is used
  __declspec(deprecated("This function or variable may be unsafe. Consider using " "_get_daylight" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__declspec(dllimport) int* __cdecl __daylight(void);



// Offset for Daylight Savings Time
  __declspec(deprecated("This function or variable may be unsafe. Consider using " "_get_dstbias" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__declspec(dllimport) long* __cdecl __dstbias(void);



// Difference in seconds between GMT and local time
  __declspec(deprecated("This function or variable may be unsafe. Consider using " "_get_timezone" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__declspec(dllimport) long* __cdecl __timezone(void);



// Standard and Daylight Savings Time time zone names
    __declspec(deprecated("This function or variable may be unsafe. Consider using " "_get_tzname" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__declspec(dllimport) char** __cdecl __tzname(void);



  
__declspec(dllimport) errno_t __cdecl _get_daylight(
      int* _Daylight
    );

 
__declspec(dllimport) errno_t __cdecl _get_dstbias(
      long* _DaylightSavingsBias
    );

  
__declspec(dllimport) errno_t __cdecl _get_timezone(
      long* _TimeZone
    );

 
__declspec(dllimport) errno_t __cdecl _get_tzname(
                             size_t* _ReturnValue,
      char*   _Buffer,
                              size_t  _SizeInBytes,
                              int     _Index
    );



//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// AppCRT Time Functions
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 
 
  __declspec(deprecated("This function or variable may be unsafe. Consider using " "asctime_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__declspec(dllimport) char* __cdecl asctime(
      struct tm const* _Tm
    );


     
    
    __declspec(dllimport) errno_t __cdecl asctime_s(
            char*            _Buffer,
                                            size_t           _SizeInBytes,
                                                         struct tm const* _Tm
        );


extern "C++" { template <size_t _Size> inline errno_t __cdecl asctime_s(  char (&_Buffer)[_Size],   struct tm const* _Time) throw() { return asctime_s(_Buffer, _Size, _Time); } }

 
__declspec(dllimport) clock_t __cdecl clock(void);

 
 
  __declspec(deprecated("This function or variable may be unsafe. Consider using " "_ctime32_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__declspec(dllimport) char* __cdecl _ctime32(
      __time32_t const* _Time
    );


__declspec(dllimport) errno_t __cdecl _ctime32_s(
        char*             _Buffer,
                                        size_t            _SizeInBytes,
                                                     __time32_t const* _Time
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _ctime32_s(  char (&_Buffer)[_Size],   __time32_t const* _Time) throw() { return _ctime32_s(_Buffer, _Size, _Time); } }

 
 
  __declspec(deprecated("This function or variable may be unsafe. Consider using " "_ctime64_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__declspec(dllimport) char* __cdecl _ctime64(
      __time64_t const* _Time
    );


__declspec(dllimport) errno_t __cdecl _ctime64_s(
        char*             _Buffer,
                                          size_t            _SizeInBytes,
                                                       __time64_t const* _Time
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _ctime64_s(  char (&_Buffer)[_Size],   __time64_t const* _Time) throw() { return _ctime64_s(_Buffer, _Size, _Time); } }

 
__declspec(dllimport) double __cdecl _difftime32(
      __time32_t _Time1,
      __time32_t _Time2
    );

 
__declspec(dllimport) double __cdecl _difftime64(
      __time64_t _Time1,
      __time64_t _Time2
    );

 
  __declspec(deprecated("This function or variable may be unsafe. Consider using " "_gmtime32_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__declspec(dllimport) struct tm* __cdecl _gmtime32(
      __time32_t const* _Time
    );


__declspec(dllimport) errno_t __cdecl _gmtime32_s(
      struct tm*        _Tm,
       __time32_t const* _Time
    );

 
  __declspec(deprecated("This function or variable may be unsafe. Consider using " "_gmtime64_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__declspec(dllimport) struct tm* __cdecl _gmtime64(
      __time64_t const* _Time
    );


__declspec(dllimport) errno_t __cdecl _gmtime64_s(
      struct tm*        _Tm,
       __time64_t const* _Time
    );

 
  __declspec(deprecated("This function or variable may be unsafe. Consider using " "_localtime32_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__declspec(dllimport) struct tm* __cdecl _localtime32(
      __time32_t const* _Time
    );


__declspec(dllimport) errno_t __cdecl _localtime32_s(
      struct tm*        _Tm,
       __time32_t const* _Time
    );

 
  __declspec(deprecated("This function or variable may be unsafe. Consider using " "_localtime64_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__declspec(dllimport) struct tm* __cdecl _localtime64(
      __time64_t const* _Time
    );


__declspec(dllimport) errno_t __cdecl _localtime64_s(
      struct tm*        _Tm,
       __time64_t const* _Time
    );

 
__declspec(dllimport) __time32_t __cdecl _mkgmtime32(
      struct tm* _Tm
    );

 
__declspec(dllimport) __time64_t __cdecl _mkgmtime64(
      struct tm* _Tm
    );


__declspec(dllimport) __time32_t __cdecl _mktime32(
      struct tm* _Tm
    );


__declspec(dllimport) __time64_t __cdecl _mktime64(
      struct tm* _Tm
    );

 

__declspec(dllimport) size_t __cdecl strftime(
       char*            _Buffer,
                               size_t           _SizeInBytes,
        char const*      _Format,
                               struct tm const* _Tm
    );

 

__declspec(dllimport) size_t __cdecl _strftime_l(
           char*            _Buffer,
                               size_t           _MaxSize,
        char const*      _Format,
                               struct tm const* _Tm,
                           _locale_t        _Locale
    );


__declspec(dllimport) errno_t __cdecl _strdate_s(
       char*  _Buffer,
                                                                              size_t _SizeInBytes
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _strdate_s(  char (&_Buffer)[_Size]) throw() { return _strdate_s(_Buffer, _Size); } }

__declspec(deprecated("This function or variable may be unsafe. Consider using " "_strdate_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport)  char* __cdecl _strdate( char *_Buffer);


__declspec(dllimport) errno_t __cdecl _strtime_s(
       char*  _Buffer,
                                                                              size_t _SizeInBytes
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _strtime_s(  char (&_Buffer)[_Size]) throw() { return _strtime_s(_Buffer, _Size); } }

__declspec(deprecated("This function or variable may be unsafe. Consider using " "_strtime_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) char* __cdecl _strtime( char *_Buffer);

__declspec(dllimport) __time32_t __cdecl _time32(
      __time32_t* _Time
    );

__declspec(dllimport) __time64_t __cdecl _time64(
      __time64_t* _Time
    );

 
 
__declspec(dllimport) int __cdecl _timespec32_get(
      struct _timespec32* _Ts,
       int                 _Base
    );

 
 
__declspec(dllimport) int __cdecl _timespec64_get(
      struct _timespec64* _Ts,
       int                 _Base
    );



//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// DesktopCRT Time Functions
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+


    __declspec(dllimport) void __cdecl _tzset(void);

    // The Win32 API GetLocalTime and SetLocalTime should be used instead.
    __declspec(deprecated("This function or variable has been superceded by newer library " "or operating system functionality. Consider using " "GetLocalTime" " " "instead. See online help for details."))
    __declspec(dllimport) unsigned __cdecl _getsystime(
          struct tm* _Tm
        );

    __declspec(deprecated("This function or variable has been superceded by newer library " "or operating system functionality. Consider using " "SetLocalTime" " " "instead. See online help for details."))
    __declspec(dllimport) unsigned __cdecl _setsystime(
          struct tm* _Tm,
          unsigned   _Milliseconds
        );





//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// Inline Function Definitions
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+


    











































































































          __declspec(deprecated("This function or variable may be unsafe. Consider using " "ctime_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
        static __inline char* __cdecl ctime(
              time_t const* const _Time
            )
        {
            #pragma warning(push)
            #pragma warning(disable: 4996)
            return _ctime64(_Time);
            #pragma warning(pop)
        }

         
        static __inline double __cdecl difftime(
              time_t const _Time1,
              time_t const _Time2
            )
        {
            return _difftime64(_Time1, _Time2);
        }

          __declspec(deprecated("This function or variable may be unsafe. Consider using " "gmtime_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
        static __inline struct tm* __cdecl gmtime(
              time_t const* const _Time)
        {
            #pragma warning(push)
            #pragma warning(disable: 4996)
            return _gmtime64(_Time);
            #pragma warning(pop)
        }

        __declspec(deprecated("This function or variable may be unsafe. Consider using " "localtime_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
        static __inline struct tm* __cdecl localtime(
              time_t const* const _Time
            )
        {
            #pragma warning(push)
            #pragma warning(disable: 4996)
            return _localtime64(_Time);
            #pragma warning(pop)
        }

         
        static __inline time_t __cdecl _mkgmtime(
              struct tm* const _Tm
            )
        {
            return _mkgmtime64(_Tm);
        }

        
        static __inline time_t __cdecl mktime(
              struct tm* const _Tm
            )
        {
            return _mktime64(_Tm);
        }

        static __inline time_t __cdecl time(
              time_t* const _Time
            )
        {
            return _time64(_Time);
        }

         
        static __inline int __cdecl timespec_get(
              struct timespec* const _Ts,
               int              const _Base
            )
        {
            return _timespec64_get((struct _timespec64*)_Ts, _Base);
        }

        
            
            static __inline errno_t __cdecl ctime_s(
                    char*         const _Buffer,
                                                    size_t        const _SizeInBytes,
                                                                 time_t const* const _Time
                )
            {
                return _ctime64_s(_Buffer, _SizeInBytes, _Time);
            }

            
            static __inline errno_t __cdecl gmtime_s(
                  struct tm*    const _Tm,
                   time_t const* const _Time
                )
            {
                return _gmtime64_s(_Tm, _Time);
            }

            
            static __inline errno_t __cdecl localtime_s(
                  struct tm*    const _Tm,
                   time_t const* const _Time
                )
            {
                return _localtime64_s(_Tm, _Time);
            }
        

    





//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//
// Non-ANSI Names for Compatibility
//
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+


    

    
        __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_tzset" ". See online help for details.")) __declspec(dllimport) void __cdecl tzset(void);
    





} __pragma(pack(pop))



/* xtimec.h -- header for high-resolution time functions */
#pragma once




/* xthrcommon.h -- common header for C/C++ threads libraries */
#pragma once





 #pragma pack(push,8)
 #pragma warning(push,3)
 #pragma warning(disable: 4455 4494  4619 4643 4702 4984 4988 )
 
 
 

 
  
 



extern "C" {

typedef unsigned int _Thrd_id_t;
typedef struct
	{	/* thread identifier for Win32 */
	void *_Hnd;	/* Win32 HANDLE */
	_Thrd_id_t _Id;
	} _Thrd_imp_t;





typedef unsigned int (__stdcall *_Thrd_callback_t)(void *);

 /* Size and alignment for _Mtx_internal_imp_t and _Cnd_internal_imp_t */
 












 
  
  
  
  
 





 

typedef struct _Mtx_internal_imp_t *_Mtx_imp_t;

typedef struct _Cnd_internal_imp_t *_Cnd_imp_t;

	/* internal */
 void __cdecl _Thrd_abort(const char *);
 int __cdecl _Thrd_start(_Thrd_imp_t *, _Thrd_callback_t, void *);

 
  
  
	/* CAUTION -- some compilers require this all on one line: */
  


 



}

 
 
 #pragma warning(pop)
 #pragma pack(pop)



/*
 * This file is derived from software bearing the following
 * restrictions:
 *
 * (c) Copyright William E. Kempf 2001
 *
 * Permission to use, copy, modify, distribute and sell this
 * software and its documentation for any purpose is hereby
 * granted without fee, provided that the above copyright
 * notice appear in all copies and that both that copyright
 * notice and this permission notice appear in supporting
 * documentation. William E. Kempf makes no representations
 * about the suitability of this software for any purpose.
 * It is provided "as is" without express or implied warranty.
 */

/*
 * Copyright (c) by P.J. Plauger. All rights reserved.
 * Consult your license regarding permissions and restrictions.
V6.50:0009 */



 #pragma pack(push,8)
 #pragma warning(push,3)
 #pragma warning(disable: 4455 4494  4619 4643 4702 4984 4988 )
 
 
 

extern "C" {

typedef struct xtime
	{	/* store time with nanosecond resolution */
	__time64_t sec;
	long nsec;
	} xtime;

 int __cdecl xtime_get(xtime*, int);

 long __cdecl _Xtime_diff_to_millis(const xtime *);
 long __cdecl _Xtime_diff_to_millis2(const xtime*, const xtime *);
 long long __cdecl _Xtime_get_ticks(void);



 long long __cdecl _Query_perf_counter(void);
 long long __cdecl _Query_perf_frequency(void);

}

 
 
 #pragma warning(pop)
 #pragma pack(pop)



/*
 * This file is derived from software bearing the following
 * restrictions:
 *
 * (c) Copyright William E. Kempf 2001
 *
 * Permission to use, copy, modify, distribute and sell this
 * software and its documentation for any purpose is hereby
 * granted without fee, provided that the above copyright
 * notice appear in all copies and that both that copyright
 * notice and this permission notice appear in supporting
 * documentation. William E. Kempf makes no representations
 * about the suitability of this software for any purpose.
 * It is provided "as is" without express or implied warranty.
 */

/*
 * Copyright (c) by P.J. Plauger. All rights reserved.
 * Consult your license regarding permissions and restrictions.
V6.50:0009 */


 #pragma pack(push,8)
 #pragma warning(push,3)
 #pragma warning(disable: 4455 4494  4619 4643 4702 4984 4988 )
 
 
 

namespace std {
namespace chrono {
	// STRUCT TEMPLATE treat_as_floating_point
template<class _Rep>
	struct treat_as_floating_point
		: is_floating_point<_Rep>
	{	// tests for floating-point type
	};

template<class _Rep>
	 constexpr bool treat_as_floating_point_v = treat_as_floating_point<_Rep>::value;

	// STRUCT TEMPLATE duration_values
template<class _Rep>
	struct duration_values
	{	// gets arithmetic properties of a type
	 static constexpr _Rep zero() noexcept // Strengthened, P0972
		{	// get zero value
		return (_Rep(0));
		}

	 static constexpr _Rep (min)() noexcept // Strengthened, P0972
		{	// get smallest value
		return (numeric_limits<_Rep>::lowest());
		}

	 static constexpr _Rep (max)() noexcept // Strengthened, P0972
		{	// get largest value
		return ((numeric_limits<_Rep>::max)());
		}
	};

	// CLASS TEMPLATE duration
template<class _Rep,
	class _Period = ratio<1>>
	class duration;

	// VARIABLE TEMPLATE _Is_duration_v
template<class _Ty>
	 constexpr bool _Is_duration_v = _Is_specialization_v<_Ty, duration>;

template<class _To,
	class _Rep,
	class _Period,
	class = enable_if_t<_Is_duration_v<_To>>>
	constexpr _To duration_cast(const duration<_Rep, _Period>&);

template<class _Rep,
	class _Period>
	class duration
	{	// represents a time duration
public:
	using rep = _Rep;
	using period = typename _Period::type;

	static_assert(!_Is_duration_v<_Rep>,
		"duration can't have duration as first template argument");
	static_assert(_Is_ratio_v<_Period>,
		"period not an instance of std::ratio");
	static_assert(0 < _Period::num,
		"period negative or zero");

	constexpr duration() = default;

	template<class _Rep2,
		class = enable_if_t<is_convertible_v<const _Rep2&, _Rep>
			&& (treat_as_floating_point_v<_Rep>
				|| !treat_as_floating_point_v<_Rep2>)>>
		constexpr explicit duration(const _Rep2& _Val)
			: _MyRep(static_cast<_Rep>(_Val))
		{	// construct from representation
		}

	template<class _Rep2,
		class _Period2,
		class = enable_if_t<treat_as_floating_point_v<_Rep>
			|| (_Ratio_divide_sfinae<_Period2, _Period>::den == 1
				&& !treat_as_floating_point_v<_Rep2>)>>
		constexpr duration(const duration<_Rep2, _Period2>& _Dur)
			: _MyRep(chrono::duration_cast<duration>(_Dur).count())
		{	// construct from a duration
		}

	 constexpr _Rep count() const
		{	// get stored rep
		return (_MyRep);
		}

	 constexpr common_type_t<duration> operator+() const
		{	// get value
		return (common_type_t<duration>(*this));
		}

	 constexpr common_type_t<duration> operator-() const
		{	// get negated value
		return (common_type_t<duration>(-_MyRep));
		}

	inline duration& operator++()
		{	// increment rep
		++_MyRep;
		return (*this);
		}

	inline duration operator++(int)
		{	// postincrement rep
		return (duration(_MyRep++));
		}

	inline duration& operator--()
		{	// decrement rep
		--_MyRep;
		return (*this);
		}

	inline duration operator--(int)
		{	// postdecrement rep
		return (duration(_MyRep--));
		}

	inline duration& operator+=(const duration& _Right)
		{	// add _Right to rep
		_MyRep += _Right._MyRep;
		return (*this);
		}

	inline duration& operator-=(const duration& _Right)
		{	// subtract _Right from rep
		_MyRep -= _Right._MyRep;
		return (*this);
		}

	inline duration& operator*=(const _Rep& _Right)
		{	// multiply rep by _Right
		_MyRep *= _Right;
		return (*this);
		}

	inline duration& operator/=(const _Rep& _Right)
		{	// divide rep by _Right
		_MyRep /= _Right;
		return (*this);
		}

	inline duration& operator%=(const _Rep& _Right)
		{	// modulus rep by _Right
		_MyRep %= _Right;
		return (*this);
		}

	inline duration& operator%=(const duration& _Right)
		{	// modulus rep by _Right
		_MyRep %= _Right.count();
		return (*this);
		}

	 static constexpr duration zero() noexcept // Strengthened, P0972
		{	// get zero value
		return (duration(duration_values<_Rep>::zero()));
		}

	 static constexpr duration (min)() noexcept // Strengthened, P0972
		{	// get minimum value
		return (duration((duration_values<_Rep>::min)()));
		}

	 static constexpr duration (max)() noexcept // Strengthened, P0972
		{	// get maximum value
		return (duration((duration_values<_Rep>::max)()));
		}

private:
	_Rep _MyRep;	// the stored rep
	};

template<class _Clock,
	class _Duration = typename _Clock::duration>
	class time_point
	{	// represents a point in time
public:
	using clock = _Clock;
	using duration = _Duration;
	using rep = typename _Duration::rep;
	using period = typename _Duration::period;

	static_assert(_Is_duration_v<_Duration>,
		"duration must be an instance of std::duration");

	constexpr time_point() = default;

	constexpr explicit time_point(const _Duration& _Other)
		: _MyDur(_Other)
		{	// construct from a duration
		}

	template<class _Duration2,
		class = enable_if_t<is_convertible_v<_Duration2, _Duration>>>
		constexpr time_point(const time_point<_Clock, _Duration2>& _Tp)
		: _MyDur(_Tp.time_since_epoch())
		{	// construct from another duration
		}

	 constexpr _Duration time_since_epoch() const
		{	// get duration from epoch
		return (_MyDur);
		}

	inline time_point& operator+=(const _Duration& _Dur)
		{	// increment by duration
		_MyDur += _Dur;
		return (*this);
		}

	inline time_point& operator-=(const _Duration& _Dur)
		{	// decrement by duration
		_MyDur -= _Dur;
		return (*this);
		}

	 static constexpr time_point (min)() noexcept // Strengthened, P0972
		{	// get minimum time point
		return (time_point((_Duration::min)()));
		}

	 static constexpr time_point (max)() noexcept // Strengthened, P0972
		{	// get maximum time point
		return (time_point((_Duration::max)()));
		}

private:
	_Duration _MyDur{duration::zero()};	// duration since the epoch
	};
}	// namespace chrono

	// STRUCT TEMPLATE _Lcm (LEAST COMMON MULTIPLE)
template<intmax_t _Ax,
	intmax_t _Bx>
	struct _Lcm
		: integral_constant<intmax_t, (_Ax / _Gcd<_Ax, _Bx>::value) * _Bx>
	{	/* compute least common multiple of _Ax and _Bx */
	};

	// STRUCT TEMPLATE common_type SPECIALIZATIONS
template<class _Rep1,
	class _Period1,
	class _Rep2,
	class _Period2>
	struct common_type<
		chrono::duration<_Rep1, _Period1>,
		chrono::duration<_Rep2, _Period2>>
	{	// common type of two durations
	using type = chrono::duration<common_type_t<_Rep1, _Rep2>,
		ratio<_Gcd<_Period1::num, _Period2::num>::value,
			_Lcm<_Period1::den, _Period2::den>::value>>;
	};

template<class _Clock,
	class _Duration1,
	class _Duration2>
	struct common_type<
		chrono::time_point<_Clock, _Duration1>,
		chrono::time_point<_Clock, _Duration2>>
	{	// common type of two time points
	using type = chrono::time_point<_Clock, common_type_t<_Duration1, _Duration2>>;
	};

namespace chrono {
	// duration ARITHMETIC
template<class _Rep1,
	class _Period1,
	class _Rep2,
	class _Period2>
	 constexpr common_type_t<duration<_Rep1, _Period1>, duration<_Rep2, _Period2>>
		operator+(
			const duration<_Rep1, _Period1>& _Left,
			const duration<_Rep2, _Period2>& _Right)
	{	// add two durations
	using _CD = common_type_t<duration<_Rep1, _Period1>, duration<_Rep2, _Period2>>;
	return (_CD(_CD(_Left).count() + _CD(_Right).count()));
	}

template<class _Rep1,
	class _Period1,
	class _Rep2,
	class _Period2>
	 constexpr common_type_t<duration<_Rep1, _Period1>, duration<_Rep2, _Period2>>
		operator-(
			const duration<_Rep1, _Period1>& _Left,
			const duration<_Rep2, _Period2>& _Right)
	{	// subtract two durations
	using _CD = common_type_t<duration<_Rep1, _Period1>, duration<_Rep2, _Period2>>;
	return (_CD(_CD(_Left).count() - _CD(_Right).count()));
	}

template<class _Rep1,
	class _Period1,
	class _Rep2,
	class = enable_if_t<is_convertible_v<const _Rep2&, common_type_t<_Rep1, _Rep2>>>>
	 constexpr duration<common_type_t<_Rep1, _Rep2>, _Period1>
		operator*(
			const duration<_Rep1, _Period1>& _Left,
			const _Rep2& _Right)
	{	// multiply duration by rep
	using _CR = common_type_t<_Rep1, _Rep2>;
	using _CD = duration<_CR, _Period1>;
	return (_CD(_CD(_Left).count() * _Right));
	}

template<class _Rep1,
	class _Rep2,
	class _Period2,
	class = enable_if_t<is_convertible_v<const _Rep1&, common_type_t<_Rep1, _Rep2>>>>
	 constexpr duration<common_type_t<_Rep1, _Rep2>, _Period2>
		operator*(
			const _Rep1& _Left,
			const duration<_Rep2, _Period2>& _Right)
	{	// multiply rep by duration
	return (_Right * _Left);
	}

template<class _CR,
	class _Period1,
	class _Rep2,
	bool = is_convertible_v<const _Rep2&, _CR>>
	struct _Duration_div_mod1
	{	// return type for duration / rep and duration % rep
	using type = duration<_CR, _Period1>;
	};

template<class _CR,
	class _Period1,
	class _Rep2>
	struct _Duration_div_mod1<_CR, _Period1, _Rep2, false>
	{	// no return type
	};

template<class _Rep1,
	class _Period1,
	class _Rep2,
	bool = _Is_duration_v<_Rep2>>
	struct _Duration_div_mod
	{	// no return type
	};

template<class _Rep1,
	class _Period1,
	class _Rep2>
	struct _Duration_div_mod<_Rep1, _Period1, _Rep2, false>
		: _Duration_div_mod1<common_type_t<_Rep1, _Rep2>,
			_Period1, _Rep2>
	{	// return type for duration / rep and duration % rep
	};

template<class _Rep1,
	class _Period1,
	class _Rep2>
	 constexpr typename _Duration_div_mod<_Rep1, _Period1, _Rep2>::type
		operator/(
			const duration<_Rep1, _Period1>& _Left,
			const _Rep2& _Right)
	{	// divide duration by rep
	using _CR = common_type_t<_Rep1, _Rep2>;
	using _CD = duration<_CR, _Period1>;
	return (_CD(_CD(_Left).count() / _Right));
	}

template<class _Rep1,
	class _Period1,
	class _Rep2,
	class _Period2>
	 constexpr common_type_t<_Rep1, _Rep2>
		operator/(
			const duration<_Rep1, _Period1>& _Left,
			const duration<_Rep2, _Period2>& _Right)
	{	// divide duration by duration
	using _CD = common_type_t<duration<_Rep1, _Period1>, duration<_Rep2, _Period2>>;
	return (_CD(_Left).count() / _CD(_Right).count());
	}

template<class _Rep1,
	class _Period1,
	class _Rep2>
	 constexpr typename _Duration_div_mod<_Rep1, _Period1, _Rep2>::type
		operator%(
			const duration<_Rep1, _Period1>& _Left,
			const _Rep2& _Right)
	{	// divide duration by rep
	using _CR = common_type_t<_Rep1, _Rep2>;
	using _CD = duration<_CR, _Period1>;
	return (_CD(_CD(_Left).count() % _Right));
	}

template<class _Rep1,
	class _Period1,
	class _Rep2,
	class _Period2>
	 constexpr common_type_t<duration<_Rep1, _Period1>, duration<_Rep2, _Period2>>
		operator%(
			const duration<_Rep1, _Period1>& _Left,
			const duration<_Rep2, _Period2>& _Right)
	{	// divide duration by duration
	using _CD = common_type_t<duration<_Rep1, _Period1>, duration<_Rep2, _Period2>>;
	return (_CD(_CD(_Left).count() % _CD(_Right).count()));
	}

	// duration COMPARISONS
template<class _Rep1,
	class _Period1,
	class _Rep2,
	class _Period2>
	 constexpr bool operator==(
		const duration<_Rep1, _Period1>& _Left,
		const duration<_Rep2, _Period2>& _Right)
	{	// test if duration == duration
	using _CT = common_type_t<duration<_Rep1, _Period1>, duration<_Rep2, _Period2>>;
	return (_CT(_Left).count() == _CT(_Right).count());
	}

template<class _Rep1,
	class _Period1,
	class _Rep2,
	class _Period2>
	 constexpr bool operator!=(
		const duration<_Rep1, _Period1>& _Left,
		const duration<_Rep2, _Period2>& _Right)
	{	// test if duration != duration
	return (!(_Left == _Right));
	}

template<class _Rep1,
	class _Period1,
	class _Rep2,
	class _Period2>
	 constexpr bool operator<(
		const duration<_Rep1, _Period1>& _Left,
		const duration<_Rep2, _Period2>& _Right)
	{	// test if duration < duration
	using _CT = common_type_t<duration<_Rep1, _Period1>, duration<_Rep2, _Period2>>;
	return (_CT(_Left).count() < _CT(_Right).count());
	}

template<class _Rep1,
	class _Period1,
	class _Rep2,
	class _Period2>
	 constexpr bool operator<=(
		const duration<_Rep1, _Period1>& _Left,
		const duration<_Rep2, _Period2>& _Right)
	{	// test if duration <= duration
	return (!(_Right < _Left));
	}

template<class _Rep1,
	class _Period1,
	class _Rep2,
	class _Period2>
	 constexpr bool operator>(
		const duration<_Rep1, _Period1>& _Left,
		const duration<_Rep2, _Period2>& _Right)
	{	// test if duration > duration
	return (_Right < _Left);
	}

template<class _Rep1,
	class _Period1,
	class _Rep2,
	class _Period2>
	 constexpr bool operator>=(
		const duration<_Rep1, _Period1>& _Left,
		const duration<_Rep2, _Period2>& _Right)
	{	// test if duration >= duration
	return (!(_Left < _Right));
	}

	// FUNCTION TEMPLATE duration_cast
template<class _To,
	class _Rep,
	class _Period,
	class _Enabled>
	 constexpr _To duration_cast(const duration<_Rep, _Period>& _Dur)
	{	// convert duration to another duration; truncate
	using _CF = ratio_divide<_Period, typename _To::period>;

	using _ToRep = typename _To::rep;
	using _CR = common_type_t<_ToRep, _Rep, intmax_t>;

#pragma warning(push)
#pragma warning(disable: 6326)	
	return (_CF::num == 1 && _CF::den == 1
			? static_cast<_To>(static_cast<_ToRep>(_Dur.count()))
		: _CF::num != 1 && _CF::den == 1
			? static_cast<_To>(static_cast<_ToRep>(
				static_cast<_CR>(
					_Dur.count()) * static_cast<_CR>(_CF::num)))
		: _CF::num == 1 && _CF::den != 1
			? static_cast<_To>(static_cast<_ToRep>(
				static_cast<_CR>(_Dur.count())
					/ static_cast<_CR>(_CF::den)))
		: static_cast<_To>(static_cast<_ToRep>(
			static_cast<_CR>(_Dur.count()) * static_cast<_CR>(_CF::num)
				/ static_cast<_CR>(_CF::den))));
#pragma warning(pop)
	}

	// FUNCTION TEMPLATE floor
template<class _To,
	class _Rep,
	class _Period,
	class = enable_if_t<_Is_duration_v<_To>>>
	 constexpr _To floor(const duration<_Rep, _Period>& _Dur)
	{	// convert duration to another duration; round towards negative infinity
		// i.e. the greatest integral result such that the result <= _Dur
	const _To _Casted{chrono::duration_cast<_To>(_Dur)};
	if (_Casted > _Dur)
		{
		return (_To{_Casted.count() - static_cast<typename _To::rep>(1)});
		}

	return (_Casted);
	}

	// FUNCTION TEMPLATE ceil
template<class _To,
	class _Rep,
	class _Period,
	class = enable_if_t<_Is_duration_v<_To>>>
	 constexpr _To ceil(const duration<_Rep, _Period>& _Dur)
	{	// convert duration to another duration; round towards positive infinity
		// i.e. the least integral result such that _Dur <= the result
	const _To _Casted{chrono::duration_cast<_To>(_Dur)};
	if (_Casted < _Dur)
		{
		return (_To{_Casted.count() + static_cast<typename _To::rep>(1)});
		}

	return (_Casted);
	}

	// FUNCTION TEMPLATE round
template<class _Rep>
	constexpr bool _Is_even(_Rep _Val)
	{	// Tests whether _Val is even
	return (_Val % 2 == 0);
	}

template<class _To,
	class _Rep,
	class _Period,
	class = enable_if_t<_Is_duration_v<_To>
		&& !treat_as_floating_point_v<typename _To::rep>>>
	 constexpr _To round(const duration<_Rep, _Period>& _Dur)
	{	// convert duration to another duration, round to nearest, ties to even
	const _To _Floored{chrono::floor<_To>(_Dur)};
	const _To _Ceiled{_Floored + _To{1}};
	const auto _Floor_adjustment = _Dur - _Floored;
	const auto _Ceil_adjustment = _Ceiled - _Dur;
	if (_Floor_adjustment < _Ceil_adjustment
		|| (_Floor_adjustment == _Ceil_adjustment && _Is_even(_Floored.count())))
		{
		return (_Floored);
		}

	return (_Ceiled);
	}

	// FUNCTION TEMPLATE abs
template<class _Rep,
	class _Period,
	class = enable_if_t<numeric_limits<_Rep>::is_signed>>
	 constexpr duration<_Rep, _Period> abs(const duration<_Rep, _Period> _Dur)
	{	// create a duration with count() the absolute value of _Dur.count()
	return (_Dur < duration<_Rep, _Period>::zero()
		? duration<_Rep, _Period>::zero() - _Dur
		: _Dur);
	}

	// duration TYPES
using nanoseconds = duration<long long, nano>;
using microseconds = duration<long long, micro>;
using milliseconds = duration<long long, milli>;
using seconds = duration<long long>;
using minutes = duration<int, ratio<60>>;
using hours = duration<int, ratio<3600>>;

	// time_point ARITHMETIC
template<class _Clock,
	class _Duration,
	class _Rep,
	class _Period>
	 constexpr time_point<_Clock,
		common_type_t<_Duration, duration<_Rep, _Period>>>
		operator+(
			const time_point<_Clock, _Duration>& _Left,
			const duration<_Rep, _Period>& _Right)
	{	// add duration to time_point
	using _RT = time_point<_Clock, common_type_t<_Duration, duration<_Rep, _Period>>>;
	return (_RT(_Left.time_since_epoch() + _Right));
	}

template<class _Rep,
	class _Period,
	class _Clock,
	class _Duration>
	 constexpr time_point<_Clock,
		common_type_t<duration<_Rep, _Period>, _Duration>>
		operator+(
			const duration<_Rep, _Period>& _Left,
			const time_point<_Clock, _Duration>& _Right)
	{	// add time_point to duration
	return (_Right + _Left);
	}

template<class _Clock,
	class _Duration,
	class _Rep,
	class _Period>
	 constexpr time_point<_Clock,
		common_type_t<_Duration, duration<_Rep, _Period>>>
		operator-(
			const time_point<_Clock, _Duration>& _Left,
			const duration<_Rep, _Period>& _Right)
	{	// subtract duration from time_point
	using _RT = time_point<_Clock, common_type_t<_Duration, duration<_Rep, _Period>>>;
	return (_RT(_Left.time_since_epoch() - _Right));
	}

template<class _Clock,
	class _Duration1,
	class _Duration2>
	 constexpr common_type_t<_Duration1, _Duration2>
		operator-(
			const time_point<_Clock, _Duration1>& _Left,
			const time_point<_Clock, _Duration2>& _Right)
	{	// add time_point to time_point
	return (_Left.time_since_epoch() - _Right.time_since_epoch());
	}

	// time_point COMPARISONS
template<class _Clock,
	class _Duration1,
	class _Duration2>
	 constexpr bool operator==(
		const time_point<_Clock, _Duration1>& _Left,
		const time_point<_Clock, _Duration2>& _Right)
	{	// test for time_point == time_point
	return (_Left.time_since_epoch() == _Right.time_since_epoch());
	}

template<class _Clock,
	class _Duration1,
	class _Duration2>
	 constexpr bool operator!=(
		const time_point<_Clock, _Duration1>& _Left,
		const time_point<_Clock, _Duration2>& _Right)
	{	// test for time_point != time_point
	return (!(_Left == _Right));
	}

template<class _Clock,
	class _Duration1,
	class _Duration2>
	 constexpr bool operator<(
		const time_point<_Clock, _Duration1>& _Left,
		const time_point<_Clock, _Duration2>& _Right)
	{	// test for time_point < time_point
	return (_Left.time_since_epoch() < _Right.time_since_epoch());
	}

template<class _Clock,
	class _Duration1,
	class _Duration2>
	 constexpr bool operator<=(
		const time_point<_Clock, _Duration1>& _Left,
		const time_point<_Clock, _Duration2>& _Right)
	{	// test for time_point <= time_point
	return (!(_Right < _Left));
	}

template<class _Clock,
	class _Duration1,
	class _Duration2>
	 constexpr bool operator>(
		const time_point<_Clock, _Duration1>& _Left,
		const time_point<_Clock, _Duration2>& _Right)
	{	// test for time_point > time_point
	return (_Right < _Left);
	}

template<class _Clock,
	class _Duration1,
	class _Duration2>
	 constexpr bool operator>=(
		const time_point<_Clock, _Duration1>& _Left,
		const time_point<_Clock, _Duration2>& _Right)
	{	// test for time_point >= time_point
	return (!(_Left < _Right));
	}

	// FUNCTION TEMPLATE time_point_cast
template<class _To,
	class _Clock,
	class _Duration,
	class = enable_if_t<_Is_duration_v<_To>>>
	 constexpr time_point<_Clock, _To> time_point_cast(const time_point<_Clock, _Duration>& _Time)
	{	// change the duration type of a time_point; truncate
	return (time_point<_Clock, _To>(
		chrono::duration_cast<_To>(_Time.time_since_epoch())));
	}

	// FUNCTION TEMPLATE floor (for time_point instances)
template<class _To,
	class _Clock,
	class _Duration,
	class = enable_if_t<_Is_duration_v<_To>>>
	 constexpr time_point<_Clock, _To> floor(const time_point<_Clock, _Duration>& _Time)
	{	// change the duration type of a time_point; round towards negative infinity
	return (time_point<_Clock, _To>(
		chrono::floor<_To>(_Time.time_since_epoch())));
	}

	// FUNCTION TEMPLATE ceil (for time_point instances)
template<class _To,
	class _Clock,
	class _Duration,
	class = enable_if_t<_Is_duration_v<_To>>>
	 constexpr time_point<_Clock, _To> ceil(const time_point<_Clock, _Duration>& _Time)
	{	// change the duration type of a time_point; round towards positive infinity
	return (time_point<_Clock, _To>(
		chrono::ceil<_To>(_Time.time_since_epoch())));
	}

	// FUNCTION TEMPLATE round (for time_point instances)
template<class _To,
	class _Clock,
	class _Duration,
	class = enable_if_t<_Is_duration_v<_To>
		&& !treat_as_floating_point_v<typename _To::rep>>>
	 constexpr time_point<_Clock, _To> round(const time_point<_Clock, _Duration>& _Time)
	{	// change the duration type of a time_point; round to nearest, ties to even
	return (time_point<_Clock, _To>(
		chrono::round<_To>(_Time.time_since_epoch())));
	}

	// CLOCKS
struct system_clock
	{	// wraps GetSystemTimePreciseAsFileTime/GetSystemTimeAsFileTime
	using rep = long long;

	using period = ratio_multiply<ratio<100, 1>, nano>;

	using duration = chrono::duration<rep, period>;
	using time_point = chrono::time_point<system_clock>;
	static constexpr bool is_steady = false;

	 static time_point now() noexcept
		{	// get current time
		return (time_point(duration(_Xtime_get_ticks())));
		}

	 static __time64_t to_time_t(const time_point& _Time) noexcept
		{	// convert to __time64_t
		return ((__time64_t)(_Time.time_since_epoch().count()
			/ 10000000LL));
		}

	 static time_point from_time_t(__time64_t _Tm) noexcept
		{	// convert from __time64_t
		return (time_point(duration(_Tm * 10000000LL)));
		}
	};

struct steady_clock
	{	// wraps QueryPerformanceCounter
	using rep = long long;
	using period = nano;
	using duration = nanoseconds;
	using time_point = chrono::time_point<steady_clock>;
	static constexpr bool is_steady = true;

	 static time_point now() noexcept
		{	// get current time
		const long long _Freq = _Query_perf_frequency();	// doesn't change after system boot
		const long long _Ctr = _Query_perf_counter();
		static_assert(period::num == 1, "This assumes period::num == 1.");
		const long long _Whole = (_Ctr / _Freq) * period::den;
		const long long _Part = (_Ctr % _Freq) * period::den / _Freq;
		return (time_point(duration(_Whole + _Part)));
		}
	};

using high_resolution_clock = steady_clock;
}	// namespace chrono

	// HELPERS
template<class _Rep,
	class _Period> inline
	xtime _To_xtime(const chrono::duration<_Rep, _Period>& _Rel_time)
	{	// convert duration to xtime
	xtime _Xt;
	if (_Rel_time <= chrono::duration<_Rep, _Period>::zero())
		{	// negative or zero relative time, return zero
		_Xt.sec = 0;
		_Xt.nsec = 0;
		}
	else
		{	// positive relative time, convert
		chrono::nanoseconds _T0 =
			chrono::system_clock::now().time_since_epoch();
		_T0 += chrono::duration_cast<chrono::nanoseconds>(_Rel_time);
		_Xt.sec = chrono::duration_cast<chrono::seconds>(_T0).count();
		_T0 -= chrono::seconds(_Xt.sec);
		_Xt.nsec = (long)_T0.count();
		}
	return (_Xt);
	}

	// duration LITERALS
inline namespace literals {
inline namespace chrono_literals {
 constexpr chrono::hours operator "" h(unsigned long long _Val)
	{	// return integral hours
	return (chrono::hours(_Val));
	}

 constexpr chrono::duration<double, ratio<3600>> operator "" h(
	long double _Val)
	{	// return floating-point hours
	return (chrono::duration<double, ratio<3600>>(_Val));
	}

 constexpr chrono::minutes (operator "" min)(unsigned long long _Val)
	{	// return integral minutes
	return (chrono::minutes(_Val));
	}

 constexpr chrono::duration<double, ratio<60>> (operator "" min)(
	long double _Val)
	{	// return floating-point minutes
	return (chrono::duration<double, ratio<60>>(_Val));
	}

 constexpr chrono::seconds operator "" s(unsigned long long _Val)
	{	// return integral seconds
	return (chrono::seconds(_Val));
	}

 constexpr chrono::duration<double> operator "" s(long double _Val)
	{	// return floating-point seconds
	return (chrono::duration<double>(_Val));
	}

 constexpr chrono::milliseconds operator "" ms(unsigned long long _Val)
	{	// return integral milliseconds
	return (chrono::milliseconds(_Val));
	}

 constexpr chrono::duration<double, milli> operator "" ms(
	long double _Val)
	{	// return floating-point milliseconds
	return (chrono::duration<double, milli>(_Val));
	}

 constexpr chrono::microseconds operator "" us(unsigned long long _Val)
	{	// return integral microseconds
	return (chrono::microseconds(_Val));
	}

 constexpr chrono::duration<double, micro> operator "" us(
	long double _Val)
	{	// return floating-point microseconds
	return (chrono::duration<double, micro>(_Val));
	}

 constexpr chrono::nanoseconds operator "" ns(unsigned long long _Val)
	{	// return integral nanoseconds
	return (chrono::nanoseconds(_Val));
	}

 constexpr chrono::duration<double, nano> operator "" ns(
	long double _Val)
	{	// return floating-point nanoseconds
	return (chrono::duration<double, nano>(_Val));
	}
}	// inline namespace chrono_literals
}	// inline namespace literals

namespace chrono {
	using namespace literals::chrono_literals;
}	// namespace chrono

}
 
 
 #pragma warning(pop)
 #pragma pack(pop)



/*
 * Copyright (c) by P.J. Plauger. All rights reserved.
 * Consult your license regarding permissions and restrictions.
V6.50:0009 */


// functional standard header
#pragma once





// tuple standard header
#pragma once







 #pragma pack(push,8)
 #pragma warning(push,3)
 #pragma warning(disable: 4455 4494  4619 4643 4702 4984 4988 )
 
 
 

namespace std {
	// STRUCT TEMPLATE _Tuple_implicit_val
template<bool _Same,
	class _Dest,
	class... _Srcs>
	struct _Tuple_implicit_val0
		: false_type
	{	// Constrain tuple's implicit constructors
	};

template<class... _Dests,
	class... _Srcs>
	struct _Tuple_implicit_val0<true, tuple<_Dests...>, _Srcs...>
		: bool_constant<conjunction_v<
			is_constructible<_Dests, _Srcs>...,
			is_convertible<_Srcs, _Dests>...
		>>
	{	// Constrain tuple's implicit constructors
	};

template<class _Dest,
	class... _Srcs>
	struct _Tuple_implicit_val
		: _Tuple_implicit_val0<tuple_size_v<_Dest> == sizeof...(_Srcs), _Dest, _Srcs...>::type
	{	// Constrain tuple's implicit constructors
	};

	// STRUCT TEMPLATE _Tuple_explicit_val
template<bool _Same,
	class _Dest,
	class... _Srcs>
	struct _Tuple_explicit_val0
		: false_type
	{	// Constrain tuple's explicit constructors
	};

template<class... _Dests,
	class... _Srcs>
	struct _Tuple_explicit_val0<true, tuple<_Dests...>, _Srcs...>
		: bool_constant<conjunction_v<
			is_constructible<_Dests, _Srcs>...,
			negation<conjunction<is_convertible<_Srcs, _Dests>...>>
		>>
	{	// Constrain tuple's explicit constructors
	};

template<class _Dest,
	class... _Srcs>
	struct _Tuple_explicit_val
		: _Tuple_explicit_val0<tuple_size_v<_Dest> == sizeof...(_Srcs), _Dest, _Srcs...>::type
	{	// Constrain tuple's explicit constructors
	};

	// VARIABLE TEMPLATE _Tuple_constructible_v
template<bool _Same,
	class _Dest,
	class... _Srcs>
	struct _Tuple_constructible_val0
		: false_type
	{
	};

template<class... _Dests,
	class... _Srcs>
	struct _Tuple_constructible_val0<true, tuple<_Dests...>, _Srcs...>
		: bool_constant<conjunction_v<is_constructible<_Dests, _Srcs>...>>
	{
	};

template<class _Dest,
	class... _Srcs>
	 constexpr bool _Tuple_constructible_v =
		_Tuple_constructible_val0<tuple_size_v<_Dest> == sizeof...(_Srcs), _Dest, _Srcs...>::value;

	// VARIABLE TEMPLATE _Tuple_nothrow_constructible_v
template<bool _Same,
	class _Dest,
	class... _Srcs>
	struct _Tuple_nothrow_constructible_val0
		: false_type
	{
	};

template<class... _Dests,
	class... _Srcs>
	struct _Tuple_nothrow_constructible_val0<true, tuple<_Dests...>, _Srcs...>
		: bool_constant<conjunction_v<is_nothrow_constructible<_Dests, _Srcs>...>>
	{
	};

template<class _Dest,
	class... _Srcs>
	 constexpr bool _Tuple_nothrow_constructible_v =
		_Tuple_nothrow_constructible_val0<tuple_size_v<_Dest> == sizeof...(_Srcs), _Dest, _Srcs...>::value;

	// VARIABLE TEMPLATE _Tuple_assignable_v
template<bool _Same,
	class _Dest,
	class... _Srcs>
	struct _Tuple_assignable_val0
		: false_type
	{
	};

template<class... _Dests,
	class... _Srcs>
	struct _Tuple_assignable_val0<true, tuple<_Dests...>, _Srcs...>
		: bool_constant<conjunction_v<is_assignable<_Dests&, _Srcs>...>>	// note _Dests& instead of _Dests
	{
	};

template<class _Dest,
	class... _Srcs>
	 constexpr bool _Tuple_assignable_v =
		_Tuple_assignable_val0<tuple_size_v<_Dest> == sizeof...(_Srcs), _Dest, _Srcs...>::value;

template<class _Dest,
	class... _Srcs>
	struct _Tuple_assignable_val
		: bool_constant<_Tuple_assignable_v<_Dest, _Srcs...>>
	{
	};

	// VARIABLE TEMPLATE _Tuple_nothrow_assignable_v
template<bool _Same,
	class _Dest,
	class... _Srcs>
	struct _Tuple_nothrow_assignable_val0
		: false_type
	{
	};

template<class... _Dests,
	class... _Srcs>
	struct _Tuple_nothrow_assignable_val0<true, tuple<_Dests...>, _Srcs...>
		: bool_constant<conjunction_v<is_nothrow_assignable<_Dests&, _Srcs>...>>	// note _Dests& instead of _Dests
	{
	};

template<class _Dest,
	class... _Srcs>
	 constexpr bool _Tuple_nothrow_assignable_v =
		_Tuple_nothrow_assignable_val0<tuple_size_v<_Dest> == sizeof...(_Srcs), _Dest, _Srcs...>::value;

	// STRUCT TEMPLATE _Tuple_convert_copy_val
template<class _Myself,
	class... _Other>
	struct _Tuple_convert_copy_val
		: true_type
	{	// Constrain tuple's converting copy constructor (LWG 2549)
	};

template<class _This,
	class _Uty>
	struct _Tuple_convert_copy_val<tuple<_This>, _Uty>
		: bool_constant<!disjunction_v<
			is_same<_This, _Uty>,
			is_constructible<_This, const tuple<_Uty>&>,
			is_convertible<const tuple<_Uty>&, _This>>>
	{	// Constrain tuple's converting copy constructor (LWG 2549)
	};

	// STRUCT TEMPLATE _Tuple_convert_move_val
template<class _Myself,
	class... _Other>
	struct _Tuple_convert_move_val
		: true_type
	{	// Constrain tuple's converting move constructor (LWG 2549)
	};

template<class _This,
	class _Uty>
	struct _Tuple_convert_move_val<tuple<_This>, _Uty>
		: bool_constant<!disjunction_v<
			is_same<_This, _Uty>,
			is_constructible<_This, tuple<_Uty>>,
			is_convertible<tuple<_Uty>, _This>>>
	{	// Constrain tuple's converting move constructor (LWG 2549)
	};

	// STRUCT TEMPLATE _Tuple_perfect_val
template<class _Myself,
	class _This2,
	class... _Rest2>
	struct _Tuple_perfect_val
		: true_type
	{	// Constrain tuple's perfect forwarding constructor (LWG issue not yet filed)
	};

template<class _Myself,
	class _This2>
	struct _Tuple_perfect_val<_Myself, _This2>
		: bool_constant<!is_same_v<_Myself, remove_const_t<remove_reference_t<_This2>>>>
	{	// Constrain tuple's perfect forwarding constructor (LWG issue not yet filed)
	};

	// STRUCT _Ignore
struct _Ignore
	{	// struct that ignores assignments
	template<class _Ty>
		constexpr const _Ignore& operator=(const _Ty&) const noexcept	// strengthened
		{	// do nothing
		return (*this);
		}
	};

 constexpr _Ignore ignore{};

	// STRUCT TEMPLATE _Tuple_val
template<class _Ty>
	struct _Tuple_val
	{	// stores each value in a tuple
	constexpr _Tuple_val()
		: _Val()
		{	// default construct
		}

	template<class _Other>
		constexpr _Tuple_val(_Other&& _Arg)
		: _Val(::std:: forward<_Other>(_Arg))
		{	// construct with argument
		}

	template<class _Alloc,
		class... _Other,
		enable_if_t<!uses_allocator_v<_Ty, _Alloc>, int> = 0>
		_Tuple_val(const _Alloc&, allocator_arg_t, _Other&&... _Arg)
		: _Val(::std:: forward<_Other>(_Arg)...)
		{	// construct with optional arguments, no allocator
		}

	template<class _Alloc,
		class... _Other,
		enable_if_t<conjunction_v<
			uses_allocator<_Ty, _Alloc>,
			is_constructible<_Ty, allocator_arg_t, const _Alloc&, _Other...>
		>, int> = 0>
		_Tuple_val(const _Alloc& _Al, allocator_arg_t, _Other&&... _Arg)
		: _Val(allocator_arg, _Al, ::std:: forward<_Other>(_Arg)...)
		{	// construct with optional arguments, leading allocator
		}

	template<class _Alloc,
		class... _Other,
		enable_if_t<conjunction_v<
			uses_allocator<_Ty, _Alloc>,
			negation<is_constructible<_Ty, allocator_arg_t, const _Alloc&, _Other...>>
		>, int> = 0>
		_Tuple_val(const _Alloc& _Al, allocator_arg_t, _Other&&... _Arg)
		: _Val(::std:: forward<_Other>(_Arg)..., _Al)
		{	// construct with optional arguments, trailing allocator
		}

	_Ty _Val;
	};

	// CLASS TEMPLATE tuple
struct _Exact_args_t
	{	// tag type to disambiguate construction (from one arg per element)
	};

struct _Unpack_tuple_t
	{	// tag type to disambiguate construction (from unpacking a tuple/pair)
	};

struct _Alloc_exact_args_t
	{	// tag type to disambiguate construction (from an allocator and one arg per element)
	};

struct _Alloc_unpack_tuple_t
	{	// tag type to disambiguate construction (from an allocator and unpacking a tuple/pair)
	};

template<class... _Types>
	class tuple;

template<>
	class tuple<>
	{	// empty tuple
public:
	constexpr tuple() noexcept
		{	// default construct
		}

	constexpr tuple(const tuple&) noexcept	// TRANSITION, for binary compatibility
		{	// copy construct
		}

	template<class _Alloc>
		tuple(allocator_arg_t, const _Alloc&) noexcept
		{	// default construct, allocator
		}

	template<class _Alloc>
		tuple(allocator_arg_t, const _Alloc&, const tuple&) noexcept
		{	// copy construct, allocator
		}

	template<class _Tag,
		enable_if_t<is_same_v<_Tag, _Exact_args_t>, int> = 0>
		constexpr tuple(_Tag) noexcept
		{	// construct from one arg per element
		}

	template<class _Tag,
		class _Alloc,
		enable_if_t<is_same_v<_Tag, _Alloc_exact_args_t>, int> = 0>
		tuple(_Tag, const _Alloc&) noexcept
		{	// construct from an allocator and one arg per element
		}

	void swap(tuple&) noexcept
		{	// swap elements
		}

	constexpr bool _Equals(const tuple&) const noexcept
		{	// test if *this == _Right
		return (true);
		}

	constexpr bool _Less(const tuple&) const noexcept
		{	// test if *this < _Right
		return (false);
		}
	};

template<class _This,
	class... _Rest>
	class tuple<_This, _Rest...>
		: private tuple<_Rest...>
	{	// recursive tuple definition
public:
	typedef _This _This_type;
	typedef tuple<_Rest...> _Mybase;

	template<class _Tag,
		class _This2,
		class... _Rest2,
		enable_if_t<is_same_v<_Tag, _Exact_args_t>, int> = 0>
		constexpr tuple(_Tag, _This2&& _This_arg, _Rest2&&... _Rest_arg)
		: _Mybase(_Exact_args_t{}, ::std:: forward<_Rest2>(_Rest_arg)...),
			_Myfirst(::std:: forward<_This2>(_This_arg))
		{	// construct from one arg per element
		}

	template<class _Tag,
		class _Tpl,
		size_t... _Indices,
		enable_if_t<is_same_v<_Tag, _Unpack_tuple_t>, int> = 0>
		constexpr tuple(_Tag, _Tpl&& _Right, index_sequence<_Indices...>);

	template<class _Tag,
		class _Tpl,
		enable_if_t<is_same_v<_Tag, _Unpack_tuple_t>, int> = 0>
		constexpr tuple(_Tag, _Tpl&& _Right)
		: tuple(_Unpack_tuple_t{}, ::std:: forward<_Tpl>(_Right),
			make_index_sequence<tuple_size_v<remove_reference_t<_Tpl>>>{})
		{	// construct from unpacking a tuple/pair
		}

	template<class _Tag,
		class _Alloc,
		class _This2,
		class... _Rest2,
		enable_if_t<is_same_v<_Tag, _Alloc_exact_args_t>, int> = 0>
		tuple(_Tag, const _Alloc& _Al, _This2&& _This_arg, _Rest2&&... _Rest_arg)
		: _Mybase(_Alloc_exact_args_t{}, _Al, ::std:: forward<_Rest2>(_Rest_arg)...),
			_Myfirst(_Al, allocator_arg, ::std:: forward<_This2>(_This_arg))
		{	// construct from an allocator and one arg per element
		}

	template<class _Tag,
		class _Alloc,
		class _Tpl,
		size_t... _Indices,
		enable_if_t<is_same_v<_Tag, _Alloc_unpack_tuple_t>, int> = 0> inline
		tuple(_Tag, const _Alloc& _Al, _Tpl&& _Right, index_sequence<_Indices...>);

	template<class _Tag,
		class _Alloc,
		class _Tpl,
		enable_if_t<is_same_v<_Tag, _Alloc_unpack_tuple_t>, int> = 0>
		tuple(_Tag, const _Alloc& _Al, _Tpl&& _Right)
		: tuple(_Alloc_unpack_tuple_t{}, _Al, ::std:: forward<_Tpl>(_Right),
			make_index_sequence<tuple_size_v<remove_reference_t<_Tpl>>>{})
		{	// construct from an allocator and unpacking a tuple/pair
		}

	template<class _This2 = _This,
		enable_if_t<conjunction_v<
			is_default_constructible<_This2>,
			is_default_constructible<_Rest>...,
			_Is_implicitly_default_constructible<_This2>,
			_Is_implicitly_default_constructible<_Rest>...
		>, int> = 0>
		constexpr tuple()
			noexcept(conjunction_v< is_nothrow_default_constructible<_This2>, is_nothrow_default_constructible<_Rest>... >)	// strengthened
		: _Mybase(), _Myfirst()
		{
		}

	template<class _This2 = _This,
		enable_if_t<conjunction_v<
			is_default_constructible<_This2>,
			is_default_constructible<_Rest>...,
			negation<conjunction<
				_Is_implicitly_default_constructible<_This2>,
				_Is_implicitly_default_constructible<_Rest>...
		>>>, int> = 0>
		constexpr explicit tuple()
			noexcept(conjunction_v< is_nothrow_default_constructible<_This2>, is_nothrow_default_constructible<_Rest>... >)	// strengthened
		: _Mybase(), _Myfirst()
		{
		}

	template<class _This2 = _This,
		enable_if_t<_Tuple_implicit_val<tuple, const _This2&, const _Rest&...>::value, int> = 0>
		constexpr tuple(const _This& _This_arg, const _Rest&... _Rest_arg)
			noexcept(conjunction_v< is_nothrow_copy_constructible<_This2>, is_nothrow_copy_constructible<_Rest>... >)	// strengthened
			: tuple(_Exact_args_t{}, _This_arg, _Rest_arg...)
		{
		}

	template<class _This2 = _This,
		enable_if_t<_Tuple_explicit_val<tuple, const _This2&, const _Rest&...>::value, int> = 0>
		constexpr explicit tuple(const _This& _This_arg, const _Rest&... _Rest_arg)
			noexcept(conjunction_v< is_nothrow_copy_constructible<_This2>, is_nothrow_copy_constructible<_Rest>... >)	// strengthened
			: tuple(_Exact_args_t{}, _This_arg, _Rest_arg...)
		{
		}

	template<class _This2,
		class... _Rest2,
		enable_if_t<conjunction_v<
			_Tuple_perfect_val<tuple, _This2, _Rest2...>,
			_Tuple_implicit_val<tuple, _This2, _Rest2...>
		>, int> = 0>
		constexpr tuple(_This2&& _This_arg, _Rest2&&... _Rest_arg)
			noexcept(_Tuple_nothrow_constructible_v<tuple, _This2, _Rest2...>)	// strengthened
			: tuple(_Exact_args_t{}, ::std:: forward<_This2>(_This_arg), ::std:: forward<_Rest2>(_Rest_arg)...)
		{
		}

	template<class _This2,
		class... _Rest2,
		enable_if_t<conjunction_v<
			_Tuple_perfect_val<tuple, _This2, _Rest2...>,
			_Tuple_explicit_val<tuple, _This2, _Rest2...>
		>, int> = 0>
		constexpr explicit tuple(_This2&& _This_arg, _Rest2&&... _Rest_arg)
			noexcept(_Tuple_nothrow_constructible_v<tuple, _This2, _Rest2...>)	// strengthened
			: tuple(_Exact_args_t{}, ::std:: forward<_This2>(_This_arg), ::std:: forward<_Rest2>(_Rest_arg)...)
		{
		}

	tuple(const tuple&) = default;
	tuple(tuple&&) = default;

	template<class... _Other,
		enable_if_t<conjunction_v<
			_Tuple_implicit_val<tuple, const _Other&...>,
			_Tuple_convert_copy_val<tuple, _Other...>
		>, int> = 0>
		constexpr tuple(const tuple<_Other...>& _Right)
			noexcept(_Tuple_nothrow_constructible_v<tuple, const _Other&...>)	// strengthened
			: tuple(_Unpack_tuple_t{}, _Right)
		{
		}

	template<class... _Other,
		enable_if_t<conjunction_v<
			_Tuple_explicit_val<tuple, const _Other&...>,
			_Tuple_convert_copy_val<tuple, _Other...>
		>, int> = 0>
		constexpr explicit tuple(const tuple<_Other...>& _Right)
			noexcept(_Tuple_nothrow_constructible_v<tuple, const _Other&...>)	// strengthened
			: tuple(_Unpack_tuple_t{}, _Right)
		{
		}

	template<class... _Other,
		enable_if_t<conjunction_v<
			_Tuple_implicit_val<tuple, _Other...>,
			_Tuple_convert_move_val<tuple, _Other...>
		>, int> = 0>
		constexpr tuple(tuple<_Other...>&& _Right)
			noexcept(_Tuple_nothrow_constructible_v<tuple, _Other...>)	// strengthened
			: tuple(_Unpack_tuple_t{}, ::std:: move(_Right))
		{
		}

	template<class... _Other,
		enable_if_t<conjunction_v<
			_Tuple_explicit_val<tuple, _Other...>,
			_Tuple_convert_move_val<tuple, _Other...>
		>, int> = 0>
		constexpr explicit tuple(tuple<_Other...>&& _Right)
			noexcept(_Tuple_nothrow_constructible_v<tuple, _Other...>)	// strengthened
			: tuple(_Unpack_tuple_t{}, ::std:: move(_Right))
		{
		}

	template<class _First,
		class _Second,
		enable_if_t<_Tuple_implicit_val<tuple, const _First&, const _Second&>::value, int> = 0>
		constexpr tuple(const pair<_First, _Second>& _Right)
			noexcept(_Tuple_nothrow_constructible_v<tuple, const _First&, const _Second&>)	// strengthened
			: tuple(_Unpack_tuple_t{}, _Right)
		{
		}

	template<class _First,
		class _Second,
		enable_if_t<_Tuple_explicit_val<tuple, const _First&, const _Second&>::value, int> = 0>
		constexpr explicit tuple(const pair<_First, _Second>& _Right)
			noexcept(_Tuple_nothrow_constructible_v<tuple, const _First&, const _Second&>)	// strengthened
			: tuple(_Unpack_tuple_t{}, _Right)
		{
		}

	template<class _First,
		class _Second,
		enable_if_t<_Tuple_implicit_val<tuple, _First, _Second>::value, int> = 0>
		constexpr tuple(pair<_First, _Second>&& _Right)
			noexcept(_Tuple_nothrow_constructible_v<tuple, _First, _Second>)	// strengthened
			: tuple(_Unpack_tuple_t{}, ::std:: move(_Right))
		{
		}

	template<class _First,
		class _Second,
		enable_if_t<_Tuple_explicit_val<tuple, _First, _Second>::value, int> = 0>
		constexpr explicit tuple(pair<_First, _Second>&& _Right)
			noexcept(_Tuple_nothrow_constructible_v<tuple, _First, _Second>)	// strengthened
			: tuple(_Unpack_tuple_t{}, ::std:: move(_Right))
		{
		}

	template<class _Alloc,
		class _This2 = _This,
		enable_if_t<conjunction_v<
			is_default_constructible<_This2>,
			is_default_constructible<_Rest>...
		>, int> = 0>
		tuple(allocator_arg_t, const _Alloc& _Al)
		: _Mybase(allocator_arg, _Al), _Myfirst(_Al, allocator_arg)
		{
		}

	template<class _Alloc,
		class _This2 = _This,
		enable_if_t<_Tuple_implicit_val<tuple, const _This2&, const _Rest&...>::value, int> = 0>
		tuple(allocator_arg_t, const _Alloc& _Al,
			const _This& _This_arg, const _Rest&... _Rest_arg)
		: tuple(_Alloc_exact_args_t{}, _Al, _This_arg, _Rest_arg...)
		{
		}

	template<class _Alloc,
		class _This2 = _This,
		enable_if_t<_Tuple_explicit_val<tuple, const _This2&, const _Rest&...>::value, int> = 0>
		explicit tuple(allocator_arg_t, const _Alloc& _Al,
			const _This& _This_arg, const _Rest&... _Rest_arg)
		: tuple(_Alloc_exact_args_t{}, _Al, _This_arg, _Rest_arg...)
		{
		}

	template<class _Alloc,
		class _This2,
		class... _Rest2,
		enable_if_t<conjunction_v<
			_Tuple_perfect_val<tuple, _This2, _Rest2...>,
			_Tuple_implicit_val<tuple, _This2, _Rest2...>
		>, int> = 0>
		tuple(allocator_arg_t, const _Alloc& _Al,
			_This2&& _This_arg, _Rest2&&... _Rest_arg)
		: tuple(_Alloc_exact_args_t{}, _Al, ::std:: forward<_This2>(_This_arg), ::std:: forward<_Rest2>(_Rest_arg)...)
		{
		}

	template<class _Alloc,
		class _This2,
		class... _Rest2,
		enable_if_t<conjunction_v<
			_Tuple_perfect_val<tuple, _This2, _Rest2...>,
			_Tuple_explicit_val<tuple, _This2, _Rest2...>
		>, int> = 0>
		explicit tuple(allocator_arg_t, const _Alloc& _Al,
			_This2&& _This_arg, _Rest2&&... _Rest_arg)
		: tuple(_Alloc_exact_args_t{}, _Al, ::std:: forward<_This2>(_This_arg), ::std:: forward<_Rest2>(_Rest_arg)...)
		{
		}

	template<class _Alloc,
		class _This2 = _This,
		enable_if_t<_Tuple_constructible_v<tuple, const _This2&, const _Rest&...>, int> = 0>
		tuple(allocator_arg_t, const _Alloc& _Al,
			const tuple& _Right)
		: tuple(_Alloc_unpack_tuple_t{}, _Al, _Right)
		{
		}

	template<class _Alloc,
		class _This2 = _This,
		enable_if_t<_Tuple_constructible_v<tuple, _This2, _Rest...>, int> = 0>
		tuple(allocator_arg_t, const _Alloc& _Al,
			tuple&& _Right)
		: tuple(_Alloc_unpack_tuple_t{}, _Al, ::std:: move(_Right))
		{
		}

	template<class _Alloc,
		class... _Other,
		enable_if_t<conjunction_v<
			_Tuple_implicit_val<tuple, const _Other&...>,
			_Tuple_convert_copy_val<tuple, _Other...>
		>, int> = 0>
		tuple(allocator_arg_t, const _Alloc& _Al,
			const tuple<_Other...>& _Right)
		: tuple(_Alloc_unpack_tuple_t{}, _Al, _Right)
		{
		}

	template<class _Alloc,
		class... _Other,
		enable_if_t<conjunction_v<
			_Tuple_explicit_val<tuple, const _Other&...>,
			_Tuple_convert_copy_val<tuple, _Other...>
		>, int> = 0>
		explicit tuple(allocator_arg_t, const _Alloc& _Al,
			const tuple<_Other...>& _Right)
		: tuple(_Alloc_unpack_tuple_t{}, _Al, _Right)
		{
		}

	template<class _Alloc,
		class... _Other,
		enable_if_t<conjunction_v<
			_Tuple_implicit_val<tuple, _Other...>,
			_Tuple_convert_move_val<tuple, _Other...>
		>, int> = 0>
		tuple(allocator_arg_t, const _Alloc& _Al,
			tuple<_Other...>&& _Right)
		: tuple(_Alloc_unpack_tuple_t{}, _Al, ::std:: move(_Right))
		{
		}

	template<class _Alloc,
		class... _Other,
		enable_if_t<conjunction_v<
			_Tuple_explicit_val<tuple, _Other...>,
			_Tuple_convert_move_val<tuple, _Other...>
		>, int> = 0>
		explicit tuple(allocator_arg_t, const _Alloc& _Al,
			tuple<_Other...>&& _Right)
		: tuple(_Alloc_unpack_tuple_t{}, _Al, ::std:: move(_Right))
		{
		}

	template<class _Alloc,
		class _First,
		class _Second,
		enable_if_t<_Tuple_implicit_val<tuple, const _First&, const _Second&>::value, int> = 0>
		tuple(allocator_arg_t, const _Alloc& _Al,
			const pair<_First, _Second>& _Right)
		: tuple(_Alloc_unpack_tuple_t{}, _Al, _Right)
		{
		}

	template<class _Alloc,
		class _First,
		class _Second,
		enable_if_t<_Tuple_explicit_val<tuple, const _First&, const _Second&>::value, int> = 0>
		explicit tuple(allocator_arg_t, const _Alloc& _Al,
			const pair<_First, _Second>& _Right)
		: tuple(_Alloc_unpack_tuple_t{}, _Al, _Right)
		{
		}

	template<class _Alloc,
		class _First,
		class _Second,
		enable_if_t<_Tuple_implicit_val<tuple, _First, _Second>::value, int> = 0>
		tuple(allocator_arg_t, const _Alloc& _Al,
			pair<_First, _Second>&& _Right)
		: tuple(_Alloc_unpack_tuple_t{}, _Al, ::std:: move(_Right))
		{
		}

	template<class _Alloc,
		class _First,
		class _Second,
		enable_if_t<_Tuple_explicit_val<tuple, _First, _Second>::value, int> = 0>
		explicit tuple(allocator_arg_t, const _Alloc& _Al,
			pair<_First, _Second>&& _Right)
		: tuple(_Alloc_unpack_tuple_t{}, _Al, ::std:: move(_Right))
		{
		}

	tuple& operator=(const volatile tuple&) = delete;

	template<class _Myself = tuple,
		class _This2 = _This,
		enable_if_t<conjunction_v<
			is_copy_assignable<_This2>,
			is_copy_assignable<_Rest>...
		>, int> = 0>
		tuple& operator=(_Identity_t<const _Myself&> _Right)
			noexcept(conjunction_v< is_nothrow_copy_assignable<_This2>, is_nothrow_copy_assignable<_Rest>... >)	// strengthened
		{
		_Myfirst._Val = _Right._Myfirst._Val;
		_Get_rest() = _Right._Get_rest();
		return (*this);
		}

	template<class _Myself = tuple,
		class _This2 = _This,
		enable_if_t<conjunction_v<
			is_move_assignable<_This2>,
			is_move_assignable<_Rest>...
		>, int> = 0>
		tuple& operator=(_Identity_t<_Myself&&> _Right)
			noexcept(conjunction_v< is_nothrow_move_assignable<_This2>, is_nothrow_move_assignable<_Rest>... >)
		{
		_Myfirst._Val = ::std:: forward<_This>(_Right._Myfirst._Val);
		_Get_rest() = ::std:: forward<_Mybase>(_Right._Get_rest());
		return (*this);
		}

	template<class... _Other,
		enable_if_t<conjunction_v<
			negation<is_same<tuple, tuple<_Other...>>>,
			_Tuple_assignable_val<tuple, const _Other&...>
		>, int> = 0>
		tuple& operator=(const tuple<_Other...>& _Right)
			noexcept(_Tuple_nothrow_assignable_v<tuple, const _Other&...>)	// strengthened
		{
		_Myfirst._Val = _Right._Myfirst._Val;
		_Get_rest() = _Right._Get_rest();
		return (*this);
		}

	template<class... _Other,
		enable_if_t<conjunction_v<
			negation<is_same<tuple, tuple<_Other...>>>,
			_Tuple_assignable_val<tuple, _Other...>
		>, int> = 0>
		tuple& operator=(tuple<_Other...>&& _Right)
			noexcept(_Tuple_nothrow_assignable_v<tuple, _Other...>)	// strengthened
		{
		_Myfirst._Val = ::std:: forward<typename tuple<_Other...>::_This_type>(_Right._Myfirst._Val);
		_Get_rest() = ::std:: forward<typename tuple<_Other...>::_Mybase>(_Right._Get_rest());
		return (*this);
		}

	template<class _First,
		class _Second,
		enable_if_t<_Tuple_assignable_v<tuple, const _First&, const _Second&>, int> = 0>
		tuple& operator=(const pair<_First, _Second>& _Right)
			noexcept(_Tuple_nothrow_assignable_v<tuple, const _First&, const _Second&>)	// strengthened
		{
		_Myfirst._Val = _Right.first;
		_Get_rest()._Myfirst._Val = _Right.second;
		return (*this);
		}

	template<class _First,
		class _Second,
		enable_if_t<_Tuple_assignable_v<tuple, _First, _Second>, int> = 0>
		tuple& operator=(pair<_First, _Second>&& _Right)
			noexcept(_Tuple_nothrow_assignable_v<tuple, _First, _Second>)	// strengthened
		{
		_Myfirst._Val = ::std:: forward<_First>(_Right.first);
		_Get_rest()._Myfirst._Val = ::std:: forward<_Second>(_Right.second);
		return (*this);
		}

	void swap(tuple& _Right)
		noexcept(conjunction_v<_Is_nothrow_swappable<_This>, _Is_nothrow_swappable<_Rest>...>)
		{
		_Swap_adl(_Myfirst._Val, _Right._Myfirst._Val);
		_Mybase::swap(_Right._Get_rest());
		}

	_Mybase& _Get_rest() noexcept
		{	// get reference to rest of elements
		return (*this);
		}

	constexpr const _Mybase& _Get_rest() const noexcept
		{	// get const reference to rest of elements
		return (*this);
		}

	template<class... _Other>
		constexpr bool _Equals(const tuple<_Other...>& _Right) const
		{	// test if *this == _Right
		return (_Myfirst._Val == _Right._Myfirst._Val
			&& _Mybase::_Equals(_Right._Get_rest()));
		}

	template<class... _Other>
		constexpr bool _Less(const tuple<_Other...>& _Right) const
		{	// test if *this < _Right
		return (_Myfirst._Val < _Right._Myfirst._Val
			|| (!(_Right._Myfirst._Val < _Myfirst._Val)
				&& _Mybase::_Less(_Right._Get_rest())));
		}

	_Tuple_val<_This> _Myfirst;	// the stored element
	};























	// OPERATORS FOR tuple
template<class... _Types1,
	class... _Types2>
	 constexpr bool operator==(const tuple<_Types1...>& _Left, const tuple<_Types2...>& _Right)
	{	// test if _Left == _Right
	static_assert(sizeof...(_Types1) == sizeof...(_Types2), "cannot compare tuples of different sizes");
	return (_Left._Equals(_Right));
	}

template<class... _Types1,
	class... _Types2>
	 constexpr bool operator!=(const tuple<_Types1...>& _Left, const tuple<_Types2...>& _Right)
	{	// test if _Left != _Right
	return (!(_Left == _Right));
	}

template<class... _Types1,
	class... _Types2>
	 constexpr bool operator<(const tuple<_Types1...>& _Left, const tuple<_Types2...>& _Right)
	{	// test if _Left < _Right
	static_assert(sizeof...(_Types1) == sizeof...(_Types2), "cannot compare tuples of different sizes");
	return (_Left._Less(_Right));
	}

template<class... _Types1,
	class... _Types2>
	 constexpr bool operator>=(const tuple<_Types1...>& _Left, const tuple<_Types2...>& _Right)
	{	// test if _Left >= _Right
	return (!(_Left < _Right));
	}

template<class... _Types1,
	class... _Types2>
	 constexpr bool operator>(const tuple<_Types1...>& _Left, const tuple<_Types2...>& _Right)
	{	// test if _Left > _Right
	return (_Right < _Left);
	}

template<class... _Types1,
	class... _Types2>
	 constexpr bool operator<=(const tuple<_Types1...>& _Left, const tuple<_Types2...>& _Right)
	{	// test if _Left <= _Right
	return (!(_Right < _Left));
	}

template<class... _Types,
	enable_if_t<conjunction_v<_Is_swappable<_Types>...>, int> = 0> inline
	void swap(tuple<_Types...>& _Left, tuple<_Types...>& _Right)
		noexcept(noexcept(_Left.swap(_Right)))
	{	// swap _Left and _Right
	return (_Left.swap(_Right));
	}


	// CLASS _Tuple_element (find element by type)
template<class _Ty,
	class _Tuple>
	struct _Tuple_element;

template<class _This,
	class... _Rest>
	struct _Tuple_element<_This, tuple<_This, _Rest...>>
	{	// select first element
	typedef int _Check_type;
	static_assert(is_void_v<typename _Tuple_element<_This, tuple<_Rest...>>::_Check_type>,
		"duplicate type T in get<T>(tuple)");

	typedef _This type;
	typedef tuple<_This, _Rest...> _Ttype;
	};

template<class _Ty,
	class _This,
	class... _Rest>
	struct _Tuple_element<_Ty, tuple<_This, _Rest...>>
		: _Tuple_element<_Ty, tuple<_Rest...>>
	{	// recursive _Tuple_element definition
	};

template<class _Ty>
	struct _Tuple_element<_Ty, tuple<>>
	{	// backstop _Tuple_element definition
	typedef void _Check_type;	// proof that no duplicate type exists
	};

	// FUNCTION TEMPLATE get (by index)
template<size_t _Index,
	class... _Types>
	 constexpr tuple_element_t<_Index, tuple<_Types...>>&
		get(tuple<_Types...>& _Tuple) noexcept
	{	// get reference to _Index element of tuple
	typedef typename tuple_element<_Index, tuple<_Types...>>::_Ttype _Ttype;
	return (((_Ttype&)_Tuple)._Myfirst._Val);
	}

template<size_t _Index,
	class... _Types>
	 constexpr const tuple_element_t<_Index, tuple<_Types...>>&
		get(const tuple<_Types...>& _Tuple) noexcept
	{	// get const reference to _Index element of tuple
	typedef typename tuple_element<_Index, tuple<_Types...>>::_Ttype _Ttype;
	return (((_Ttype&)_Tuple)._Myfirst._Val);
	}

template<size_t _Index,
	class... _Types>
	 constexpr tuple_element_t<_Index, tuple<_Types...>>&&
		get(tuple<_Types...>&& _Tuple) noexcept
	{	// get rvalue reference to _Index element of tuple
	typedef typename tuple_element<_Index, tuple<_Types...>>::_Ttype _Ttype;
	typedef tuple_element_t<_Index, tuple<_Types...>>&& _RRtype;
	return (::std:: forward<_RRtype>(((_Ttype&)_Tuple)._Myfirst._Val));
	}

template<size_t _Index,
	class... _Types>
	 constexpr const tuple_element_t<_Index, tuple<_Types...>>&&
		get(const tuple<_Types...>&& _Tuple) noexcept
	{	// get const rvalue reference to _Index element of tuple
	typedef typename tuple_element<_Index, tuple<_Types...>>::_Ttype _Ttype;
	typedef const tuple_element_t<_Index, tuple<_Types...>>&& _RRtype;
	return (::std:: forward<_RRtype>(((_Ttype&)_Tuple)._Myfirst._Val));
	}

	// FUNCTION TEMPLATE get (by type)
template<class _Ty,
	class... _Types>
	 constexpr _Ty& get(tuple<_Types...>& _Tuple) noexcept
	{	// get reference to _Ty element of tuple
	typedef typename _Tuple_element<_Ty, tuple<_Types...>>::_Ttype _Ttype;
	return (((_Ttype&)_Tuple)._Myfirst._Val);
	}

template<class _Ty,
	class... _Types>
	 constexpr const _Ty& get(const tuple<_Types...>& _Tuple) noexcept
	{	// get const reference to _Ty element of tuple
	typedef typename _Tuple_element<_Ty, tuple<_Types...>>::_Ttype _Ttype;
	return (((_Ttype&)_Tuple)._Myfirst._Val);
	}

template<class _Ty,
	class... _Types>
	 constexpr _Ty&& get(tuple<_Types...>&& _Tuple) noexcept
	{	// get rvalue reference to _Ty element of tuple
	typedef typename _Tuple_element<_Ty, tuple<_Types...>>::_Ttype _Ttype;
	return (::std:: forward<_Ty&&>(((_Ttype&)_Tuple)._Myfirst._Val));
	}

template<class _Ty,
	class... _Types>
	 constexpr const _Ty&& get(const tuple<_Types...>&& _Tuple) noexcept
	{	// get const rvalue reference to _Ty element of tuple
	typedef typename _Tuple_element<_Ty, tuple<_Types...>>::_Ttype _Ttype;
	return (::std:: forward<const _Ty&&>(((_Ttype&)_Tuple)._Myfirst._Val));
	}

	// CONSTRUCTOR TEMPLATES FOR tuple
template<class _This,
	class... _Rest>
	template<class _Tag,
		class _Tpl,
		size_t... _Indices,
		enable_if_t<is_same_v<_Tag, _Unpack_tuple_t>, int>>
		constexpr tuple<_This, _Rest...>::tuple(_Tag, _Tpl&& _Right, index_sequence<_Indices...>)
		: tuple(_Exact_args_t{}, ::std:: get<_Indices>(::std:: forward<_Tpl>(_Right))...)
		{	// construct from unpacking a tuple/pair, using get<I>()
		}

template<class _This,
	class... _Rest>
	template<class _Tag,
		class _Alloc,
		class _Tpl,
		size_t... _Indices,
		enable_if_t<is_same_v<_Tag, _Alloc_unpack_tuple_t>, int>> inline
		tuple<_This, _Rest...>::tuple(_Tag, const _Alloc& _Al, _Tpl&& _Right, index_sequence<_Indices...>)
		: tuple(_Alloc_exact_args_t{}, _Al, ::std:: get<_Indices>(::std:: forward<_Tpl>(_Right))...)
		{	// construct from an allocator and unpacking a tuple/pair, using get<I>()
		}

	// FUNCTION TEMPLATE make_tuple
template<class... _Types>
	 constexpr tuple<_Unrefwrap_t<_Types>...>
		make_tuple(_Types&&... _Args)
	{	// make tuple from elements
	typedef tuple<_Unrefwrap_t<_Types>...> _Ttype;
	return (_Ttype(::std:: forward<_Types>(_Args)...));
	}

	// FUNCTION TEMPLATE tie
template<class... _Types>
	 constexpr tuple<_Types&...>
		tie(_Types&... _Args) noexcept
	{	// make tuple from elements
	typedef tuple<_Types&...> _Ttype;
	return (_Ttype(_Args...));
	}

	// FUNCTION TEMPLATE forward_as_tuple
template<class... _Types>
	 constexpr tuple<_Types&&...>
		forward_as_tuple(_Types&&... _Args) noexcept
	{	// forward arguments in a tuple
	return (tuple<_Types&&...>(::std:: forward<_Types>(_Args)...));
	}

	// STRUCT TEMPLATE _Cat_sequences
template<class _Seq_type1,
	class _Seq_type2>
	struct _Cat_sequences;

template<size_t... _Indexes1,
	size_t... _Indexes2>
	struct _Cat_sequences<index_sequence<_Indexes1...>,
		index_sequence<_Indexes2...>>
	{	// concatenates two index_sequence types
	typedef index_sequence<_Indexes1..., _Indexes2...> type;
	};

	// FORWARD DECLARATIONS
template<class _Ty,
	size_t _Size>
	class array;

template<size_t _Idx,
	class _Ty,
	size_t _Size>
	 constexpr _Ty& get(array<_Ty, _Size>& _Arr) noexcept;

template<size_t _Idx,
	class _Ty,
	size_t _Size>
	 constexpr const _Ty& get(const array<_Ty, _Size>& _Arr) noexcept;

template<size_t _Idx,
	class _Ty,
	size_t _Size>
	 constexpr _Ty&& get(array<_Ty, _Size>&& _Arr) noexcept;

template<size_t _Idx,
	class _Ty,
	size_t _Size>
	 constexpr const _Ty&& get(const array<_Ty, _Size>&& _Arr) noexcept;

	// STRUCT TEMPLATE _View_as_tuple
template<class _Ty,
	class... _For_array>
	struct _View_as_tuple
	{	// tuple_cat() supports only tuples, pairs, and arrays
	static_assert(_Always_false<_Ty>,
		"Unsupported tuple_cat arguments.");
	};

template<class... _Types>
	struct _View_as_tuple<tuple<_Types...>>
	{	// view a tuple as a tuple
	typedef tuple<_Types...> type;
	};

template<class _Ty1,
	class _Ty2>
	struct _View_as_tuple<pair<_Ty1, _Ty2>>
	{	// view a pair as a tuple
	typedef tuple<_Ty1, _Ty2> type;
	};

template<class _Ty,
	class... _Types>
	struct _View_as_tuple<array<_Ty, 0>, _Types...>
	{	// view an array as a tuple; ends recursion at 0
	typedef tuple<_Types...> type;
	};

template<class _Ty,
	size_t _Size,
	class... _Types>
	struct _View_as_tuple<array<_Ty, _Size>, _Types...>
		: _View_as_tuple<array<_Ty, _Size - 1>, _Ty, _Types...>
	{	// view an array as a tuple; counts down to 0
	};

	// STRUCT TEMPLATE _Repeat_for
template<size_t _Nx,
	class _Ty>
	struct _Repeat_for
		: integral_constant<size_t, _Nx>
	{	// repeats _Nx for each _Ty in a parameter pack
	};

	// FUNCTION TEMPLATE tuple_cat
template<class _Ret,
	class _Kx_arg,
	class _Ix_arg,
	size_t _Ix_next,
	class... _Tuples>
	struct _Tuple_cat2
	{	// determine tuple_cat's return type and _Kx/_Ix indices
	static_assert(sizeof...(_Tuples) == 0,
		"Unsupported tuple_cat arguments.");
	typedef _Ret type;
	typedef _Kx_arg _Kx_arg_seq;
	typedef _Ix_arg _Ix_arg_seq;
	};

template<class... _Types1,
	class _Kx_arg,
	size_t... _Ix,
	size_t _Ix_next,
	class... _Types2,
	class... _Rest>
	struct _Tuple_cat2<tuple<_Types1...>, _Kx_arg,
		index_sequence<_Ix...>, _Ix_next,
		tuple<_Types2...>, _Rest...>
		: _Tuple_cat2<
			tuple<_Types1..., _Types2...>,
			typename _Cat_sequences<_Kx_arg, index_sequence_for<_Types2...>>::type,
			index_sequence<_Ix..., _Repeat_for<_Ix_next, _Types2>::value...>,
			_Ix_next + 1,
			_Rest...>
	{	// determine tuple_cat's return type and _Kx/_Ix indices
	};

template<class... _Tuples>
	struct _Tuple_cat1
		: _Tuple_cat2<tuple<>, index_sequence<>,
				index_sequence<>, 0,
			typename _View_as_tuple<decay_t<_Tuples>>::type...>
	{	// prepare to determine tuple_cat's return type and _Kx/_Ix indices
	};

#pragma warning(push)
#pragma warning(disable: 4100)	
template<class _Ret,
	size_t... _Kx,
	size_t... _Ix,
	class _Ty>
	constexpr _Ret _Tuple_cat(index_sequence<_Kx...>,
		index_sequence<_Ix...>, _Ty&& _Arg)
	{	// concatenate tuples
	return (_Ret(::std:: get<_Kx>(::std:: get<_Ix>(::std:: forward<_Ty>(_Arg)))...));
	}
#pragma warning(pop)

template<class... _Tuples>
	 constexpr typename _Tuple_cat1<_Tuples...>::type
		tuple_cat(_Tuples&&... _Tpls)
	{	// concatenate tuples
	typedef _Tuple_cat1<_Tuples...> _Cat1;
	return (_Tuple_cat<typename _Cat1::type>(
		typename _Cat1::_Kx_arg_seq(), typename _Cat1::_Ix_arg_seq(),
		::std:: forward_as_tuple(::std:: forward<_Tuples>(_Tpls)...)));
	}











































	// FUNCTION TEMPLATE _For_each_tuple_element
template<class _Tpl,
	class _Fx,
	size_t... _Indices> inline
	void _For_each_tuple_element_impl(_Tpl&& _Tuple,
		_Fx _Func, index_sequence<_Indices...>)
	{	// call _Func() on the _Indices elements of _Tuple
	int _Ignored[] = { (static_cast<void>(_Func(
		::std:: get<_Indices>(::std:: forward<_Tpl>(_Tuple))
		)), 0)... };
	(void)_Ignored;
	}

template<class _Tpl,
	class _Fx> inline
	void _For_each_tuple_element(_Tpl&& _Tuple, _Fx _Func)
	{	// call _Func() on each element in _Tuple
	_For_each_tuple_element_impl(
		::std:: forward<_Tpl>(_Tuple),
		_Func,
		make_index_sequence<tuple_size_v<remove_reference_t<_Tpl>>>()
		);
	}


#pragma warning(push)
#pragma warning(disable: 4100)	
	// TEMPLATE CONSTRUCTOR pair::pair(tuple, tuple, sequence, sequence)
template<class _Ty1,
	class _Ty2>
	template<class _Tuple1,
		class _Tuple2,
		size_t... _Indexes1,
		size_t... _Indexes2> inline
		pair<_Ty1, _Ty2>::pair(_Tuple1& _Val1,
			_Tuple2& _Val2,
			index_sequence<_Indexes1...>,
			index_sequence<_Indexes2...>)
		: first(::std:: get<_Indexes1>(::std:: move(_Val1))...),
			second(::std:: get<_Indexes2>(::std:: move(_Val2))...)
		{	// construct from pair of tuples
		}
#pragma warning(pop)

	// TEMPLATE CONSTRUCTOR pair::pair(piecewise_construct_t, tuple, tuple)
template<class _Ty1,
	class _Ty2>
	template<class... _Types1,
		class... _Types2> inline
		pair<_Ty1, _Ty2>::pair(piecewise_construct_t,
			tuple<_Types1...> _Val1,
			tuple<_Types2...> _Val2)
		: pair(_Val1, _Val2,
			index_sequence_for<_Types1...>(),
			index_sequence_for<_Types2...>())
		{	// construct from pair of tuples
		}

	// STRUCT TEMPLATE uses_allocator
template<class... _Types,
	class _Alloc>
	struct uses_allocator<tuple<_Types...>, _Alloc>
		: true_type
	{	// true_type if container allocator enabled
	};


namespace [[deprecated("warning STL4002: " "The non-Standard std::tr1 namespace and TR1-only machinery are deprecated and will be REMOVED. You can " "define _SILENCE_TR1_NAMESPACE_DEPRECATION_WARNING to acknowledge that you have received this warning.")]] tr1 {
using ::std:: get;
using ::std:: ignore;
using ::std:: make_tuple;
using ::std:: ref;
using ::std:: tie;
using ::std:: tuple;
}


}

 
 
 #pragma warning(pop)
 #pragma pack(pop)



/*
 * Copyright (c) by P.J. Plauger. All rights reserved.
 * Consult your license regarding permissions and restrictions.
V6.50:0009 */









 #pragma pack(push,8)
 #pragma warning(push,3)
 #pragma warning(disable: 4455 4494  4619 4643 4702 4984 4988 )
 
 
 

namespace std {
		// STRUCT TEMPLATE plus
// defined in <xstddef>

		// STRUCT TEMPLATE minus
// defined in <xstddef>

		// STRUCT TEMPLATE multiplies
// defined in <xstddef>

		// STRUCT TEMPLATE divides
template<class _Ty = void>
	struct divides
	{	// functor for operator/
	 typedef _Ty first_argument_type;
	 typedef _Ty second_argument_type;
	 typedef _Ty result_type;

	constexpr _Ty operator()(const _Ty& _Left, const _Ty& _Right) const
		{	// apply operator/ to operands
		return (_Left / _Right);
		}
	};

		// STRUCT TEMPLATE modulus
template<class _Ty = void>
	struct modulus
	{	// functor for operator%
	 typedef _Ty first_argument_type;
	 typedef _Ty second_argument_type;
	 typedef _Ty result_type;

	constexpr _Ty operator()(const _Ty& _Left, const _Ty& _Right) const
		{	// apply operator% to operands
		return (_Left % _Right);
		}
	};

		// STRUCT TEMPLATE negate
template<class _Ty = void>
	struct negate
	{	// functor for unary operator-
	 typedef _Ty argument_type;
	 typedef _Ty result_type;

	constexpr _Ty operator()(const _Ty& _Left) const
		{	// apply operator- to operand
		return (-_Left);
		}
	};

		// STRUCT TEMPLATE equal_to
// defined in <xstddef>

		// STRUCT TEMPLATE not_equal_to
// defined in <xstddef>

		// STRUCT TEMPLATE greater
// defined in <xstddef>

		// STRUCT TEMPLATE less
// defined in <xstddef>

		// STRUCT TEMPLATE greater_equal
// defined in <xstddef>

		// STRUCT TEMPLATE less_equal
// defined in <xstddef>

		// STRUCT TEMPLATE logical_and
template<class _Ty = void>
	struct logical_and
	{	// functor for operator&&
	 typedef _Ty first_argument_type;
	 typedef _Ty second_argument_type;
	 typedef bool result_type;

	constexpr bool operator()(const _Ty& _Left, const _Ty& _Right) const
		{	// apply operator&& to operands
		return (_Left && _Right);
		}
	};

		// STRUCT TEMPLATE logical_or
template<class _Ty = void>
	struct logical_or
	{	// functor for operator||
	 typedef _Ty first_argument_type;
	 typedef _Ty second_argument_type;
	 typedef bool result_type;

	constexpr bool operator()(const _Ty& _Left, const _Ty& _Right) const
		{	// apply operator|| to operands
		return (_Left || _Right);
		}
	};

		// STRUCT TEMPLATE logical_not
template<class _Ty = void>
	struct logical_not
	{	// functor for unary operator!
	 typedef _Ty argument_type;
	 typedef bool result_type;

	constexpr bool operator()(const _Ty& _Left) const
		{	// apply operator! to operand
		return (!_Left);
		}
	};

		// STRUCT TEMPLATE bit_and
template<class _Ty = void>
	struct bit_and
	{	// functor for operator&
	 typedef _Ty first_argument_type;
	 typedef _Ty second_argument_type;
	 typedef _Ty result_type;

	constexpr _Ty operator()(const _Ty& _Left, const _Ty& _Right) const
		{	// apply operator& to operands
		return (_Left & _Right);
		}
	};

		// STRUCT TEMPLATE bit_or
template<class _Ty = void>
	struct bit_or
	{	// functor for operator|
	 typedef _Ty first_argument_type;
	 typedef _Ty second_argument_type;
	 typedef _Ty result_type;

	constexpr _Ty operator()(const _Ty& _Left, const _Ty& _Right) const
		{	// apply operator| to operands
		return (_Left | _Right);
		}
	};

		// STRUCT TEMPLATE bit_xor
template<class _Ty = void>
	struct bit_xor
	{	// functor for operator^
	 typedef _Ty first_argument_type;
	 typedef _Ty second_argument_type;
	 typedef _Ty result_type;

	constexpr _Ty operator()(const _Ty& _Left, const _Ty& _Right) const
		{	// apply operator^ to operands
		return (_Left ^ _Right);
		}
	};

		// STRUCT TEMPLATE bit_not
template<class _Ty = void>
	struct bit_not
	{	// functor for unary operator~
	 typedef _Ty argument_type;
	 typedef _Ty result_type;

	constexpr _Ty operator()(const _Ty& _Left) const
		{	// apply operator~ to operand
		return (~_Left);
		}
	};

		// STRUCT TEMPLATE SPECIALIZATION plus
// defined in <xstddef>

		// STRUCT TEMPLATE SPECIALIZATION minus
// defined in <xstddef>

		// STRUCT TEMPLATE SPECIALIZATION multiplies
// defined in <xstddef>

		// STRUCT TEMPLATE SPECIALIZATION divides
template<>
	struct divides<void>
	{	// transparent functor for operator/
	typedef int is_transparent;

	template<class _Ty1,
		class _Ty2>
		constexpr auto operator()(_Ty1&& _Left, _Ty2&& _Right) const
		-> decltype(::std:: forward<_Ty1>(_Left) / ::std:: forward<_Ty2>(_Right))
		{	// transparently apply operator/ to operands
		return (::std:: forward<_Ty1>(_Left) / ::std:: forward<_Ty2>(_Right));
		}
	};

		// STRUCT TEMPLATE SPECIALIZATION modulus
template<>
	struct modulus<void>
	{	// transparent functor for operator%
	typedef int is_transparent;

	template<class _Ty1,
		class _Ty2>
		constexpr auto operator()(_Ty1&& _Left, _Ty2&& _Right) const
		-> decltype(::std:: forward<_Ty1>(_Left) % ::std:: forward<_Ty2>(_Right))
		{	// transparently apply operator% to operands
		return (::std:: forward<_Ty1>(_Left) % ::std:: forward<_Ty2>(_Right));
		}
	};

		// STRUCT TEMPLATE SPECIALIZATION negate
template<>
	struct negate<void>
	{	// transparent functor for unary operator-
	typedef int is_transparent;

	template<class _Ty>
		constexpr auto operator()(_Ty&& _Left) const
		-> decltype(-::std:: forward<_Ty>(_Left))
		{	// transparently apply operator- to operand
		return (-::std:: forward<_Ty>(_Left));
		}
	};

		// STRUCT TEMPLATE SPECIALIZATION equal_to
// defined in <xstddef>

		// STRUCT TEMPLATE SPECIALIZATION not_equal_to
// defined in <xstddef>

		// STRUCT TEMPLATE SPECIALIZATION greater
// defined in <xstddef>

		// STRUCT TEMPLATE SPECIALIZATION less
// defined in <xstddef>

		// STRUCT TEMPLATE SPECIALIZATION greater_equal
// defined in <xstddef>

		// STRUCT TEMPLATE SPECIALIZATION less_equal
// defined in <xstddef>

		// STRUCT TEMPLATE SPECIALIZATION logical_and
template<>
	struct logical_and<void>
	{	// transparent functor for operator&&
	typedef int is_transparent;

	template<class _Ty1,
		class _Ty2>
		constexpr auto operator()(_Ty1&& _Left, _Ty2&& _Right) const
		-> decltype(::std:: forward<_Ty1>(_Left) && ::std:: forward<_Ty2>(_Right))
		{	// transparently apply operator&& to operands
		return (::std:: forward<_Ty1>(_Left) && ::std:: forward<_Ty2>(_Right));
		}
	};

		// STRUCT TEMPLATE SPECIALIZATION logical_or
template<>
	struct logical_or<void>
	{	// transparent functor for operator||
	typedef int is_transparent;

	template<class _Ty1,
		class _Ty2>
		constexpr auto operator()(_Ty1&& _Left, _Ty2&& _Right) const
		-> decltype(::std:: forward<_Ty1>(_Left) || ::std:: forward<_Ty2>(_Right))
		{	// transparently apply operator|| to operands
		return (::std:: forward<_Ty1>(_Left) || ::std:: forward<_Ty2>(_Right));
		}
	};

		// STRUCT TEMPLATE SPECIALIZATION logical_not
template<>
	struct logical_not<void>
	{	// transparent functor for unary operator!
	typedef int is_transparent;

	template<class _Ty>
		constexpr auto operator()(_Ty&& _Left) const
		-> decltype(!::std:: forward<_Ty>(_Left))
		{	// transparently apply operator! to operand
		return (!::std:: forward<_Ty>(_Left));
		}
	};

		// STRUCT TEMPLATE SPECIALIZATION bit_and
template<>
	struct bit_and<void>
	{	// transparent functor for operator&
	typedef int is_transparent;

	template<class _Ty1,
		class _Ty2>
		constexpr auto operator()(_Ty1&& _Left, _Ty2&& _Right) const
		-> decltype(::std:: forward<_Ty1>(_Left) & ::std:: forward<_Ty2>(_Right))
		{	// transparently apply operator& to operands
		return (::std:: forward<_Ty1>(_Left) & ::std:: forward<_Ty2>(_Right));
		}
	};

		// STRUCT TEMPLATE SPECIALIZATION bit_or
template<>
	struct bit_or<void>
	{	// transparent functor for operator|
	typedef int is_transparent;

	template<class _Ty1,
		class _Ty2>
		constexpr auto operator()(_Ty1&& _Left, _Ty2&& _Right) const
		-> decltype(::std:: forward<_Ty1>(_Left) | ::std:: forward<_Ty2>(_Right))
		{	// transparently apply operator| to operands
		return (::std:: forward<_Ty1>(_Left) | ::std:: forward<_Ty2>(_Right));
		}
	};

		// STRUCT TEMPLATE SPECIALIZATION bit_xor
template<>
	struct bit_xor<void>
	{	// transparent functor for operator^
	typedef int is_transparent;

	template<class _Ty1,
		class _Ty2>
		constexpr auto operator()(_Ty1&& _Left, _Ty2&& _Right) const
		-> decltype(::std:: forward<_Ty1>(_Left) ^ ::std:: forward<_Ty2>(_Right))
		{	// transparently apply operator^ to operands
		return (::std:: forward<_Ty1>(_Left) ^ ::std:: forward<_Ty2>(_Right));
		}
	};

		// STRUCT TEMPLATE SPECIALIZATION bit_not
template<>
	struct bit_not<void>
	{	// transparent functor for unary operator~
	typedef int is_transparent;

	template<class _Ty>
		constexpr auto operator()(_Ty&& _Left) const
		-> decltype(~::std:: forward<_Ty>(_Left))
		{	// transparently apply operator~ to operand
		return (~::std:: forward<_Ty>(_Left));
		}
	};

#pragma warning(push)
#pragma warning(disable: 4996)	
		// CLASS TEMPLATE unary_negate
template<class _Fn>
	class  unary_negate
	{	// functor adapter !_Func(left)
public:
	typedef typename _Fn::argument_type argument_type;
	typedef bool result_type;

	constexpr explicit unary_negate(const _Fn& _Func)
		: _Functor(_Func)
		{	// construct from functor
		}

	constexpr bool operator()(const argument_type& _Left) const
		{	// apply functor to operand
		return (!_Functor(_Left));
		}

private:
	_Fn _Functor;	// the functor to apply
	};

		// FUNCTION TEMPLATE not1
template<class _Fn>
	  constexpr unary_negate<_Fn> not1(const _Fn& _Func)
	{	// return a unary_negate functor adapter
	return (unary_negate<_Fn>(_Func));
	}

		// CLASS TEMPLATE binary_negate
template<class _Fn>
	class  binary_negate
	{	// functor adapter !_Func(left, right)
public:
	typedef typename _Fn::first_argument_type first_argument_type;
	typedef typename _Fn::second_argument_type second_argument_type;
	typedef bool result_type;

	constexpr explicit binary_negate(const _Fn& _Func)
		: _Functor(_Func)
		{	// construct from functor
		}

	constexpr bool operator()(const first_argument_type& _Left,
		const second_argument_type& _Right) const
		{	// apply functor to operands
		return (!_Functor(_Left, _Right));
		}

private:
	_Fn _Functor;	// the functor to apply
	};

		// FUNCTION TEMPLATE not2
template<class _Fn>
	  constexpr binary_negate<_Fn> not2(const _Fn& _Func)
	{	// return a binary_negate functor adapter
	return (binary_negate<_Fn>(_Func));
	}
#pragma warning(pop)

 
#pragma warning(push)
#pragma warning(disable: 4996)	
		// CLASS TEMPLATE binder1st
template<class _Fn>
	class binder1st
		: public unary_function<typename _Fn::second_argument_type,
			typename _Fn::result_type>
	{	// functor adapter _Func(stored, right)
public:
	typedef unary_function<typename _Fn::second_argument_type,
		typename _Fn::result_type> _Base;
	typedef typename _Base::argument_type argument_type;
	typedef typename _Base::result_type result_type;

	binder1st(const _Fn& _Func,
		const typename _Fn::first_argument_type& _Left)
		: op(_Func), value(_Left)
		{	// construct from functor and left operand
		}

	result_type operator()(const argument_type& _Right) const
		{	// apply functor to operands
		return (op(value, _Right));
		}

	result_type operator()(argument_type& _Right) const
		{	// apply functor to operands
		return (op(value, _Right));
		}

protected:
	_Fn op;	// the functor to apply
	typename _Fn::first_argument_type value;	// the left operand
	};

		// FUNCTION TEMPLATE bind1st
template<class _Fn,
	class _Ty>
	 inline binder1st<_Fn> bind1st(const _Fn& _Func, const _Ty& _Left)
	{	// return a binder1st functor adapter
	typename _Fn::first_argument_type _Val(_Left);
	return (binder1st<_Fn>(_Func, _Val));
	}

		// CLASS TEMPLATE binder2nd
template<class _Fn>
	class binder2nd
		: public unary_function<typename _Fn::first_argument_type,
			typename _Fn::result_type>
	{	// functor adapter _Func(left, stored)
public:
	typedef unary_function<typename _Fn::first_argument_type,
		typename _Fn::result_type> _Base;
	typedef typename _Base::argument_type argument_type;
	typedef typename _Base::result_type result_type;

	binder2nd(const _Fn& _Func,
		const typename _Fn::second_argument_type& _Right)
		: op(_Func), value(_Right)
		{	// construct from functor and right operand
		}

	result_type operator()(const argument_type& _Left) const
		{	// apply functor to operands
		return (op(_Left, value));
		}

	result_type operator()(argument_type& _Left) const
		{	// apply functor to operands
		return (op(_Left, value));
		}

protected:
	_Fn op;	// the functor to apply
	typename _Fn::second_argument_type value;	// the right operand
	};

		// FUNCTION TEMPLATE bind2nd
template<class _Fn,
	class _Ty>
	 inline binder2nd<_Fn> bind2nd(const _Fn& _Func, const _Ty& _Right)
	{	// return a binder2nd functor adapter
	typename _Fn::second_argument_type _Val(_Right);
	return (binder2nd<_Fn>(_Func, _Val));
	}
#pragma warning(pop)

		// CLASS TEMPLATE pointer_to_unary_function
template<class _Arg,
	class _Result,
	class _Fn = _Result (*)(_Arg)>
	class pointer_to_unary_function
		: public unary_function<_Arg, _Result>
	{	// functor adapter (*pfunc)(left)
public:
	explicit pointer_to_unary_function(_Fn _Left)
		: _Pfun(_Left)
		{	// construct from pointer
		}

	_Result operator()(_Arg _Left) const
		{	// call function with operand
		return (_Pfun(_Left));
		}

protected:
	_Fn _Pfun;	// the function pointer
	};

		// CLASS TEMPLATE pointer_to_binary_function
template<class _Arg1,
	class _Arg2,
	class _Result,
	class _Fn = _Result (*)(_Arg1, _Arg2)>
	class pointer_to_binary_function
		: public binary_function<_Arg1, _Arg2, _Result>
	{	// functor adapter (*pfunc)(left, right)
public:
	explicit pointer_to_binary_function(_Fn _Left)
		: _Pfun(_Left)
		{	// construct from pointer
		}

	_Result operator()(_Arg1 _Left, _Arg2 _Right) const
		{	// call function with operands
		return (_Pfun(_Left, _Right));
		}

protected:
	_Fn _Pfun;	// the function pointer
	};

		// FUNCTION TEMPLATE ptr_fun

















template<class _Arg, class _Result>  inline pointer_to_unary_function<_Arg, _Result, _Result (__cdecl *)(_Arg)> ptr_fun(_Result (__cdecl *_Left)(_Arg)) { return (pointer_to_unary_function<_Arg, _Result, _Result (__cdecl *)(_Arg)>(_Left)); } template<class _Arg1, class _Arg2, class _Result>  inline pointer_to_binary_function<_Arg1, _Arg2, _Result, _Result (__cdecl *)(_Arg1, _Arg2)> ptr_fun(_Result (__cdecl *_Left)(_Arg1, _Arg2)) { return (pointer_to_binary_function<_Arg1, _Arg2, _Result, _Result (__cdecl *)(_Arg1, _Arg2)>(_Left)); }    template<class _Arg, class _Result>  inline pointer_to_unary_function<_Arg, _Result, _Result (__vectorcall *)(_Arg)> ptr_fun(_Result (__vectorcall *_Left)(_Arg)) { return (pointer_to_unary_function<_Arg, _Result, _Result (__vectorcall *)(_Arg)>(_Left)); } template<class _Arg1, class _Arg2, class _Result>  inline pointer_to_binary_function<_Arg1, _Arg2, _Result, _Result (__vectorcall *)(_Arg1, _Arg2)> ptr_fun(_Result (__vectorcall *_Left)(_Arg1, _Arg2)) { return (pointer_to_binary_function<_Arg1, _Arg2, _Result, _Result (__vectorcall *)(_Arg1, _Arg2)>(_Left)); }


		// CLASS TEMPLATE mem_fun_t
template<class _Result,
	class _Ty>
	class mem_fun_t
		: public unary_function<_Ty *, _Result>
	{	// functor adapter (*p->*pfunc)(), non-const *pfunc
public:
	explicit mem_fun_t(_Result (_Ty::*_Pm)())
		: _Pmemfun(_Pm)
		{	// construct from pointer
		}

	_Result operator()(_Ty *_Pleft) const
		{	// call function
		return ((_Pleft->*_Pmemfun)());
		}

private:
	_Result (_Ty::*_Pmemfun)();	// the member function pointer
	};

		// CLASS TEMPLATE mem_fun1_t
template<class _Result,
	class _Ty,
	class _Arg>
	class mem_fun1_t
		: public binary_function<_Ty *, _Arg, _Result>
	{	// functor adapter (*p->*pfunc)(val), non-const *pfunc
public:
	explicit mem_fun1_t(_Result (_Ty::*_Pm)(_Arg))
		: _Pmemfun(_Pm)
		{	// construct from pointer
		}

	_Result operator()(_Ty *_Pleft, _Arg _Right) const
		{	// call function with operand
		return ((_Pleft->*_Pmemfun)(_Right));
		}

private:
	_Result (_Ty::*_Pmemfun)(_Arg);	// the member function pointer
	};

		// CLASS TEMPLATE const_mem_fun_t
template<class _Result,
	class _Ty>
	class const_mem_fun_t
		: public unary_function<const _Ty *, _Result>
	{	// functor adapter (*p->*pfunc)(), const *pfunc
public:
	explicit const_mem_fun_t(_Result (_Ty::*_Pm)() const)
		: _Pmemfun(_Pm)
		{	// construct from pointer
		}

	_Result operator()(const _Ty *_Pleft) const
		{	// call function
		return ((_Pleft->*_Pmemfun)());
		}

private:
	_Result (_Ty::*_Pmemfun)() const;	// the member function pointer
	};

		// CLASS TEMPLATE const_mem_fun1_t
template<class _Result,
	class _Ty,
	class _Arg>
	class const_mem_fun1_t
		: public binary_function<const _Ty *, _Arg, _Result>
	{	// functor adapter (*p->*pfunc)(val), const *pfunc
public:
	explicit const_mem_fun1_t(_Result (_Ty::*_Pm)(_Arg) const)
		: _Pmemfun(_Pm)
		{	// construct from pointer
		}

	_Result operator()(const _Ty *_Pleft, _Arg _Right) const
		{	// call function with operand
		return ((_Pleft->*_Pmemfun)(_Right));
		}

private:
	_Result (_Ty::*_Pmemfun)(_Arg) const;	// the member function pointer
	};

		// FUNCTION TEMPLATE mem_fun
template<class _Result,
	class _Ty>
	 inline mem_fun_t<_Result, _Ty> mem_fun(_Result (_Ty::*_Pm)())
	{	// return a mem_fun_t functor adapter
	return (mem_fun_t<_Result, _Ty>(_Pm));
	}

template<class _Result,
	class _Ty,
	class _Arg>
	 inline mem_fun1_t<_Result, _Ty, _Arg> mem_fun(_Result (_Ty::*_Pm)(_Arg))
	{	// return a mem_fun1_t functor adapter
	return (mem_fun1_t<_Result, _Ty, _Arg>(_Pm));
	}

template<class _Result,
	class _Ty>
	 inline const_mem_fun_t<_Result, _Ty> mem_fun(_Result (_Ty::*_Pm)() const)
	{	// return a const_mem_fun_t functor adapter
	return (const_mem_fun_t<_Result, _Ty>(_Pm));
	}

template<class _Result,
	class _Ty,
	class _Arg>
	 inline const_mem_fun1_t<_Result, _Ty, _Arg> mem_fun(_Result (_Ty::*_Pm)(_Arg) const)
	{	// return a const_mem_fun1_t functor adapter
	return (const_mem_fun1_t<_Result, _Ty, _Arg>(_Pm));
	}

		// CLASS TEMPLATE mem_fun_ref_t
template<class _Result,
	class _Ty>
	class mem_fun_ref_t
		: public unary_function<_Ty, _Result>
	{	// functor adapter (*left.*pfunc)(), non-const *pfunc
public:
	explicit mem_fun_ref_t(_Result (_Ty::*_Pm)())
		: _Pmemfun(_Pm)
		{	// construct from pointer
		}

	_Result operator()(_Ty& _Left) const
		{	// call function
		return ((_Left.*_Pmemfun)());
		}

private:
	_Result (_Ty::*_Pmemfun)();	// the member function pointer
	};

		// CLASS TEMPLATE mem_fun1_ref_t
template<class _Result,
	class _Ty,
	class _Arg>
	class mem_fun1_ref_t
		: public binary_function<_Ty, _Arg, _Result>
	{	// functor adapter (*left.*pfunc)(val), non-const *pfunc
public:
	explicit mem_fun1_ref_t(_Result (_Ty::*_Pm)(_Arg))
		: _Pmemfun(_Pm)
		{	// construct from pointer
		}

	_Result operator()(_Ty& _Left, _Arg _Right) const
		{	// call function with operand
		return ((_Left.*_Pmemfun)(_Right));
		}

private:
	_Result (_Ty::*_Pmemfun)(_Arg);	// the member function pointer
	};

		// CLASS TEMPLATE const_mem_fun_ref_t
template<class _Result,
	class _Ty>
	class const_mem_fun_ref_t
		: public unary_function<_Ty, _Result>
	{	// functor adapter (*left.*pfunc)(), const *pfunc
public:
	explicit const_mem_fun_ref_t(_Result (_Ty::*_Pm)() const)
		: _Pmemfun(_Pm)
		{	// construct from pointer
		}

	_Result operator()(const _Ty& _Left) const
		{	// call function
		return ((_Left.*_Pmemfun)());
		}

private:
	_Result (_Ty::*_Pmemfun)() const;	// the member function pointer
	};

		// CLASS TEMPLATE const_mem_fun1_ref_t
template<class _Result,
	class _Ty,
	class _Arg>
	class const_mem_fun1_ref_t
		: public binary_function<_Ty, _Arg, _Result>
	{	// functor adapter (*left.*pfunc)(val), const *pfunc
public:
	explicit const_mem_fun1_ref_t(_Result (_Ty::*_Pm)(_Arg) const)
		: _Pmemfun(_Pm)
		{	// construct from pointer
		}

	_Result operator()(const _Ty& _Left, _Arg _Right) const
		{	// call function with operand
		return ((_Left.*_Pmemfun)(_Right));
		}

private:
	_Result (_Ty::*_Pmemfun)(_Arg) const;	// the member function pointer
	};

		// FUNCTION TEMPLATE mem_fun_ref
template<class _Result,
	class _Ty>
	 inline mem_fun_ref_t<_Result, _Ty> mem_fun_ref(_Result (_Ty::*_Pm)())
	{	// return a mem_fun_ref_t functor adapter
	return (mem_fun_ref_t<_Result, _Ty>(_Pm));
	}

template<class _Result,
	class _Ty,
	class _Arg>
	 inline mem_fun1_ref_t<_Result, _Ty, _Arg> mem_fun_ref(_Result (_Ty::*_Pm)(_Arg))
	{	// return a mem_fun1_ref_t functor adapter
	return (mem_fun1_ref_t<_Result, _Ty, _Arg>(_Pm));
	}

template<class _Result,
	class _Ty>
	 inline const_mem_fun_ref_t<_Result, _Ty> mem_fun_ref(_Result (_Ty::*_Pm)() const)
	{	// return a const_mem_fun_ref_t functor adapter
	return (const_mem_fun_ref_t<_Result, _Ty>(_Pm));
	}

template<class _Result,
	class _Ty,
	class _Arg>
	 inline const_mem_fun1_ref_t<_Result, _Ty, _Arg> mem_fun_ref(_Result (_Ty::*_Pm)(_Arg) const)
	{	// return a const_mem_fun1_ref_t functor adapter
	return (const_mem_fun1_ref_t<_Result, _Ty, _Arg>(_Pm));
	}
 

	// FUNCTION TEMPLATE mem_fn
template<class _Memptr>
	class _Mem_fn
		: public _Weak_types<_Memptr>::type
	{	// wrap a pointer to member function/data
private:
	_Memptr _Pm;

public:
	explicit _Mem_fn(_Memptr _Val) noexcept
		: _Pm(_Val)
		{	// construct, storing a pointer to member function/data
		}

	template<class... _Types>
		auto operator()(_Types&&... _Args) const
		noexcept(noexcept(::std:: invoke(_Pm, ::std:: forward<_Types>(_Args)...)))	// strengthened
		-> decltype(::std:: invoke(_Pm, ::std:: forward<_Types>(_Args)...))
		{	// invoke a pointer to member function/data
		return (::std:: invoke(_Pm, ::std:: forward<_Types>(_Args)...));
		}
	};

template<class _Rx,
	class _Ty>
	 inline _Mem_fn<_Rx _Ty::*> mem_fn(_Rx _Ty::* _Pm) noexcept
	{	// wrap a pointer to member function/data
	return (_Mem_fn<_Rx _Ty::*>(_Pm));
	}





































































































































// IMPLEMENT function

	// CLASS bad_function_call
class bad_function_call
	: public exception
	{	// exception thrown when an empty std::function is called
public:
	bad_function_call() noexcept
		{	// construct
		}

	 virtual const char *  what() const noexcept override
		{	// return pointer to message string
		return ("bad function call");
		}
	};

[[noreturn]]  void __cdecl _Xbad_function_call();

	// FUNCTION TEMPLATE _Test_callable
template<class _Fty>
	class function;

template<class _Ty> inline
	bool _Test_callable(const _Ty& _Arg, true_type) noexcept
	{	// std::function must store non-null testable callable objects
	return (!!_Arg);
	}

template<class _Ty> inline
	bool _Test_callable(const _Ty&, false_type) noexcept
	{	// std::function must store arbitrary callable objects
	return (true);
	}

template<class _Ty> inline
	bool _Test_callable(const _Ty& _Arg) noexcept
	{	// determine whether std::function must store _Arg
	bool_constant<is_member_pointer_v<_Ty> || (is_pointer_v<_Ty>
		&& is_function_v<remove_pointer_t<_Ty>>)> _Testable;
	return (_Test_callable(_Arg, _Testable));
	}

template<class _Fty> inline
	bool _Test_callable(const function<_Fty>& _Arg) noexcept
	{	// determine whether std::function must store _Arg
	return (!!_Arg);
	}

#pragma warning(push)
#pragma warning(disable: 4265)	
	// CLASS TEMPLATE _Func_base
template<class _Rx,
	class... _Types>
	class __declspec(novtable) _Func_base
	{	// abstract base for implementation types
public:
	virtual _Func_base * _Copy(void *) const = 0;
	virtual _Func_base * _Move(void *) = 0;
	virtual _Rx _Do_call(_Types&&...) = 0;
	virtual const type_info& _Target_type() const noexcept = 0;
	virtual void _Delete_this(bool) noexcept = 0;


	const void *_Target(const type_info& _Info) const noexcept
		{	// return pointer to stored object of type _Info
		return (_Target_type() == _Info ? _Get() : nullptr);
		}


	_Func_base() = default;
	_Func_base(const _Func_base&) = delete;
	_Func_base& operator=(const _Func_base&) = delete;
	// dtor non-virtual due to _Delete_this()

private:
	virtual const void *_Get() const noexcept = 0;
	};
#pragma warning(pop)

	// STRUCT TEMPLATE _Is_large
constexpr size_t _Space_size = (_Small_object_num_ptrs - 1) * sizeof (void *);

template<class _Impl>
	struct _Is_large
		: bool_constant<_Space_size < sizeof (_Impl)
			|| !_Impl::_Nothrow_move::value>
	{	// determine whether _Impl must be dynamically allocated
	};

#pragma warning(push)
#pragma warning(disable: 4265)	


	// CLASS TEMPLATE _Func_impl
template<class _Callable,
	class _Alloc,
	class _Rx,
	class... _Types>
	class _Func_impl final
		: public _Func_base<_Rx, _Types...>
	{	// derived class for specific implementation types that use allocators
public:
	typedef _Func_base<_Rx, _Types...> _Mybase;
	typedef _Rebind_alloc_t<_Alloc, _Func_impl> _Myalty;
	typedef allocator_traits<_Myalty> _Myalty_traits;
	typedef is_nothrow_move_constructible<_Callable> _Nothrow_move;

	template<class _Other1,
		class _Other2>
		_Func_impl(_Other1&& _Val, _Other2&& _Ax)
		: _Mypair(_One_then_variadic_args_t(),
			::std:: forward<_Other2>(_Ax), ::std:: forward<_Other1>(_Val))
		{	// construct
		}

	// dtor non-virtual due to _Delete_this()

private:
	virtual _Mybase *_Copy(void *_Where) const override
		{	// return clone of *this
		return (_Clone(_Where, _Is_large<_Func_impl>()));
		}

	_Mybase *_Clone(void *, true_type) const
		{	// return clone of *this, large (dynamically allocated)
		_Myalty _Al(_Myax());
		const auto _Ptr = _Myalty_traits::allocate(_Al, 1);

		try {
			_Myalty_traits::construct(_Al, _Unfancy(_Ptr), _Callee(), _Myax());
		} catch (...) {
			_Myalty_traits::deallocate(_Al, _Ptr, 1);
		throw;
		}

		return (_Unfancy(_Ptr));
		}

	_Mybase *_Clone(void *_Where, false_type) const
		{	// return clone of *this, small (locally stored)
		_Myalty _Al(_Myax());
		_Func_impl * _Ptr = static_cast<_Func_impl *>(_Where);
		_Myalty_traits::construct(_Al, _Ptr, _Callee(), _Myax());
		return (_Ptr);
		}

	virtual _Mybase *_Move(void *_Where) override
		{	// return clone of *this
		_Myalty _Al(_Myax());
		_Func_impl *_Ptr = static_cast<_Func_impl *>(_Where);
		_Myalty_traits::construct(_Al, _Ptr, ::std:: move(_Callee()), ::std:: move(_Myax()));
		return (_Ptr);
		}

	virtual _Rx _Do_call(_Types&&... _Args) override;

	virtual const type_info& _Target_type() const noexcept override
		{	// return type information for stored object

		return (typeid(_Callable));



		}

	virtual const void *_Get() const noexcept override
		{	// return address of stored object
		return (::std:: addressof(_Callee()));
		}

	virtual void _Delete_this(bool _Deallocate) noexcept override
		{	// destroy self
		_Myalty _Al(_Myax());
		_Myalty_traits::destroy(_Al, this);
		if (_Deallocate)
			{
			_Deallocate_plain(_Al, this);
			}
		}

	_Compressed_pair<_Alloc, _Callable> _Mypair;

	_Alloc& _Myax() noexcept
		{	// return reference to allocator
		return (_Mypair._Get_first());
		}

	const _Alloc& _Myax() const noexcept
		{	// return const reference to allocator
		return (_Mypair._Get_first());
		}

	_Callable& _Callee() noexcept
		{	// return reference to wrapped function
		return (_Mypair._Get_second());
		}

	const _Callable& _Callee() const noexcept
		{	// return const reference to wrapped function
		return (_Mypair._Get_second());
		}
	};


	// CLASS TEMPLATE _Func_impl_no_alloc
template<class _Callable,
	class _Rx,
	class... _Types>
	class _Func_impl_no_alloc final
		: public _Func_base<_Rx, _Types...>
	{	// derived class for specific implementation types that don't use allocators
public:
	typedef _Func_base<_Rx, _Types...> _Mybase;
	typedef is_nothrow_move_constructible<_Callable> _Nothrow_move;

	template<class _Other,
		class = enable_if_t<!is_same_v<_Func_impl_no_alloc, decay_t<_Other>>>>
		explicit _Func_impl_no_alloc(_Other&& _Val)
		: _Callee(::std:: forward<_Other>(_Val))
		{	// construct
		}

	// dtor non-virtual due to _Delete_this()

private:
	virtual _Mybase *_Copy(void *_Where) const override
		{	// return clone of *this
		return (_Clone(_Where, _Is_large<_Func_impl_no_alloc>()));
		}

	_Mybase *_Clone(void *, true_type) const
		{	// return clone of *this, large (dynamically allocated)
		return (_Global_new<_Func_impl_no_alloc>(_Callee));
		}

	_Mybase *_Clone(void *_Where, false_type) const
		{	// return clone of *this, small (locally stored)
		return (::new (_Where) _Func_impl_no_alloc(_Callee));
		}

	virtual _Mybase *_Move(void *_Where) override
		{	// return clone of *this
		return (::new (_Where) _Func_impl_no_alloc(::std:: move(_Callee)));
		}

	virtual _Rx _Do_call(_Types&&... _Args) override;

	virtual const type_info& _Target_type() const noexcept override
		{	// return type information for stored object

		return (typeid(_Callable));



		}

	virtual const void *_Get() const noexcept override
		{	// return address of stored object
		return (::std:: addressof(_Callee));
		}

	virtual void _Delete_this(bool _Dealloc) noexcept override
		{	// destroy self
		this->~_Func_impl_no_alloc();
		if (_Dealloc)
			{
			_Deallocate<alignof(_Func_impl_no_alloc)>(this, sizeof(_Func_impl_no_alloc));
			}
		}

	_Callable _Callee;
	};
#pragma warning(pop)

	// CLASS TEMPLATE _Func_class
template<class _Ret,
	class... _Types>
	class _Func_class
		: public _Arg_types<_Types...>
	{	// implement function template
public:
	typedef _Ret result_type;

	typedef _Func_base<_Ret, _Types...> _Ptrt;

	_Func_class() noexcept
		{	// construct without stored object
		_Set(nullptr);
		}

	_Ret operator()(_Types... _Args) const;

	~_Func_class() noexcept
		{	// destroy the object
		_Tidy();
		}

protected:
	template<class _Fx,
		class _Function>
		using _Enable_if_callable_t = enable_if_t<conjunction_v<
			negation<is_same<decay_t<_Fx>, _Function>>,
			_Is_invocable_r<_Ret, _Fx, _Types...>>>;

	bool _Empty() const noexcept
		{	// return true if no stored object
		return (_Getimpl() == nullptr);
		}

	void _Reset_copy(const _Func_class& _Right)
		{	// copy _Right's stored object
		if (!_Right._Empty())
			{
			_Set(_Right._Getimpl()->_Copy(_Getspace()));
			}
		}

	void _Reset_move(_Func_class&& _Right)
		{	// move _Right's stored object
		if (!_Right._Empty())
			{
			if (_Right._Local())
				{	// move and tidy
				_Set(_Right._Getimpl()->_Move(_Getspace()));
				_Right._Tidy();
				}
			else
				{	// steal from _Right
				_Set(_Right._Getimpl());
				_Right._Set(nullptr);
				}
			}
		}

	template<class _Fx>
		void _Reset(_Fx&& _Val)
		{	// store copy of _Val
		if (!_Test_callable(_Val))
			{	// null member pointer/function pointer/std::function
			return;	// already empty
			}

		using _Impl = _Func_impl_no_alloc<decay_t<_Fx>, _Ret, _Types...>;
		_Reset_impl<_Impl>(::std:: forward<_Fx>(_Val), _Is_large<_Impl>());
		}

	template<class _Myimpl,
		class _Fx>
		void _Reset_impl(_Fx&& _Val, true_type)
		{	// store copy of _Val, large (dynamically allocated)
		_Set(_Global_new<_Myimpl>(::std:: forward<_Fx>(_Val)));
		}

	template<class _Myimpl,
		class _Fx>
		void _Reset_impl(_Fx&& _Val, false_type)
		{	// store copy of _Val, small (locally stored)
		_Set(::new (_Getspace()) _Myimpl(::std:: forward<_Fx>(_Val)));
		}


	template<class _Fx,
		class _Alloc>
		void _Reset_alloc(_Fx&& _Val, const _Alloc& _Ax)
		{	// store copy of _Val with allocator
		if (!_Test_callable(_Val))
			{	// null member pointer/function pointer/std::function
			return;	// already empty
			}

		using _Myimpl = _Func_impl<decay_t<_Fx>, _Alloc, _Ret, _Types...>;
		_Myimpl *_Ptr = nullptr;

		_Rebind_alloc_t<_Alloc, _Myimpl> _Al(_Ax);
		_Reset_impl_alloc(::std:: forward<_Fx>(_Val), _Ax, _Ptr, _Al, _Is_large<_Myimpl>());
		}

	template<class _Fx,
		class _Alloc,
		class _Myimpl,
		class _Alimpl>
		void _Reset_impl_alloc(_Fx&& _Val, const _Alloc& _Ax,
			_Myimpl *, _Alimpl& _Al, true_type)
		{	// store copy of _Val with allocator, large (dynamically allocated)
		using _Alimpl_traits = allocator_traits<_Alimpl>;
		const auto _Ptr = _Alimpl_traits::allocate(_Al, 1);

		try {
			_Alimpl_traits::construct(_Al, _Unfancy(_Ptr), ::std:: forward<_Fx>(_Val), _Ax);
		} catch (...) {
			_Alimpl_traits::deallocate(_Al, _Ptr, 1);
		throw;
		}

		_Set(_Unfancy(_Ptr));
		}

	template<class _Fx,
		class _Alloc,
		class _Myimpl,
		class _Alimpl>
		void _Reset_impl_alloc(_Fx&& _Val, const _Alloc& _Ax,
			_Myimpl *, _Alimpl& _Al, false_type)
		{	// store copy of _Val with allocator, small (locally stored)
		_Myimpl *_Ptr = static_cast<_Myimpl *>(_Getspace());
		allocator_traits<_Alimpl>::construct(_Al, _Ptr, ::std:: forward<_Fx>(_Val), _Ax);
		_Set(_Ptr);
		}


	void _Tidy() noexcept
		{	// clean up
		if (!_Empty())
			{	// destroy callable object and maybe delete it
			_Getimpl()->_Delete_this(!_Local());
			_Set(nullptr);
			}
		}

	void _Swap(_Func_class& _Right) noexcept
		{	// swap contents with contents of _Right
		if (!_Local() && !_Right._Local())
			{	// just swap pointers
			_Ptrt *_Temp = _Getimpl();
			_Set(_Right._Getimpl());
			_Right._Set(_Temp);
			}
		else
			{	// do three-way move
			_Func_class _Temp;
			_Temp._Reset_move(::std:: move(*this));
			_Reset_move(::std:: move(_Right));
			_Right._Reset_move(::std:: move(_Temp));
			}
		}


	const type_info& _Target_type() const noexcept
		{	// return type information for stored object
		return (_Getimpl() ? _Getimpl()->_Target_type() : typeid(void));
		}

	const void *_Target(const type_info& _Info) const noexcept
		{	// return pointer to stored object
		return (_Getimpl() ? _Getimpl()->_Target(_Info) : nullptr);
		}


private:
	bool _Local() const noexcept
		{	// test for locally stored copy of object
		return (_Getimpl() == _Getspace());
		}

	union _Storage
		{	// storage for small objects (basic_string is small)
		max_align_t _Dummy1;	// for maximum alignment
		char _Dummy2[_Space_size];	// to permit aliasing
		_Ptrt *_Ptrs[_Small_object_num_ptrs];	// _Ptrs[_Small_object_num_ptrs - 1] is reserved
		};

	_Storage _Mystorage;
	enum {_EEN_IMPL = _Small_object_num_ptrs - 1};	// helper for expression evaluator
	_Ptrt *_Getimpl() const noexcept
		{	// get pointer to object
		return (_Mystorage._Ptrs[_Small_object_num_ptrs - 1]);
		}

	void _Set(_Ptrt *_Ptr) noexcept
		{	// store pointer to object
		_Mystorage._Ptrs[_Small_object_num_ptrs - 1] = _Ptr;
		}

	void *_Getspace() noexcept
		{	// get pointer to storage space
		return (&_Mystorage);
		}

	const void *_Getspace() const noexcept
		{	// get pointer to storage space
		return (&_Mystorage);
		}
	};

	// STRUCT TEMPLATE _Get_function_impl
template<class _Tx>
	struct _Get_function_impl;









template<class _Ret, class... _Types> struct _Get_function_impl<_Ret __cdecl (_Types...)> { typedef _Func_class<_Ret, _Types...> type; };    template<class _Ret, class... _Types> struct _Get_function_impl<_Ret __vectorcall (_Types...)> { typedef _Func_class<_Ret, _Types...> type; };


	// CLASS TEMPLATE function
template<class _Fty>
	class function
		: public _Get_function_impl<_Fty>::type
	{	// wrapper for callable objects
private:
	typedef typename _Get_function_impl<_Fty>::type _Mybase;

public:
	function() noexcept
		{	// construct empty function wrapper
		}

	function(nullptr_t) noexcept
		{	// construct empty function wrapper from null pointer
		}

	function(const function& _Right)
		{	// construct holding copy of _Right
		this->_Reset_copy(_Right);
		}

	template<class _Fx,
		class = typename _Mybase::template _Enable_if_callable_t<_Fx&, function>>
		function(_Fx _Func)
		{	// construct wrapper holding copy of _Func
		this->_Reset(::std:: move(_Func));
		}


	template<class _Alloc>
		function(allocator_arg_t, const _Alloc&) noexcept
		{	// construct empty function wrapper, allocator
		}

	template<class _Alloc>
		function(allocator_arg_t, const _Alloc&, nullptr_t) noexcept
		{	// construct empty function wrapper from null pointer, allocator
		}

	template<class _Alloc>
		function(allocator_arg_t, const _Alloc& _Ax, const function& _Right)
		{	// construct wrapper holding copy of _Right, allocator
		this->_Reset_alloc(_Right, _Ax);
		}

	template<class _Fx,
		class _Alloc,
		class = typename _Mybase::template _Enable_if_callable_t<_Fx&, function>>
		function(allocator_arg_t, const _Alloc& _Ax, _Fx _Func)
		{	// construct wrapper holding copy of _Func, allocator
		this->_Reset_alloc(::std:: move(_Func), _Ax);
		}


	function& operator=(const function& _Right)
		{	// assign _Right
		function(_Right).swap(*this);
		return (*this);
		}

	function(function&& _Right)
		{	// construct holding moved copy of _Right
		this->_Reset_move(::std:: move(_Right));
		}


	template<class _Alloc>
		function(allocator_arg_t, const _Alloc& _Al, function&& _Right)
		{	// construct wrapper holding moved copy of _Right, allocator
		this->_Reset_alloc(::std:: move(_Right), _Al);
		}


	function& operator=(function&& _Right)
		{	// assign by moving _Right
		if (this != ::std:: addressof(_Right))
			{	// clean up and copy
			this->_Tidy();
			this->_Reset_move(::std:: move(_Right));
			}
		return (*this);
		}

	template<class _Fx,
		class = typename _Mybase::template _Enable_if_callable_t<decay_t<_Fx>&, function>>
		function& operator=(_Fx&& _Func)
		{	// assign function object _Func
		function(::std:: forward<_Fx>(_Func)).swap(*this);
		return (*this);
		}


	template<class _Fx,
		class _Alloc>
		void assign(_Fx&& _Func, const _Alloc& _Ax)
		{	// assign wrapper holding copy of _Func, allocator
		function(allocator_arg, _Ax, ::std:: forward<_Fx>(_Func)).swap(*this);
		}


	function& operator=(nullptr_t) noexcept
		{	// clear function object
		this->_Tidy();
		return (*this);
		}

	template<class _Fx>
		function& operator=(reference_wrapper<_Fx> _Func) noexcept
		{	// assign wrapper holding reference_wrapper to function object
		this->_Tidy();
		this->_Reset(_Func);
		return (*this);
		}

	void swap(function& _Right) noexcept
		{	// swap with _Right
		this->_Swap(_Right);
		}

	explicit operator bool() const noexcept
		{	// test if wrapper holds function object
		return (!this->_Empty());
		}


	 const type_info& target_type() const noexcept
		{	// return type_info object for target type
		return (this->_Target_type());
		}

	template<class _Fx>
		 _Fx * target() noexcept
		{	// return pointer to target object
		return (reinterpret_cast<_Fx *>(const_cast<void *>(this->_Target(typeid(_Fx)))));
		}

	template<class _Fx>
		 const _Fx * target() const noexcept
		{	// return pointer to target object
		return (reinterpret_cast<const _Fx *>(this->_Target(typeid(_Fx))));
		}









	};






























	// FUNCTION TEMPLATE swap
template<class _Fty> inline
	void swap(function<_Fty>& _Left, function<_Fty>& _Right) noexcept
	{	// swap contents of _Left with contents of _Right
	_Left.swap(_Right);
	}

	// TEMPLATE NULL POINTER COMPARISONS
template<class _Fty>
	 inline bool operator==(const function<_Fty>& _Other, nullptr_t) noexcept
	{	// compare to null pointer
	return (!_Other);
	}

template<class _Fty>
	 inline bool operator==(nullptr_t, const function<_Fty>& _Other) noexcept
	{	// compare to null pointer
	return (!_Other);
	}

template<class _Fty>
	 inline bool operator!=(const function<_Fty>& _Other, nullptr_t) noexcept
	{	// compare to null pointer
	return (static_cast<bool>(_Other));
	}

template<class _Fty>
	 inline bool operator!=(nullptr_t, const function<_Fty>& _Other) noexcept
	{	// compare to null pointer
	return (static_cast<bool>(_Other));
	}

	// PLACEHOLDERS
template<int _Nx>
	struct _Ph
	{	// placeholder
	};

template<class _Tx>
	struct is_placeholder
		: integral_constant<int, 0>
	{	// template to indicate that _Tx is not a placeholder
	};

template<int _Nx>
	struct is_placeholder<_Ph<_Nx>>
		: integral_constant<int, _Nx>
	{	// template specialization to indicate that _Ph<_Nx> is a placeholder
	};

template<class _Tx>
	struct is_placeholder<const _Tx>
		: is_placeholder<_Tx>::type
	{	// ignore cv-qualifiers
	};

template<class _Tx>
	struct is_placeholder<volatile _Tx>
		: is_placeholder<_Tx>::type
	{	// ignore cv-qualifiers
	};

template<class _Tx>
	struct is_placeholder<const volatile _Tx>
		: is_placeholder<_Tx>::type
	{	// ignore cv-qualifiers
	};

template<class _Ty>
	 constexpr int is_placeholder_v = is_placeholder<_Ty>::value;

	// CLASS TEMPLATE _Binder FORWARD DECLARATION
template<class _Ret,
	class _Fx,
	class... _Types>
	class _Binder;

	// STRUCT TEMPLATE is_bind_expression
template<class _Tx>
	struct is_bind_expression
		: false_type
	{	// template to indicate that _Tx is not a bind expression
	};

template<class _Ret,
	class _Fx,
	class... _Types>
	struct is_bind_expression<_Binder<_Ret, _Fx, _Types...>>
		: true_type
	{	// template specialization to indicate a bind expression
	};

template<class _Tx>
	struct is_bind_expression<const _Tx>
		: is_bind_expression<_Tx>::type
	{	// ignore cv-qualifiers
	};

template<class _Tx>
	struct is_bind_expression<volatile _Tx>
		: is_bind_expression<_Tx>::type
	{	// ignore cv-qualifiers
	};

template<class _Tx>
	struct is_bind_expression<const volatile _Tx>
		: is_bind_expression<_Tx>::type
	{	// ignore cv-qualifiers
	};

template<class _Ty>
	 constexpr bool is_bind_expression_v = is_bind_expression<_Ty>::value;

	// FUNCTION TEMPLATE _Fix_arg
template<class _Cv_TiD,
	bool = _Is_specialization_v<remove_cv_t<_Cv_TiD>, reference_wrapper>,
	bool = is_bind_expression_v<_Cv_TiD>,
	int = is_placeholder_v<_Cv_TiD>>
	struct _Select_fixer;

template<class _Cv_TiD>
	struct _Select_fixer<_Cv_TiD, true, false, 0>
	{	// reference_wrapper fixer
	template<class _Untuple>
		static auto _Fix(_Cv_TiD& _Tid, _Untuple&&)
		-> typename _Cv_TiD::type&
		{	// unwrap a reference_wrapper
		return (_Tid.get());
		}
	};

template<class _Cv_TiD>
	struct _Select_fixer<_Cv_TiD, false, true, 0>
	{	// nested bind fixer
#pragma warning(push)
#pragma warning(disable: 4100)	
	template<class _Untuple,
		size_t... _Jx>
		static auto _Apply(_Cv_TiD& _Tid, _Untuple&& _Ut,
			index_sequence<_Jx...>)
		-> decltype(_Tid(::std:: get<_Jx>(::std:: move(_Ut))...))
		{	// call a nested bind expression
		return (_Tid(::std:: get<_Jx>(::std:: move(_Ut))...));
		}
#pragma warning(pop)

	template<class _Untuple>
		static auto _Fix(_Cv_TiD& _Tid, _Untuple&& _Ut)
		-> decltype(_Apply(_Tid, ::std:: move(_Ut),
			make_index_sequence<tuple_size_v<_Untuple>>()))
		{	// call a nested bind expression
		return (_Apply(_Tid, ::std:: move(_Ut),
			make_index_sequence<tuple_size_v<_Untuple>>()));
		}
	};

template<class _Cv_TiD>
	struct _Select_fixer<_Cv_TiD, false, false, 0>
	{	// identity fixer
	template<class _Untuple>
		static _Cv_TiD& _Fix(_Cv_TiD& _Tid, _Untuple&&)
		{	// pass a bound argument as an lvalue (important!)
		return (_Tid);
		}
	};

template<class _Cv_TiD,
	int _Jx>
	struct _Select_fixer<_Cv_TiD, false, false, _Jx>
	{	// placeholder fixer
	static_assert(_Jx > 0, "invalid is_placeholder value");

	template<class _Untuple>
		static auto _Fix(_Cv_TiD&, _Untuple&& _Ut)
		-> decltype(::std:: get<_Jx - 1>(::std:: move(_Ut)))
		{	// choose the Jth unbound argument (1-based indexing)
		return (::std:: get<_Jx - 1>(::std:: move(_Ut)));
		}
	};

template<class _Cv_TiD,
	class _Untuple> inline
	auto _Fix_arg(_Cv_TiD& _Tid, _Untuple&& _Ut)
	-> decltype(_Select_fixer<_Cv_TiD>::_Fix(_Tid, ::std:: move(_Ut)))
	{	// translate an argument for bind
	return (_Select_fixer<_Cv_TiD>::_Fix(_Tid, ::std:: move(_Ut)));
	}

#pragma warning(push)
#pragma warning(disable: 4100)	
	// FUNCTION TEMPLATE _Call_binder
template<class _Ret,
	size_t... _Ix,
	class _Cv_FD,
	class _Cv_tuple_TiD,
	class _Untuple> inline
	auto _Call_binder(_Invoker_ret<_Ret>, index_sequence<_Ix...>,
		_Cv_FD& _Obj, _Cv_tuple_TiD& _Tpl, _Untuple&& _Ut)
	-> decltype(_Invoker_ret<_Ret>::_Call(_Obj, _Fix_arg(::std:: get<_Ix>(_Tpl), ::std:: move(_Ut))...))
	{	// bind() and bind<R>() invocation
	return (_Invoker_ret<_Ret>::_Call(_Obj, _Fix_arg(::std:: get<_Ix>(_Tpl), ::std:: move(_Ut))...));
	}
#pragma warning(pop)

	// CLASS TEMPLATE _Binder
template<class _Ret>
	struct _Forced_result_type
	{	// used by bind<R>()
	 typedef _Ret result_type;
	};

template<class _Ret,
	class _Fx>
	struct _Binder_result_type
	{	// provide result_type (sometimes)
	typedef decay_t<_Fx> _Decayed;

	typedef typename _Weak_types<_Decayed>::type _All_weak_types;

	typedef conditional_t<is_same_v<_Ret, _Unforced>,
		_Weak_result_type<_All_weak_types>,
		_Forced_result_type<_Ret>> type;
	};

template<class _Ret,
	class _Fx,
	class... _Types>
	class _Binder
		: public _Binder_result_type<_Ret, _Fx>::type
	{	// wrap bound callable object and arguments
private:
	typedef index_sequence_for<_Types...> _Seq;
	typedef decay_t<_Fx> _First;
	typedef tuple<decay_t<_Types>...> _Second;

	_Compressed_pair<_First, _Second> _Mypair;

public:
	explicit _Binder(_Fx&& _Func, _Types&&... _Args)
		: _Mypair(_One_then_variadic_args_t(),
			::std:: forward<_Fx>(_Func), ::std:: forward<_Types>(_Args)...)
		{	// construct from forwarded callable object and arguments
		}













template<class... _Unbound> auto operator()(_Unbound&&... _Unbargs)  -> decltype(_Call_binder(_Invoker_ret<_Ret>(), _Seq(), _Mypair._Get_first(), _Mypair._Get_second(), ::std:: forward_as_tuple(::std:: forward<_Unbound>(_Unbargs)...))) { return (_Call_binder(_Invoker_ret<_Ret>(), _Seq(), _Mypair._Get_first(), _Mypair._Get_second(), ::std:: forward_as_tuple(::std:: forward<_Unbound>(_Unbargs)...))); } template<class... _Unbound> auto operator()(_Unbound&&... _Unbargs) const -> decltype(_Call_binder(_Invoker_ret<_Ret>(), _Seq(), _Mypair._Get_first(), _Mypair._Get_second(), ::std:: forward_as_tuple(::std:: forward<_Unbound>(_Unbargs)...))) { return (_Call_binder(_Invoker_ret<_Ret>(), _Seq(), _Mypair._Get_first(), _Mypair._Get_second(), ::std:: forward_as_tuple(::std:: forward<_Unbound>(_Unbargs)...))); }

	};

	// FUNCTION TEMPLATE bind (implicit return type)
template<class _Fx,
	class... _Types>
	 inline _Binder<_Unforced, _Fx, _Types...> bind(_Fx&& _Func, _Types&&... _Args)
	{	// bind a callable object with an implicit return type
	return (_Binder<_Unforced, _Fx, _Types...>(::std:: forward<_Fx>(_Func), ::std:: forward<_Types>(_Args)...));
	}

	// FUNCTION TEMPLATE bind (explicit return type)
template<class _Ret,
	class _Fx,
	class... _Types>
	 _Binder<_Ret, _Fx, _Types...> bind(_Fx&& _Func, _Types&&... _Args)
	{	// bind a callable object with an explicit return type
	return (_Binder<_Ret, _Fx, _Types...>(::std:: forward<_Fx>(_Func), ::std:: forward<_Types>(_Args)...));
	}

	// PLACEHOLDER ARGUMENTS
		namespace placeholders {	// placeholders
 constexpr _Ph<1> _1{};
 constexpr _Ph<2> _2{};
 constexpr _Ph<3> _3{};
 constexpr _Ph<4> _4{};
 constexpr _Ph<5> _5{};
 constexpr _Ph<6> _6{};
 constexpr _Ph<7> _7{};
 constexpr _Ph<8> _8{};
 constexpr _Ph<9> _9{};
 constexpr _Ph<10> _10{};
 constexpr _Ph<11> _11{};
 constexpr _Ph<12> _12{};
 constexpr _Ph<13> _13{};
 constexpr _Ph<14> _14{};
 constexpr _Ph<15> _15{};
 constexpr _Ph<16> _16{};
 constexpr _Ph<17> _17{};
 constexpr _Ph<18> _18{};
 constexpr _Ph<19> _19{};
 constexpr _Ph<20> _20{};
		}	// namespace placeholders


	// STRUCT TEMPLATE uses_allocator
template<class _Fty,
	class _Alloc>
	struct uses_allocator<function<_Fty>, _Alloc>
		: true_type
	{	// true_type if container allocator enabled
	};




















































































































































































































































































































































































































































































































































































































































































































































namespace [[deprecated("warning STL4002: " "The non-Standard std::tr1 namespace and TR1-only machinery are deprecated and will be REMOVED. You can " "define _SILENCE_TR1_NAMESPACE_DEPRECATION_WARNING to acknowledge that you have received this warning.")]] tr1 {
using ::std:: bad_function_call;
using ::std:: bind;
using ::std:: function;
using ::std:: is_bind_expression;
using ::std:: is_placeholder;
using ::std:: mem_fn;
using ::std:: swap;
namespace placeholders {
	using namespace ::std:: placeholders;
}
}



// EVERYTHING BELOW WILL HAVE STRANGE LINE NUMBERS


template<class _Callable,
	class _Alloc,
	class _Rx,
	class... _Types> inline
	/* virtual */ _Rx _Func_impl<_Callable, _Alloc, _Rx, _Types...>::_Do_call(_Types&&... _Args) /* override */



		{	// call wrapped function



		auto& _The_callee = _Callee();



		return (_Invoker_ret<_Rx>::_Call(_The_callee, ::std:: forward<_Types>(_Args)...));



		}


template<class _Callable,
	class _Rx,
	class... _Types> inline
	/* virtual */ _Rx _Func_impl_no_alloc<_Callable, _Rx, _Types...>::_Do_call(_Types&&... _Args) /* override */



		{	// call wrapped function



		return (_Invoker_ret<_Rx>::_Call(_Callee, ::std:: forward<_Types>(_Args)...));



		}

template<class _Ret,
	class... _Types> inline
	_Ret _Func_class<_Ret, _Types...>::operator()(_Types... _Args) const



		{	// call through stored object



		if (_Empty())



			{



			_Xbad_function_call();



			}



		const auto _Impl = _Getimpl();



		return (_Impl->_Do_call(::std:: forward<_Types>(_Args)...));



		}

}

 
 
 #pragma warning(pop)
 #pragma pack(pop)



/*
 * Copyright (c) by P.J. Plauger. All rights reserved.
 * Consult your license regarding permissions and restrictions.
V6.50:0009 */



// thread standard header
#pragma once




 











// xthread internal header
#pragma once





// xtime internal header
#pragma once





 #pragma pack(push,8)
 #pragma warning(push,3)
 #pragma warning(disable: 4455 4494  4619 4643 4702 4984 4988 )
 
 
 

namespace stdext
	{	// Dinkum Libraries
	namespace threads
		{	// Dinkum C++ Threads Library
using ::xtime;
using ::xtime_get;
		}	// namespace threads
	}	// namespace stdext
 
 
 #pragma warning(pop)
 #pragma pack(pop)



/*
 * This file is derived from software bearing the following
 * restrictions:
 *
 * (c) Copyright William E. Kempf 2001
 *
 * Permission to use, copy, modify, distribute and sell this
 * software and its documentation for any purpose is hereby
 * granted without fee, provided that the above copyright
 * notice appear in all copies and that both that copyright
 * notice and this permission notice appear in supporting
 * documentation. William E. Kempf makes no representations
 * about the suitability of this software for any purpose.
 * It is provided "as is" without express or implied warranty.
 */

/*
 * Copyright (c) by P.J. Plauger. All rights reserved.
 * Consult your license regarding permissions and restrictions.
V6.50:0009 */


/* xthreads.h -- internal header for threads library */
#pragma once







 #pragma pack(push,8)
 #pragma warning(push,3)
 #pragma warning(disable: 4455 4494  4619 4643 4702 4984 4988 )
 
 
 

extern "C" {
enum {	/* return codes */
	_Thrd_success,
	_Thrd_nomem,
	_Thrd_timedout,
	_Thrd_busy,
	_Thrd_error
	};

	/* threads */
typedef _Thrd_imp_t _Thrd_t;
typedef int (*_Thrd_start_t)(void *);

 int __cdecl _Thrd_create(_Thrd_t *, _Thrd_start_t, void *);

 int __cdecl _Thrd_detach(_Thrd_t);
 void __cdecl _Thrd_exit(int);
 int __cdecl _Thrd_join(_Thrd_t, int *);
 void __cdecl _Thrd_sleep(const xtime*);
 void __cdecl _Thrd_yield(void);
 unsigned int __cdecl _Thrd_hardware_concurrency(void);
 int __cdecl _Thrd_equal(_Thrd_t, _Thrd_t);
 _Thrd_t __cdecl _Thrd_current(void);
 _Thrd_id_t __cdecl _Thrd_id(void);

	/* mutexes */
typedef _Mtx_imp_t _Mtx_t;
enum {	/* mutex types */
	_Mtx_plain = 0x01,
	_Mtx_try	= 0x02,
	_Mtx_timed	= 0x04,
	_Mtx_recursive = 0x100
	};

 int __cdecl _Mtx_init(_Mtx_t *, int);
 void __cdecl _Mtx_destroy(_Mtx_t);
 void __cdecl _Mtx_init_in_situ(_Mtx_t, int);
 void __cdecl _Mtx_destroy_in_situ(_Mtx_t);
 int __cdecl _Mtx_current_owns(_Mtx_t);
 int __cdecl _Mtx_lock(_Mtx_t);
 int __cdecl _Mtx_trylock(_Mtx_t);
 int __cdecl _Mtx_timedlock(_Mtx_t, const xtime *);
 int __cdecl _Mtx_unlock(_Mtx_t);

 void *__cdecl _Mtx_getconcrtcs(_Mtx_t);
 void __cdecl _Mtx_clear_owner(_Mtx_t);
 void __cdecl _Mtx_reset_owner(_Mtx_t);

	/* shared mutex */
	/* these declarations must be in sync with those in thr/sharedmutex.cpp */
typedef void * _Smtx_t;
void __cdecl _Smtx_lock_exclusive(_Smtx_t *);
void __cdecl _Smtx_lock_shared(_Smtx_t *);
int __cdecl _Smtx_try_lock_exclusive(_Smtx_t *);
int __cdecl _Smtx_try_lock_shared(_Smtx_t *);
void __cdecl _Smtx_unlock_exclusive(_Smtx_t *);
void __cdecl _Smtx_unlock_shared(_Smtx_t *);

	/* condition variables */
typedef _Cnd_imp_t _Cnd_t;

 int __cdecl _Cnd_init(_Cnd_t *);
 void __cdecl _Cnd_destroy(_Cnd_t);
 void __cdecl _Cnd_init_in_situ(_Cnd_t);
 void __cdecl _Cnd_destroy_in_situ(_Cnd_t);
 int __cdecl _Cnd_wait(_Cnd_t, _Mtx_t);
 int __cdecl _Cnd_timedwait(_Cnd_t,
	_Mtx_t, const xtime *);
 int __cdecl _Cnd_broadcast(_Cnd_t);
 int __cdecl _Cnd_signal(_Cnd_t);
 void __cdecl _Cnd_register_at_thread_exit(_Cnd_t,
	_Mtx_t, int *);
 void __cdecl _Cnd_unregister_at_thread_exit(_Mtx_t);
 void __cdecl _Cnd_do_broadcast_at_thread_exit(void);

	/* utility functions */
 void __cdecl _Thrd_abort(const char *);
}
 
 
 #pragma warning(pop)
 #pragma pack(pop)



/*
 * This file is derived from software bearing the following
 * restrictions:
 *
 * (c) Copyright William E. Kempf 2001
 *
 * Permission to use, copy, modify, distribute and sell this
 * software and its documentation for any purpose is hereby
 * granted without fee, provided that the above copyright
 * notice appear in all copies and that both that copyright
 * notice and this permission notice appear in supporting
 * documentation. William E. Kempf makes no representations
 * about the suitability of this software for any purpose.
 * It is provided "as is" without express or implied warranty.
 */

/*
 * Copyright (c) by P.J. Plauger. All rights reserved.
 * Consult your license regarding permissions and restrictions.
V6.50:0009 */





 #pragma pack(push,8)
 #pragma warning(push,3)
 #pragma warning(disable: 4455 4494  4619 4643 4702 4984 4988 )
 
 
 

namespace std {
enum {	// constants for error codes
	_DEVICE_OR_RESOURCE_BUSY,
	_INVALID_ARGUMENT,
	_NO_SUCH_PROCESS,
	_NOT_ENOUGH_MEMORY,
	_OPERATION_NOT_PERMITTED,
	_RESOURCE_DEADLOCK_WOULD_OCCUR,
	_RESOURCE_UNAVAILABLE_TRY_AGAIN
	};

 void __cdecl _Throw_C_error(int _Code);
 void __cdecl _Throw_Cpp_error(int _Code);

inline int _Check_C_return(int _Res)
	{	// throw exception on failure
	if (_Res != _Thrd_success)
		_Throw_C_error(_Res);
	return (_Res);
	}

inline int _Check_C_return(int _Res, int _Other)
	{	// throw exception on failure
	if (_Res != _Thrd_success && _Res != _Other)
		_Throw_C_error(_Res);
	return (_Res);
	}

	// C++ WRAPPERS FOR C FUNCTIONS (SAME NAMES, IN NAMESPACE std)
inline int _Thrd_startX(_Thrd_imp_t *_Thr, _Thrd_callback_t _Fp, void *_Arg)
	{	// throw exception on failure
	const int _Res = _Thrd_start(_Thr, _Fp, _Arg);
	return (_Check_C_return(_Res != _Thrd_error ? _Res : _Thrd_nomem));
	}

inline int _Thrd_detachX(_Thrd_t _Thr)
	{	// throw exception on failure
	return (_Check_C_return(_Thrd_detach(_Thr)));
	}

inline int _Thrd_joinX(_Thrd_t _Thr, int *_Res)
	{	// throw exception on failure
	return (_Check_C_return(_Thrd_join(_Thr, _Res)));
	}

inline int _Mtx_initX(_Mtx_t *_Mtx, int _Type)
	{	// throw exception on failure
	return (_Check_C_return(_Mtx_init(_Mtx, _Type)));
	}

inline int _Mtx_lockX(_Mtx_t _Mtx)
	{	// throw exception on failure
	return (_Check_C_return(_Mtx_lock(_Mtx)));
	}

inline int _Mtx_trylockX(_Mtx_t _Mtx)
	{	// throw exception on failure
	return (_Check_C_return(_Mtx_trylock(_Mtx), _Thrd_busy));
	}

inline int _Mtx_timedlockX(_Mtx_t _Mtx, const xtime *_Xt)
	{	// throw exception on failure
	return (_Check_C_return(_Mtx_timedlock(_Mtx, _Xt), _Thrd_timedout));
	}

inline int _Mtx_unlockX(_Mtx_t _Mtx)
	{	// throw exception on failure
	return (_Check_C_return(_Mtx_unlock(_Mtx)));
	}

inline int _Cnd_initX(_Cnd_t *_Cnd)
	{	// throw exception on failure
	return (_Check_C_return(_Cnd_init(_Cnd)));
	}

inline int _Cnd_waitX(_Cnd_t _Cnd, _Mtx_t _Mtx)
	{	// throw exception on failure
	return (_Check_C_return(_Cnd_wait(_Cnd, _Mtx)));
	}

inline int _Cnd_timedwaitX(_Cnd_t _Cnd,
	_Mtx_t _Mtx, const xtime *_Xt)
	{	// throw exception on failure
	return (_Check_C_return(_Cnd_timedwait(_Cnd, _Mtx, _Xt), _Thrd_timedout));
	}

inline int _Cnd_broadcastX(_Cnd_t _Cnd)
	{	// throw exception on failure
	return (_Check_C_return(_Cnd_broadcast(_Cnd)));
	}

inline int _Cnd_signalX(_Cnd_t _Cnd)
	{	// throw exception on failure
	return (_Check_C_return(_Cnd_signal(_Cnd)));
	}

class _Auto_cnd
	{	// clean up condition variable on destruction
public:
	_Auto_cnd(_Cnd_t _Cndp)
		: _Active(true), _MyCndp(_Cndp)
		{	// construct from condition variable pointer
		}

	~_Auto_cnd() noexcept
		{	// destroy the object
		if (_Active)
			_Cnd_destroy(_MyCndp);
		}

	void _Release()
		{	// release the condition variable
		_Active = false;
		}

private:
	bool _Active;
	_Cnd_t _MyCndp;
	};

class _Auto_mtx
	{	// clean up mutex on destruction
public:
	_Auto_mtx(_Mtx_t _Mtxp)
		: _Active(true), _MyMtxp(_Mtxp)
		{	// construct from mutex
		}

	~_Auto_mtx() noexcept
		{	// destroy the object
		if (_Active)
			_Mtx_destroy(_MyMtxp);
		}

	void _Release()
		{	// release the mutex
		_Active = false;
		}

private:
	bool _Active;
	_Mtx_t _MyMtxp;
	};

#pragma warning(push)
#pragma warning(disable: 4265)	
class __declspec(novtable) _Pad
	{	// base class for launching threads
public:
	_Pad()
		{	// initialize handshake
		_Cnd_initX(&_Cond);
		_Auto_cnd _Cnd_cleaner(_Cond);
		_Mtx_initX(&_Mtx, _Mtx_plain);
		_Auto_mtx _Mtx_cleaner(_Mtx);
		_Started = false;
		_Mtx_lockX(_Mtx);
		_Mtx_cleaner._Release();
		_Cnd_cleaner._Release();
		}

	~_Pad() noexcept
		{	// clean up handshake; non-virtual due to type-erasure
		_Auto_cnd _Cnd_cleaner(_Cond);
		_Auto_mtx _Mtx_cleaner(_Mtx);
		_Mtx_unlockX(_Mtx);
		}

	void _Launch(_Thrd_t *_Thr)
		{	// launch a thread
		_Thrd_startX(_Thr, _Call_func, this);
		while (!_Started)
			_Cnd_waitX(_Cond, _Mtx);
		}

	void _Release()
		{	// notify caller that it's okay to continue
		_Mtx_lockX(_Mtx);
		_Started = true;
		_Cnd_signalX(_Cond);
		_Mtx_unlockX(_Mtx);
		}

	virtual void _Go() = 0;

private:
	static unsigned int __stdcall _Call_func(void *_Data)
		{	// entry point for new thread
		static_cast<_Pad *>(_Data)->_Go();
		return (0);
		}

	_Cnd_t _Cond;
	_Mtx_t _Mtx;
	bool _Started;
	};

template<class _Target>
	class _LaunchPad final
		: public _Pad
	{	// stub for launching threads
public:
	template<class _Other> inline
		_LaunchPad(_Other&& _Tgt)
		: _MyTarget(::std:: forward<_Other>(_Tgt))
		{	// construct from target
		}

	virtual void _Go()
		{	// run the thread function object
		_Run(this);
		}

private:
	template<size_t... _Idxs>
		static void _Execute(typename _Target::element_type& _Tup,
			index_sequence<_Idxs...>)
		{	// invoke function object packed in tuple
		::std:: invoke(::std:: move(::std:: get<_Idxs>(_Tup))...);
		}

	static void _Run(_LaunchPad *_Ln) noexcept	// enforces termination
		{	// construct local unique_ptr and call function object within
		_Target _Local(::std:: forward<_Target>(_Ln->_MyTarget));
		_Ln->_Release();
		_Execute(*_Local,
			make_index_sequence<tuple_size_v<typename _Target::element_type>>());
		_Cnd_do_broadcast_at_thread_exit();
		}

	_Target _MyTarget;
	};
#pragma warning(pop)

template<class _Target> inline
	void _Launch(_Thrd_t *_Thr, _Target&& _Tg)
	{	// launch a new thread
	_LaunchPad<_Target> _Launcher(::std:: forward<_Target>(_Tg));
	_Launcher._Launch(_Thr);
	}
}

 
 
 #pragma warning(pop)
 #pragma pack(pop)



/*
 * Copyright (c) by P.J. Plauger. All rights reserved.
 * Consult your license regarding permissions and restrictions.
V6.50:0009 */



 #pragma pack(push,8)
 #pragma warning(push,3)
 #pragma warning(disable: 4455 4494  4619 4643 4702 4984 4988 )
 
 
 

namespace std {
class thread
	{	// class for observing and managing threads
public:
	class id;

	typedef void *native_handle_type;

	thread() noexcept
		{	// construct with no thread
		(_Thr._Hnd = nullptr, _Thr._Id = 0);
		}


	template<class _Fn,
		class... _Args,
		class = enable_if_t<!is_same_v<remove_cv_t<remove_reference_t<_Fn>>, thread>>>
		explicit thread(_Fn&& _Fx, _Args&&... _Ax)
		{	// construct with _Fx(_Ax...)
		_Launch(&_Thr,
			::std:: make_unique<tuple<decay_t<_Fn>, decay_t<_Args>...> >(
				::std:: forward<_Fn>(_Fx), ::std:: forward<_Args>(_Ax)...));
		}


	~thread() noexcept
		{	// clean up
		if (joinable())
			::std:: terminate();
		}

	thread(thread&& _Other) noexcept
		: _Thr(_Other._Thr)
		{	// move from _Other
		(_Other._Thr._Hnd = nullptr, _Other._Thr._Id = 0);
		}

	thread& operator=(thread&& _Other) noexcept
		{	// move from _Other
		return (_Move_thread(_Other));
		}

	thread(const thread&) = delete;
	thread& operator=(const thread&) = delete;

	void swap(thread& _Other) noexcept
		{	// swap with _Other
		::std:: swap(_Thr, _Other._Thr);
		}

	 bool joinable() const noexcept
		{	// return true if this thread can be joined
		return (!(_Thr._Id == 0));
		}

	void join();

	void detach()
		{	// detach thread
		if (!joinable())
			_Throw_Cpp_error(_INVALID_ARGUMENT);
		_Thrd_detachX(_Thr);
		(_Thr._Hnd = nullptr, _Thr._Id = 0);
		}

	 id get_id() const noexcept;

	 static unsigned int hardware_concurrency() noexcept
		{	// return number of hardware thread contexts
		return (_Thrd_hardware_concurrency());
		}

	 native_handle_type native_handle()
		{	// return Win32 HANDLE as void *
		return (_Thr._Hnd);
		}

private:
	thread& _Move_thread(thread& _Other)
		{	// move from _Other
		if (joinable())
			::std:: terminate();
		_Thr = _Other._Thr;
		(_Other._Thr._Hnd = nullptr, _Other._Thr._Id = 0);
		return (*this);
		}

	_Thrd_t _Thr;
	};

	namespace this_thread {
 thread::id get_id() noexcept;

inline void yield() noexcept
	{	// give up balance of time slice
	_Thrd_yield();
	}

inline void sleep_until(const stdext::threads::xtime *_Abs_time)
	{	// sleep until _Abs_time
	_Thrd_sleep(_Abs_time);
	}

template<class _Rep,
	class _Period> inline
	void sleep_for(const chrono::duration<_Rep, _Period>& _Rel_time)
	{	// sleep for duration
	stdext::threads::xtime _Tgt = _To_xtime(_Rel_time);
	this_thread::sleep_until(&_Tgt);
	}

template<class _Clock,
	class _Duration> inline
	void sleep_until(
		const chrono::time_point<_Clock, _Duration>& _Abs_time)
	{	// sleep until time point
	this_thread::sleep_for(_Abs_time.time_since_epoch() - _Clock::now().time_since_epoch());
	}
	}	// namespace this_thread

class thread::id
	{	// thread id
public:
	id() noexcept
		: _Id(0)
		{	// id for no thread
		}

	template<class _Ch,
		class _Tr>
		basic_ostream<_Ch, _Tr>& _To_text(
			basic_ostream<_Ch, _Tr>& _Str)
		{	// insert representation into stream
		return (_Str << _Id);
		}

private:
	id(_Thrd_id_t _Other_id)
		: _Id(_Other_id)
		{	// construct from unique id
		}

	_Thrd_id_t _Id;

	friend thread::id thread::get_id() const noexcept;
	friend thread::id this_thread::get_id() noexcept;
	friend bool operator==(thread::id _Left, thread::id _Right) noexcept;
	friend bool operator<(thread::id _Left, thread::id _Right) noexcept;
	friend hash<thread::id>;
	};

inline void thread::join()
	{	// join thread
	if (!joinable())
		_Throw_Cpp_error(_INVALID_ARGUMENT);
	const bool _Is_null = (_Thr._Id == 0);	// Avoid Clang -Wparentheses-equality
	if (_Is_null)
		_Throw_Cpp_error(_INVALID_ARGUMENT);
	if (get_id() == ::std:: this_thread::get_id())
		_Throw_Cpp_error(_RESOURCE_DEADLOCK_WOULD_OCCUR);
	if (_Thrd_join(_Thr, nullptr) != _Thrd_success)
		_Throw_Cpp_error(_NO_SUCH_PROCESS);
	(_Thr._Hnd = nullptr, _Thr._Id = 0);
	}

 inline thread::id thread::get_id() const noexcept
	{	// return id for this thread
	return (_Thr._Id);
	}

 inline thread::id this_thread::get_id() noexcept
	{	// return id for current thread
	return (_Thrd_id());
	}

inline void swap(thread& _Left, thread& _Right) noexcept
	{	// swap _Left with _Right
	_Left.swap(_Right);
	}

 inline bool operator==(thread::id _Left, thread::id _Right) noexcept
	{	// return true if _Left and _Right identify the same thread
	return (_Left._Id == _Right._Id);
	}

 inline bool operator!=(thread::id _Left, thread::id _Right) noexcept
	{	// return true if _Left and _Right do not identify the same thread
	return (!(_Left == _Right));
	}

 inline bool operator<(thread::id _Left, thread::id _Right) noexcept
	{	// return true if _Left precedes _Right
	return (_Left._Id < _Right._Id);
	}

 inline bool operator<=(thread::id _Left, thread::id _Right) noexcept
	{	// return true if _Left precedes or equals _Right
	return (!(_Right < _Left));
	}

 inline bool operator>(thread::id _Left, thread::id _Right) noexcept
	{	// return true if _Left follows _Right
	return (_Right < _Left);
	}

 inline bool operator>=(thread::id _Left, thread::id _Right) noexcept
	{	// return true if _Left follows or equals _Right
	return (!(_Left < _Right));
	}

template<class _Ch,
	class _Tr>
	basic_ostream<_Ch, _Tr>& operator<<(
		basic_ostream<_Ch, _Tr>& _Str,
		thread::id _Id)
	{	// insert id into stream
	return (_Id._To_text(_Str));
	}

	// STRUCT TEMPLATE SPECIALIZATION hash
template<>
	struct hash<thread::id>
	{	// hash functor for thread::id
	 typedef thread::id argument_type;
	 typedef size_t result_type;

	 size_t operator()(const thread::id _Keyval) const noexcept
		{	// hash _Keyval to size_t value by pseudorandomizing transform
		return (_Hash_representation(_Keyval._Id));
		}
	};
}

 
 
 #pragma warning(pop)
 #pragma pack(pop)



/*
 * Copyright (c) by P.J. Plauger. All rights reserved.
 * Consult your license regarding permissions and restrictions.
V6.50:0009 */





 #pragma pack(push,8)
 #pragma warning(push,3)
 #pragma warning(disable: 4455 4494  4619 4643 4702 4984 4988 )
 
 
 

namespace std {
class condition_variable;
class condition_variable_any;

	// MUTUAL EXCLUSION
class _Mutex_base
	{	// base class for all mutex types
public:
	_Mutex_base(int _Flags = 0) noexcept
		{	// construct with _Flags
		_Mtx_init_in_situ(_Mymtx(), _Flags | _Mtx_try);
		}

	~_Mutex_base() noexcept
		{	// clean up
		_Mtx_destroy_in_situ(_Mymtx());
		}

	_Mutex_base(const _Mutex_base&) = delete;
	_Mutex_base& operator=(const _Mutex_base&) = delete;

	void lock()
		{	// lock the mutex
		_Mtx_lockX(_Mymtx());
		}

	 bool try_lock()
		{	// try to lock the mutex
		return (_Mtx_trylockX(_Mymtx()) == _Thrd_success);
		}

	void unlock()
		{	// unlock the mutex
		_Mtx_unlockX(_Mymtx());
		}

	typedef void *native_handle_type;

	 native_handle_type native_handle()
		{	// return Concurrency::critical_section * as void *
		return (_Mtx_getconcrtcs(_Mymtx()));
		}

private:
	friend condition_variable;
	friend condition_variable_any;

	aligned_storage_t<80,
		8> _Mtx_storage;

	_Mtx_t _Mymtx() noexcept
		{	// get pointer to _Mtx_internal_imp_t inside _Mtx_storage
		return (reinterpret_cast<_Mtx_t>(&_Mtx_storage));
		}
	};

class mutex
	: public _Mutex_base
	{	// class for mutual exclusion
public:
	/* constexpr */ mutex() noexcept	// TRANSITION
		: _Mutex_base()
		{	// default construct
		}

	mutex(const mutex&) = delete;
	mutex& operator=(const mutex&) = delete;
	};

class recursive_mutex
	: public _Mutex_base
	{	// class for recursive mutual exclusion
public:
	recursive_mutex()
		: _Mutex_base(_Mtx_recursive)
		{	// default construct
		}

	 bool try_lock() noexcept
		{	// try to lock the mutex
		return (_Mutex_base::try_lock());
		}

	recursive_mutex(const recursive_mutex&) = delete;
	recursive_mutex& operator=(const recursive_mutex&) = delete;
	};


	// LOCK PROPERTIES
struct adopt_lock_t
	{	// indicates adopt lock
	explicit adopt_lock_t() = default;
	};

struct defer_lock_t
	{	// indicates defer lock
	explicit defer_lock_t() = default;
	};

struct try_to_lock_t
	{	// indicates try to lock
	explicit try_to_lock_t() = default;
	};

 constexpr adopt_lock_t adopt_lock{};
 constexpr defer_lock_t defer_lock{};
 constexpr try_to_lock_t try_to_lock{};

		// CLASS TEMPLATE unique_lock
template<class _Mutex>
	class unique_lock
	{	// whizzy class with destructor that unlocks mutex
public:
	typedef _Mutex mutex_type;

	// CONSTRUCT, ASSIGN, AND DESTROY
	unique_lock() noexcept
		: _Pmtx(nullptr), _Owns(false)
		{	// default construct
		}

	explicit unique_lock(_Mutex& _Mtx)
		: _Pmtx(::std:: addressof(_Mtx)), _Owns(false)
		{	// construct and lock
		_Pmtx->lock();
		_Owns = true;
		}

	unique_lock(_Mutex& _Mtx, adopt_lock_t)
		: _Pmtx(::std:: addressof(_Mtx)), _Owns(true)
		{	// construct and assume already locked
		}

	unique_lock(_Mutex& _Mtx, defer_lock_t) noexcept
		: _Pmtx(::std:: addressof(_Mtx)), _Owns(false)
		{	// construct but don't lock
		}

	unique_lock(_Mutex& _Mtx, try_to_lock_t)
		: _Pmtx(::std:: addressof(_Mtx)), _Owns(_Pmtx->try_lock())
		{	// construct and try to lock
		}

	template<class _Rep,
		class _Period>
		unique_lock(_Mutex& _Mtx,
			const chrono::duration<_Rep, _Period>& _Rel_time)
		: _Pmtx(::std:: addressof(_Mtx)), _Owns(_Pmtx->try_lock_for(_Rel_time))
		{	// construct and lock with timeout
		}

	template<class _Clock,
		class _Duration>
		unique_lock(_Mutex& _Mtx,
			const chrono::time_point<_Clock, _Duration>& _Abs_time)
		: _Pmtx(::std:: addressof(_Mtx)), _Owns(_Pmtx->try_lock_until(_Abs_time))
		{	// construct and lock with timeout
		}

	unique_lock(_Mutex& _Mtx, const xtime *_Abs_time)
		: _Pmtx(::std:: addressof(_Mtx)), _Owns(false)
		{	// try to lock until _Abs_time
		_Owns = _Pmtx->try_lock_until(_Abs_time);
		}

	unique_lock(unique_lock&& _Other) noexcept
		: _Pmtx(_Other._Pmtx), _Owns(_Other._Owns)
		{	// destructive copy
		_Other._Pmtx = nullptr;
		_Other._Owns = false;
		}

	unique_lock& operator=(unique_lock&& _Other)
		{	// destructive copy
		if (this != ::std:: addressof(_Other))
			{	// different, move contents
			if (_Owns)
				_Pmtx->unlock();
			_Pmtx = _Other._Pmtx;
			_Owns = _Other._Owns;
			_Other._Pmtx = nullptr;
			_Other._Owns = false;
			}
		return (*this);
		}

	~unique_lock() noexcept
		{	// clean up
		if (_Owns)
			_Pmtx->unlock();
		}

	unique_lock(const unique_lock&) = delete;
	unique_lock& operator=(const unique_lock&) = delete;

	void lock()
		{	// lock the mutex
		_Validate();
		_Pmtx->lock();
		_Owns = true;
		}

	 bool try_lock()
		{	// try to lock the mutex
		_Validate();
		_Owns = _Pmtx->try_lock();
		return (_Owns);
		}

	template<class _Rep,
		class _Period>
		 bool try_lock_for(const chrono::duration<_Rep, _Period>& _Rel_time)
		{	// try to lock mutex for _Rel_time
		_Validate();
		_Owns = _Pmtx->try_lock_for(_Rel_time);
		return (_Owns);
		}

	template<class _Clock,
		class _Duration>
		 bool try_lock_until(const chrono::time_point<_Clock, _Duration>& _Abs_time)
		{	// try to lock mutex until _Abs_time
		_Validate();
		_Owns = _Pmtx->try_lock_until(_Abs_time);
		return (_Owns);
		}

	 bool try_lock_until(const xtime *_Abs_time)
		{	// try to lock the mutex until _Abs_time
		_Validate();
		_Owns = _Pmtx->try_lock_until(_Abs_time);
		return (_Owns);
		}

	void unlock()
		{	// try to unlock the mutex
		if (!_Pmtx || !_Owns)
			throw system_error( ::std:: make_error_code(errc::operation_not_permitted));

		_Pmtx->unlock();
		_Owns = false;
		}

	void swap(unique_lock& _Other) noexcept
		{	// swap with _Other
		::std:: swap(_Pmtx, _Other._Pmtx);
		::std:: swap(_Owns, _Other._Owns);
		}

	_Mutex *release() noexcept
		{	// disconnect
		_Mutex *_Res = _Pmtx;
		_Pmtx = nullptr;
		_Owns = false;
		return (_Res);
		}

	 bool owns_lock() const noexcept
		{	// return true if this object owns the lock
		return (_Owns);
		}

	explicit operator bool() const noexcept
		{	// return true if this object owns the lock
		return (_Owns);
		}

	 _Mutex *mutex() const noexcept
		{	// return pointer to managed mutex
		return (_Pmtx);
		}

private:
	_Mutex *_Pmtx;
	bool _Owns;

	void _Validate() const
		{	// check if the mutex can be locked
		if (!_Pmtx)
			throw system_error( ::std:: make_error_code(errc::operation_not_permitted));

		if (_Owns)
			throw system_error( ::std:: make_error_code(errc::resource_deadlock_would_occur));
		}
	};

		// FUNCTION TEMPLATE swap FOR unique_lock
template<class _Mutex>
	void swap(unique_lock<_Mutex>& _Left,
		unique_lock<_Mutex>& _Right) noexcept
	{	// swap _Left and _Right
	_Left.swap(_Right);
	}

		// FUNCTION TEMPLATE _Lock_from_locks
template<size_t... _Indices,
	class... _LockN> inline
	void _Lock_from_locks(const int _Target, index_sequence<_Indices...>, _LockN&... _LkN)
	{	// lock _LkN[_Target]
	int _Ignored[] = { ((static_cast<int>(_Indices) == _Target
		? (void)_LkN.lock()
		: void()), 0)... };
	(void)_Ignored;
	}

		// FUNCTION TEMPLATE _Try_lock_from_locks
template<size_t... _Indices,
	class... _LockN> inline
	bool _Try_lock_from_locks(const int _Target, index_sequence<_Indices...>, _LockN&... _LkN)
	{	// try to lock _LkN[_Target]
	bool _Result{};
	int _Ignored[] = { ((static_cast<int>(_Indices) == _Target
		? (void)(_Result = _LkN.try_lock())
		: void()), 0)... };
	(void)_Ignored;
	return (_Result);
	}

		// FUNCTION TEMPLATE _Unlock_locks
template<size_t... _Indices,
	class... _LockN> inline
	void _Unlock_locks(const int _First, const int _Last, index_sequence<_Indices...>, _LockN&... _LkN)
	noexcept // enforces termination
	{	// unlock locks in _LkN[_First, _Last)
	int _Ignored[] = { ((_First <= static_cast<int>(_Indices) && static_cast<int>(_Indices) < _Last
		? (void)_LkN.unlock()
		: void()), 0)... };
	(void)_Ignored;
	}

		// FUNCTION TEMPLATE try_lock
template<class... _LockN> inline
	int _Try_lock_range(const int _First, const int _Last, _LockN&... _LkN)
	{	// try to lock all locks in _LkN[_First, _Last)
	using _Indices = index_sequence_for<_LockN...>;
	int _Next = _First;
	try {
	for (; _Next != _Last; ++_Next)
		{
		if (!_Try_lock_from_locks(_Next, _Indices{}, _LkN...))
			{	// try_lock failed, backout
			_Unlock_locks(_First, _Next, _Indices{}, _LkN...);
			return (_Next);
			}
		}
	} catch (...) {
	_Unlock_locks(_First, _Next, _Indices{}, _LkN...);
	throw;
	}

	return (-1);
	}

template<class _Lock0,
	class _Lock1,
	class _Lock2,
	class... _LockN> inline
	int _Try_lock1(_Lock0& _Lk0, _Lock1& _Lk1, _Lock2& _Lk2, _LockN&... _LkN)
	{	// try to lock 3 or more locks
	return (_Try_lock_range(0, sizeof...(_LockN) + 3, _Lk0, _Lk1, _Lk2, _LkN...));
	}

template<class _Lock0,
	class _Lock1> inline
	int _Try_lock1(_Lock0& _Lk0, _Lock1& _Lk1)
	{	// try to lock 2 locks, special case for better codegen and reduced metaprogramming for common case
	if (!_Lk0.try_lock())
		{
		return (0);
		}

	try {
	if (!_Lk1.try_lock())
		{
		_Lk0.unlock();
		return (1);
		}
	} catch (...) {
	_Lk0.unlock();
	throw;
	}

	return (-1);
	}

template<class _Lock0,
	class _Lock1,
	class... _LockN>
	 inline int try_lock(_Lock0& _Lk0, _Lock1& _Lk1, _LockN&... _LkN)
	{	// try to lock multiple locks
	return (_Try_lock1(_Lk0, _Lk1, _LkN...));
	}


		// FUNCTION TEMPLATE lock
template<class... _LockN> inline
	int _Lock_attempt(const int _Hard_lock, _LockN&... _LkN)
	{	// attempt to lock 3 or more locks, starting by locking _LkN[_Hard_lock] and trying to lock the rest
	using _Indices = index_sequence_for<_LockN...>;
	_Lock_from_locks(_Hard_lock, _Indices{}, _LkN...);
	int _Failed = -1;
	int _Backout_start = _Hard_lock; // that is, unlock _Hard_lock

	try {
	_Failed = _Try_lock_range(0, _Hard_lock, _LkN...);
	if (_Failed == -1)
		{
		_Backout_start = 0; // that is, unlock [0, _Hard_lock] if the next throws
		_Failed = _Try_lock_range(_Hard_lock + 1, sizeof...(_LockN), _LkN...);
		if (_Failed == -1)
			{	// we got all the locks
			return (-1);
			}
		}
	} catch (...) {
	_Unlock_locks(_Backout_start, _Hard_lock + 1, _Indices{}, _LkN...);
	throw;
	}

	// we didn't get all the locks, backout
	_Unlock_locks(_Backout_start, _Hard_lock + 1, _Indices{}, _LkN...);
	::std:: this_thread::yield();
	return (_Failed);
	}

template<class _Lock0,
	class _Lock1,
	class _Lock2,
	class... _LockN> inline
	void _Lock_nonmember1(_Lock0& _Lk0, _Lock1& _Lk1, _Lock2& _Lk2, _LockN&... _LkN)
	{	// lock 3 or more locks, without deadlock
	int _Hard_lock = 0;
	while (_Hard_lock != -1)
		{
		_Hard_lock = _Lock_attempt(_Hard_lock, _Lk0, _Lk1, _Lk2, _LkN...);
		}
	}

template<class _Lock0,
	class _Lock1> inline
	bool _Lock_attempt_small(_Lock0& _Lk0, _Lock1& _Lk1)
	{	// attempt to lock 2 locks, by first locking _Lk0, and then trying to lock _Lk1
		// returns whether to try again
	_Lk0.lock();
	try {
	if (_Lk1.try_lock())
		{
		return (false);
		}
	} catch (...) {
	_Lk0.unlock();
	throw;
	}

	_Lk0.unlock();
	::std:: this_thread::yield();
	return (true);
	}

template<class _Lock0,
	class _Lock1> inline
	void _Lock_nonmember1(_Lock0& _Lk0, _Lock1& _Lk1)
	{	// lock 2 locks, without deadlock, special case for better codegen and reduced metaprogramming for common case
	while (_Lock_attempt_small(_Lk0, _Lk1)
		&& _Lock_attempt_small(_Lk1, _Lk0))
		{	// keep trying
		}
	}

template<class _Lock0,
	class _Lock1,
	class... _LockN> inline
	void lock(_Lock0& _Lk0, _Lock1& _Lk1, _LockN&... _LkN)
	{	// lock multiple locks, without deadlock
	_Lock_nonmember1(_Lk0, _Lk1, _LkN...);
	}


		// CLASS TEMPLATE lock_guard
template<class _Mutex>
	class lock_guard
	{	// class with destructor that unlocks a mutex
public:
	using mutex_type = _Mutex;

	explicit lock_guard(_Mutex& _Mtx)
		: _MyMutex(_Mtx)
		{	// construct and lock
		_MyMutex.lock();
		}

	lock_guard(_Mutex& _Mtx, adopt_lock_t)
		: _MyMutex(_Mtx)
		{	// construct but don't lock
		}

	~lock_guard() noexcept
		{	// unlock
		_MyMutex.unlock();
		}

	lock_guard(const lock_guard&) = delete;
	lock_guard& operator=(const lock_guard&) = delete;
private:
	_Mutex& _MyMutex;
	};

















































































		// FUNCTION TEMPLATE _Invoke_stored_explicit
template<class... _Types,
	size_t... _Indices> inline
	auto _Invoke_stored_explicit(tuple<_Types...>&& _Tuple, index_sequence<_Indices...>)
		-> decltype(::std:: invoke(::std:: get<_Indices>(::std:: move(_Tuple))...))
	{	// invoke() a tuple with explicit parameter ordering
	return (::std:: invoke(::std:: get<_Indices>(::std:: move(_Tuple))...));
	}

		// FUNCTION TEMPLATE _Invoke_stored
template<class... _Types> inline
	auto _Invoke_stored(tuple<_Types...>&& _Tuple)
		-> decltype(_Invoke_stored_explicit(::std:: move(_Tuple), index_sequence_for<_Types...>()))
	{	// invoke() a tuple
	return (_Invoke_stored_explicit(::std:: move(_Tuple), index_sequence_for<_Types...>()));
	}

		// FUNCTION TEMPLATE call_once
[[noreturn]]  void __cdecl _XGetLastError();

template<class _Tuple,
	class _Seq,
	size_t _Idx> inline
	int __stdcall _Callback_once(void *, void *_Pv, void **)
	{	// adapt call_once() to callback API
	_Tuple *_Ptup = static_cast<_Tuple *>(_Pv);

	try {
		// Note explicit _Seq() selects every element from *_Ptup except the last,
		// which contains call_once's exception_ptr.
		_Invoke_stored_explicit(::std:: move(*_Ptup), _Seq());
	} catch (...) {
		auto& _Ref = ::std:: get<_Idx>(*_Ptup);
		_Ref = ::std:: current_exception();
		return (0);
	}

	return (1);
	}

template<class _Fn,
	class... _Args> inline
	void (call_once)(once_flag& _Flag, _Fn&& _Fx, _Args&&... _Ax)
	{	// call _Fx(_Ax...) once
	typedef tuple<_Fn&&, _Args&&..., exception_ptr&> _Tuple;
	typedef make_index_sequence<1 + sizeof...(_Args)> _Seq;

	exception_ptr _Exc;
	_Tuple _Tup(::std:: forward<_Fn>(_Fx), ::std:: forward<_Args>(_Ax)..., _Exc);

	_Execute_once_fp_t _Fp = &_Callback_once<_Tuple, _Seq, 1 + sizeof...(_Args)>;

	if (_Execute_once(_Flag, _Fp, ::std:: addressof(_Tup)) != 0)
		return;

	if (_Exc)
		::std:: rethrow_exception(_Exc);

	_XGetLastError();
	}

enum class cv_status {	// names for wait returns
	no_timeout,
	timeout
	};

class condition_variable
	{	// class for waiting for conditions
public:
	typedef _Cnd_t native_handle_type;

	condition_variable()
		{	// construct
		_Cnd_init_in_situ(_Mycnd());
		}

	~condition_variable() noexcept
		{	// destroy
		_Cnd_destroy_in_situ(_Mycnd());
		}

	condition_variable(const condition_variable&) = delete;
	condition_variable& operator=(const condition_variable&) = delete;

	void notify_one() noexcept
		{	// wake up one waiter
		_Cnd_signalX(_Mycnd());
		}

	void notify_all() noexcept
		{	// wake up all waiters
		_Cnd_broadcastX(_Mycnd());
		}

	void wait(unique_lock<mutex>& _Lck)
		{	// wait for signal
		// Nothing to do to comply with LWG 2135 because std::mutex lock/unlock are nothrow
		_Cnd_waitX(_Mycnd(), _Lck.mutex()->_Mymtx());
		}

	template<class _Predicate>
		void wait(unique_lock<mutex>& _Lck, _Predicate _Pred)
		{	// wait for signal and test predicate
		while (!_Pred())
			wait(_Lck);
		}

	template<class _Rep,
		class _Period>
		cv_status wait_for(
			unique_lock<mutex>& _Lck,
			const chrono::duration<_Rep, _Period>& _Rel_time)
		{	// wait for duration
		::stdext:: threads::xtime _Tgt = _To_xtime(_Rel_time);
		return (wait_until(_Lck, &_Tgt));
		}

	template<class _Rep,
		class _Period,
		class _Predicate>
		bool wait_for(
			unique_lock<mutex>& _Lck,
			const chrono::duration<_Rep, _Period>& _Rel_time,
			_Predicate _Pred)
		{	// wait for signal with timeout and check predicate
		::stdext:: threads::xtime _Tgt = _To_xtime(_Rel_time);
		return (_Wait_until1(_Lck, &_Tgt, _Pred));
		}

	template<class _Clock,
		class _Duration>
		cv_status wait_until(
			unique_lock<mutex>& _Lck,
			const chrono::time_point<_Clock, _Duration>& _Abs_time)
		{	// wait until time point
		::stdext:: threads::xtime _Tgt = _To_xtime(_Abs_time - _Clock::now());
		return (wait_until(_Lck, &_Tgt));
		}

	template<class _Clock,
		class _Duration,
		class _Predicate>
		bool wait_until(
			unique_lock<mutex>& _Lck,
			const chrono::time_point<_Clock, _Duration>& _Abs_time,
			_Predicate _Pred)
		{	// wait for signal with timeout and check predicate
		::stdext:: threads::xtime _Tgt = _To_xtime(_Abs_time - _Clock::now());
		return (_Wait_until1(_Lck, &_Tgt, _Pred));
		}

	cv_status wait_until(
		unique_lock<mutex>& _Lck,
		const xtime *_Abs_time)
		{	// wait for signal with timeout
		if (!_Mtx_current_owns(_Lck.mutex()->_Mymtx()))
			_Throw_Cpp_error(_OPERATION_NOT_PERMITTED);

		// Nothing to do to comply with LWG 2135 because std::mutex lock/unlock are nothrow
		const int _Res = _Cnd_timedwaitX(_Mycnd(),
			_Lck.mutex()->_Mymtx(), _Abs_time);
		return (_Res == _Thrd_timedout
			? cv_status::timeout : cv_status::no_timeout);
		}

	template<class _Predicate>
		bool wait_until(
			unique_lock<mutex>& _Lck,
			const xtime *_Abs_time,
			_Predicate _Pred)
		{	// wait for signal with timeout and check predicate
		return (_Wait_until1(_Lck, _Abs_time, _Pred));
		}

	 native_handle_type native_handle()
		{	// return condition variable handle
		return (_Mycnd());
		}

	void _Register(unique_lock<mutex>& _Lck, int *_Ready)
		{	// register this object for release at thread exit
		_Cnd_register_at_thread_exit(_Mycnd(),
			_Lck.release()->_Mymtx(), _Ready);
		}

	void _Unregister(mutex& _Mtx)
		{	// unregister this object for release at thread exit
		_Cnd_unregister_at_thread_exit(_Mtx._Mymtx());
		}

private:
	aligned_storage_t<72,
		8> _Cnd_storage;

	_Cnd_t _Mycnd() noexcept
		{	// get pointer to _Cnd_internal_imp_t inside _Cnd_storage
		return (reinterpret_cast<_Cnd_t>(&_Cnd_storage));
		}

	template<class _Predicate>
		bool _Wait_until1(
			unique_lock<mutex>& _Lck,
			const xtime *_Abs_time,
			_Predicate& _Pred)
		{	// wait for signal with timeout and check predicate
		while (!_Pred())
			if (wait_until(_Lck, _Abs_time) == cv_status::timeout)
				return (_Pred());
		return (true);
		}
	};

struct _UInt_is_zero
	{
	const unsigned int& _UInt;

	 bool operator()() const
		{
		return (_UInt == 0);
		}
	};

class timed_mutex
	{	// class for timed mutual exclusion
public:
	timed_mutex() noexcept
		: _My_locked(0)
		{	// default construct
		}

	timed_mutex(const timed_mutex&) = delete;
	timed_mutex& operator=(const timed_mutex&) = delete;

	void lock()
		{	// lock the mutex
		unique_lock<mutex> _Lock(_My_mutex);
		while (_My_locked != 0)
			_My_cond.wait(_Lock);
		_My_locked = 0xffffffff;
		}

	 bool try_lock() noexcept
		{	// try to lock the mutex
		lock_guard<mutex> _Lock(_My_mutex);
		if (_My_locked != 0)
			return (false);
		else
			{
			_My_locked = 0xffffffff;
			return (true);
			}
		}

	void unlock()
		{	// unlock the mutex
			{
			// The lock here is necessary
			lock_guard<mutex> _Lock(_My_mutex);
			_My_locked = 0;
			}
		_My_cond.notify_one();
		}

	template<class _Rep,
		class _Period>
		 bool try_lock_for(const chrono::duration<_Rep, _Period>& _Rel_time)
		{	// try to lock for duration
		return (try_lock_until(chrono::steady_clock::now() + _Rel_time));
		}

	template<class _Time>
		bool _Try_lock_until(_Time _Abs_time)
		{	// try to lock the mutex with timeout
		unique_lock<mutex> _Lock(_My_mutex);
		if (!_My_cond.wait_until(_Lock, _Abs_time, _UInt_is_zero{_My_locked}))
			{
			return (false);
			}

		_My_locked = 0xffffffff;
		return (true);
		}

	template<class _Clock,
		class _Duration>
		 bool try_lock_until(const chrono::time_point<_Clock, _Duration>& _Abs_time)
		{	// try to lock the mutex with timeout
		return (_Try_lock_until(_Abs_time));
		}

	 bool try_lock_until(const xtime *_Abs_time)
		{	// try to lock the mutex with timeout
		return (_Try_lock_until(_Abs_time));
		}

private:
	mutex _My_mutex;
	condition_variable _My_cond;
	unsigned int _My_locked;
	};

class recursive_timed_mutex
	{	// class for recursive timed mutual exclusion
public:
	recursive_timed_mutex() noexcept
		: _My_locked(0)
		{	// default construct
		}

	recursive_timed_mutex(const recursive_timed_mutex&) = delete;
	recursive_timed_mutex& operator=(const recursive_timed_mutex&) = delete;

	void lock()
		{	// lock the mutex
		const thread::id _Tid = this_thread::get_id();

		unique_lock<mutex> _Lock(_My_mutex);

		if (_Tid == _My_owner)
			{
			if (_My_locked < 0xffffffff)
				{
				++_My_locked;
				}
			else
				{
				throw system_error(::std:: make_error_code(errc::device_or_resource_busy));
				}
			}
		else
			{
			while (_My_locked != 0)
				{
				_My_cond.wait(_Lock);
				}

			_My_locked = 1;
			_My_owner = _Tid;
			}
		}

	 bool try_lock() noexcept
		{	// try to lock the mutex
		const thread::id _Tid = this_thread::get_id();

		lock_guard<mutex> _Lock(_My_mutex);

		if (_Tid == _My_owner)
			{
			if (_My_locked < 0xffffffff)
				{
				++_My_locked;
				}
			else
				{
				return (false);
				}
			}
		else
			{
			if (_My_locked != 0)
				{
				return (false);
				}
			else
				{
				_My_locked = 1;
				_My_owner = _Tid;
				}
			}
		return (true);
		}

	void unlock()
		{	// unlock the mutex
		bool _Do_notify = false;

			{
			lock_guard<mutex> _Lock(_My_mutex);
			--_My_locked;
			if (_My_locked == 0)
				{
				_Do_notify = true;
				_My_owner = thread::id();
				}
			}

		if (_Do_notify)
			{
			_My_cond.notify_one();
			}
		}

	template<class _Rep,
		class _Period>
		 bool try_lock_for(const chrono::duration<_Rep, _Period>& _Rel_time)
		{	// try to lock for duration
		return (try_lock_until(chrono::steady_clock::now() + _Rel_time));
		}

	template<class _Time>
		bool _Try_lock_until(_Time _Abs_time)
		{	// try to lock the mutex with timeout
		const thread::id _Tid = this_thread::get_id();

		unique_lock<mutex> _Lock(_My_mutex);

		if (_Tid == _My_owner)
			{
			if (_My_locked < 0xffffffff)
				{
				++_My_locked;
				}
			else
				{
				return (false);
				}
			}
		else
			{
			if (!_My_cond.wait_until(_Lock, _Abs_time, _UInt_is_zero{_My_locked}))
				{
				return (false);
				}

			_My_locked = 1;
			_My_owner = _Tid;
			}
		return (true);
		}

	template<class _Clock,
		class _Duration>
		 bool try_lock_until(const chrono::time_point<_Clock, _Duration>& _Abs_time)
		{	// try to lock the mutex with timeout
		return (_Try_lock_until(_Abs_time));
		}

	 bool try_lock_until(const xtime *_Abs_time)
		{	// try to lock the mutex with timeout
		return (_Try_lock_until(_Abs_time));
		}

private:
	mutex _My_mutex;
	condition_variable _My_cond;
	unsigned int _My_locked;
	thread::id _My_owner;
	};
}
 
 
 #pragma warning(pop)
 #pragma pack(pop)



/*
 * Copyright (c) by P.J. Plauger. All rights reserved.
 * Consult your license regarding permissions and restrictions.
V6.50:0009 */


#pragma once



// iostream standard header
#pragma once





 #pragma pack(push,8)
 #pragma warning(push,3)
 #pragma warning(disable: 4455 4494  4619 4643 4702 4984 4988 )
 
 
 
namespace std {
  











		// OBJECTS
 extern __declspec(dllimport) istream cin, *_Ptr_cin;
 extern __declspec(dllimport) ostream cout, *_Ptr_cout;
 extern __declspec(dllimport) ostream cerr, *_Ptr_cerr;
 extern __declspec(dllimport) ostream clog, *_Ptr_clog;

 extern __declspec(dllimport) wistream wcin, *_Ptr_wcin;
 extern __declspec(dllimport) wostream wcout, *_Ptr_wcout;
 extern __declspec(dllimport) wostream wcerr, *_Ptr_wcerr;
 extern __declspec(dllimport) wostream wclog, *_Ptr_wclog;

		// CLASS _Winit
class __declspec(dllimport) _Winit {
public:
	__thiscall _Winit();
	__thiscall ~_Winit() noexcept;
private:
	 static int _Init_cnt;
	};
  
}
 
 
 #pragma warning(pop)
 #pragma pack(pop)



/*
 * Copyright (c) by P.J. Plauger. All rights reserved.
 * Consult your license regarding permissions and restrictions.
V6.50:0009 */


#pragma once


// locale standard header
#pragma once





// xlocbuf internal header (from <locale>)
#pragma once





 #pragma pack(push,8)
 #pragma warning(push,3)
 #pragma warning(disable: 4455 4494  4619 4643 4702 4984 4988 )
 
 
 

namespace std {
#pragma warning(push)
#pragma warning(disable: 4996)
		// CLASS TEMPLATE wbuffer_convert
template<class _Codecvt,
	class _Elem = wchar_t,
	class _Traits = char_traits<_Elem> >
	class  wbuffer_convert
		: public basic_streambuf<_Elem, _Traits>
	{	// stream buffer associated with a codecvt facet
	enum _Mode {_Unused, _Wrote, _Need, _Got, _Eof};
	enum {_STRING_INC = 8};
public:
	typedef streambuf _Mysb;
	typedef char_traits<char> _Byte_traits;

	typedef typename _Traits::int_type int_type;
	typedef typename _Traits::pos_type pos_type;
	typedef typename _Traits::off_type off_type;
	typedef typename _Codecvt::state_type state_type;

	explicit wbuffer_convert(_Mysb *_Strbuf = nullptr)
		: _State(), _Pcvt(new _Codecvt),
			_Mystrbuf(_Strbuf), _Status(_Unused), _Nback(0)
		{	// construct with byte stream buffer pointer
		_Loc = locale(_Loc, _Pcvt);
		}

	wbuffer_convert(_Mysb *_Strbuf, const _Codecvt *_Pcvt_arg)
		: _State(), _Pcvt(_Pcvt_arg),
			_Mystrbuf(_Strbuf), _Status(_Unused), _Nback(0)
		{	// construct with byte stream buffer pointer and codecvt
		_Loc = locale(_Loc, _Pcvt);
		}

	wbuffer_convert(_Mysb *_Strbuf,
		const _Codecvt *_Pcvt_arg, state_type _State_arg)
		: _State(_State_arg), _Pcvt(_Pcvt_arg),
			_Mystrbuf(_Strbuf), _Status(_Unused), _Nback(0)
		{	// construct with byte stream buffer pointer, codecvt, and state
		_Loc = locale(_Loc, _Pcvt);
		}

	virtual ~wbuffer_convert() noexcept
		{	// destroy the object
		char *_Buf = (char *)_Str.c_str();

		while (_Status == _Wrote)
			{	// put any trailing homing shift
			char *_Dest;

			if (_Str.size() < _STRING_INC)
				_Str.assign(_STRING_INC, '\0');
			switch (_Pcvt->unshift(_State,
				_Buf, _Buf + _Str.size(), _Dest))
				{	// test result of homing conversion
			case _Codecvt::ok:
				_Status = _Unused;	// homed successfully

			case _Codecvt::partial:	// fall through
				{	// put any generated bytes
				int _Count = (int)(_Dest - _Buf);
				if (0 < _Count
					&& _Byte_traits::eq_int_type(
						_Byte_traits::eof(),
						(_Byte_traits::int_type)_Mystrbuf->sputn(_Buf,
						_Count)))
					return;	// write failed

				if (_Status == _Wrote && _Count == 0)
					_Str.append(_STRING_INC, '\0');	// try with more space
				break;
				}

			case _Codecvt::noconv:
				return;	// nothing to do

			default:
				return;	// conversion failed
				}
			}
		}

	 _Mysb *rdbuf() const
		{	// return byte stream buffer pointer
		return (_Mystrbuf);
		}

	_Mysb *rdbuf(_Mysb *_Strbuf)
		{	// set byte stream buffer pointer
		_Mysb *_Oldstrbuf = _Mystrbuf;
		_Mystrbuf = _Strbuf;
		return (_Oldstrbuf);
		}

	 state_type state() const
		{	// get state
		return (_State);
		}

	wbuffer_convert(const wbuffer_convert&) = delete;
	wbuffer_convert& operator=(const wbuffer_convert&) = delete;

protected:
	virtual int_type overflow(int_type _Meta = _Traits::eof())
		{	// put an element to stream
		if (_Traits::eq_int_type(_Traits::eof(), _Meta))
			return (_Traits::not_eof(_Meta));	// EOF, return success code
		else if (_Mystrbuf == nullptr || 0 < _Nback
			|| (_Status != _Unused && _Status != _Wrote))
			return (_Traits::eof());	// no buffer or reading, fail
		else
			{	// put using codecvt facet
			char *_Buf = (char *)_Str.c_str();
			const _Elem _Ch = _Traits::to_char_type(_Meta);
			const _Elem *_Src;
			char *_Dest;

			if (_Str.size() < _STRING_INC)
				_Str.assign(_STRING_INC, '\0');
			for (_Status = _Wrote; ; )
				switch (_Pcvt->out(_State,
					&_Ch, &_Ch + 1, _Src,
					_Buf, _Buf + _Str.size(), _Dest))
				{	// test result of converting one element
				case _Codecvt::partial:
				case _Codecvt::ok:
					{	// converted something, try to put it out
					int _Count = (int)(_Dest - _Buf);
					if (0 < _Count
						&& _Byte_traits::eq_int_type(
							_Byte_traits::eof(),
							(_Byte_traits::int_type)_Mystrbuf->sputn(_Buf,
							_Count)))
						{
						return (_Traits::eof());	// write failed
						}

					if (_Src != &_Ch)
						{
						return (_Meta);	// converted whole element
						}

					if (0 >= _Count)
						{
						if (_Str.size() >= 4 * _STRING_INC)
							{
							return (_Traits::eof());	// conversion failed
							}

						_Str.append(_STRING_INC, '\0');	// try with more space
						}

					break;
					}

				case _Codecvt::noconv:
					if (_Traits::eq_int_type(
						_Traits::eof(),
						(typename _Traits::int_type)_Mystrbuf->sputn(
							(char *)&_Ch,
							(streamsize)sizeof (_Elem))))
						{
						return (_Traits::eof());
						}

					return (_Meta);	// put native byte order

				default:
					return (_Traits::eof());	// conversion failed
				}
			}
		}

	virtual int_type pbackfail(int_type _Meta = _Traits::eof())
		{	// put an element back to stream
		if (sizeof (_Myback) / sizeof (_Myback[0]) <= _Nback
			|| _Status == _Wrote)
			return (_Traits::eof());	// nowhere to put back
		else
			{	// enough room, put it back
			if (!_Traits::eq_int_type(_Traits::eof(), _Meta))
				_Myback[_Nback] = _Traits::to_char_type(_Meta);
			++_Nback;
			if (_Status == _Unused)
				_Status = _Got;
			return (_Meta);
			}
		}

	virtual int_type underflow()
		{	// get an element from stream, but don't point past it
		int_type _Meta;

		if (0 >= _Nback)
			{
			if (_Traits::eq_int_type(_Traits::eof(), _Meta = _Get_elem()))
				{
				return (_Meta);	// _Get_elem failed, return EOF
				}

			_Myback[_Nback++] = _Traits::to_char_type(_Meta);
			}

		return (_Traits::to_int_type(_Myback[_Nback - 1]));
		}

#pragma warning(push)
#pragma warning(disable: 6385)	
								// the readable size is 'X' bytes, but 'Y' bytes may be read.
	virtual int_type uflow()
		{	// get an element from stream, point past it
		int_type _Meta;

		if (0 >= _Nback)
			{
			if (_Traits::eq_int_type(_Traits::eof(), _Meta = _Get_elem()))
				{
				return (_Meta);	// _Get_elem failed, return EOF
				}

			_Myback[_Nback++] = _Traits::to_char_type(_Meta);
			}

		return (_Traits::to_int_type(_Myback[--_Nback]));
		}
#pragma warning(pop)

	virtual pos_type seekoff(off_type,
		ios::seekdir,
		ios::openmode =
			(ios::openmode)(ios::in | ios::out))
		{	// change position by _Off
		return (pos_type(-1));	// always fail
		}

	virtual pos_type seekpos(pos_type,
		ios::openmode =
			(ios::openmode)(ios::in | ios::out))
		{	// change position to _Pos
		return (pos_type(-1));	// always fail
		}

private:
	int_type _Get_elem()
		{	// compose an element from byte stream buffer
		if (_Mystrbuf != nullptr && _Status != _Wrote)
			{	// got buffer, haven't written, try to compose an element
			if (_Status != _Eof)
				{
				if (_Str.empty())
					{
					_Status = _Need;
					}
				else
					{
					_Status = _Got;
					}
				}

			while (_Status != _Eof)
				{	// get using codecvt facet
				char *_Buf = (char *)_Str.c_str();
				_Elem _Ch, *_Dest;
				const char *_Src;
				int _Meta;

				if (_Status == _Need)
					{
					if (_Byte_traits::eq_int_type(_Byte_traits::eof(),
						_Meta = _Mystrbuf->sbumpc()))
						{
						_Status = _Eof;
						}
					else
						{
						_Str.push_back(_Byte_traits::to_char_type(_Meta));
						}
					}

				switch (_Pcvt->in(_State,
					_Buf, _Buf + _Str.size(), _Src,
					&_Ch, &_Ch + 1, _Dest))
					{	// test result of converting one element
				case _Codecvt::partial:
				case _Codecvt::ok:
					_Str.erase((size_t)0,	// discard any used input
						(size_t)(_Src - _Buf));
					if (_Dest != &_Ch)
						return (_Traits::to_int_type(_Ch));
					break;

				case _Codecvt::noconv:
					if (_Str.size() < sizeof (_Elem))
						break;	// no conversion, but need more chars
					:: memcpy(&_Ch, _Buf,
						sizeof (_Elem));	// copy raw bytes to element
					_Str.erase((size_t)0, sizeof (_Elem));
					return (_Traits::to_int_type(_Ch));	// return result

				default:
					_Status = _Eof;	// conversion failed
					}
				}
			}

		return (_Traits::eof());
		}

	state_type _State;	// code conversion state
	const _Codecvt *_Pcvt;	// the codecvt facet
	_Mysb *_Mystrbuf;	// pointer to stream buffer
	_Mode _Status;		// buffer read/write status
	size_t _Nback;			// number of elements in putback buffer
	_Elem _Myback[8];	// putback buffer
	string _Str;	// unconsumed input bytes
	locale _Loc;	// manages reference to codecvt facet
	};

		// CLASS TEMPLATE wstring_convert
template<class _Codecvt,
	class _Elem = wchar_t,
	class _Walloc = allocator<_Elem>,
	class _Balloc = allocator<char> >
	class  wstring_convert
	{	// converts between _Elem (wide) and char (byte) strings
	enum {_BUF_INC = 8, _BUF_MAX = 16};
	void _Init(const _Codecvt *_Pcvt_arg = new _Codecvt)
		{	// initialize the object
		_State = state_type{};
		_Pcvt = _Pcvt_arg;
		_Loc = locale(_Loc, _Pcvt);
		_Nconv = 0;
		}

public:
	typedef basic_string<char, char_traits<char>, _Balloc> byte_string;
	typedef basic_string<_Elem, char_traits<_Elem>, _Walloc> wide_string;
	typedef typename _Codecvt::state_type state_type;
	typedef typename wide_string::traits_type::int_type int_type;

	wstring_convert()
		: _Has_state(false), _Has_berr(false), _Has_werr(false)
		{	// construct with no error strings
		_Init();
		}

	explicit wstring_convert(const _Codecvt *_Pcvt_arg)
		: _Has_state(false), _Has_berr(false), _Has_werr(false)
		{	// construct with no error strings and codecvt
		_Init(_Pcvt_arg);
		}

	wstring_convert(const _Codecvt *_Pcvt_arg, state_type _State_arg)
		: _Has_state(true), _Has_berr(false), _Has_werr(false)
		{	// construct with no error strings, codecvt, and state
		_Init(_Pcvt_arg);
		_State = _State_arg;
		}

	explicit wstring_convert(const byte_string& _Berr_arg)
		: _Berr(_Berr_arg), _Has_state(false), _Has_berr(true), _Has_werr(false)
		{	// construct with byte error string
		_Init();
		}

	wstring_convert(const byte_string& _Berr_arg,
		const wide_string& _Werr_arg)
		: _Berr(_Berr_arg), _Werr(_Werr_arg), _Has_state(false), _Has_berr(true), _Has_werr(true)
		{	// construct with byte and wide error strings
		_Init();
		}

	virtual ~wstring_convert() noexcept
		{	// destroy the object
		}

	 size_t converted() const noexcept
		{	// get conversion count
		return (_Nconv);
		}

	 state_type state() const
		{	// get state
		return (_State);
		}

	 wide_string from_bytes(char _Byte)
		{	// convert a byte to a wide string
		return (from_bytes(&_Byte, &_Byte + 1));
		}

	 wide_string from_bytes(const char *_Ptr)
		{	// convert a NTBS to a wide string
		return (from_bytes(_Ptr, _Ptr + :: strlen(_Ptr)));
		}

	 wide_string from_bytes(const byte_string& _Bstr)
		{	// convert a byte string to a wide string
		const char *_Ptr = _Bstr.c_str();
		return (from_bytes(_Ptr, _Ptr + _Bstr.size()));
		}

	 wide_string from_bytes(const char *_First, const char *_Last)
		{	// convert byte sequence [_First, _Last) to a wide string
		wide_string _Wbuf, _Wstr;
		const char *_First_sav = _First;

		if (!_Has_state)
			_State = state_type{};	// reset state if not remembered
		_Wbuf.append((:: size_t)_BUF_INC, (_Elem)'\0');
		for (_Nconv = 0; _First != _Last; _Nconv = static_cast<size_t>(_First - _First_sav))
			{	// convert one or more bytes
			_Elem *_Dest = &*_Wbuf.begin();
			_Elem *_Dnext;

			switch (_Pcvt->in(_State,
				_First, _Last, _First,
				_Dest, _Dest + _Wbuf.size(), _Dnext))
				{	// test result of converting one or more bytes
			case _Codecvt::partial:
			case _Codecvt::ok:
				if (_Dest < _Dnext)
					_Wstr.append(_Dest, static_cast<size_t>(_Dnext - _Dest));
				else if (_Wbuf.size() < _BUF_MAX)
					_Wbuf.append(static_cast<size_t>(_BUF_INC), '\0');
				else if (_Has_werr)
					return (_Werr);
				else
					throw range_error("bad conversion");
				break;

			case _Codecvt::noconv:
				for (; _First != _Last; ++_First)
					_Wstr.push_back((_Elem)(unsigned char)*_First);
				break;	// no conversion, just copy code values

			default:
				if (_Has_werr)
					return (_Werr);
				else
					throw range_error("bad conversion");
				}
			}
		return (_Wstr);
		}

	 byte_string to_bytes(_Elem _Char)
		{	// convert a wide char to a byte string
		return (to_bytes(&_Char, &_Char + 1));
		}

	 byte_string to_bytes(const _Elem *_Wptr)
		{	// convert a NTWCS to a byte string
		const _Elem *_Next = _Wptr;
		while ((int_type)*_Next != 0)
			{
			++_Next;
			}

		return (to_bytes(_Wptr, _Next));
		}

	 byte_string to_bytes(const wide_string& _Wstr)
		{	// convert a wide string to a byte string
		const _Elem *_Wptr = _Wstr.c_str();
		return (to_bytes(_Wptr, _Wptr + _Wstr.size()));
		}

	 byte_string to_bytes(const _Elem *_First, const _Elem *_Last)
		{	// convert wide sequence [_First, _Last) to a byte string
		byte_string _Bbuf, _Bstr;
		const _Elem *_First_sav = _First;

		if (!_Has_state)
			_State = state_type{};	// reset state if not remembered
		_Bbuf.append((:: size_t)_BUF_INC, '\0');
		for (_Nconv = 0; _First != _Last; _Nconv = static_cast<size_t>(_First - _First_sav))
			{	// convert one or more wide chars
			char *_Dest = &*_Bbuf.begin();
			char *_Dnext;

			switch (_Pcvt->out(_State,
				_First, _Last, _First,
				_Dest, _Dest + _Bbuf.size(), _Dnext))
				{	// test result of converting one or more wide chars
			case _Codecvt::partial:
			case _Codecvt::ok:
				if (_Dest < _Dnext)
					_Bstr.append(_Dest, (:: size_t)(_Dnext - _Dest));
				else if (_Bbuf.size() < _BUF_MAX)
					_Bbuf.append((:: size_t)_BUF_INC, '\0');
				else if (_Has_berr)
					return (_Berr);
				else
					throw range_error("bad conversion");
				break;

			case _Codecvt::noconv:
				for (; _First != _Last; ++_First)
					_Bstr.push_back((char)(int_type)*_First);
				break;	// no conversion, just copy code values

			default:
				if (_Has_berr)
					return (_Berr);
				else
					throw range_error("bad conversion");
				}
			}
		return (_Bstr);
		}

	wstring_convert(const wstring_convert&) = delete;
	wstring_convert& operator=(const wstring_convert&) = delete;

private:
	const _Codecvt *_Pcvt;	// the codecvt facet
	locale _Loc;	// manages reference to codecvt facet
	byte_string _Berr;
	wide_string _Werr;
	state_type _State;	// the remembered state
	bool _Has_state;
	bool _Has_berr;
	bool _Has_werr;
	size_t _Nconv;
	};
#pragma warning(pop)
}
 
 
 #pragma warning(pop)
 #pragma pack(pop)



/*
 * Copyright (c) by P.J. Plauger. All rights reserved.
 * Consult your license regarding permissions and restrictions.
V6.50:0009 */


// xlocmes internal header (from <locale>)
#pragma once





 #pragma pack(push,8)
 #pragma warning(push,3)
 #pragma warning(disable: 4455 4494  4619 4643 4702 4984 4988 )
 
 
 

namespace std {
		// STRUCT messages_base
struct messages_base
	: public locale::facet
	{	// base class for messages
	typedef int catalog;

	explicit messages_base(size_t _Refs = 0)
		: locale::facet(_Refs)
		{	// default constructor
		}
	};

		// CLASS TEMPLATE messages
template<class _Elem>
	class messages
		: public messages_base
	{	// facet for obtaining messages from a catalog
public:
	typedef _Elem char_type;
	typedef basic_string<_Elem, char_traits<_Elem>, allocator<_Elem> >
		string_type;

	catalog open(const string& _Catname, const locale& _Loc) const
		{	// open catalog
		return (do_open(_Catname, _Loc));
		}

	string_type get(catalog _Catval, int _Set, int _Message,
		const string_type& _Dflt) const
		{	// get message from set in catalog
		return (do_get(_Catval, _Set, _Message, _Dflt));
		}

	void close(catalog _Catval) const
		{	// close catalog
		do_close(_Catval);
		}

	 __declspec(dllimport) static locale::id id;	// unique facet id

	explicit messages(size_t _Refs = 0)
		: messages_base(_Refs)
		{	// construct from current locale
		{ _Locinfo _Lobj;
			_Init(_Lobj);
		}
		}

	messages(const _Locinfo& _Lobj, size_t _Refs = 0)
		: messages_base(_Refs)
		{	// construct from specified locale
		_Init(_Lobj);
		}

	static size_t _Getcat(const locale::facet **_Ppf = nullptr,
		const locale *_Ploc = nullptr)
		{	// return locale category mask and construct standard facet
		if (_Ppf != nullptr && *_Ppf == nullptr)
			*_Ppf = new messages<_Elem>(
				_Locinfo(_Ploc->c_str()));
		return (6);
		}

protected:
	messages(const char *_Locname, size_t _Refs = 0)
		: messages_base(_Refs)
		{	// construct from specified locale
		{ _Locinfo _Lobj(_Locname);
			_Init(_Lobj);
		}
		}

	virtual  ~messages() noexcept
		{	// destroy the object
		}

	void _Init(const _Locinfo&)
		{	// initialize from _Locinfo object (do nothing)
		}

	virtual catalog  do_open(const string&, const locale&) const
		{	// open catalog (do nothing)
		return (-1);
		}

	virtual string_type  do_get(catalog, int, int,
		const string_type& _Dflt) const
		{	// get message from set in catalog (return default)
		return (_Dflt);
		}

	virtual void  do_close(catalog) const
		{	// close catalog (do nothing)
		}
	};

		// STATIC messages::id OBJECT





template<class _Elem>
	 locale::id messages<_Elem>::id;





		// CLASS TEMPLATE messages_byname
template<class _Elem>
	class messages_byname
		: public messages<_Elem>
	{	// messages for named locale
public:
	explicit messages_byname(const char *_Locname, size_t _Refs = 0)
		: messages<_Elem>(_Locname, _Refs)
		{	// construct for named locale
		}

	explicit messages_byname(const string& _Str, size_t _Refs = 0)
		: messages<_Elem>(_Str.c_str(), _Refs)
		{	// construct for named locale
		}

protected:
	virtual  ~messages_byname() noexcept
		{	// destroy the object
		}
	};

 

  
template  locale::id messages<char>::id;
template  locale::id messages<wchar_t>::id;
  

  


 
}
 
 
 #pragma warning(pop)
 #pragma pack(pop)



/*
 * Copyright (c) by P.J. Plauger. All rights reserved.
 * Consult your license regarding permissions and restrictions.
V6.50:0009 */


// xlocmon internal header (from <locale>)
#pragma once





 #pragma pack(push,8)
 #pragma warning(push,3)
 #pragma warning(disable: 4455 4494  4619 4643 4702 4984 4988 )
 
 
 

namespace std {
		// STRUCT money_base
struct money_base
	: public locale::facet
	{	// ultimate base class for moneypunct
	enum
		{	// constants for different format codes
		symbol = '$', sign = '+', space = ' ', value = 'v', none = 'x'};
	typedef int part;

	struct pattern
		{	// four-part formats for monetary text
		char field[4];
		};

	money_base(size_t _Refs = 0)
		: locale::facet(_Refs)
		{	// default constructor
		}
	};

		// CLASS TEMPLATE _Mpunct
template<class _Elem>
	class _Mpunct
		: public money_base
	{	// common base class for moneypunct<_Elem, false/true>
public:
	typedef _Elem char_type;
	typedef basic_string<_Elem, char_traits<_Elem>, allocator<_Elem> >
		string_type;

	_Elem decimal_point() const
		{	// return decimal point
		return (do_decimal_point());
		}

	_Elem thousands_sep() const
		{	// return thousands separator
		return (do_thousands_sep());
		}

	string grouping() const
		{	// return grouping string
		return (do_grouping());
		}

	string_type curr_symbol() const
		{	// return currency symbol string
		return (do_curr_symbol());
		}

	string_type positive_sign() const
		{	// return plus sign
		return (do_positive_sign());
		}

	string_type negative_sign() const
		{	// return minus sign
		return (do_negative_sign());
		}

	int frac_digits() const
		{	// return number of fraction digits
		return (do_frac_digits());
		}

	pattern pos_format() const
		{	// return format for positive values
		return (do_pos_format());
		}

	pattern neg_format() const
		{	// return format for negative values
		return (do_neg_format());
		}

	explicit _Mpunct(size_t _Refs, bool _Intl)
		: money_base(_Refs), _International(_Intl)
		{	// construct from current locale
		{ _Locinfo _Lobj;
			_Init(_Lobj);
		}
		}

	_Mpunct(const _Locinfo& _Lobj, size_t _Refs, bool _Intl,
		bool _Isdef = false)
		: money_base(_Refs), _International(_Intl)
		{	// construct from specified locale
		_Init(_Lobj, _Isdef);
		}

protected:
	_Mpunct(const char *_Locname, size_t _Refs,
		bool _Intl, bool _Isdef = false)
		: money_base(_Refs), _International(_Intl)
		{	// construct from specified locale
		{ _Locinfo _Lobj(_Locname);
			_Init(_Lobj, _Isdef);
		}
		}

	virtual  ~_Mpunct() noexcept
		{	// destroy the object
		_Tidy();
		}

	template<class _Elem2>
		void _Getvals(_Elem2, const lconv *_Ptr)
		{	// get values
		_Currencysign = _Maklocstr(_International ? _Ptr->int_curr_symbol : _Ptr->currency_symbol,
			static_cast<_Elem2 *>(nullptr), _Cvt);
		_Plussign = _Maklocstr(4 < (unsigned int)_Ptr->p_sign_posn ? "" : _Ptr->positive_sign,
			static_cast<_Elem2 *>(nullptr), _Cvt);
		_Minussign = _Maklocstr(4 < (unsigned int)_Ptr->n_sign_posn ? "-" : _Ptr->negative_sign,
			static_cast<_Elem2 *>(nullptr), _Cvt);
		_Decimalpoint = _Maklocchr(_Ptr->mon_decimal_point[0], static_cast<_Elem2 *>(nullptr), _Cvt);
		_Kseparator = _Maklocchr(_Ptr->mon_thousands_sep[0], static_cast<_Elem2 *>(nullptr), _Cvt);
		}

	void _Getvals(wchar_t, const lconv *_Ptr)
		{	// get values
		_Currencysign = (const _Elem *)_Maklocwcs(_International
			? _Ptr->_W_int_curr_symbol : _Ptr->_W_currency_symbol);
		_Plussign = (const _Elem *)_Maklocwcs(
			4 < (unsigned int)_Ptr->p_sign_posn
				? L"" : _Ptr->_W_positive_sign);
		_Minussign = (const _Elem *)_Maklocwcs(
			4 < (unsigned int)_Ptr->n_sign_posn
				? L"-" : _Ptr->_W_negative_sign);
		_Decimalpoint = (_Elem)_Ptr->_W_mon_decimal_point[0];
		_Kseparator = (_Elem)_Ptr->_W_mon_thousands_sep[0];
		}

	void _Init(const _Locinfo& _Lobj, bool _Isdef = false)
		{	// initialize from _Lobj
		_Cvt = _Lobj._Getcvt();
		const lconv *_Ptr = _Lobj._Getlconv();

		_Grouping = nullptr;
		_Currencysign = nullptr;
		_Plussign = nullptr;
		_Minussign = nullptr;

		try {
		_Grouping = _Maklocstr(_Ptr->mon_grouping, static_cast<char *>(nullptr), _Cvt);
		_Getvals((_Elem)0, _Ptr);
		} catch (...) {
		_Tidy();
		throw;
		}

		_Fracdigits = _International ? _Ptr->int_frac_digits
			: _Ptr->frac_digits;
		if (_Fracdigits < 0 || 127 <= _Fracdigits)
			_Fracdigits = 0;

		_Makpat(_Plusformat, static_cast<unsigned int>(_Ptr->p_sep_by_space),
			static_cast<unsigned int>(_Ptr->p_cs_precedes), static_cast<unsigned int>(_Ptr->p_sign_posn));
		_Makpat(_Minusformat, static_cast<unsigned int>(_Ptr->n_sep_by_space),
			static_cast<unsigned int>(_Ptr->n_cs_precedes), static_cast<unsigned int>(_Ptr->n_sign_posn));

		if (_Isdef)
			{	// apply defaults for required facets
			:: memcpy(&_Plusformat, "$+xv", 4);
			:: memcpy(&_Minusformat, "$+xv", 4);
			}
		}

	virtual _Elem  do_decimal_point() const
		{	// return decimal point
		return (_Decimalpoint);
		}

	virtual _Elem  do_thousands_sep() const
		{	// return thousands separator
		return (_Kseparator);
		}

	virtual string  do_grouping() const
		{	// return grouping string
		return (string(_Grouping));
		}

	virtual string_type  do_curr_symbol() const
		{	// return currency symbol string
		return (string_type(_Currencysign));
		}

	virtual string_type  do_positive_sign() const
		{	// return plus sign
		return (string_type(_Plussign));
		}

	virtual string_type  do_negative_sign() const
		{	// return minus sign
		return (string_type(_Minussign));
		}

	virtual int  do_frac_digits() const
		{	// return number of fraction digits
		return (_Fracdigits);
		}

	virtual pattern  do_pos_format() const
		{	// return format for positive values
		return (_Plusformat);
		}

	virtual pattern  do_neg_format() const
		{	// return format for negative values
		return (_Minusformat);
		}

private:
	void _Makpat(pattern& _Pattern, unsigned int _Sepbyspace,
		unsigned int _Symbolprecedes, unsigned int _Signposition)
		{	// make format pattern from locale information
		const char *_Ptr = _International || 2 < _Sepbyspace
			|| 1 < _Symbolprecedes || 4 < _Signposition
				? "$+xv"	// international or bad parameters
				: &(
				"+v$x" "+v$x" "v$+x" "v+$x" "v$+x"
				"+$vx" "+$vx" "$v+x" "+$vx" "$+vx"
				"+v $" "+v $" "v $+" "v +$" "v $+"
				"+$ v" "+$ v" "$ v+" "+$ v" "$+ v"
				"+xv$" "+ v$" "v$ +" "v+ $" "v$ +"
				"+x$v" "+ $v" "$v +" "+ $v" "$ +v")
					[_Signposition * 4	// pick even/odd column
					+ _Symbolprecedes * 20	// pick even/odd row
					+ _Sepbyspace * 40];	// pick first/second/third group

		:: memcpy(_Pattern.field, _Ptr, sizeof(_Pattern.field));
		}

	void _Tidy()
		{	// free all storage
		:: free((void *)_Grouping);
		:: free((void *)_Currencysign);
		:: free((void *)_Plussign);
		:: free((void *)_Minussign);
		}

	const char *_Grouping;	// grouping string, "" for "C" locale
	_Elem _Decimalpoint;	// decimal point, '\0' for "C" locale
	_Elem _Kseparator;	// thousands separator, '\0' for "C" locale
	const _Elem *_Currencysign;	// currency symbol, "" for "C" locale
	const _Elem *_Plussign;	// plus sign, "" for "C" locale
	const _Elem *_Minussign;	// minus sign, "-" for "C" locale
	int _Fracdigits;	// number of fraction digits, 0 for "C" locale
	pattern _Plusformat;	// positive format, "$+vx" for "C" locale
	pattern _Minusformat;	// negative format, "$+vx" for "C" locale
	bool _International;	// true if international format

	_Locinfo::_Cvtvec _Cvt;		// conversion information
	};

		// CLASS TEMPLATE moneypunct
template<class _Elem,
	bool _Intl = false>
	class moneypunct
		: public _Mpunct<_Elem>
	{	// facet for defining monetary punctuation text
public:
	 __declspec(dllimport) static const bool intl;	// true if international
	 __declspec(dllimport) static locale::id id;	// unique facet id

	explicit moneypunct(size_t _Refs = 0)
		: _Mpunct<_Elem>(_Refs, _Intl)
		{	// construct from current locale
		}

	moneypunct(const _Locinfo& _Lobj, size_t _Refs = 0, bool _Isdef = false)
		: _Mpunct<_Elem>(_Lobj, _Refs, _Intl, _Isdef)
		{	// construct from specified locale
		}

	static size_t _Getcat(const locale::facet **_Ppf = nullptr,
		const locale *_Ploc = nullptr)
		{	// return locale category mask and construct standard facet
		if (_Ppf != nullptr && *_Ppf == nullptr)
			*_Ppf = new moneypunct<_Elem, _Intl>(
				_Locinfo(_Ploc->c_str()), 0, true);
		return (3);
		}

protected:
	moneypunct(const char *_Locname, size_t _Refs = 0)
		: _Mpunct<_Elem>(_Locname, _Refs, _Intl)
		{	// construct from specified locale
		}

	virtual  ~moneypunct() noexcept
		{	// destroy the object
		}
	};






		// STATIC moneypunct::intl OBJECT
template<class _Elem,
	bool _Intl>
	 const bool moneypunct<_Elem, _Intl>::intl = _Intl;

		// STATIC moneypunct::id OBJECT
template<class _Elem,
	bool _Intl>
	 locale::id moneypunct<_Elem, _Intl>::id;





		// CLASS TEMPLATE moneypunct_byname
template<class _Elem,
	bool _Intl = false>
	class moneypunct_byname
		: public moneypunct<_Elem, _Intl>
	{	// moneypunct for named locale
public:
	explicit moneypunct_byname(const char *_Locname, size_t _Refs = 0)
		: moneypunct<_Elem, _Intl>(_Locname, _Refs)
		{	// construct for named locale
		}

	explicit moneypunct_byname(const string& _Str, size_t _Refs = 0)
		: moneypunct<_Elem, _Intl>(_Str.c_str(), _Refs)
		{	// construct for named locale
		}

protected:
	virtual  ~moneypunct_byname() noexcept
		{	// destroy the object
		}
	};

		// CLASS TEMPLATE money_get
template<class _Elem,
	class _InIt = istreambuf_iterator<_Elem, char_traits<_Elem> > >
	class money_get
		: public locale::facet
	{	// facet for converting text to encoded monetary amounts
	typedef moneypunct<_Elem, false> _Mypunct0;
	typedef moneypunct<_Elem, true> _Mypunct1;

public:
	typedef _Elem char_type;
	typedef _InIt iter_type;
	typedef basic_string<_Elem, char_traits<_Elem>, allocator<_Elem> >
		string_type;

	_InIt get(_InIt _First, _InIt _Last,
		bool _Intl, ios_base& _Iosbase, ios_base::iostate& _State,
			long double& _Val) const
		{	// get long double from [_First, _Last) into _Val
		return (do_get(_First, _Last, _Intl, _Iosbase, _State, _Val));
		}

	_InIt get(_InIt _First, _InIt _Last,
		bool _Intl, ios_base& _Iosbase, ios_base::iostate& _State,
			string_type& _Val) const
		{	// get string_type from [_First, _Last) into _Val
		return (do_get(_First, _Last, _Intl, _Iosbase, _State, _Val));
		}

	 __declspec(dllimport) static locale::id id;	// unique facet id

	explicit money_get(size_t _Refs = 0)
		: locale::facet(_Refs)
		{	// construct from current locale
		{ _Locinfo _Lobj;
			_Init(_Lobj);
		}
		}

	money_get(const _Locinfo& _Lobj, size_t _Refs = 0)
		: locale::facet(_Refs)
		{	// construct from specified locale
		_Init(_Lobj);
		}

	static size_t _Getcat(const locale::facet **_Ppf = nullptr,
		const locale *_Ploc = nullptr)
		{	// return locale category mask and construct standard facet
		if (_Ppf != nullptr && *_Ppf == nullptr)
			*_Ppf = new money_get<_Elem, _InIt>(
				_Locinfo(_Ploc->c_str()));
		return (3);
		}

protected:
	virtual  ~money_get() noexcept
		{	// destroy the object
		}

	void _Init(const _Locinfo&)
		{	// initialize from _Locinfo object
		}

	virtual _InIt  do_get(_InIt _First, _InIt _Last,
		bool _Intl, ios_base& _Iosbase, ios_base::iostate& _State,
			long double& _Val) const
		{	// get long double from [_First, _Last) into _Val
		_Elem _Atoms[sizeof ("0123456789-")];
		string _Str = _Getmfld(_First, _Last, _Intl, _Iosbase, _Atoms);

		if (_First == _Last)
			_State |= ios_base::eofbit;
		if (_Str.size() == 0)
			_State |= ios_base::failbit;	// _Getmfld failed
		else
			{	// convert to long double
			const char *_Eb = _Str.c_str();
			char *_Ep;
			int _Errno = 0;
			const long double _Ans =
				_Stodx_v2(_Eb, &_Ep, 0, &_Errno);	// convert and "widen" double to long double

			if (_Ep == _Eb || _Errno != 0)
				_State |= ios_base::failbit;
			else
				_Val = _Ans;	// deliver value
			}
		return (_First);
		}

	virtual _InIt  do_get(_InIt _First, _InIt _Last,
		bool _Intl, ios_base& _Iosbase, ios_base::iostate& _State,
			string_type& _Val) const
		{	// get string_type from [_First, _Last) into _Val
		_Elem _Atoms[sizeof ("0123456789-")];
		string _Str = _Getmfld(_First, _Last, _Intl, _Iosbase, _Atoms);
		size_t _Len = _Str.size();

		if (_First == _Last)
			_State |= ios_base::eofbit;
		if (_Len == 0)
			_State |= ios_base::failbit;	// _Getmfld failed
		else
			{	// deliver value
			size_t _Idx = 0;
			_Val.resize(_Len);
			if (_Str[0] == '-')
				_Val[_Idx++] = _Atoms[10];
			for (; _Idx < _Len; ++_Idx)
				_Val[_Idx] = _Atoms[_Str[_Idx] - '0'];	// map digits
			}
		return (_First);
		}

private:
	string _Getmfld(_InIt& _First, _InIt& _Last,
		bool _Intl, ios_base& _Iosbase, _Elem (&_Atoms)[12]) const
		{	// get monetary field from [_First, _Last) into string_type
		_Adl_verify_range(_First, _Last);
		const _Mpunct<_Elem> *_Ppunct_fac;
		if (_Intl)
			{
			_Ppunct_fac = ::std:: addressof(::std:: use_facet<_Mypunct1>(_Iosbase.getloc()));	// international
			}
		else
			{
			_Ppunct_fac = ::std:: addressof(::std:: use_facet<_Mypunct0>(_Iosbase.getloc()));	// local
			}

		bool _Bad = false, _Neg = false;
		string_type _Sign;
		const money_base::pattern _Pattern = _Ppunct_fac->neg_format();
		string _Val;
		size_t _Idx;
		static constexpr char _Src[] = {"0123456789-"};
		const ctype<_Elem>& _Ctype_fac = ::std:: use_facet<ctype<_Elem>>(_Iosbase.getloc());
		_Ctype_fac.widen(&_Src[0], &_Src[sizeof (_Src)], _Atoms);

		for (size_t _Off = 0; !_Bad && _Off < 4; ++_Off)
			switch (_Pattern.field[_Off])
				{	// parse a format component
			case money_base::symbol:
				{	// parse currency symbol
				string_type _Symbol = _Ppunct_fac->curr_symbol();
				typename string_type::const_iterator _Source;

				if ((!(_Iosbase.flags() & ios_base::showbase)
						&& _First != _Last && *_First != *_Symbol.c_str())
					|| (_Off == 3 && _Sign.size() <= 1
						&& (_First == _Last || *_First != *_Symbol.c_str())))
					{	// showbase ==> mandatory symbol
						// or
						// currency symbol optional at end
					_Symbol.erase();
					}

				_Source = _Symbol.begin();
				while (_First != _Last && _Source != _Symbol.end()
						&& *_First == *_Source)
					{	// still matching currency symbol
					++_Source;
					++_First;
					}

				if (_Source != _Symbol.end())
					{
					_Bad = true;	// currency symbol match failed
					}
				break;
				}

			case money_base::sign:	// parse sign
				if (_First != _Last)
					{
					if (0 < _Ppunct_fac->positive_sign().size()
						&& _Ppunct_fac->positive_sign()[0] == *_First)
						{	// match positive sign
						++_First;
						_Sign = _Ppunct_fac->positive_sign();
						}
					else if (0 < _Ppunct_fac->negative_sign().size()
						&& _Ppunct_fac->negative_sign()[0] == *_First)
						{	// match negative sign
						++_First;
						_Sign = _Ppunct_fac->negative_sign();
						_Neg = true;
						}
					else if (0 != _Ppunct_fac->positive_sign().size() && 0 == _Ppunct_fac->negative_sign().size())
						{
						_Neg = true;
						}
					}

				break;	// sign match can't fail

			case money_base::value:
				{	// parse value field
				int _Fracdigseen = 0;
				int _Fracdigits = _Ppunct_fac->frac_digits();
				const string _Grouping = _Ppunct_fac->grouping();
				const _Elem _Kseparator = _Grouping.size() == 0
					? (_Elem)0 : _Ppunct_fac->thousands_sep();

				if (_Kseparator == (_Elem)0
					|| 127 <= (unsigned char)*_Grouping.c_str())
					for (; _First != _Last
						&& (_Idx = _Find_elem(_Atoms, *_First)) < 10;
						++_First)
					_Val += _Src[_Idx];	// no grouping, just gather digits
				else
					{	// grouping specified, gather digits and group sizes
					string _Groups;
					_Groups.push_back('\0');
					size_t _Group = 0;

					for (; _First != _Last; ++_First)
						if ((_Idx = _Find_elem(_Atoms, *_First)) < 10)
							{	// got a digit, add to group size
							_Val += _Src[_Idx];
							if (_Groups[_Group] != 127)
								++_Groups[_Group];
							}
						else if (_Groups[_Group] == '\0'
							|| *_First != _Kseparator)
							break;	// not a group separator, done
						else
							{	// add a new group to _Groups string
							_Groups.push_back('\0');
							++_Group;
							}

					if (_Group != 0)
						{	// thousands separators seen
						if ('\0' < _Groups[_Group])
							{
							++_Group;	// add trailing group to group count
							}
						else
							{
							_Bad = true;	// trailing separator, fail
							}
						}

					for (const char *_Pg = _Grouping.c_str(); !_Bad && 0 < _Group; )
						{
						if (*_Pg == 127)
							{
							break;	// end of grouping constraints to check
							}

						if ((0 < --_Group && *_Pg != _Groups[_Group])
							|| (0 == _Group && *_Pg < _Groups[_Group]))
							{
							_Bad = true;	// bad group size, fail
							}
						else if ('\0' < _Pg[1])
							{
							++_Pg;	// group size okay, advance to next test
							}
						}

					if (_Bad)
						{
						break;	// bad grouping, give up
						}
					}

				const _Elem _Point = _Ppunct_fac->decimal_point();
				if (_First != _Last
					&& _Point != (_Elem)0
					&& *_First == _Point)
					{	// seen decimal point, gather fraction digits
					while (++_First != _Last
						&& _Fracdigseen < _Fracdigits
						&& (_Idx = _Find_elem(_Atoms, *_First)) < 10)
						{
						_Val += _Src[_Idx];
						++_Fracdigseen;
						}

					if (_Fracdigseen < _Fracdigits)
						_Bad = true;	// short fraction
					}

				if (_Val.size() == 0)
					_Bad = true;	// fail if no elements parsed
				else
					for (; _Fracdigseen < _Fracdigits; ++_Fracdigseen)
						_Val += '0';	// pad out fraction with zeros
				break;
				}

			case money_base::space:
			case money_base::none:
				{	// parse optional space
				if (_Off == 3)
					{
					break;	// ignore space at end
					}

				bool _Seen = false;

				for (; _First != _Last
					&& _Ctype_fac.is(ctype_base::space, *_First); ++_First)
					{
					_Seen = true;	// skip any space
					}

				if (_Pattern.field[_Off] == money_base::space && !_Seen)
					{
					_Bad = true;	// fail if no space seen
					}
				}	// parse optional space
				}	// switch

		if (!_Bad && 1 < _Sign.size())
			{	// match rest of sign string
			auto _Source = _Sign.begin();

			while (++_Source != _Sign.end() && _First != _Last && *_First == *_Source)
				{
				++_First;
				}

			if (_Source != _Sign.end())
				{
				_Bad = true;	// rest of sign doesn't match, fail
				}
			}

		if (_Bad)
			{
			_Val.erase();	// bad input, return empty string
			}
		else if (_Neg)
			{
			_Val.insert((size_t)0, (size_t)1, '-');	// minus sign
			}

		return (_Val);
		}
	};

		// STATIC money_get::id OBJECT





template<class _Elem,
	class _InIt>
	 locale::id money_get<_Elem, _InIt>::id;





		// CLASS TEMPLATE money_put
template<class _Elem,
	class _OutIt = ostreambuf_iterator<_Elem, char_traits<_Elem> > >
	class money_put
		: public locale::facet
	{	// facet for converting encoded monetary amounts to text
	typedef moneypunct<_Elem, false> _Mypunct0;
	typedef moneypunct<_Elem, true> _Mypunct1;

public:
	typedef _Elem char_type;
	typedef _OutIt iter_type;
	typedef basic_string<_Elem, char_traits<_Elem>, allocator<_Elem> >
		string_type;

	_OutIt put(_OutIt _Dest,
		bool _Intl, ios_base& _Iosbase, _Elem _Fill,
			long double _Val) const
		{	// put long double to _Dest
		return (do_put(_Dest, _Intl, _Iosbase, _Fill, _Val));
		}

	_OutIt put(_OutIt _Dest,
		bool _Intl, ios_base& _Iosbase, _Elem _Fill,
			const string_type& _Val) const
		{	// put string_type to _Dest
		return (do_put(_Dest, _Intl, _Iosbase, _Fill, _Val));
		}

	 __declspec(dllimport) static locale::id id;	// unique facet id

	explicit money_put(size_t _Refs = 0)
		: locale::facet(_Refs)
		{	// construct from current locale
		{ _Locinfo _Lobj;
			_Init(_Lobj);
		}
		}

	money_put(const _Locinfo& _Lobj, size_t _Refs = 0)
		: locale::facet(_Refs)
		{	// construct from specified locale
		_Init(_Lobj);
		}

	static size_t _Getcat(const locale::facet **_Ppf = nullptr,
		const locale *_Ploc = nullptr)
		{	// return locale category mask and construct standard facet
		if (_Ppf != nullptr && *_Ppf == nullptr)
			*_Ppf = new money_put<_Elem, _OutIt>(
				_Locinfo(_Ploc->c_str()));
		return (3);
		}

protected:
	virtual  ~money_put() noexcept
		{	// destroy the object
		}

	void _Init(const _Locinfo&)
		{	// initialize from _Locinfo object
		}

	virtual _OutIt  do_put(_OutIt _Dest,
		bool _Intl, ios_base& _Iosbase, _Elem _Fill,
			long double _Val) const
		{	// put long double to _Dest
		bool _Negative = false;
		if (_Val < 0)
			{
			_Negative = true;
			_Val = -_Val;
			}

		size_t _Exp;
		for (_Exp = 0; 1e35 <= _Val && _Exp < 5000; _Exp += 10)
			_Val /= 1e10;	// drop 10 zeros before decimal point

		char _Buf[40];

		// convert to chars:
		const auto _Count = static_cast<size_t>(:: sprintf_s(_Buf, sizeof (_Buf), "%.0Lf", _Val));

		if (_Count < 0)
			return (_Dest);	// bad conversion, give up

		const ctype<_Elem>& _Ctype_fac = ::std:: use_facet<ctype<_Elem>>(_Iosbase.getloc());
		const _Elem _E0 = _Ctype_fac.widen('0');

		string_type _Val2(_Count, (_Elem)0);
		_Ctype_fac.widen(&_Buf[0], &_Buf[_Count], &_Val2[0]);
		_Val2.append(_Exp, _E0);	// scale by trailing zeros
		return (_Putmfld(_Dest, _Intl, _Iosbase, _Fill,
			_Negative, _Val2, _E0));
		}

	virtual _OutIt  do_put(_OutIt _Dest,
		bool _Intl, ios_base& _Iosbase, _Elem _Fill,
			const string_type& _Val) const
		{	// put string_type to _Dest
		static constexpr char _Src[] = {"0123456789-"};
		_Elem _Atoms[sizeof (_Src)];
		const ctype<_Elem>& _Ctype_fac = ::std:: use_facet<ctype<_Elem>>(_Iosbase.getloc());
		_Ctype_fac.widen(&_Src[0], &_Src[sizeof (_Src)], _Atoms);

		bool _Negative = false;
		size_t _Idx0 = 0;
		if (!_Val.empty() && _Val[0] == _Atoms[10])
			{	// strip off '-'
			_Negative = true;
			++_Idx0;
			}

		size_t _Size = _Val.size();
		size_t _Idx = _Idx0;
		for (; _Idx < _Size && _Find_elem(_Atoms, _Val[_Idx]) < 10; ++_Idx)
			{	// count digits
			}

		string_type _Val2(&_Val[_Idx0], (size_t)(_Idx - _Idx0));
		if (_Val2.empty())	// replace empty digit string with '0'
			{
			_Val2.push_back(_Atoms[0]);
			}

		return (_Putmfld(_Dest, _Intl, _Iosbase, _Fill,
			_Negative, _Val2, _Atoms[0]));
		}

private:
	_OutIt _Putmfld(_OutIt _Dest,
		bool _Intl, ios_base& _Iosbase, _Elem _Fill,
			bool _Neg, string_type _Val, _Elem _E0) const
		{	// put string_type with just digits to _Dest
		const _Mpunct<_Elem> *_Ppunct_fac;
		if (_Intl)
			{
			_Ppunct_fac = ::std:: addressof(::std:: use_facet<_Mypunct1>(_Iosbase.getloc()));	// international
			}
		else
			{
			_Ppunct_fac = ::std:: addressof(::std:: use_facet<_Mypunct0>(_Iosbase.getloc()));	// local
			}

		const string _Grouping = _Ppunct_fac->grouping();
		int _Ifracdigits = _Ppunct_fac->frac_digits();
		const auto _Fracdigits = static_cast<unsigned int>(_Ifracdigits < 0 ? -_Ifracdigits : _Ifracdigits);

		if (_Val.size() <= _Fracdigits)
			_Val.insert((size_t)0, _Fracdigits - _Val.size() + 1, _E0);
		else if (*_Grouping.c_str() != 127 && '\0' < *_Grouping.c_str())
			{	// grouping specified, add thousands separators
			const _Elem _Kseparator = _Ppunct_fac->thousands_sep();
			const char *_Pg = _Grouping.c_str();
			size_t _Off = _Val.size() - _Fracdigits;	// start of fraction

			while (*_Pg != 127 && '\0' < *_Pg
				&& (size_t)*_Pg < _Off)
				{	// add a thousands separator, right to left
				_Val.insert(_Off -= *_Pg, (size_t)1, _Kseparator);
				if ('\0' < _Pg[1])
					++_Pg;	// not last group, advance
				}
			}

		money_base::pattern _Pattern;
		string_type _Sign;
		if (_Neg)
			{	// negative value, choose appropriate format and sign
			_Pattern = _Ppunct_fac->neg_format();
			_Sign = _Ppunct_fac->negative_sign();
			}
		else
			{	// positive value, choose appropriate format and sign
			_Pattern = _Ppunct_fac->pos_format();
			_Sign = _Ppunct_fac->positive_sign();
			}

		string_type _Symbol;
		if (_Iosbase.flags() & ios_base::showbase)
			_Symbol = _Ppunct_fac->curr_symbol();	// showbase ==> show $

		bool _Intern = false;
		size_t _Fillcount, _Off;
		for (_Fillcount = 0, _Off = 0; _Off < 4; ++_Off)
			switch (_Pattern.field[_Off])
			{	// accumulate total length in _Fillcount
			case money_base::symbol:	// count currency symbol size
				_Fillcount += _Symbol.size();
				break;

			case money_base::sign:	// count sign size
				_Fillcount += _Sign.size();
				break;

			case money_base::value:	// count value field size
				_Fillcount += _Val.size() + (0 < _Fracdigits ? 1 : 0)
					+ (_Val.size() <= _Fracdigits
						? _Fracdigits - _Val.size() + 1 : 0);
				break;

			case money_base::space:	// count space size
				++_Fillcount;	// at least one space
				// fall through

			case money_base::none:	// count space size
				if (_Off != 3)
					_Intern = true;	// optional internal fill
				break;
			}

		_Fillcount = _Iosbase.width() <= 0
			|| (size_t)_Iosbase.width() <= _Fillcount
				? 0 : (size_t)_Iosbase.width() - _Fillcount;

		ios_base::fmtflags _Afl =
			_Iosbase.flags() & ios_base::adjustfield;
		if (_Afl != ios_base::left
			&& (_Afl != ios_base::internal || !_Intern))
			{	// put leading fill
			_Dest = _Rep(_Dest, _Fill, _Fillcount);
			_Fillcount = 0;
			}

		for (_Off = 0; _Off < 4; ++_Off)
			switch (_Pattern.field[_Off])
				{	// put components as specified by _Pattern
			case money_base::symbol:	// put currency symbol
				_Dest = _Put(_Dest, _Symbol.begin(), _Symbol.size());
				break;

			case money_base::sign:	// put sign
				if (0 < _Sign.size())
					_Dest = _Put(_Dest, _Sign.begin(), 1);
				break;

			case money_base::value:	// put value field
				if (_Fracdigits == 0)
					_Dest = _Put(_Dest, _Val.begin(),
						_Val.size());	// no fraction part
				else if (_Val.size() <= _Fracdigits)
					{	// put leading zero, all fraction digits
					*_Dest++ = _E0;
					*_Dest++ = _Ppunct_fac->decimal_point();
					_Dest = _Rep(_Dest, _E0,
						_Fracdigits - _Val.size());	// insert zeros
					_Dest = _Put(_Dest, _Val.begin(), _Val.size());
					}
				else
					{	// put both integer and fraction parts
					_Dest = _Put(_Dest, _Val.begin(),
						_Val.size() - _Fracdigits);	// put integer part
					*_Dest++ = _Ppunct_fac->decimal_point();
					_Dest = _Put(_Dest, _Val.end() - static_cast<ptrdiff_t>(_Fracdigits),
						_Fracdigits);	// put fraction part
					}
				break;

			case money_base::space:	// put any internal fill
				_Dest = _Rep(_Dest, _Fill, 1);
				// fall through

			case money_base::none:	// put any internal fill
				if (_Afl == ios_base::internal)
					{	// put internal fill
					_Dest = _Rep(_Dest, _Fill, _Fillcount);
					_Fillcount = 0;
					}
				}

		if (1 < _Sign.size())
			_Dest = _Put(_Dest, _Sign.begin() + 1,
				_Sign.size() - 1);	// put remainder of sign
		_Iosbase.width(0);
		return (_Rep(_Dest, _Fill, _Fillcount));	// put trailing fill
		}

	static _OutIt _Put(_OutIt _Dest,
		typename string_type::const_iterator _Source, size_t _Count)
		{	// put [_Source, _Source + _Count) to _Dest
		for (; 0 < _Count; --_Count, (void)++_Dest, ++_Source)
			*_Dest = *_Source;
		return (_Dest);
		}

	static _OutIt _Rep(_OutIt _Dest,
		_Elem _Ch, size_t _Count)
		{	// put _Count * _Ch to _Dest
		for (; 0 < _Count; --_Count, (void)++_Dest)
			*_Dest = _Ch;
		return (_Dest);
		}
	};

		// STATIC money_put::id OBJECT





template<class _Elem,
	class _OutIt>
	 locale::id money_put<_Elem, _OutIt>::id;

 

  
template  const bool moneypunct<char, true>::intl;
template  const bool moneypunct<char, false>::intl;
template  locale::id
	moneypunct<char, true>::id;
template  locale::id
	moneypunct<char, false>::id;
template  locale::id
	money_get<char, istreambuf_iterator<char,
		char_traits<char> > >::id;
template  locale::id
	money_put<char, ostreambuf_iterator<char,
		char_traits<char> > >::id;

template  const bool moneypunct<wchar_t, true>::intl;
template  const bool moneypunct<wchar_t, false>::intl;
template  locale::id
	moneypunct<wchar_t, true>::id;
template  locale::id
	moneypunct<wchar_t, false>::id;
template  locale::id
	money_get<wchar_t, istreambuf_iterator<wchar_t,
		char_traits<wchar_t> > >::id;
template  locale::id
	money_put<wchar_t, ostreambuf_iterator<wchar_t,
		char_traits<wchar_t> > >::id;
  

  













 





}

 
 
 #pragma warning(pop)
 #pragma pack(pop)



/*
 * Copyright (c) by P.J. Plauger. All rights reserved.
 * Consult your license regarding permissions and restrictions.
V6.50:0009 */



// xloctime internal header (from <locale>)
#pragma once




// ctime standard header
#pragma once







#pragma pack(push,8)
#pragma warning(push,3)
#pragma warning(disable: 4455 4494  4619 4643 4702 4984 4988 )




namespace std {
using :: clock_t; using :: size_t;
using :: time_t; using :: tm;
using :: asctime; using :: clock; using :: ctime;
using :: difftime; using :: gmtime; using :: localtime;
using :: mktime; using :: strftime; using :: time;
}



#pragma warning(pop)
#pragma pack(pop)




/*
 * Copyright (c) by P.J. Plauger. All rights reserved.
 * Consult your license regarding permissions and restrictions.
V6.50:0009 */



 #pragma pack(push,8)
 #pragma warning(push,3)
 #pragma warning(disable: 4455 4494  4619 4643 4702 4984 4988 )
 
 
 

namespace std {
		// STRUCT time_base
struct __declspec(dllimport) time_base
	: public locale::facet
	{	// base class for time_get
	enum dateorder
		{	// constants for different orders of date components
		no_order, dmy, mdy, ymd, ydm};

	 time_base(size_t _Refs = 0)
		: locale::facet(_Refs)
		{	// default constructor
		}

	 ~time_base() noexcept
		{	// destroy the object
		}
	};

		// CLASS TEMPLATE time_get
template<class _Elem,
	class _InIt = istreambuf_iterator<_Elem, char_traits<_Elem> > >
	class time_get
		: public time_base
	{	// facet for converting text to encoded times
public:
	typedef _Elem char_type;
	typedef _InIt iter_type;
	typedef ctype<_Elem> _Ctype;

	 static locale::id id;	// unique facet id

	dateorder  date_order() const
		{	// return date order code
		return (do_date_order());
		}

	_InIt  get_time(_InIt _First, _InIt _Last,
		ios_base& _Iosbase, ios_base::iostate& _State, tm *_Pt) const
		{	// get time of day from [_First, _Last) into _Pt
		return (do_get_time(_First, _Last, _Iosbase, _State, _Pt));
		}

	_InIt  get_date(_InIt _First, _InIt _Last,
		ios_base& _Iosbase, ios_base::iostate& _State, tm *_Pt) const
		{	// get date from [_First, _Last) into _Pt
		return (do_get_date(_First, _Last, _Iosbase, _State, _Pt));
		}

	_InIt  get_weekday(_InIt _First, _InIt _Last,
		ios_base& _Iosbase, ios_base::iostate& _State, tm *_Pt) const
		{	// get weekday from [_First, _Last) into _Pt
		return (do_get_weekday(_First, _Last, _Iosbase, _State, _Pt));
		}

	_InIt  get_monthname(_InIt _First, _InIt _Last,
		ios_base& _Iosbase, ios_base::iostate& _State, tm *_Pt) const
		{	// get month from [_First, _Last) into _Pt
		return (do_get_monthname(_First, _Last, _Iosbase, _State, _Pt));
		}

	_InIt  get_year(_InIt _First, _InIt _Last,
		ios_base& _Iosbase, ios_base::iostate& _State, tm *_Pt) const
		{	// get year from [_First, _Last) into _Pt
		return (do_get_year(_First, _Last, _Iosbase, _State, _Pt));
		}

	_InIt  get(_InIt _First, _InIt _Last,
		ios_base& _Iosbase, ios_base::iostate& _State, tm *_Pt,
			char _Specifier, char _Modifier = '\0') const
		{	// get formatted time for _Specifier/_Modifier
		return (do_get(_First, _Last, _Iosbase, _State, _Pt,
			_Specifier, _Modifier));
		}

	_InIt  get(_InIt _First, _InIt _Last,
		ios_base& _Iosbase, ios_base::iostate& _State, tm *_Pt,
			const _Elem *_Fmtfirst, const _Elem *_Fmtlast) const
		{	// get formatted time for format string
		_Adl_verify_range(_Fmtfirst, _Fmtlast);
		const _Ctype& _Ctype_fac = ::std:: use_facet<_Ctype>(_Iosbase.getloc());

		_State = ios_base::goodbit;

		for (; _Fmtfirst != _Fmtlast; ++_Fmtfirst)
			{
			if (_Ctype_fac.narrow(*_Fmtfirst) != '%')
				{	// match literal element
				if (_Ctype_fac.is(_Ctype::space, *_Fmtfirst))
					{
					while (_First != _Last && _Ctype_fac.is(_Ctype::space, *_First))
						{
						++_First;
						}
					}
				else if (*_First != *_Fmtfirst)
					{	// bad literal match
					_State |= ios_base::failbit;
					break;
					}
				else
					{
					++_First;
					}
				}
			else if (++_Fmtfirst == _Fmtlast)
				{	// treat trailing % as literal match
				if (*_First != _Fmtfirst[-1])
					{
					_State |= ios_base::failbit;
					}
				else
					{
					++_First;
					}
				break;
				}
			else
				{	// get specifier after %
				char _Specifier = _Ctype_fac.narrow(*_Fmtfirst);
				char _Modifier = '\0';
				_Elem _Percent = _Fmtfirst[-1];

				if (_Specifier == 'E' || _Specifier == 'O'
					|| _Specifier == 'Q' || _Specifier == '#')
					{
					if (++_Fmtfirst == _Fmtlast)
						{	// no specifier, treat %[E0Q#] as literal match
						if (*_First != _Percent
							|| ++_First == _Last
							|| _Ctype_fac.narrow(*_First) != _Specifier)
							{
							_State |= ios_base::failbit;
							}
						else
							{
							++_First;
							}

						break;
						}
					else
						{	// save both qualifier and specifier
						_Modifier = _Specifier;
						_Specifier = _Ctype_fac.narrow(*_Fmtfirst);
						}
					}

				_First = do_get(_First, _Last, _Iosbase, _State, _Pt,
					_Specifier, _Modifier);	// convert a single field
				}
			}

		if (_First == _Last)
			{
			_State |= ios_base::eofbit;
			}

		return (_First);
		}

	explicit  time_get(size_t _Refs = 0)
		: time_base(_Refs)
		{	// construct from current locale
		{ _Locinfo _Lobj;
			_Init(_Lobj);
		}
		}

	 time_get(const _Locinfo& _Lobj, size_t _Refs = 0)
		: time_base(_Refs)
		{	// construct from specified locale
		_Init(_Lobj);
		}

	static size_t __cdecl _Getcat(const locale::facet **_Ppf = nullptr,
		const locale *_Ploc = nullptr)
		{	// return locale category mask and construct standard facet
		if (_Ppf != nullptr && *_Ppf == nullptr)
			*_Ppf = new time_get<_Elem, _InIt>(
				_Locinfo(_Ploc->c_str()));
		return (5);
		}

protected:
	virtual  ~time_get() noexcept
		{	// destroy the object
		_Tidy();
		}

	 time_get(const char *_Locname, size_t _Refs = 0)
		: time_base(_Refs)
		{	// construct from specified locale
		{ _Locinfo _Lobj(_Locname);
			_Init(_Lobj);
		}
		}

	template<class _Elem2>
		void  _Getvals(_Elem2, const _Locinfo& _Lobj)
		{	// get values
		_Cvt = _Lobj._Getcvt();

		if (is_same_v<_Elem2, wchar_t>)
			{
			_Days = (const _Elem *)_Maklocwcs((const wchar_t *)_Lobj._W_Getdays());
			_Months = (const _Elem *)_Maklocwcs((const wchar_t *)_Lobj._W_Getmonths());
			_Ampm = (const _Elem *)_Maklocwcs(L":AM:am:PM:pm");
			}
		else
			{
			_Days = _Maklocstr(_Lobj._Getdays(), static_cast<_Elem *>(nullptr), _Cvt);
			_Months = _Maklocstr(_Lobj._Getmonths(), static_cast<_Elem *>(nullptr), _Cvt);
			_Ampm = _Maklocstr(":AM:am:PM:pm", static_cast<_Elem *>(nullptr), _Cvt);
			}
		}

	void  _Init(const _Locinfo& _Lobj)
		{	// initialize from _Lobj
		_Days = nullptr;
		_Months = nullptr;
		_Ampm = nullptr;

		try {
		_Getvals((_Elem)0, _Lobj);

		_Dateorder = (dateorder)_Lobj._Getdateorder();

		} catch (...) {
		_Tidy();
		throw;
		}
		}

	virtual dateorder  do_date_order() const
		{	// return date order code
		return (_Dateorder);
		}

	virtual _InIt  do_get_time(
		_InIt _First, _InIt _Last,
		ios_base& _Iosbase, ios_base::iostate& _State, tm *_Pt) const
		{	// get time of day from [_First, _Last) into _Pt
		const _Ctype& _Ctype_fac = ::std:: use_facet<_Ctype>(_Iosbase.getloc());

		_State |= _Getint(_First, _Last, 0, 23,
			_Pt->tm_hour, _Ctype_fac);

		if (_State != ios_base::goodbit || _Ctype_fac.narrow(*_First) != ':')
			_State |= ios_base::failbit;	// hour field is bad
		else
			_State |= _Getint(++_First, _Last, 0, 59,
				_Pt->tm_min, _Ctype_fac);

		if (_State != ios_base::goodbit || _Ctype_fac.narrow(*_First) != ':')
			_State |= ios_base::failbit;	// min field is bad
		else
			_State |= _Getint(++_First, _Last, 0, 59,
				_Pt->tm_sec, _Ctype_fac);
		return (_First);
		}

	virtual _InIt  do_get_date(
		_InIt _First, _InIt _Last,
		ios_base& _Iosbase, ios_base::iostate& _State, tm *_Pt) const
		{	// get date from [_First, _Last) into _Pt
		const _Ctype& _Ctype_fac = ::std:: use_facet<_Ctype>(_Iosbase.getloc());

		dateorder _Dorder = date_order();
		if (_Dorder == no_order)
			_Dorder = mdy;

		if (_First != _Last)
			{
			if (!_Ctype_fac.is(_Ctype::digit, *_First))
				{	// begins with month name, assume mdy
				_First = get_monthname(_First, _Last, _Iosbase, _State, _Pt);
				_Dorder = mdy;
				}
			else if (_Dorder == mdy)
				{	// get month number
				_State |= _Getint(_First, _Last, 1, 12, _Pt->tm_mon, _Ctype_fac);
				--_Pt->tm_mon;
				}
			else if (_Dorder == dmy)
				{
				_State |= _Getint(_First, _Last, 1, 31, _Pt->tm_mday, _Ctype_fac);
				}
			else	// ymd or ydm
				{
				_First = get_year(_First, _Last, _Iosbase, _State, _Pt);
				}
			}

		while (_First != _Last && _Ctype_fac.is(_Ctype::space, *_First))
			{
			++_First;	// skip spaces
			}

		if (_First != _Last)
			{	// skip [:,/]
			char _Ch = _Ctype_fac.narrow(*_First);
			if (_Ch == ':' || _Ch == ',' || _Ch == '/')
				{
				++_First;
				}
			}

		while (_First != _Last && _Ctype_fac.is(_Ctype::space, *_First))
			{
			++_First;	// skip spaces
			}

		if (_First != _Last)
			{
			if (!_Ctype_fac.is(_Ctype::digit, *_First))
				{
				if (_Dorder == mdy)
					{
					_State |= ios_base::failbit;	// error, month already seen
					}
				else
					{	// month name is second, like it or not
					_First = get_monthname(_First, _Last, _Iosbase, _State, _Pt);
					if (_Dorder == ydm)
						{
						_Dorder = ymd;
						}
					}
				}
			else if (_Dorder == dmy || _Dorder == ymd)
				{	// get month number
				_State |= _Getint(_First, _Last, 1, 12, _Pt->tm_mon, _Ctype_fac);
				--_Pt->tm_mon;
				}
			else
				{
				_State |= _Getint(_First, _Last, 1, 31, _Pt->tm_mday, _Ctype_fac);
				}
			}

		while (_First != _Last && _Ctype_fac.is(_Ctype::space, *_First))
			{
			++_First;	// skip spaces
			}

		if (_First != _Last)
			{	// skip [:,/]
			char _Ch = _Ctype_fac.narrow(*_First);
			if (_Ch == ':' || _Ch == ',' || _Ch == '/')
				{
				++_First;
				}
			}

		while (_First != _Last && _Ctype_fac.is(_Ctype::space, *_First))
			{
			++_First;	// skip spaces
			}

		if (_First == _Last)
			{
			_State |= ios_base::failbit;	// error, missing component(s)
			}
		else if (!_Ctype_fac.is(_Ctype::digit, *_First))
			{
			if (_Dorder != ydm)
				{
				_State |= ios_base::failbit;	// error, month out of place
				}
			else
				{
				_First = get_monthname(_First, _Last, _Iosbase, _State, _Pt);
				}
			}
		else if (_Dorder == ydm)
			{	// get month number
			_State |= _Getint(_First, _Last, 1, 12, _Pt->tm_mon, _Ctype_fac);
			--_Pt->tm_mon;
			}
		else if (_Dorder == ymd)
			{
			_State |= _Getint(_First, _Last, 1, 31, _Pt->tm_mday, _Ctype_fac);
			}
		else	// mdy or dmy
			{
			_First = get_year(_First, _Last, _Iosbase, _State, _Pt);
			}

		if (_First == _Last)
			{
			_State |= ios_base::eofbit;
			}

		return (_First);
		}

	virtual _InIt  do_get_weekday(
		_InIt _First, _InIt _Last,
		ios_base&, ios_base::iostate& _State, tm *_Pt) const
		{	// get weekday from [_First, _Last) into _Pt
		int _Num = _Getloctxt(_First, _Last, (size_t)0, _Days);
		if (_Num < 0)
			{
			_State |= ios_base::failbit;
			}
		else
			{
			_Pt->tm_wday = _Num >> 1;	// set wday
			}

		return (_First);
		}

	virtual _InIt  do_get_monthname(
		_InIt _First, _InIt _Last,
		ios_base&, ios_base::iostate& _State, tm *_Pt) const
		{	// get month from [_First, _Last) into _Pt
		int _Num = _Getloctxt(_First, _Last, (size_t)0, _Months);

		if (_Num < 0)
			_State |= ios_base::failbit;
		else
			_Pt->tm_mon = _Num >> 1;	// set mon
		return (_First);
		}

	virtual _InIt  do_get_year(
		_InIt _First, _InIt _Last,
		ios_base& _Iosbase, ios_base::iostate& _State, tm *_Pt) const
		{	// get year from [_First, _Last) into _Pt
		const _Ctype& _Ctype_fac = ::std:: use_facet<_Ctype>(_Iosbase.getloc());

		int _Ans = 0;
		ios_base::iostate _Res = _Getint(_First, _Last, 0, 9999,
			_Ans, _Ctype_fac);

		_State |= _Res;	// pass on eofbit and failbit
		if (!(_Res & ios_base::failbit))
			{
			if (_Ans < 69)
				{
				_Pt->tm_year = _Ans + 100;	// [0, 68] parsed as [2000, 2068]
				}
			else if (_Ans < 100)
				{
				_Pt->tm_year = _Ans;		// [69, 99] parsed as [1969, 1999]
				}
			else
				{
				_Pt->tm_year = _Ans - 1900;	// [100, 9999] parsed literally
				}
			}

		return (_First);
		}

	virtual _InIt  do_get(_InIt _First, _InIt _Last,
		ios_base& _Iosbase, ios_base::iostate& _State, tm *_Pt,
		char _Specifier, char = 0) const
		{	// get formatted time for _Specifier (_Modifier ignored)
		const _Ctype& _Ctype_fac = ::std:: use_facet<_Ctype>(_Iosbase.getloc());
		int _Ans = 0;

		_State = ios_base::goodbit;

		switch (_Specifier)
			{	// process format specifier
		case 'a':
		case 'A':
			_First = get_weekday(_First, _Last, _Iosbase, _State, _Pt);
			break;

		case 'b':
		case 'B':
		case 'h':
			_First = get_monthname(_First, _Last, _Iosbase, _State, _Pt);
			break;

		case 'c':
			_First = _Getfmt(_First, _Last, _Iosbase, _State, _Pt,
				"%b %d %H : %M : %S %Y");
			break;

		case 'C':
			_State |= _Getint(_First, _Last, 0, 99,
				_Ans, _Ctype_fac);
			if (!(_State & ios_base::failbit))
				_Pt->tm_year = _Ans * 100 - 1900;	// convert to century
			break;

		case 'd':
		case 'e':
			_State |= _Getint(_First, _Last, 1, 31,
				_Pt->tm_mday, _Ctype_fac);
			break;

		case 'D':
			_First = _Getfmt(_First, _Last, _Iosbase, _State, _Pt,
				"%m / %d / %y");
			break;

		case 'H':
			_State |= _Getint(_First, _Last, 0, 23,
				_Pt->tm_hour, _Ctype_fac);
			break;

		case 'I':
			_State |= _Getint(_First, _Last, 1, 12,
				_Ans, _Ctype_fac);
			if (!(_State & ios_base::failbit))
				_Pt->tm_hour = _Ans == 12 ? 0 : _Ans;
			break;

		case 'j':
			_State |= _Getint(_First, _Last, 1, 366,
				_Pt->tm_yday, _Ctype_fac);
			break;

		case 'm':
			_State |= _Getint(_First, _Last, 1, 12,
				_Ans, _Ctype_fac);
			if (!(_State & ios_base::failbit))
				_Pt->tm_mon = _Ans - 1;
			break;

		case 'M':
			_State |= _Getint(_First, _Last, 0, 59,
				_Pt->tm_min, _Ctype_fac);
			break;

		case 'n':
		case 't':
			_First = _Getfmt(_First, _Last, _Iosbase, _State, _Pt,
				" ");
			break;

		case 'p':
			_Ans = _Getloctxt(_First, _Last, (size_t)0, ":AM:am:PM:pm");
			if (_Ans < 0)
				_State |= ios_base::failbit;
			else if (1 < _Ans)
				_Pt->tm_hour += 12;
			break;

		case 'r':
			_First = _Getfmt(_First, _Last, _Iosbase, _State, _Pt,
				"%I : %M : %S %p");
			break;

		case 'R':
			_First = _Getfmt(_First, _Last, _Iosbase, _State, _Pt,
				"%H : %M");
			break;

		case 'S':
			_State |= _Getint(_First, _Last, 0, 60,
				_Pt->tm_sec, _Ctype_fac);
			break;

		case 'T':
		case 'X':
			_First = _Getfmt(_First, _Last, _Iosbase, _State, _Pt,
				"%H : %M : %S");
			break;

		case 'U':
			_State |= _Getint(_First, _Last, 0, 53,
				_Pt->tm_yday, _Ctype_fac);
			break;

		case 'w':
			_State |= _Getint(_First, _Last, 0, 6,
				_Pt->tm_wday, _Ctype_fac);
			break;

		case 'W':
			_State |= _Getint(_First, _Last, 0, 53,
				_Pt->tm_yday, _Ctype_fac);
			break;

		case 'x':
			_First = _Getfmt(_First, _Last, _Iosbase, _State, _Pt,
				"%d / %m / %y");
			break;

		case 'y':
			_State |= _Getint(_First, _Last, 0, 99,
				_Ans, _Ctype_fac);
			if (!(_State & ios_base::failbit))
				_Pt->tm_year = _Ans < 69 ? _Ans + 100 : _Ans;
			break;

		case 'Y':
			_First = get_year(_First, _Last, _Iosbase, _State, _Pt);
			break;

		default:
			_State |= ios_base::failbit;	// unknown specifier
			}

		if (_First == _Last)
			_State |= ios_base::eofbit;
		return (_First);
		}

	_InIt  _Getfmt(_InIt _First, _InIt _Last,
		ios_base& _Iosbase, ios_base::iostate& _State, tm *_Pt,
			const char *_Fmtfirst) const
		{	// get formatted time for format NTBS
		const _Ctype& _Ctype_fac = ::std:: use_facet<_Ctype>(_Iosbase.getloc());

		for (; *_Fmtfirst != '\0'; ++_Fmtfirst)
			{
			if (*_Fmtfirst == '%')
				{
				_First = do_get(_First, _Last, _Iosbase, _State, _Pt,
					*++_Fmtfirst);	// convert a single field
				}
			else if (*_Fmtfirst == ' ')
				{
				while (_First != _Last && _Ctype_fac.is(_Ctype::space, *_First))
					{
					++_First;
					}
				}
			else if (_Ctype_fac.narrow(*_First) != *_Fmtfirst)
				{	// bad literal match
				_State |= ios_base::failbit;
				break;
				}
			else
				{
				++_First;
				}
			}

		if (_First == _Last)
			{
			_State |= ios_base::eofbit;
			}

		return (_First);
		}

private:
	ios_base::iostate __cdecl _Getint(
		_InIt& _First, _InIt& _Last,
		int _Lo, int _Hi, int& _Val,
		const _Ctype& _Ctype_fac) const
		{	// get integer in range [_Lo, _Hi] from [_First, _Last)
		char _Ac[32], *_Ep;
		char *_Ptr = _Ac;
		char _Ch;

		if (_First != _Last)
			{
			if ((_Ch = _Ctype_fac.narrow(*_First)) == '+')
				{	// copy plus sign
				*_Ptr++ = '+';
				++_First;
				}
			else if (_Ch == '-')
				{	// copy minus sign
				*_Ptr++ = '-';
				++_First;
				}
			}

		bool _Seendigit = false;

		for (; _First != _Last && _Ctype_fac.narrow(*_First) == '0'; ++_First)
			{	// strip leading zeros
			_Seendigit = true;
			}

		if (_Seendigit)
			*_Ptr++ = '0';	// replace one or more with single zero

		for (char *const _Pe = &_Ac[32 - 1]; _First != _Last
			&& '0' <= (_Ch = _Ctype_fac.narrow(*_First)) && _Ch <= '9';
			_Seendigit = true, (void)++_First)
			{	// copy digits
			*_Ptr = _Ch;
			if (_Ptr < _Pe)
				++_Ptr;	// drop trailing digits if already too large
			}

		if (!_Seendigit)
			_Ptr = _Ac;
		*_Ptr = '\0';
		int _Errno = 0;
		const long _Ans = :: _Stolx(_Ac, &_Ep, 10, &_Errno);
		ios_base::iostate _State = ios_base::goodbit;

		if (_First == _Last)
			_State |= ios_base::eofbit;
		if (_Ep == _Ac || _Errno != 0 || _Ans < _Lo || _Hi < _Ans)
			_State |= ios_base::failbit;	// bad conversion
		else
			_Val = _Ans;	// store valid result
		return (_State);
		}

	void  _Tidy()
		{	// free all storage
		:: free((void *)_Days);
		:: free((void *)_Months);
		:: free((void *)_Ampm);
		}

	const _Elem *_Days;	// ":Sun:Sunday:Mon:Monday..." for example
	const _Elem *_Months;	// "Jan:January:Feb:February..." for example
	const _Elem *_Ampm;	// ":AM:am:PM:pm"
	dateorder _Dateorder;
	_Locinfo::_Cvtvec _Cvt;		// conversion information
	};

		// STATIC time_get::id OBJECT





template<class _Elem,
	class _InIt>
	 locale::id time_get<_Elem, _InIt>::id;





		// CLASS TEMPLATE time_get_byname
template<class _Elem,
	class _InIt = istreambuf_iterator<_Elem, char_traits<_Elem> > >
	class time_get_byname
		: public time_get<_Elem, _InIt>
	{	// time_get for named locale
public:
	explicit time_get_byname(const char *_Locname, size_t _Refs = 0)
		: time_get<_Elem, _InIt>(_Locname, _Refs)
		{	// construct for named locale
		}

	explicit time_get_byname(const string& _Str, size_t _Refs = 0)
		: time_get<_Elem, _InIt>(_Locinfo(_Str.c_str()), _Refs)
		{	// construct for named locale
		}

protected:
	virtual  ~time_get_byname() noexcept
		{	// destroy the object
		}
	};

		// CLASS TEMPLATE time_put
template<class _Elem,
	class _OutIt = ostreambuf_iterator<_Elem, char_traits<_Elem> > >
	class time_put
		: public locale::facet
	{	// facet for converting encoded times to text
public:
	typedef _Elem char_type;
	typedef _OutIt iter_type;
	typedef ctype<_Elem> _Ctype;

	_OutIt  put(_OutIt _Dest,
		ios_base& _Iosbase, _Elem _Fill, const tm *_Pt,
			const _Elem *_Fmtfirst, const _Elem *_Fmtlast) const
		{	// put formatted time from _Pt to _Dest for [_Fmtfirst, _Fmtlast)
		const _Ctype& _Ctype_fac = ::std:: use_facet<_Ctype>(_Iosbase.getloc());

		for (; _Fmtfirst != _Fmtlast; ++_Fmtfirst)
			{
			if (_Ctype_fac.narrow(*_Fmtfirst) != '%')
				{
				*_Dest++ = *_Fmtfirst;	// copy literal element
				}
			else if (++_Fmtfirst == _Fmtlast)
				{	// treat trailing % as %%
				*_Dest++ = _Fmtfirst[-1];
				break;
				}
			else
				{	// get specifier after %
				char _Specifier = _Ctype_fac.narrow(*_Fmtfirst);
				char _Modifier = '\0';
				_Elem _Percent = _Fmtfirst[-1];

				if (_Specifier == 'E' || _Specifier == 'O'
					|| _Specifier == 'Q' || _Specifier == '#')
					{
					if (++_Fmtfirst == _Fmtlast)
						{	// no specifier, copy %[E0Q#] as literal elements
						*_Dest++ = _Percent;
						*_Dest++ = _Specifier;
						break;
						}

					// save both qualifier and specifier
					_Modifier = _Specifier;
					_Specifier = _Ctype_fac.narrow(*_Fmtfirst);
					}

				_Dest = do_put(_Dest, _Iosbase, _Fill, _Pt,
					_Specifier, _Modifier);	// convert a single field
				}
			}

		return (_Dest);
		}

	_OutIt  put(_OutIt _Dest,
		ios_base& _Iosbase, _Elem _Fill, const tm *_Pt,
		char _Specifier, char _Modifier = '\0') const
		{	// put formatted time from _Pt to _Dest for _Specifier/_Modifier
		return (do_put(_Dest, _Iosbase, _Fill, _Pt, _Specifier, _Modifier));
		}

	 static locale::id id;	// unique facet id

	explicit  time_put(size_t _Refs = 0)
		: locale::facet(_Refs)
		{	// construct from current locale
		{ _Locinfo _Lobj;
			_Init(_Lobj);
		}
		}

	 time_put(const _Locinfo& _Lobj, size_t _Refs = 0)
		: locale::facet(_Refs)
		{	// construct from specified locale
		_Init(_Lobj);
		}

	static size_t __cdecl _Getcat(const locale::facet **_Ppf = nullptr,
		const locale *_Ploc = nullptr)
		{	// return locale category mask and construct standard facet
		if (_Ppf != nullptr && *_Ppf == nullptr)
			{
			*_Ppf = new time_put<_Elem, _OutIt>(_Locinfo(_Ploc->c_str()));
			}

		return (5);
		}

protected:
	virtual  ~time_put() noexcept
		{	// destroy the object
		}

	void  _Init(const _Locinfo& _Lobj)
		{	// initialize from _Lobj
		_Tnames = _Lobj._Gettnames();
		}

	virtual _OutIt  do_put(_OutIt _Dest,
		ios_base&, _Elem, const tm *_Pt,
			char _Specifier, char _Modifier = '\0') const
		{	// put formatted time from _Pt to _Dest for [_Fmtfirst, _Fmtlast)
		char _Fmt[5] = "!%x\0";	// '!' for nonzero count, null for modifier
		size_t _Count, _Num;
		string _Str;

		if (_Modifier == '\0')
			_Fmt[2] = _Specifier;
		else
			{	// add both modifier and specifier
			_Fmt[2] = _Modifier;
			_Fmt[3] = _Specifier;
			}

		for (_Num = 16; ; _Num *= 2)
			{	// convert into ever larger string buffer until success
			_Str.append(_Num, '\0');
			if (0 < (_Count = _Strftime(&*_Str.begin(), _Str.size(), _Fmt, _Pt, _Tnames._Getptr())))
				{
				break;
				}
			}

		return (::std:: copy(&_Str[1], &_Str[_Count], _Dest));
		}

private:
	_Locinfo::_Timevec _Tnames;	// locale-specific stuff for _Strftime
	};

		// STATIC time_put::id OBJECT





template<class _Elem,
	class _OutIt>
	 locale::id time_put<_Elem, _OutIt>::id;





		// CLASS time_put<wchar_t>
template<class _OutIt>
	class __declspec(dllimport) time_put<wchar_t, _OutIt>
		: public locale::facet
	{	// facet for converting encoded times to wchar_t text
public:
	typedef wchar_t _Elem;
	typedef _Elem char_type;
	typedef _OutIt iter_type;
	typedef ctype<_Elem> _Ctype;

	_OutIt  put(_OutIt _Dest,
		ios_base& _Iosbase, _Elem _Fill, const tm *_Pt,
			const _Elem *_Fmtfirst, const _Elem *_Fmtlast) const
		{	// put formatted time from _Pt to _Dest for [_Fmtfirst, _Fmtlast)
		const _Ctype& _Ctype_fac = ::std:: use_facet<_Ctype>(_Iosbase.getloc());

		for (; _Fmtfirst != _Fmtlast; ++_Fmtfirst)
			{
			if (_Ctype_fac.narrow(*_Fmtfirst) != '%')
				{
				*_Dest++ = *_Fmtfirst;	// copy literal element
				}
			else if (++_Fmtfirst == _Fmtlast)
				{	// treat trailing % as %%
				*_Dest++ = _Fmtfirst[-1];
				break;
				}
			else
				{	// get specifier after %
				_Elem _Raw = *_Fmtfirst;
				char _Specifier = _Ctype_fac.narrow(_Raw);
				char _Modifier = '\0';
				_Elem _Percent = _Fmtfirst[-1];

				if (_Specifier == 'E' || _Specifier == 'O'
					|| _Specifier == 'Q' || _Specifier == '#')
					{
					if (++_Fmtfirst == _Fmtlast)
						{	// no specifier, copy %[E0Q#] as literal elements
						*_Dest++ = _Percent;
						*_Dest++ = _Raw;
						break;
						}

					// save both qualifier and specifier
					_Modifier = _Specifier;
					_Specifier = _Ctype_fac.narrow(*_Fmtfirst);
					}

				_Dest = do_put(_Dest, _Iosbase, _Fill, _Pt,
					_Specifier, _Modifier);	// convert a single field
				}
			}

		return (_Dest);
		}

	_OutIt  put(_OutIt _Dest,
		ios_base& _Iosbase, _Elem _Fill, const tm *_Pt,
		char _Specifier, char _Modifier = '\0') const
		{	// put formatted time from _Pt to _Dest for _Specifier/_Modifier
		return (do_put(_Dest, _Iosbase, _Fill, _Pt, _Specifier, _Modifier));
		}

	 static locale::id id;	// unique facet id

	explicit  time_put(size_t _Refs = 0)
		: locale::facet(_Refs)
		{	// construct from current locale
		{ _Locinfo _Lobj;
			_Init(_Lobj);
		}
		}

	 time_put(const _Locinfo& _Lobj, size_t _Refs = 0)
		: locale::facet(_Refs)
		{	// construct from specified locale
		_Init(_Lobj);
		}

	static size_t __cdecl _Getcat(const locale::facet **_Ppf = nullptr,
		const locale *_Ploc = nullptr)
		{	// return locale category mask and construct standard facet
		if (_Ppf != nullptr && *_Ppf == nullptr)
			{
			*_Ppf = new time_put<_Elem, _OutIt>(_Locinfo(_Ploc->c_str()));
			}

		return (5);
		}

protected:
	virtual  ~time_put() noexcept
		{	// destroy the object
		}

	 time_put(const char *_Locname, size_t _Refs = 0)
		: locale::facet(_Refs)
		{	// construct from specified locale
		{ _Locinfo _Lobj(_Locname);
			_Init(_Lobj);
		}
		}

	void  _Init(const _Locinfo& _Lobj)
		{	// initialize from _Lobj
		_Tnames = _Lobj._W_Gettnames();
		}

	virtual _OutIt  do_put(_OutIt _Dest,
		ios_base&, _Elem, const tm *_Pt,
			char _Specifier, char _Modifier = '\0') const
		{	// put formatted time from _Pt to _Dest for [_Fmtfirst, _Fmtlast)
		wchar_t _Fmt[5] = L"!%x\0";	// ! for nonzero count, null for modifier
		size_t _Count, _Num;
		wstring _Str;

		if (_Modifier == '\0')
			_Fmt[2] = (_Elem)_Specifier;	// conversion rule unspecified
		else
			{	// add both modifier and specifier
			_Fmt[2] = (_Elem)_Modifier;
			_Fmt[3] = (_Elem)_Specifier;
			}

		for (_Num = 16; ; _Num *= 2)
			{	// convert into ever larger string buffer until success
			_Str.append(_Num, '\0');
			if (0 < (_Count = _Wcsftime(&*_Str.begin(), _Str.size(),
				_Fmt, _Pt, _Tnames._Getptr())))
				break;
			}
		return (::std:: copy(&_Str[1], &_Str[_Count], _Dest));
		}

private:
	_Locinfo::_Timevec _Tnames;	// locale-specific stuff for _Wcsftime
	};

		// STATIC time_put::id OBJECT





template<class _OutIt>
	 locale::id time_put<wchar_t, _OutIt>::id;





 































































































































































		// CLASS TEMPLATE time_put_byname
template<class _Elem,
	class _OutIt = ostreambuf_iterator<_Elem, char_traits<_Elem> > >
	class time_put_byname
		: public time_put<_Elem, _OutIt>
	{	// time_put for named locale
public:
	explicit time_put_byname(const char *_Locname, size_t _Refs = 0)
		: time_put<_Elem, _OutIt>(_Locname, _Refs)
		{	// construct for named locale
		}

	explicit time_put_byname(const string& _Str, size_t _Refs = 0)
		: time_put<_Elem, _OutIt>(_Str.c_str(), _Refs)
		{	// construct for named locale
		}

protected:
	virtual  ~time_put_byname() noexcept
		{	// destroy the object
		}
	};

 

  
template class __declspec(dllimport) time_get<char,
	istreambuf_iterator<char, char_traits<char> > >;
template class __declspec(dllimport) time_put<char,
	ostreambuf_iterator<char, char_traits<char> > >;
template  void  time_get<char,
	istreambuf_iterator<char, char_traits<char>>>::_Getvals(wchar_t, const _Locinfo&);

template class __declspec(dllimport) time_get<wchar_t,
	istreambuf_iterator<wchar_t, char_traits<wchar_t> > >;
template class __declspec(dllimport) time_put<wchar_t,
	ostreambuf_iterator<wchar_t, char_traits<wchar_t> > >;
template  void  time_get<wchar_t,
	istreambuf_iterator<wchar_t, char_traits<wchar_t>>>::_Getvals(wchar_t, const _Locinfo&);
  

  







 
}

 
 
 #pragma warning(pop)
 #pragma pack(pop)



/*
 * Copyright (c) by P.J. Plauger. All rights reserved.
 * Consult your license regarding permissions and restrictions.
V6.50:0009 */


 #pragma pack(push,8)
 #pragma warning(push,3)
 #pragma warning(disable: 4455 4494  4619 4643 4702 4984 4988 )
 
 
 

namespace std {
		// CLASS TEMPLATE collate
template<class _Elem>
	class collate
		: public locale::facet
	{	// facet for ordering sequences of elements
public:
	typedef _Elem char_type;
	typedef basic_string<_Elem, char_traits<_Elem>,
		allocator<_Elem> > string_type;

	int compare(const _Elem *_First1, const _Elem *_Last1,
		const _Elem *_First2, const _Elem *_Last2) const
		{	// compare [_First1, _Last1) to [_First2, _Last2)
		return (do_compare(_First1, _Last1, _First2, _Last2));
		}

	string_type transform(const _Elem *_First, const _Elem *_Last) const
		{	// transform [_First, _Last) to key string
		return (do_transform(_First, _Last));
		}

	long hash(const _Elem *_First, const _Elem *_Last) const
		{	// compute hash code for [_First, _Last)
		return (do_hash(_First, _Last));
		}

	 __declspec(dllimport) static locale::id id;	// unique facet id

	explicit collate(size_t _Refs = 0)
		: locale::facet(_Refs)
		{	// construct from current locale
		{ _Locinfo _Lobj;
			_Init(_Lobj);
		}
		}

	collate(const _Locinfo& _Lobj, size_t _Refs = 0)
		: locale::facet(_Refs)
		{	// construct from specified locale
		_Init(_Lobj);
		}

	static size_t _Getcat(const locale::facet **_Ppf = nullptr,
		const locale *_Ploc = nullptr)
		{	// return locale category mask and construct standard facet
		if (_Ppf != nullptr && *_Ppf == nullptr)
			*_Ppf = new collate<_Elem>(
				_Locinfo(_Ploc->name().c_str()));
		return (1);
		}

protected:
	 ~collate() noexcept
		{	// destroy the object
		:: free(_Coll._LocaleName);
		}

protected:
	collate(const char *_Locname, size_t _Refs = 0)
		: locale::facet(_Refs)
		{	// construct from specified locale
		{ _Locinfo _Lobj(_Locname);
			_Init(_Lobj);
		}
		}

	void _Init(const _Locinfo& _Lobj)
		{	// initialize from _Lobj
		_Coll = _Lobj._Getcoll();
		}

	virtual int  do_compare(const _Elem *_First1, const _Elem *_Last1,
		const _Elem *_First2, const _Elem *_Last2) const
		{	// compare [_First1, _Last1) to [_First2, _Last2)
		_Adl_verify_range(_First1, _Last1);
		_Adl_verify_range(_First2, _Last2);
		int _Ans = _LStrcoll(_First1, _Last1, _First2, _Last2, &_Coll);
		return (_Ans < 0 ? -1 : _Ans == 0 ? 0 : +1);
		}

	virtual string_type  do_transform(const _Elem *_First,
		const _Elem *_Last) const
		{	// transform [_First, _Last) to key string
		_Adl_verify_range(_First, _Last);
		size_t _Count;
		string_type _Str;

		for (_Count = static_cast<size_t>(_Last - _First); 0 < _Count; )
			{	// grow string if locale-specific strxfrm fails
			_Str.resize(_Count);
			if ((_Count = _LStrxfrm(&*_Str.begin(),
				&*_Str.begin() + _Str.size(),
					_First, _Last, &_Coll)) <= _Str.size())
				break;
			}
		_Str.resize(_Count);
		return (_Str);
		}

	virtual long  do_hash(const _Elem *_First, const _Elem *_Last) const
		{	// compute hash code for [_First, _Last)
		_Adl_verify_range(_First, _Last);
		return (static_cast<long>(_Hash_array_representation(_First, static_cast<size_t>(_Last - _First))));
		}

private:
	_Locinfo::_Collvec _Coll;	// used by _LStrcoll and _XStrxfrm
	};

		// STATIC collate::id OBJECT





template<class _Elem>
	 locale::id collate<_Elem>::id;

 

  
template  locale::id collate<char>::id;
template  locale::id collate<wchar_t>::id;
  

  


 





		// CLASS TEMPLATE collate_byname
template<class _Elem>
	class collate_byname
		: public collate<_Elem>
	{	// collate for named locale
public:
	explicit collate_byname(const char *_Locname, size_t _Refs = 0)
		: collate<_Elem>(_Locname, _Refs)
		{	// construct for named locale
		}

	explicit collate_byname(const string& _Str, size_t _Refs = 0)
		: collate<_Elem>(_Locinfo(_Str.c_str()), _Refs)
		{	// construct for named locale
		}

protected:
	virtual  ~collate_byname() noexcept
		{	// destroy the object
		}
	};

		// FUNCTION TEMPLATE has_facet
template<class _Facet> inline
	bool has_facet(const locale& _Loc) noexcept
	{	// test if facet is in locale
	{ ::std:: _Lockit _Lock(0);	// the thread lock, make get atomic
		size_t _Id = _Facet::id;
		return (_Loc._Getfacet(_Id) != nullptr
			|| _Facet::_Getcat() != (size_t)(-1));
	}
	}

		// FUNCTION TEMPLATE isalnum
template<class _Elem> inline
	bool (isalnum)(_Elem _Ch, const locale& _Loc)
	{	// test if character is alphanumeric, locale specific
	return (::std:: use_facet<ctype<_Elem>>(_Loc).is(ctype_base::alnum, _Ch));
	}

		// FUNCTION TEMPLATE isalpha
template<class _Elem> inline
	bool (isalpha)(_Elem _Ch, const locale& _Loc)
	{	// test if character is alphabetic, locale specific
	return (::std:: use_facet<ctype<_Elem>>(_Loc).is(ctype_base::alpha, _Ch));
	}

		// FUNCTION TEMPLATE isblank
template<class _Elem> inline
	bool (isblank)(_Elem _Ch, const locale& _Loc)
	{	// test if character is blank, locale specific
	return (::std:: use_facet<ctype<_Elem>>(_Loc).is(ctype_base::blank, _Ch));
	}

		// FUNCTION TEMPLATE iscntrl
template<class _Elem> inline
	bool (iscntrl)(_Elem _Ch, const locale& _Loc)
	{	// test if character is control, locale specific
	return (::std:: use_facet<ctype<_Elem>>(_Loc).is(ctype_base::cntrl, _Ch));
	}

		// FUNCTION TEMPLATE isdigit
template<class _Elem> inline
	bool (isdigit)(_Elem _Ch, const locale& _Loc)
	{	// test if character is digit, locale specific
	return (::std:: use_facet<ctype<_Elem>>(_Loc).is(ctype_base::digit, _Ch));
	}

		// FUNCTION TEMPLATE isgraph
template<class _Elem> inline
	bool (isgraph)(_Elem _Ch, const locale& _Loc)
	{	// test if character is graphic, locale specific
	return (::std:: use_facet<ctype<_Elem>>(_Loc).is(ctype_base::graph, _Ch));
	}

		// FUNCTION TEMPLATE islower
template<class _Elem> inline
	bool (islower)(_Elem _Ch, const locale& _Loc)
	{	// test if character is lower case, locale specific
	return (::std:: use_facet<ctype<_Elem>>(_Loc).is(ctype_base::lower, _Ch));
	}

		// FUNCTION TEMPLATE isprint
template<class _Elem> inline
	bool (isprint)(_Elem _Ch, const locale& _Loc)
	{	// test if character is printing, locale specific
	return (::std:: use_facet<ctype<_Elem>>(_Loc).is(ctype_base::print, _Ch));
	}

		// FUNCTION TEMPLATE ispunct
template<class _Elem> inline
	bool (ispunct)(_Elem _Ch, const locale& _Loc)
	{	// test if character is punctuation, locale specific
	return (::std:: use_facet<ctype<_Elem>>(_Loc).is(ctype_base::punct, _Ch));
	}

		// FUNCTION TEMPLATE isspace
template<class _Elem> inline
	bool (isspace)(_Elem _Ch, const locale& _Loc)
	{	// test if character is whitespace, locale specific
	return (::std:: use_facet<ctype<_Elem>>(_Loc).is(ctype_base::space, _Ch));
	}

		// FUNCTION TEMPLATE isupper
template<class _Elem> inline
	bool (isupper)(_Elem _Ch, const locale& _Loc)
	{	// test if character is upper case, locale specific
	return (::std:: use_facet<ctype<_Elem>>(_Loc).is(ctype_base::upper, _Ch));
	}

		// FUNCTION TEMPLATE isxdigit
template<class _Elem> inline
	bool (isxdigit)(_Elem _Ch, const locale& _Loc)
	{	// test if character is hexadecimal digit, locale specific
	return (::std:: use_facet<ctype<_Elem>>(_Loc).is(ctype_base::xdigit, _Ch));
	}

		// FUNCTION TEMPLATE tolower
template<class _Elem> inline
	_Elem (tolower)(_Elem _Ch, const locale& _Loc)
	{	// convert character to lower case, locale specific
	return (::std:: use_facet<ctype<_Elem>>(_Loc).tolower(_Ch));
	}

		// FUNCTION TEMPLATE toupper
template<class _Elem> inline
	_Elem (toupper)(_Elem _Ch, const locale& _Loc)
	{	// convert character to upper case, locale specific
	return (::std:: use_facet<ctype<_Elem>>(_Loc).toupper(_Ch));
	}
}
 
 
 #pragma warning(pop)
 #pragma pack(pop)



/*
 * Copyright (c) by P.J. Plauger. All rights reserved.
 * Consult your license regarding permissions and restrictions.
V6.50:0009 */











struct KeyEvent
{
	int code;
	bool isSpecial;
	KeyEvent(int code = -1, bool isSpecial = false) : code(code), isSpecial(isSpecial) {};

	bool isUpDown() { return isSpecial && (code == 72 || code == 80); }
	bool isLeftRight() { return isSpecial && (code == 75 || code == 77); }
};

KeyEvent getKeyEvent();
char convertWideCharToChar(wchar_t w);


using namespace std;

class MenuElement;
class MenuElementTitle;
class MenuElementSubtitle;
class MenuElementFunctionButton;
class MenuElementEditField;
class MenuElementChoice;

class FolderLeaveAttempt : public exception {};
class FolderProcessedUpDownKeyEvent : public exception {};

class MenuElement
{
protected:
	string text;
public:
	MenuElement(string text);
	virtual ~MenuElement();

	virtual string str() const = 0;
	virtual void processKeyEvent(KeyEvent keyEvent) = 0;
	virtual bool isChoosable() = 0;
	virtual string getAdditionalText();
	auto& getText();
};

class MenuElementTitle : public MenuElement
{
public:
	MenuElementTitle(string text);
	~MenuElementTitle() {};

	string str() const;
	void processKeyEvent(KeyEvent keyEvent);
	bool isChoosable();
};

class MenuElementSubtitle : public MenuElement
{
public:
	MenuElementSubtitle(string text) : MenuElement(text) {};
	~MenuElementSubtitle() {};

	string str() const;
	void processKeyEvent(KeyEvent keyEvent) {};
	bool isChoosable() { return false; };
};

class MenuElementFunctionButton : public MenuElement
{
private:
	void(*buttonPressHandler)();
public:
	MenuElementFunctionButton(string text, void(*buttonPressHandler)()) : MenuElement(text), buttonPressHandler(buttonPressHandler) {};
	~MenuElementFunctionButton() {};
	string str() const;
	void processKeyEvent(KeyEvent keyEvent);
	bool isChoosable() { return true; };
	auto& getButtonPressHandler() { return buttonPressHandler; };
};

class MenuElementEditField : public MenuElement
{
private:
	string input;
	bool isTextHidden;
	string allowedSymbols;
	int maxLength;
	int minLength;
public:
	MenuElementEditField(string text, bool isTextHidden = false, string allowedSymbols = "", int minLength = 0, int maxLength = 0) :
		MenuElement(text), input(""), isTextHidden(isTextHidden), allowedSymbols(allowedSymbols), minLength(minLength), maxLength(maxLength) {};
	~MenuElementEditField() {};

	string str() const;
	string& getInput();
	bool hasFreeSpace();
	bool isCharAllowed(char ch);
	void processKeyEvent(KeyEvent keyEvent);
	bool isChoosable() { return true; };
	string getAdditionalText() override
	{
		return "          " + to_string(minLength) + " .\n"
			"         : " + allowedSymbols;
	}
};

class MenuElementChoice : public MenuElement
{
public:
	static const string noChoicesFoundMessage;
private:
	vector<string> options;
	int activeOption = 0;
public:
	MenuElementChoice(string text, vector<string> options) : MenuElement(text), options(options) {};
	MenuElementChoice(string text, int rangeStart, int rangeEnd, int rangeStep = 1) : MenuElement(text)
	{
		for (int i = rangeStart; i < rangeEnd; i += rangeStep)
		{
			options.push_back(to_string(i));
		}
	};

	~MenuElementChoice() {};

	string str() const;

	// TODO:  
	//     (  ),  MenuElementChoice::noChoicesFoundMessage.
	string getChoice()
	{
		if (options.size())
		{
			return options[activeOption];
		}
		else
		{
			return noChoicesFoundMessage;
		}
	};
	auto& getOptions() { return options; };
	auto& getActiveOption() { return activeOption; };
	void processKeyEvent(KeyEvent keyEvent);
	bool isChoosable() { return true; };
};

class MenuElementFolder : public MenuElement
{
private:
	vector<MenuElement *> elements;
	int chosenElementIndex;
	bool isActive;
public:
	MenuElementFolder(string text) : chosenElementIndex(0), isActive(false), MenuElement(text) {};
	~MenuElementFolder() {
		for (auto it : elements)
		{
			delete it;
		}
	};

	string str() const;
	void processKeyEvent(KeyEvent keyEvent);
	bool isChoosable() { return true; };
	auto& getElements() { return elements; };
	auto& getIsActive() { return isActive; };

	MenuElementFolder* addElement(MenuElement * ref)
	{
		elements.push_back(ref);
		return this;
	}
};

int findNextActiveElementIndex(vector<MenuElement*> elements, int chosenElementIndex);
int findPrevActiveElementIndex(vector<MenuElement*> elements, int chosenElementIndex);


using namespace std;

class Menu;

class MenuIsEmpty : public exception {};
class MenuHasNoChosenElement : public exception {};

class Menu
{
private:
	static stack<Menu *> menuStack;
	static bool isLoopRunning;
	static mutex g_lock;
	static const int viewField;
	vector<MenuElement *> elements;
	int chosenElementIndex;
	static void controlLoop();
	static void printLoop();
	static void noBlinkOutput(string src);
	Menu* (*contentGenerator)();
public:
	//      -1,         
	Menu() : chosenElementIndex(-1) {};
	~Menu()
	{
		for (auto it : elements)
		{
			delete it;
		}
	};
	string str() const;
	void processKeyEvent(KeyEvent keyEvent);
	Menu* addElement(MenuElement* ref);
	void addToStack();
	auto& getElements() { return elements; }
	//    ,      
	Menu* initChosenElementIndex();
	int getChosenElementIndex() { return chosenElementIndex; };
	static Menu* getActive() { return menuStack.top(); };
	static void popStack(int popCount = 1);
	static void run()
	{
		thread t1(controlLoop);
		thread t2(printLoop);
		t1.join();
		t2.join();
	}
	static void finish() { isLoopRunning = false; };
	static auto& getMutex() { return g_lock; };
	static void setConsoleResolution();

	auto& getContentGenerator() { return contentGenerator; }
};



// map standard header
#pragma once






// xtree internal header
#pragma once










 #pragma pack(push,8)
 #pragma warning(push,3)
 #pragma warning(disable: 4455 4494  4619 4643 4702 4984 4988 )
 
 
 

namespace std {
		// CLASS TEMPLATE _Tree_unchecked_const_iterator
template<class _Mytree,
	class _Base = _Iterator_base0>
	class _Tree_unchecked_const_iterator
		: public _Base
	{	// unchecked iterator for nonmutable tree
public:
	using iterator_category = bidirectional_iterator_tag;

	using _Nodeptr = typename _Mytree::_Nodeptr;
	using value_type = typename _Mytree::value_type;
	using difference_type = typename _Mytree::difference_type;
	using pointer = typename _Mytree::const_pointer;
	using reference = const value_type&;

	_Tree_unchecked_const_iterator()
		: _Ptr()
		{	// construct with null node pointer
		}

	_Tree_unchecked_const_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
		: _Ptr(_Pnode)
		{	// construct with node pointer _Pnode
		this->_Adopt(_Plist);
		}

	 reference operator*() const
		{	// return designated value
		return (_Ptr->_Myval);
		}

	 pointer operator->() const
		{	// return pointer to class object
		return (pointer_traits<pointer>::pointer_to(**this));
		}

	_Tree_unchecked_const_iterator& operator++()
		{	// preincrement
		if (_Ptr->_Right->_Isnil)
			{	// climb looking for right subtree
			_Nodeptr _Pnode;
			while (!(_Pnode = _Ptr->_Parent)->_Isnil && _Ptr == _Pnode->_Right)
				{
				_Ptr = _Pnode;	// ==> parent while right subtree
				}

			_Ptr = _Pnode;	// ==> parent (head if end())
			}
		else
			{
			_Ptr = _Mytree::_Min(_Ptr->_Right);	// ==> smallest of right subtree
			}

		return (*this);
		}

	_Tree_unchecked_const_iterator operator++(int)
		{	// postincrement
		_Tree_unchecked_const_iterator _Tmp = *this;
		++*this;
		return (_Tmp);
		}

	_Tree_unchecked_const_iterator& operator--()
		{	// predecrement
		if (_Ptr->_Isnil)
			{
			_Ptr = _Ptr->_Right;	// end() ==> rightmost
			}
		else if (_Ptr->_Left->_Isnil)
			{	// climb looking for left subtree
			_Nodeptr _Pnode;
			while (!(_Pnode = _Ptr->_Parent)->_Isnil && _Ptr == _Pnode->_Left)
				{
				_Ptr = _Pnode;	// ==> parent while left subtree
				}

			if (!_Ptr->_Isnil)
				{	// decrement non-begin()
				_Ptr = _Pnode;	// ==> parent if not head
				}
			}
		else
			{
			_Ptr = _Mytree::_Max(_Ptr->_Left);	// ==> largest of left subtree
			}

		return (*this);
		}

	_Tree_unchecked_const_iterator operator--(int)
		{	// postdecrement
		_Tree_unchecked_const_iterator _Tmp = *this;
		--*this;
		return (_Tmp);
		}

	 bool operator==(const _Tree_unchecked_const_iterator& _Right) const
		{	// test for iterator equality
		return (_Ptr == _Right._Ptr);
		}

	 bool operator!=(const _Tree_unchecked_const_iterator& _Right) const
		{	// test for iterator inequality
		return (!(*this == _Right));
		}

	_Nodeptr _Ptr;	// pointer to node
	};

	// CLASS TEMPLATE _Tree_unchecked_iterator
template<class _Mytree>
	class _Tree_unchecked_iterator
		: public _Tree_unchecked_const_iterator<_Mytree>
	{	// unchecked iterator for mutable tree
public:
	using _Mybase = _Tree_unchecked_const_iterator<_Mytree>;
	using iterator_category = bidirectional_iterator_tag;

	using _Nodeptr = typename _Mytree::_Nodeptr;
	using value_type = typename _Mytree::value_type;
	using difference_type = typename _Mytree::difference_type;
	using pointer = typename _Mytree::pointer;
	using reference = value_type&;

	_Tree_unchecked_iterator()
		{	// construct with null node
		}

	_Tree_unchecked_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
		: _Mybase(_Pnode, _Plist)
		{	// construct with node pointer _Pnode
		}

	 reference operator*() const
		{	// return designated value
		return ((reference)**(_Mybase *)this);
		}

	 pointer operator->() const
		{	// return pointer to class object
		return (pointer_traits<pointer>::pointer_to(**this));
		}

	_Tree_unchecked_iterator& operator++()
		{	// preincrement
		++static_cast<_Mybase&>(*this);
		return (*this);
		}

	_Tree_unchecked_iterator operator++(int)
		{	// postincrement
		_Tree_unchecked_iterator _Tmp = *this;
		++*this;
		return (_Tmp);
		}

	_Tree_unchecked_iterator& operator--()
		{	// predecrement
		--static_cast<_Mybase&>(*this);
		return (*this);
		}

	_Tree_unchecked_iterator operator--(int)
		{	// postdecrement
		_Tree_unchecked_iterator _Tmp = *this;
		--*this;
		return (_Tmp);
		}
	};

	// CLASS TEMPLATE _Tree_const_iterator
template<class _Mytree>
	class _Tree_const_iterator
		: public _Tree_unchecked_const_iterator<_Mytree, _Iterator_base>
	{	// iterator for nonmutable tree
public:
	using _Mybase = _Tree_unchecked_const_iterator<_Mytree, _Iterator_base>;
	using iterator_category = bidirectional_iterator_tag;

	using _Nodeptr = typename _Mytree::_Nodeptr;
	using value_type = typename _Mytree::value_type;
	using difference_type = typename _Mytree::difference_type;
	using pointer = typename _Mytree::const_pointer;
	using reference = const value_type&;

	_Tree_const_iterator()
		: _Mybase()
		{	// construct with null node pointer
		}

	_Tree_const_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
		: _Mybase(_Pnode, _Plist)
		{	// construct with node pointer _Pnode
		}

	 reference operator*() const
		{	// return designated value
 
		const auto _Mycont = static_cast<const _Mytree *>(this->_Getcont());
		do { if (_Mycont) { } else { do { (void) ((1 != _CrtDbgReport(2, "c:\\visual studio\\vc\\tools\\msvc\\14.16.27023\\include\\xtree", 221, 0, "%s", "cannot dereference value-initialized map/set iterator")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"cannot dereference value-initialized map/set iterator\"", __LPREFIX( __FUNCTION__), L"c:\\visual studio\\vc\\tools\\msvc\\14.16.27023\\include\\xtree", 221, 0); } while (false); } ; } while (false);
		do { if (this->_Ptr != _Mycont->_Myhead) { } else { do { (void) ((1 != _CrtDbgReport(2, "c:\\visual studio\\vc\\tools\\msvc\\14.16.27023\\include\\xtree", 222, 0, "%s", "cannot dereference end map/set iterator")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"cannot dereference end map/set iterator\"", __LPREFIX( __FUNCTION__), L"c:\\visual studio\\vc\\tools\\msvc\\14.16.27023\\include\\xtree", 222, 0); } while (false); } ; } while (false);
 

		return (this->_Ptr->_Myval);
		}

	 pointer operator->() const
		{	// return pointer to class object
		return (pointer_traits<pointer>::pointer_to(**this));
		}

	_Tree_const_iterator& operator++()
		{	// preincrement
 
		do { if (this->_Getcont()) { } else { do { (void) ((1 != _CrtDbgReport(2, "c:\\visual studio\\vc\\tools\\msvc\\14.16.27023\\include\\xtree", 236, 0, "%s", "cannot increment value-initialized map/set iterator")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"cannot increment value-initialized map/set iterator\"", __LPREFIX( __FUNCTION__), L"c:\\visual studio\\vc\\tools\\msvc\\14.16.27023\\include\\xtree", 236, 0); } while (false); } ; } while (false);
		do { if (!this->_Ptr->_Isnil) { } else { do { (void) ((1 != _CrtDbgReport(2, "c:\\visual studio\\vc\\tools\\msvc\\14.16.27023\\include\\xtree", 237, 0, "%s", "cannot increment end map/set iterator")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"cannot increment end map/set iterator\"", __LPREFIX( __FUNCTION__), L"c:\\visual studio\\vc\\tools\\msvc\\14.16.27023\\include\\xtree", 237, 0); } while (false); } ; } while (false);
 

		++static_cast<_Mybase&>(*this);
		return (*this);
		}

	_Tree_const_iterator operator++(int)
		{	// postincrement
		_Tree_const_iterator _Tmp = *this;
		++*this;
		return (_Tmp);
		}

	_Tree_const_iterator& operator--()
		{	// predecrement
 


		do { if (this->_Getcont()) { } else { do { (void) ((1 != _CrtDbgReport(2, "c:\\visual studio\\vc\\tools\\msvc\\14.16.27023\\include\\xtree", 256, 0, "%s", "cannot decrement value-initialized map/set iterator")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"cannot decrement value-initialized map/set iterator\"", __LPREFIX( __FUNCTION__), L"c:\\visual studio\\vc\\tools\\msvc\\14.16.27023\\include\\xtree", 256, 0); } while (false); } ; } while (false);
		_Nodeptr _Ptrsav = this->_Ptr;
		--static_cast<_Mybase&>(*this);
		do { if (_Ptrsav != this->_Ptr) { } else { do { (void) ((1 != _CrtDbgReport(2, "c:\\visual studio\\vc\\tools\\msvc\\14.16.27023\\include\\xtree", 259, 0, "%s", "cannot decrement begin map/set iterator")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"cannot decrement begin map/set iterator\"", __LPREFIX( __FUNCTION__), L"c:\\visual studio\\vc\\tools\\msvc\\14.16.27023\\include\\xtree", 259, 0); } while (false); } ; } while (false);
 

		return (*this);
		}

	_Tree_const_iterator operator--(int)
		{	// postdecrement
		_Tree_const_iterator _Tmp = *this;
		--*this;
		return (_Tmp);
		}

	 bool operator==(const _Tree_const_iterator& _Right) const
		{	// test for iterator equality
 
		do { if (this->_Getcont() == _Right._Getcont()) { } else { do { (void) ((1 != _CrtDbgReport(2, "c:\\visual studio\\vc\\tools\\msvc\\14.16.27023\\include\\xtree", 275, 0, "%s", "map/set iterators incompatible")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"map/set iterators incompatible\"", __LPREFIX( __FUNCTION__), L"c:\\visual studio\\vc\\tools\\msvc\\14.16.27023\\include\\xtree", 275, 0); } while (false); } ; } while (false);
 

		return (this->_Ptr == _Right._Ptr);
		}

	 bool operator!=(const _Tree_const_iterator& _Right) const
		{	// test for iterator inequality
		return (!(*this == _Right));
		}

 
	friend void _Verify_range(const _Tree_const_iterator& _First, const _Tree_const_iterator& _Last)
		{
		do { if (_First._Getcont() == _Last._Getcont()) { } else { do { (void) ((1 != _CrtDbgReport(2, "c:\\visual studio\\vc\\tools\\msvc\\14.16.27023\\include\\xtree", 290, 0, "%s", "map/set iterators in range are from different containers")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"map/set iterators in range are from different containers\"", __LPREFIX( __FUNCTION__), L"c:\\visual studio\\vc\\tools\\msvc\\14.16.27023\\include\\xtree", 290, 0); } while (false); } ; } while (false);
		}
 

	 _Tree_unchecked_const_iterator<_Mytree> _Unwrapped() const
		{
		return (_Tree_unchecked_const_iterator<_Mytree>(this->_Ptr, static_cast<const _Mytree *>(this->_Getcont())));
		}

	void _Seek_to(const _Tree_unchecked_const_iterator<_Mytree> _It)
		{
		this->_Ptr = _It._Ptr;
		}
	};

	// CLASS TEMPLATE _Tree_iterator
template<class _Mytree>
	class _Tree_iterator
		: public _Tree_const_iterator<_Mytree>
	{	// iterator for mutable tree
public:
	using _Mybase = _Tree_const_iterator<_Mytree>;
	using iterator_category = bidirectional_iterator_tag;

	using _Nodeptr = typename _Mytree::_Nodeptr;
	using value_type = typename _Mytree::value_type;
	using difference_type = typename _Mytree::difference_type;

	using pointer = typename _Mytree::pointer;
	using reference = value_type&;

	_Tree_iterator()
		{	// construct with null node
		}

	_Tree_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
		: _Mybase(_Pnode, _Plist)
		{	// construct with node pointer _Pnode
		}

	 reference operator*() const
		{	// return designated value
		return ((reference)**(_Mybase *)this);
		}

	 pointer operator->() const
		{	// return pointer to class object
		return (pointer_traits<pointer>::pointer_to(**this));
		}

	_Tree_iterator& operator++()
		{	// preincrement
		++static_cast<_Mybase&>(*this);
		return (*this);
		}

	_Tree_iterator operator++(int)
		{	// postincrement
		_Tree_iterator _Tmp = *this;
		++*this;
		return (_Tmp);
		}

	_Tree_iterator& operator--()
		{	// predecrement
		--static_cast<_Mybase&>(*this);
		return (*this);
		}

	_Tree_iterator operator--(int)
		{	// postdecrement
		_Tree_iterator _Tmp = *this;
		--*this;
		return (_Tmp);
		}

	 _Tree_unchecked_iterator<_Mytree> _Unwrapped() const
		{
		return (_Tree_unchecked_iterator<_Mytree>(this->_Ptr, static_cast<const _Mytree *>(this->_Getcont())));
		}
	};

		// tree TYPE WRAPPERS
template<class _Value_type,
	class _Size_type,
	class _Difference_type,
	class _Pointer,
	class _Const_pointer,
	class _Reference,
	class _Const_reference,
	class _Nodeptr_type>
	struct _Tree_iter_types
	{	// wraps types needed by iterators
	using value_type = _Value_type;
	using size_type = _Size_type;
	using difference_type = _Difference_type;
	using pointer = _Pointer;
	using const_pointer = _Const_pointer;
	using _Nodeptr = _Nodeptr_type;
	};

template<class _Value_type,
	class _Voidptr>
	struct _Tree_node
		{	// tree node
		using _Nodeptr = _Rebind_pointer_t<_Voidptr, _Tree_node>;
		_Nodeptr _Left;	// left subtree, or smallest element if head
		_Nodeptr _Parent;	// parent, or root of tree if head
		_Nodeptr _Right;	// right subtree, or largest element if head
		char _Color;	// _Red or _Black, _Black if head
		char _Isnil;	// true only if head (also nil) node
		_Value_type _Myval;	// the stored value, unused if head

		_Tree_node& operator=(const _Tree_node&) = delete;

		template<class _Alloc>
			static void _Freenode0(_Alloc& _Al, _Nodeptr _Ptr) noexcept
			{
			using _Alnode = _Rebind_alloc_t<_Alloc, _Tree_node>;
			using _Alnode_traits = allocator_traits<_Alnode>;
			_Alnode _Node_alloc(_Al);
			_Alnode_traits::destroy(_Node_alloc, ::std:: addressof(_Ptr->_Left));
			_Alnode_traits::destroy(_Node_alloc, ::std:: addressof(_Ptr->_Parent));
			_Alnode_traits::destroy(_Node_alloc, ::std:: addressof(_Ptr->_Right));
			_Alnode_traits::deallocate(_Node_alloc, _Ptr, 1);
			}
		};

template<class _Ty>
	struct _Tree_simple_types
		: public _Simple_types<_Ty>
	{	// wraps types needed by iterators
	using _Node = _Tree_node<_Ty, void *>;
	using _Nodeptr = _Node *;
	};

template<class _Ty,
	class _Alloc>
	struct _Tree_base_types
	{	// types needed for a container base
	using _Alty = _Rebind_alloc_t<_Alloc, _Ty>;
	using _Alty_traits = allocator_traits<_Alty>;
	using _Node = _Tree_node<_Ty, typename allocator_traits<_Alloc>::void_pointer>;
	using _Alnode = _Rebind_alloc_t<_Alloc, _Node>;
	using _Alnode_traits = allocator_traits<_Alnode>;
	using _Nodeptr = typename _Alnode_traits::pointer;

	using _Val_types = conditional_t<_Is_simple_alloc_v<_Alnode>,
		_Tree_simple_types<_Ty>,
		_Tree_iter_types<_Ty,
			typename _Alty_traits::size_type,
			typename _Alty_traits::difference_type,
			typename _Alty_traits::pointer,
			typename _Alty_traits::const_pointer,
			_Ty&,
			const _Ty&,
			_Nodeptr>>;
	};

		// CLASS TEMPLATE _Tree_val
template<class _Val_types>
	class _Tree_val
		: public _Container_base
	{	// base class for tree to hold data
public:
	using _Nodeptr = typename _Val_types::_Nodeptr;

	using value_type = typename _Val_types::value_type;
	using size_type = typename _Val_types::size_type;
	using difference_type = typename _Val_types::difference_type;
	using pointer = typename _Val_types::pointer;
	using const_pointer = typename _Val_types::const_pointer;
	using reference = value_type&;
	using const_reference = const value_type&;

	using const_iterator = _Tree_const_iterator<_Tree_val>;

	_Tree_val()
		: _Myhead(),
		_Mysize(0)
		{	// initialize data
		}

	enum _Redbl
		{	// colors for link to parent
		_Red, _Black};

	static _Nodeptr _Max(_Nodeptr _Pnode)
		{	// return rightmost node in subtree at _Pnode
		while (!_Pnode->_Right->_Isnil)
			_Pnode = _Pnode->_Right;
		return (_Pnode);
		}

	static _Nodeptr _Min(_Nodeptr _Pnode)
		{	// return leftmost node in subtree at _Pnode
		while (!_Pnode->_Left->_Isnil)
			_Pnode = _Pnode->_Left;
		return (_Pnode);
		}

	_Nodeptr& _Root() const
		{	// return root of nonmutable tree
		return (_Myhead->_Parent);
		}

	_Nodeptr& _Lmost() const
		{	// return leftmost node in nonmutable tree
		return (_Myhead->_Left);
		}

	_Nodeptr& _Rmost() const
		{	// return rightmost node in nonmutable tree
		return (_Myhead->_Right);
		}

	void _Lrotate(_Nodeptr _Wherenode)
		{	// promote right node to root of subtree
		_Nodeptr _Pnode = _Wherenode->_Right;
		_Wherenode->_Right = _Pnode->_Left;

		if (!_Pnode->_Left->_Isnil)
			{
			_Pnode->_Left->_Parent = _Wherenode;
			}

		_Pnode->_Parent = _Wherenode->_Parent;

		if (_Wherenode == _Myhead->_Parent)
			{
			_Myhead->_Parent = _Pnode;
			}
		else if (_Wherenode == _Wherenode->_Parent->_Left)
			{
			_Wherenode->_Parent->_Left = _Pnode;
			}
		else
			{
			_Wherenode->_Parent->_Right = _Pnode;
			}

		_Pnode->_Left = _Wherenode;
		_Wherenode->_Parent = _Pnode;
		}

	void _Rrotate(_Nodeptr _Wherenode)
		{	// promote left node to root of subtree
		_Nodeptr _Pnode = _Wherenode->_Left;
		_Wherenode->_Left = _Pnode->_Right;

		if (!_Pnode->_Right->_Isnil)
			_Pnode->_Right->_Parent = _Wherenode;
		_Pnode->_Parent = _Wherenode->_Parent;

		if (_Wherenode == _Myhead->_Parent)
			{
			_Myhead->_Parent = _Pnode;
			}
		else if (_Wherenode == _Wherenode->_Parent->_Right)
			{
			_Wherenode->_Parent->_Right = _Pnode;
			}
		else
			{
			_Wherenode->_Parent->_Left = _Pnode;
			}

		_Pnode->_Right = _Wherenode;
		_Wherenode->_Parent = _Pnode;
		}

	_Nodeptr _Extract(const_iterator _Where)
		{	// extract node at _Where
 
		do { if (_Where._Getcont() == this && !_Where._Ptr->_Isnil) { } else { do { (void) ((1 != _CrtDbgReport(2, "c:\\visual studio\\vc\\tools\\msvc\\14.16.27023\\include\\xtree", 565, 0, "%s", "map/set erase iterator outside range")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"map/set erase iterator outside range\"", __LPREFIX( __FUNCTION__), L"c:\\visual studio\\vc\\tools\\msvc\\14.16.27023\\include\\xtree", 565, 0); } while (false); } ; } while (false);
 

		_Nodeptr _Erasednode = _Where._Ptr;	// node to erase
		++_Where;	// save successor iterator for return

		_Nodeptr _Fixnode;	// the node to recolor as needed
		_Nodeptr _Fixnodeparent;	// parent of _Fixnode (which may be nil)
		_Nodeptr _Pnode = _Erasednode;

		if (_Pnode->_Left->_Isnil)
			{
			_Fixnode = _Pnode->_Right;	// stitch up right subtree
			}
		else if (_Pnode->_Right->_Isnil)
			{
			_Fixnode = _Pnode->_Left;	// stitch up left subtree
			}
		else
			{	// two subtrees, must lift successor node to replace erased
			_Pnode = _Where._Ptr;	// _Pnode is successor node
			_Fixnode = _Pnode->_Right;	// _Fixnode is only subtree
			}

		if (_Pnode == _Erasednode)
			{	// at most one subtree, relink it
			_Fixnodeparent = _Erasednode->_Parent;
			if (!_Fixnode->_Isnil)
				_Fixnode->_Parent = _Fixnodeparent;	// link up

			if (_Root() == _Erasednode)
				{
				_Root() = _Fixnode;	// link down from root
				}
			else if (_Fixnodeparent->_Left == _Erasednode)
				{
				_Fixnodeparent->_Left = _Fixnode;	// link down to left
				}
			else
				{
				_Fixnodeparent->_Right = _Fixnode;	// link down to right
				}

			if (_Lmost() == _Erasednode)
				{
				_Lmost() = _Fixnode->_Isnil
					? _Fixnodeparent	// smallest is parent of erased node
					: _Min(_Fixnode);	// smallest in relinked subtree
				}

			if (_Rmost() == _Erasednode)
				{
				_Rmost() = _Fixnode->_Isnil
					? _Fixnodeparent	// largest is parent of erased node
					: _Max(_Fixnode);	// largest in relinked subtree
				}
			}
		else
			{	// erased has two subtrees, _Pnode is successor to erased
			_Erasednode->_Left->_Parent = _Pnode;	// link left up
			_Pnode->_Left = _Erasednode->_Left;	// link successor down

			if (_Pnode == _Erasednode->_Right)
				{
				_Fixnodeparent = _Pnode;	// successor is next to erased
				}
			else
				{	// successor further down, link in place of erased
				_Fixnodeparent = _Pnode->_Parent;	// parent is successor's
				if (!_Fixnode->_Isnil)
					{
					_Fixnode->_Parent = _Fixnodeparent;	// link fix up
					}

				_Fixnodeparent->_Left = _Fixnode;	// link fix down
				_Pnode->_Right = _Erasednode->_Right;	// link next down
				_Erasednode->_Right->_Parent = _Pnode;	// right up
				}

			if (_Root() == _Erasednode)
				{
				_Root() = _Pnode;	// link down from root
				}
			else if (_Erasednode->_Parent->_Left == _Erasednode)
				{
				_Erasednode->_Parent->_Left = _Pnode;	// link down to left
				}
			else
				{
				_Erasednode->_Parent->_Right = _Pnode;	// link down to right
				}

			_Pnode->_Parent = _Erasednode->_Parent;	// link successor up
			::std:: swap(_Pnode->_Color, _Erasednode->_Color);	// recolor it
			}

		if (_Erasednode->_Color == this->_Black)
			{	// erasing black link, must recolor/rebalance tree
			for (; _Fixnode != _Root()
				&& _Fixnode->_Color == this->_Black;
				_Fixnodeparent = _Fixnode->_Parent)
				if (_Fixnode == _Fixnodeparent->_Left)
					{	// fixup left subtree
					_Pnode = _Fixnodeparent->_Right;
					if (_Pnode->_Color == this->_Red)
						{	// rotate red up from right subtree
						_Pnode->_Color = this->_Black;
						_Fixnodeparent->_Color = this->_Red;
						_Lrotate(_Fixnodeparent);
						_Pnode = _Fixnodeparent->_Right;
						}

					if (_Pnode->_Isnil)
						_Fixnode = _Fixnodeparent;	// shouldn't happen
					else if (_Pnode->_Left->_Color == this->_Black
						&& _Pnode->_Right->_Color == this->_Black)
						{	// redden right subtree with black children
						_Pnode->_Color = this->_Red;
						_Fixnode = _Fixnodeparent;
						}
					else
						{	// must rearrange right subtree
						if (_Pnode->_Right->_Color == this->_Black)
							{	// rotate red up from left sub-subtree
							_Pnode->_Left->_Color = this->_Black;
							_Pnode->_Color = this->_Red;
							_Rrotate(_Pnode);
							_Pnode = _Fixnodeparent->_Right;
							}

						_Pnode->_Color = _Fixnodeparent->_Color;
						_Fixnodeparent->_Color = this->_Black;
						_Pnode->_Right->_Color = this->_Black;
						_Lrotate(_Fixnodeparent);
						break;	// tree now recolored/rebalanced
						}
					}
				else
					{	// fixup right subtree
					_Pnode = _Fixnodeparent->_Left;
					if (_Pnode->_Color == this->_Red)
						{	// rotate red up from left subtree
						_Pnode->_Color = this->_Black;
						_Fixnodeparent->_Color = this->_Red;
						_Rrotate(_Fixnodeparent);
						_Pnode = _Fixnodeparent->_Left;
						}

					if (_Pnode->_Isnil)
						_Fixnode = _Fixnodeparent;	// shouldn't happen
					else if (_Pnode->_Right->_Color == this->_Black
						&& _Pnode->_Left->_Color == this->_Black)
						{	// redden left subtree with black children
						_Pnode->_Color = this->_Red;
						_Fixnode = _Fixnodeparent;
						}
					else
						{	// must rearrange left subtree
						if (_Pnode->_Left->_Color == this->_Black)
							{	// rotate red up from right sub-subtree
							_Pnode->_Right->_Color = this->_Black;
							_Pnode->_Color = this->_Red;
							_Lrotate(_Pnode);
							_Pnode = _Fixnodeparent->_Left;
							}

						_Pnode->_Color = _Fixnodeparent->_Color;
						_Fixnodeparent->_Color = this->_Black;
						_Pnode->_Left->_Color = this->_Black;
						_Rrotate(_Fixnodeparent);
						break;	// tree now recolored/rebalanced
						}
					}

			_Fixnode->_Color = this->_Black;	// stopping node is black
			}

		if (0 < _Mysize)
			--_Mysize;

		return (_Erasednode);
		}

	_Nodeptr _Myhead;	// pointer to head node
	size_type _Mysize;	// number of elements
	};

		// CLASS TEMPLATE _Tree_comp_alloc
template<class _Traits>
	class _Tree_comp_alloc
	{	// base class for tree to hold ordering predicate, allocator
public:
	using allocator_type = typename _Traits::allocator_type;
	using key_compare = typename _Traits::key_compare;

	using _Alloc_types = _Tree_base_types<typename _Traits::value_type, allocator_type>;

	using _Alnode = typename _Alloc_types::_Alnode;
	using _Alnode_traits = typename _Alloc_types::_Alnode_traits;
	using _Alproxy = _Rebind_alloc_t<_Alnode, _Container_proxy>;
	using _Alproxy_traits = allocator_traits<_Alproxy>;
	using _Node = typename _Alloc_types::_Node;
	using _Nodeptr = typename _Alloc_types::_Nodeptr;
	using _Val_types = typename _Alloc_types::_Val_types;

	using value_type = typename _Val_types::value_type;
	using size_type = typename _Val_types::size_type;
	using difference_type = typename _Val_types::difference_type;
	using pointer = typename _Val_types::pointer;
	using const_pointer = typename _Val_types::const_pointer;
	using reference = value_type&;
	using const_reference = const value_type&;

	using iterator = _Tree_iterator<_Tree_val<_Val_types>>;
	using const_iterator = _Tree_const_iterator<_Tree_val<_Val_types>>;
	using _Unchecked_iterator = _Tree_unchecked_iterator<_Tree_val<_Val_types>>;
	using _Unchecked_const_iterator = _Tree_unchecked_const_iterator<_Tree_val<_Val_types>>;

	enum _Redbl
		{	// colors for link to parent
		_Red, _Black
		};

	_Tree_comp_alloc(const key_compare& _Parg)
		: _Mypair(_One_then_variadic_args_t(), _Parg,
			_Zero_then_variadic_args_t())
		{	// construct from comparator
		_Construct();
		}

	template<class _Any_alloc,
		class = enable_if_t<!is_same_v<remove_cv_t<remove_reference_t<_Any_alloc>>, _Tree_comp_alloc>>>
		_Tree_comp_alloc(const key_compare& _Parg, _Any_alloc&& _Al)
		: _Mypair(_One_then_variadic_args_t(), _Parg,
			_One_then_variadic_args_t(),
			::std:: forward<_Any_alloc>(_Al))
		{	// construct from comparator, allocator
		_Construct();
		}

 



















	void _Construct()
		{	// construct head node, proxy
		auto& _My_data = _Get_data();
		_My_data._Myhead = _Buyheadnode();
		try {
		_Alloc_proxy();
		} catch (...) {
		_Freeheadnode(_My_data._Myhead);
		throw;
		}
		}

	~_Tree_comp_alloc() noexcept
		{	// destroy head node, proxy
		_Freeheadnode(_Get_data()._Myhead);
		_Free_proxy();
		}

	void _Alloc_proxy()
		{	// construct proxy
		_Alproxy _Proxy_allocator(_Getal());
		_Myproxy() = _Unfancy(_Proxy_allocator.allocate(1));
		_Alproxy_traits::construct(_Proxy_allocator, _Myproxy(), _Container_proxy());
		_Myproxy()->_Mycont = ::std:: addressof(_Get_data());
		}

	void _Free_proxy()
		{	// destroy proxy
		_Alproxy _Proxy_allocator(_Getal());
		_Orphan_all();
		_Alproxy_traits::destroy(_Proxy_allocator, _Myproxy());
		_Deallocate_plain(_Proxy_allocator, _Myproxy());
		_Myproxy() = nullptr;
		}

	_Iterator_base12 **_Getpfirst() const
		{	// get address of iterator chain
		return (_Get_data()._Getpfirst());
		}

	_Container_proxy * & _Myproxy() noexcept
		{	// return reference to _Myproxy
		return (_Get_data()._Myproxy);
		}

	_Container_proxy * const & _Myproxy() const noexcept
		{	// return const reference to _Myproxy
		return (_Get_data()._Myproxy);
		}
 

	void _Copy_alloc(const _Alnode& _Al)
		{	// replace old allocator
		const bool _Reload = _Alnode_traits::propagate_on_container_copy_assignment::value
			&& _Getal() != _Al;

		if (_Reload)
			{
			_Free_proxy();
			_Freeheadnode(_Get_data()._Myhead);
			}

		_Pocca(_Getal(), _Al);

		if (_Reload)
			{
			_Get_data()._Myhead = _Buyheadnode();
			_Alloc_proxy();
			}
		}

	void _Move_alloc(_Alnode& _Al)
		{	// replace old allocator
		const bool _Reload = _Alnode_traits::propagate_on_container_move_assignment::value
			&& _Getal() != _Al;

		if (_Reload)
			{
			_Free_proxy();
			_Freeheadnode(_Get_data()._Myhead);
			}

		_Pocma(_Getal(), _Al);

		if (_Reload)
			{
			_Get_data()._Myhead = _Buyheadnode();
			_Alloc_proxy();
			}
		}

	void _Orphan_all()
		{	// orphan all iterators
		_Get_data()._Orphan_all();
		}

	void _Swap_all(_Tree_comp_alloc& _Right)
		{	// swap all iterators
		_Get_data()._Swap_all(_Right._Get_data());
		}

	_Nodeptr _Buyheadnode()
		{	// get head node using current allocator
		_Alnode& _Al = _Getal();
		_Nodeptr _Pnode = _Al.allocate(1);

		try {
		_Alnode_traits::construct(_Al, ::std:: addressof(_Pnode->_Left), _Pnode);
		_Alnode_traits::construct(_Al, ::std:: addressof(_Pnode->_Parent), _Pnode);
		_Alnode_traits::construct(_Al, ::std:: addressof(_Pnode->_Right), _Pnode);
		} catch (...) {
		_Al.deallocate(_Pnode, 1);
		throw;
		}

		_Pnode->_Color = _Black;
		_Pnode->_Isnil = true;
		return (_Pnode);
		}

	void _Freeheadnode(_Nodeptr _Pnode)
		{	// free head node using current allocator
		_Node::_Freenode0(_Getal(), _Pnode);
		}

	_Nodeptr _Buynode0()
		{	// allocate a non-value node
		_Alnode& _Al = _Getal();
		_Nodeptr _Pnode = _Al.allocate(1);

		auto& _My_data = _Get_data();

		try {
		_Alnode_traits::construct(_Al, ::std:: addressof(_Pnode->_Left), _My_data._Myhead);
		_Alnode_traits::construct(_Al, ::std:: addressof(_Pnode->_Parent), _My_data._Myhead);
		_Alnode_traits::construct(_Al, ::std:: addressof(_Pnode->_Right), _My_data._Myhead);
		} catch (...) {
		_Al.deallocate(_Pnode, 1);
		throw;
		}

		return (_Pnode);
		}

	void _Freenode0(_Nodeptr _Pnode)
		{	// free non-value node using current allocator
		_Node::_Freenode0(_Getal(), _Pnode);
		}

	template<class... _Valty>
		_Nodeptr _Buynode(_Valty&&... _Val)
		{	// allocate a node with defaults and set links and value
		_Nodeptr _Pnode = _Buynode0();

		_Pnode->_Color = _Red;
		_Pnode->_Isnil = false;

		try {
		_Alnode_traits::construct(_Getal(),
			::std:: addressof(_Pnode->_Myval), ::std:: forward<_Valty>(_Val)...);
		} catch (...) {
		_Freenode0(_Pnode);
		throw;
		}

		return (_Pnode);
		}

	key_compare& _Getcomp() noexcept
		{	// return reference to ordering predicate
		return (_Mypair._Get_first());
		}

	const key_compare& _Getcomp() const noexcept
		{	// return const reference to ordering predicate
		return (_Mypair._Get_first());
		}

	_Alnode& _Getal() noexcept
		{	// return reference to allocator
		return (_Mypair._Get_second()._Get_first());
		}

	const _Alnode& _Getal() const noexcept
		{	// return const reference to allocator
		return (_Mypair._Get_second()._Get_first());
		}

	_Tree_val<_Val_types>& _Get_data() noexcept
		{	// return reference to _Tree_val
		return (_Mypair._Get_second()._Get_second());
		}

	const _Tree_val<_Val_types>& _Get_data() const noexcept
		{	// return const reference to _Tree_val
		return (_Mypair._Get_second()._Get_second());
		}

private:
	_Compressed_pair<key_compare,
		_Compressed_pair<_Alnode, _Tree_val<_Val_types>>> _Mypair;
	};

		// CLASS TEMPLATE _Tree
template<class _Traits>
	class _Tree
		: public _Tree_comp_alloc<_Traits>
	{	// ordered red-black tree for map/multimap/set/multiset
public:
	using _Mybase = _Tree_comp_alloc<_Traits>;

	using key_type = typename _Traits::key_type;
	using value_compare = typename _Traits::value_compare;
	enum
		{	// get multi parameter
		_Multi = _Traits::_Multi};

	using _Node = typename _Mybase::_Node;
	using _Nodeptr = typename _Mybase::_Nodeptr;
	using _Alnode = typename _Mybase::_Alnode;
	using _Alnode_traits = typename _Mybase::_Alnode_traits;

	using key_compare = typename _Mybase::key_compare;
	using allocator_type = typename _Mybase::allocator_type;

	using value_type = typename _Mybase::value_type;
	using size_type = typename _Mybase::size_type;
	using difference_type = typename _Mybase::difference_type;
	using pointer = typename _Mybase::pointer;
	using const_pointer = typename _Mybase::const_pointer;
	using reference = value_type&;
	using const_reference = const value_type&;

	using iterator = conditional_t<is_same_v<key_type, value_type>,
		typename _Mybase::const_iterator,
		typename _Mybase::iterator>;
	using const_iterator = typename _Mybase::const_iterator;
	using _Unchecked_iterator = conditional_t<is_same_v<key_type, value_type>,
		typename _Mybase::_Unchecked_const_iterator,
		typename _Mybase::_Unchecked_iterator>;
	using _Unchecked_const_iterator = typename _Mybase::_Unchecked_const_iterator;

	using reverse_iterator = ::std:: reverse_iterator<iterator>;
	using const_reverse_iterator = ::std:: reverse_iterator<const_iterator>;

	using _Pairib = pair<iterator, bool>;
	using _Pairii = pair<iterator, iterator>;
	using _Paircc = pair<const_iterator, const_iterator>;

	using _Mytreeval = _Tree_val<typename _Mybase::_Val_types>;

	struct _Copy_tag
		{	// signals copying
		};
	struct _Move_tag
		{	// signals moving
		};

	_Tree(const key_compare& _Parg)
		: _Mybase(_Parg)
		{	// construct empty tree from comparator
		}

	_Tree(const key_compare& _Parg,
		const allocator_type& _Al)
		: _Mybase(_Parg, _Al)
		{	// construct empty tree from comparator, allocator
		}

	template<class _Any_alloc>
		_Tree(const _Tree& _Right, _Any_alloc&& _Al)
		: _Mybase(_Right.key_comp(), ::std:: forward<_Any_alloc>(_Al))
		{	// construct tree by copying _Right, allocator
		try {
		_Copy(_Right, _Copy_tag());
		} catch (...) {
		_Tidy();
		throw;
		}
		}

	_Tree(_Tree&& _Right)
		: _Mybase(_Right.key_comp(), ::std:: move(_Right._Getal()))
		{	// construct tree by moving _Right
		_Assign_rv(::std:: move(_Right), true_type());
		}

	_Tree(_Tree&& _Right, const allocator_type& _Al)
		: _Mybase(_Right.key_comp(), _Al)
		{	// construct tree by moving _Right, allocator
		_Assign_rv(::std:: move(_Right), false_type());
		}

	_Tree& operator=(_Tree&& _Right)
		{	// assign by moving _Right
		if (this != ::std:: addressof(_Right))
			{	// different, move it
			clear();
			this->_Move_alloc(_Right._Getal());
			this->_Getcomp() = _Right._Getcomp();
			_Assign_rv(::std:: move(_Right), bool_constant<_Always_equal_after_move<_Alnode>>{});
			}
		return (*this);
		}

	void _Assign_rv(_Tree&& _Right, true_type)
		{	// move from _Right, stealing its contents
		this->_Swap_all(_Right);
		_Swap_adl(this->_Getcomp(), _Right._Getcomp());
		auto& _My_data = this->_Get_data();
		auto& _Right_data = _Right._Get_data();
		_Swap_adl(_My_data._Myhead, _Right_data._Myhead);
		::std:: swap(_My_data._Mysize, _Right_data._Mysize);
		}

	void _Assign_rv(_Tree&& _Right, false_type)
		{	// move from _Right, possibly moving its contents
		if (this->_Getal() == _Right._Getal())
			{
			_Assign_rv(::std:: move(_Right), true_type());
			}
		else
			{
			_Copy(_Right, _Move_tag());
			}
		}

	template<class... _Valty>
		_Pairib emplace(_Valty&&... _Val)
		{	// try to insert value_type(_Val...), favoring right side
		_Nodeptr _Newnode = this->_Buynode(::std:: forward<_Valty>(_Val)...);
		return (_Insert_nohint(false, _Newnode->_Myval, _Newnode));
		}

	template<class... _Valty>
		iterator emplace_hint(const_iterator _Where, _Valty&&... _Val)
		{	// insert value_type(_Val...) at _Where
		_Nodeptr _Newnode = this->_Buynode(::std:: forward<_Valty>(_Val)...);
		return (_Insert_hint(_Where, _Newnode->_Myval, _Newnode));
		}

	~_Tree() noexcept
		{	// destroy tree
		_Tidy();
		}

	_Tree& operator=(const _Tree& _Right)
		{	// replace contents from _Right
		if (this != ::std:: addressof(_Right))
			{	// different, assign it
			clear();
			this->_Copy_alloc(_Right._Getal());
			this->_Getcomp() = _Right._Getcomp();
			_Copy(_Right, _Copy_tag());
			}

		return (*this);
		}

	 iterator begin() noexcept
		{	// return iterator for beginning of mutable sequence
		auto& _My_data = this->_Get_data();
		return (iterator(_My_data._Lmost(), ::std:: addressof(_My_data)));
		}

	 const_iterator begin() const noexcept
		{	// return iterator for beginning of nonmutable sequence
		auto& _My_data = this->_Get_data();
		return (const_iterator(_My_data._Lmost(), ::std:: addressof(_My_data)));
		}

	 iterator end() noexcept
		{	// return iterator for end of mutable sequence
		auto& _My_data = this->_Get_data();
		return (iterator(_My_data._Myhead, ::std:: addressof(_My_data)));
		}

	 const_iterator end() const noexcept
		{	// return iterator for end of nonmutable sequence
		auto& _My_data = this->_Get_data();
		return (const_iterator(_My_data._Myhead, ::std:: addressof(_My_data)));
		}

	_Unchecked_iterator _Unchecked_begin() noexcept
		{	// return unchecked iterator for beginning of mutable sequence
		return (_Unchecked_iterator(this->_Get_data()._Lmost(), nullptr));
		}

	_Unchecked_const_iterator _Unchecked_begin() const noexcept
		{	// return unchecked iterator for beginning of nonmutable sequence
		return (_Unchecked_const_iterator(this->_Get_data()._Lmost(), nullptr));
		}

	_Unchecked_iterator _Unchecked_end() noexcept
		{	// return unchecked iterator for end of mutable sequence
		return (_Unchecked_iterator(this->_Get_data()._Myhead, nullptr));
		}

	_Unchecked_const_iterator _Unchecked_end() const noexcept
		{	// return unchecked iterator for end of nonmutable sequence
		return (_Unchecked_const_iterator(this->_Get_data()._Myhead, nullptr));
		}

	 reverse_iterator rbegin() noexcept
		{	// return iterator for beginning of reversed mutable sequence
		return (reverse_iterator(end()));
		}

	 const_reverse_iterator rbegin() const noexcept
		{	// return iterator for beginning of reversed nonmutable sequence
		return (const_reverse_iterator(end()));
		}

	 reverse_iterator rend() noexcept
		{	// return iterator for end of reversed mutable sequence
		return (reverse_iterator(begin()));
		}

	 const_reverse_iterator rend() const noexcept
		{	// return iterator for end of reversed nonmutable sequence
		return (const_reverse_iterator(begin()));
		}

	 const_iterator cbegin() const noexcept
		{	// return iterator for beginning of nonmutable sequence
		return (begin());
		}

	 const_iterator cend() const noexcept
		{	// return iterator for end of nonmutable sequence
		return (end());
		}

	 const_reverse_iterator crbegin() const noexcept
		{	// return iterator for beginning of reversed nonmutable sequence
		return (rbegin());
		}

	 const_reverse_iterator crend() const noexcept
		{	// return iterator for end of reversed nonmutable sequence
		return (rend());
		}

	 size_type size() const noexcept
		{	// return length of sequence
		return (this->_Get_data()._Mysize);
		}

	 size_type max_size() const noexcept
		{	// return maximum possible length of sequence
		return (_Alnode_traits::max_size(this->_Getal()));
		}

	 bool empty() const noexcept
		{	// return true only if sequence is empty
		return (size() == 0);
		}

	 allocator_type get_allocator() const noexcept
		{	// return allocator object for values
		return (static_cast<allocator_type>(this->_Getal()));
		}

	 key_compare key_comp() const
		{	// return object for comparing keys
		return (this->_Getcomp());
		}

	 value_compare value_comp() const
		{	// return object for comparing values
		return (value_compare(key_comp()));
		}

	template<bool _Multi2 = _Multi,
		enable_if_t<!_Multi2, int> = 0>
		_Pairib insert(const value_type& _Val)
		{	// try to insert node with value _Val, favoring right side
		return (_Insert_nohint(false, _Val, _Not_a_node_tag()));
		}

	template<bool _Multi2 = _Multi,
		enable_if_t<_Multi2, int> = 0>
		iterator insert(const value_type& _Val)
		{	// try to insert node with value _Val, favoring right side
		return (_Insert_nohint(false, _Val, _Not_a_node_tag()).first);
		}

	template<bool _Multi2 = _Multi,
		enable_if_t<!_Multi2, int> = 0>
		_Pairib insert(value_type&& _Val)
		{	// try to insert node with value _Val, favoring right side
		return (_Insert_nohint(false, ::std:: move(_Val), _Not_a_node_tag()));
		}

	template<bool _Multi2 = _Multi,
		enable_if_t<_Multi2, int> = 0>
		iterator insert(value_type&& _Val)
		{	// try to insert node with value _Val, favoring right side
		return (_Insert_nohint(false, ::std:: move(_Val), _Not_a_node_tag()).first);
		}

	iterator insert(const_iterator _Where,
		const value_type& _Val)
		{	// try to insert node with value _Val using _Where as a hint
		return (_Insert_hint(_Where, _Val, _Not_a_node_tag()));
		}

	iterator insert(const_iterator _Where, value_type&& _Val)
		{	// try to insert node with value _Val using _Where as a hint
		return (_Insert_hint(_Where, ::std:: move(_Val), _Not_a_node_tag()));
		}

	template<class _Iter>
		void insert(_Iter _First, _Iter _Last)
		{	// insert [_First, _Last) one at a time
		_Adl_verify_range(_First, _Last);
		auto _UFirst = _Get_unwrapped(_First);
		const auto _ULast = _Get_unwrapped(_Last);
		for (; _UFirst != _ULast; ++_UFirst)
			{
			emplace_hint(end(), *_UFirst);
			}
		}

	void insert(initializer_list<value_type> _Ilist)
		{	// insert initializer_list
		insert(_Ilist.begin(), _Ilist.end());
		}

	template<class _Iter = iterator,
		class = enable_if_t<!is_same_v<_Iter, const_iterator>>>
		iterator erase(iterator _Where)
		{	// erase element at _Where
		return (erase(const_iterator{_Where}));
		}

	iterator erase(const_iterator _Where)
		{	// erase element at _Where
		auto& _My_data = this->_Get_data();
 
		do { if (_Where._Getcont() == ::std:: addressof(_My_data) && !_Where._Ptr->_Isnil) { } else { do { (void) ((1 != _CrtDbgReport(2, "c:\\visual studio\\vc\\tools\\msvc\\14.16.27023\\include\\xtree", 1366, 0, "%s", "map/set erase iterator outside range")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"map/set erase iterator outside range\"", __LPREFIX( __FUNCTION__), L"c:\\visual studio\\vc\\tools\\msvc\\14.16.27023\\include\\xtree", 1366, 0); } while (false); } ; } while (false);
 

		const_iterator _Successor = _Where;
		++_Successor;	// save successor iterator for return
		_Nodeptr _Erasednode = _My_data._Extract(_Where);	// node to erase

 
		_Orphan_ptr(_Erasednode);
 

		_Alnode& _Al = this->_Getal();
		_Alnode_traits::destroy(_Al, ::std:: addressof(_Erasednode->_Myval));	// delete erased node
		_Node::_Freenode0(_Al, _Erasednode);

		return (iterator(_Successor._Ptr, ::std:: addressof(_My_data)));	// return successor iterator
		}

	iterator erase(const_iterator _First, const_iterator _Last)
		{	// erase [_First, _Last)
		if (_First == begin() && _Last == end())
			{	// erase all
			clear();
			return (begin());
			}
		else
			{	// partial erase, one at a time
			while (_First != _Last)
				erase(_First++);
			return (iterator(_First._Ptr, ::std:: addressof(this->_Get_data())));
			}
		}

	size_type erase(const key_type& _Keyval)
		{	// erase and count all that match _Keyval
		_Pairii _Where = equal_range(_Keyval);
		const auto _Num = static_cast<size_type>(::std:: distance(_Where.first, _Where.second));
		erase(_Where.first, _Where.second);
		return (_Num);
		}

	void clear() noexcept
		{	// erase all
 
		this->_Orphan_ptr(nullptr);
 

		auto& _My_data = this->_Get_data();
		auto _Head = _My_data._Myhead;
		_Erase(_My_data._Root());
		_My_data._Root() = _Head;
		_My_data._Lmost() = _Head;
		_My_data._Rmost() = _Head;
		_My_data._Mysize = 0;
		}

	 iterator find(const key_type& _Keyval)
		{	// find an element in mutable sequence that matches _Keyval
		iterator _Where = lower_bound(_Keyval);
		return (_Where == end()
			|| _Debug_lt_pred(this->_Getcomp(), _Keyval, this->_Key(_Where._Ptr))
					? end() : _Where);
		}

	 const_iterator find(const key_type& _Keyval) const
		{	// find an element in nonmutable sequence that matches _Keyval
		const_iterator _Where = lower_bound(_Keyval);
		return (_Where == end()
			|| _Debug_lt_pred(this->_Getcomp(), _Keyval, this->_Key(_Where._Ptr))
					? end() : _Where);
		}

	template<class _Other,
		class _Mycomp = key_compare,
		class = typename _Mycomp::is_transparent>
		 iterator find(const _Other& _Keyval)
		{	// find an element in mutable sequence that matches _Keyval
		iterator _Where = lower_bound(_Keyval);
		return (_Where == end()
			|| _Debug_lt_pred(this->_Getcomp(), _Keyval, this->_Key(_Where._Ptr))
					? end() : _Where);
		}

	template<class _Other,
		class _Mycomp = key_compare,
		class = typename _Mycomp::is_transparent>
		 const_iterator find(const _Other& _Keyval) const
		{	// find an element in nonmutable sequence that matches _Keyval
		const_iterator _Where = lower_bound(_Keyval);
		return (_Where == end()
			|| _Debug_lt_pred(this->_Getcomp(), _Keyval, this->_Key(_Where._Ptr))
					? end() : _Where);
		}

	 size_type count(const key_type& _Keyval) const
		{	// count all elements that match _Keyval
		_Paircc _Ans = equal_range(_Keyval);
		return (static_cast<size_type>(::std:: distance(_Ans.first, _Ans.second)));
		}

	template<class _Other,
		class _Mycomp = key_compare,
		class = typename _Mycomp::is_transparent>
		 size_type count(const _Other& _Keyval) const
		{	// count all elements that match _Keyval
		_Paircc _Ans = equal_range(_Keyval);
		return (static_cast<size_type>(::std:: distance(_Ans.first, _Ans.second)));
		}

	 iterator lower_bound(const key_type& _Keyval)
		{	// find leftmost node not less than _Keyval in mutable tree
		return (iterator(_Lbound(_Keyval), ::std:: addressof(this->_Get_data())));
		}

	 const_iterator lower_bound(const key_type& _Keyval) const
		{	// find leftmost node not less than _Keyval in nonmutable tree
		return (const_iterator(_Lbound(_Keyval), ::std:: addressof(this->_Get_data())));
		}

	template<class _Other,
		class _Mycomp = key_compare,
		class = typename _Mycomp::is_transparent>
		 iterator lower_bound(const _Other& _Keyval)
		{	// find leftmost node not less than _Keyval in mutable tree
		return (iterator(_Lbound(_Keyval), ::std:: addressof(this->_Get_data())));
		}

	template<class _Other,
		class _Mycomp = key_compare,
		class = typename _Mycomp::is_transparent>
		 const_iterator lower_bound(const _Other& _Keyval) const
		{	// find leftmost node not less than _Keyval in nonmutable tree
		return (const_iterator(_Lbound(_Keyval), ::std:: addressof(this->_Get_data())));
		}

	 iterator upper_bound(const key_type& _Keyval)
		{	// find leftmost node greater than _Keyval in mutable tree
		return (iterator(_Ubound(_Keyval), ::std:: addressof(this->_Get_data())));
		}

	 const_iterator upper_bound(const key_type& _Keyval) const
		{	// find leftmost node greater than _Keyval in nonmutable tree
		return (const_iterator(_Ubound(_Keyval), ::std:: addressof(this->_Get_data())));
		}

	template<class _Other,
		class _Mycomp = key_compare,
		class = typename _Mycomp::is_transparent>
		 iterator upper_bound(const _Other& _Keyval)
		{	// find leftmost node greater than _Keyval in mutable tree
		return (iterator(_Ubound(_Keyval), ::std:: addressof(this->_Get_data())));
		}

	template<class _Other,
		class _Mycomp = key_compare,
		class = typename _Mycomp::is_transparent>
		 const_iterator upper_bound(const _Other& _Keyval) const
		{	// find leftmost node greater than _Keyval in nonmutable tree
		return (const_iterator(_Ubound(_Keyval), ::std:: addressof(this->_Get_data())));
		}

	 _Pairii equal_range(const key_type& _Keyval)
		{	// find range equivalent to _Keyval in mutable tree
		return (_Eqrange(_Keyval));
		}

	 _Paircc equal_range(const key_type& _Keyval) const
		{	// find range equivalent to _Keyval in nonmutable tree
		return (_Eqrange(_Keyval));
		}

	template<class _Other,
		class _Mycomp = key_compare,
		class = typename _Mycomp::is_transparent>
		 _Pairii equal_range(const _Other& _Keyval)
		{	// find range equivalent to _Keyval in mutable tree
		return (_Eqrange(_Keyval));
		}

	template<class _Other,
		class _Mycomp = key_compare,
		class = typename _Mycomp::is_transparent>
		 _Paircc equal_range(const _Other& _Keyval) const
		{	// find range equivalent to _Keyval in nonmutable tree
		return (_Eqrange(_Keyval));
		}

	void swap(_Tree& _Right) noexcept(_Is_nothrow_swappable<key_compare>::value) // strengthened
		{	// exchange contents with _Right
		if (this != ::std:: addressof(_Right))
			{	// (maybe) swap allocators, swap control information
			_Swap_adl(this->_Getcomp(), _Right._Getcomp());
			_Pocs(this->_Getal(), _Right._Getal());
			this->_Swap_all(_Right);
			auto& _My_data = this->_Get_data();
			auto& _Right_data = _Right._Get_data();
			_Swap_adl(_My_data._Myhead, _Right_data._Myhead);
			::std:: swap(_My_data._Mysize, _Right_data._Mysize);
			}
		}

protected:
	template<class _Valty>
		_Nodeptr _Buy_if_not_node(_Nodeptr _Node, _Valty&&)
		{	// node exists, just return it
		return (_Node);
		}

	template<class _Valty>
		_Nodeptr _Buy_if_not_node(_Not_a_node_tag, _Valty&& _Val)
		{	// node doesn't exist, make it
		return (this->_Buynode(::std:: forward<_Valty>(_Val)));
		}

	void _Destroy_if_node(_Nodeptr _Newnode)
		{	// node exists, destroy it
		_Alnode& _Al = this->_Getal();
		_Alnode_traits::destroy(_Al, ::std:: addressof(_Newnode->_Myval));
		_Node::_Freenode0(_Al, _Newnode);
		}

	void _Destroy_if_node(_Not_a_node_tag)
		{	// node doesn't exist, do nothing
		}

	template<class _Valty,
		class _Nodety>
		iterator _Insert_hint(const_iterator _Where,
			_Valty&& _Val, _Nodety _Newnode)
		{	// try to insert node using _Where as a hint
		const_iterator _Next;
		bool _Leftish = false;	// assume nearest point is end of sequence
		auto& _My_data = this->_Get_data();

		try {
 
		do { if (_Where._Getcont() == ::std:: addressof(_My_data)) { } else { do { (void) ((1 != _CrtDbgReport(2, "c:\\visual studio\\vc\\tools\\msvc\\14.16.27023\\include\\xtree", 1606, 0, "%s", "map/set insert iterator outside range")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\"map/set insert iterator outside range\"", __LPREFIX( __FUNCTION__), L"c:\\visual studio\\vc\\tools\\msvc\\14.16.27023\\include\\xtree", 1606, 0); } while (false); } ; } while (false);
 

#pragma warning(push)
#pragma warning(disable: 4127)	
		if (size() == 0)
			{
			return (_Insert_at(true, _My_data._Myhead,
				::std:: forward<_Valty>(_Val), _Newnode));	// empty tree
			}
		else if (this->_Multi)
			{	// insert even if duplicate
			if (_Where == begin())
				{	// insert at beginning if before first element
				if (!_Debug_lt_pred(this->_Getcomp(), this->_Key(_Where._Ptr), this->_Kfn(_Val)))
					return (_Insert_at(true, _Where._Ptr,
						::std:: forward<_Valty>(_Val), _Newnode));
				_Leftish = true;	// nearest point is beginning of sequence
				}
			else if (_Where == end())
				{	// insert at end if after last element
				if (!_Debug_lt_pred(this->_Getcomp(), this->_Kfn(_Val), this->_Key(_My_data._Rmost())))
					return (_Insert_at(false, _My_data._Rmost(),
						::std:: forward<_Valty>(_Val), _Newnode));
				}
			else if (!_Debug_lt_pred(this->_Getcomp(), this->_Key(_Where._Ptr), this->_Kfn(_Val))
				&& !_Debug_lt_pred(this->_Getcomp(), this->_Kfn(_Val), this->_Key((--(_Next = _Where))._Ptr)))
				{	// insert before _Where
				if (_Next._Ptr->_Right->_Isnil)
					return (_Insert_at(false, _Next._Ptr,
						::std:: forward<_Valty>(_Val), _Newnode));
				else
					return (_Insert_at(true, _Where._Ptr,
						::std:: forward<_Valty>(_Val), _Newnode));
				}
			else if (!_Debug_lt_pred(this->_Getcomp(), this->_Kfn(_Val), this->_Key(_Where._Ptr))
				&& (++(_Next = _Where) == end()
					|| !_Debug_lt_pred(this->_Getcomp(), this->_Key(_Next._Ptr), this->_Kfn(_Val))))
				{	// insert after _Where
				if (_Where._Ptr->_Right->_Isnil)
					return (_Insert_at(false, _Where._Ptr,
						::std:: forward<_Valty>(_Val), _Newnode));
				else
					return (_Insert_at(true, _Next._Ptr,
						::std:: forward<_Valty>(_Val), _Newnode));
				}
			else
				{
				_Leftish = true;	// nearest point is beginning of sequence
				}
			}
		else
			{	// insert only if unique
			if (_Where == begin())
				{	// insert at beginning if before first element
				if (_Debug_lt_pred(this->_Getcomp(), this->_Kfn(_Val), this->_Key(_Where._Ptr)))
					{
					return (_Insert_at(true, _Where._Ptr,
						::std:: forward<_Valty>(_Val), _Newnode));
					}
				}
			else if (_Where == end())
				{	// insert at end if after last element
				if (_Debug_lt_pred(this->_Getcomp(), this->_Key(_My_data._Rmost()), this->_Kfn(_Val)))
					{
					return (_Insert_at(false, _My_data._Rmost(),
						::std:: forward<_Valty>(_Val), _Newnode));
					}
				}
			else if (_Debug_lt_pred(this->_Getcomp(), this->_Kfn(_Val), this->_Key(_Where._Ptr))
				&& _Debug_lt_pred(this->_Getcomp(), this->_Key((--(_Next = _Where))._Ptr), this->_Kfn(_Val)))
				{	// insert before _Where
				if (_Next._Ptr->_Right->_Isnil)
					{
					return (_Insert_at(false, _Next._Ptr,
						::std:: forward<_Valty>(_Val), _Newnode));
					}
				else
					{
					return (_Insert_at(true, _Where._Ptr,
						::std:: forward<_Valty>(_Val), _Newnode));
					}
				}
			else if (_Debug_lt_pred(this->_Getcomp(), this->_Key(_Where._Ptr), this->_Kfn(_Val))
				&& (++(_Next = _Where) == end()
					|| _Debug_lt_pred(this->_Getcomp(), this->_Kfn(_Val), this->_Key(_Next._Ptr))))
				{	// insert after _Where
				if (_Where._Ptr->_Right->_Isnil)
					{
					return (_Insert_at(false, _Where._Ptr,
						::std:: forward<_Valty>(_Val), _Newnode));
					}
				else
					{
					return (_Insert_at(true, _Next._Ptr,
						::std:: forward<_Valty>(_Val), _Newnode));
					}
				}
			}
#pragma warning(pop)
		} catch (...) {
		_Destroy_if_node(_Newnode);
		throw;
		}

		return (_Insert_nohint(_Leftish,
			::std:: forward<_Valty>(_Val), _Newnode).first);
		}

	template<class _Valty,
		class _Nodety>
		_Pairib _Insert_nohint(bool _Leftish,
			_Valty&& _Val, _Nodety _Newnode)
		{	// try to insert node, on left if _Leftish
		auto& _My_data = this->_Get_data();
		try {
		_Nodeptr _Wherenode = _My_data._Myhead;
		_Nodeptr _Trynode = _Wherenode->_Parent;
		bool _Addleft = true;	// add to left of head if tree empty

		while (!_Trynode->_Isnil)
			{	// look for leaf to insert before (_Addleft) or after
			_Wherenode = _Trynode;
			if (_Leftish)
				{
				_Addleft = !_Debug_lt_pred(this->_Getcomp(), this->_Key(_Trynode), this->_Kfn(_Val));	// favor left end
				}
			else
				{
				_Addleft = _Debug_lt_pred(this->_Getcomp(), this->_Kfn(_Val), this->_Key(_Trynode));	// favor right end
				}

			_Trynode = _Addleft ? _Trynode->_Left : _Trynode->_Right;
			}

#pragma warning(push)
#pragma warning(disable: 4127)	
		if (this->_Multi)
			{
			return (_Pairib(_Insert_at(_Addleft, _Wherenode,
				::std:: forward<_Valty>(_Val), _Newnode), true));
			}
		else
			{	// insert only if unique
			iterator _Where = iterator(_Wherenode, ::std:: addressof(_My_data));
			if (!_Addleft)
				{	// need to test if insert after is okay
				}
			else if (_Where == begin())
				{
				return (_Pairib(_Insert_at(true, _Wherenode,
					::std:: forward<_Valty>(_Val), _Newnode), true));
				}
			else
				{
				--_Where;	// need to test if insert before is okay
				}

			if (_Debug_lt_pred(this->_Getcomp(), this->_Key(_Where._Ptr), this->_Kfn(_Val)))
				{
				return (_Pairib(_Insert_at(_Addleft, _Wherenode,
					::std:: forward<_Valty>(_Val), _Newnode), true));
				}
			else
				{	// duplicate, don't insert
				_Destroy_if_node(_Newnode);
				return (_Pairib(_Where, false));
				}
			}
#pragma warning(pop)
		} catch (...) {
		_Destroy_if_node(_Newnode);
		throw;
		}
		}

	template<class _Valty,
		class _Nodety>
		iterator _Insert_at(bool _Addleft, _Nodeptr _Wherenode, _Valty&& _Val, _Nodety _Node)
		{	// add node with value next to _Wherenode, to left if _Addleft
		auto& _My_data = this->_Get_data();
		if (max_size() - 1 <= _My_data._Mysize)
			{	// tree would get too big, fail
			_Destroy_if_node(_Node);
			_Xlength_error("map/set<T> too long");
			}

		_Nodeptr _Newnode = _Buy_if_not_node(_Node, ::std:: forward<_Valty>(_Val));

		++_My_data._Mysize;
		_Newnode->_Parent = _Wherenode;

		if (_Wherenode == _My_data._Myhead)
			{	// first node in tree, just set head values
			_My_data._Root() = _Newnode;
			_My_data._Lmost() = _Newnode;
			_My_data._Rmost() = _Newnode;
			}
		else if (_Addleft)
			{	// add to left of _Wherenode
			_Wherenode->_Left = _Newnode;
			if (_Wherenode == _My_data._Lmost())
				{
				_My_data._Lmost() = _Newnode;
				}
			}
		else
			{	// add to right of _Wherenode
			_Wherenode->_Right = _Newnode;
			if (_Wherenode == _My_data._Rmost())
				{
				_My_data._Rmost() = _Newnode;
				}
			}

		for (_Nodeptr _Pnode = _Newnode; _Pnode->_Parent->_Color == this->_Red; )
			{
			if (_Pnode->_Parent == _Pnode->_Parent->_Parent->_Left)
				{	// fixup red-red in left subtree
				_Wherenode = _Pnode->_Parent->_Parent->_Right;
				if (_Wherenode->_Color == this->_Red)
					{	// parent has two red children, blacken both
					_Pnode->_Parent->_Color = this->_Black;
					_Wherenode->_Color = this->_Black;
					_Pnode->_Parent->_Parent->_Color = this->_Red;
					_Pnode = _Pnode->_Parent->_Parent;
					}
				else
					{	// parent has red and black children
					if (_Pnode == _Pnode->_Parent->_Right)
						{	// rotate right child to left
						_Pnode = _Pnode->_Parent;
						_My_data._Lrotate(_Pnode);
						}

					_Pnode->_Parent->_Color = this->_Black;	// propagate red up
					_Pnode->_Parent->_Parent->_Color = this->_Red;
					_My_data._Rrotate(_Pnode->_Parent->_Parent);
					}
				}
			else
				{	// fixup red-red in right subtree
				_Wherenode = _Pnode->_Parent->_Parent->_Left;
				if (_Wherenode->_Color == this->_Red)
					{	// parent has two red children, blacken both
					_Pnode->_Parent->_Color = this->_Black;
					_Wherenode->_Color = this->_Black;
					_Pnode->_Parent->_Parent->_Color = this->_Red;
					_Pnode = _Pnode->_Parent->_Parent;
					}
				else
					{	// parent has red and black children
					if (_Pnode == _Pnode->_Parent->_Left)
						{	// rotate left child to right
						_Pnode = _Pnode->_Parent;
						_My_data._Rrotate(_Pnode);
						}

					_Pnode->_Parent->_Color = this->_Black;	// propagate red up
					_Pnode->_Parent->_Parent->_Color = this->_Red;
					_My_data._Lrotate(_Pnode->_Parent->_Parent);
					}
				}
			}

		_My_data._Root()->_Color = this->_Black;	// root is always black
		return (iterator(_Newnode, ::std:: addressof(_My_data)));
		}

	template<class _Moveit>
		void _Copy(const _Tree& _Right, _Moveit _Movefl)
		{	// copy or move entire tree from _Right
		auto& _My_data = this->_Get_data();
		_My_data._Root() = _Copy_nodes(_Right._Get_data()._Root(), _My_data._Myhead, _Movefl);
		_My_data._Mysize = _Right.size();
		if (!_My_data._Root()->_Isnil)
			{	// nonempty tree, look for new smallest and largest
			_My_data._Lmost() = _Mytreeval::_Min(_My_data._Root());
			_My_data._Rmost() = _Mytreeval::_Max(_My_data._Root());
			}
		else
			{	// empty tree, just tidy head pointers
			_My_data._Lmost() = _My_data._Myhead;
			_My_data._Rmost() = _My_data._Myhead;
			}
		}

	template<class _Ty,
		class _Is_set>
		_Nodeptr _Copy_or_move(_Ty& _Val, _Copy_tag, _Is_set)
		{	// copy to new node
		return (this->_Buynode(_Val));
		}

	template<class _Ty>
		_Nodeptr _Copy_or_move(_Ty& _Val, _Move_tag, true_type)
		{	// move to new node -- set
		return (this->_Buynode(::std:: move(_Val)));
		}

	template<class _Ty>
		_Nodeptr _Copy_or_move(_Ty& _Val, _Move_tag, false_type)
		{	// move to new node -- map
		return (this->_Buynode(
			::std:: move(const_cast<key_type&>(_Val.first)),
			::std:: move(_Val.second)));
		}

	template<class _Moveit>
		_Nodeptr _Copy_nodes(_Nodeptr _Rootnode, _Nodeptr _Wherenode,
			_Moveit _Movefl)
		{	// copy entire subtree, recursively
		_Nodeptr _Newroot = this->_Get_data()._Myhead;	// point at nil node

		if (!_Rootnode->_Isnil)
			{	// copy or move a node, then any subtrees
			typename is_same<key_type, value_type>::type _Is_set;
			_Nodeptr _Pnode = _Copy_or_move(_Rootnode->_Myval, _Movefl, _Is_set);
			_Pnode->_Parent = _Wherenode;
			_Pnode->_Color = _Rootnode->_Color;
			if (_Newroot->_Isnil)
				_Newroot = _Pnode;	// memorize new root

			try {
			_Pnode->_Left = _Copy_nodes(_Rootnode->_Left, _Pnode, _Movefl);
			_Pnode->_Right = _Copy_nodes(_Rootnode->_Right, _Pnode, _Movefl);
			} catch (...) {
			_Erase(_Newroot);	// subtree copy failed, bail out
			throw;
			}
			}

		return (_Newroot);	// return newly constructed tree
		}

	template<class _Other>
		_Paircc _Eqrange(const _Other& _Keyval) const
		{	// find leftmost node not less than _Keyval
		auto& _My_data = this->_Get_data();
		_Nodeptr _Pnode = _My_data._Root();
		_Nodeptr _Lonode = _My_data._Myhead;	// end() if search fails
		_Nodeptr _Hinode = _My_data._Myhead;	// end() if search fails

		while (!_Pnode->_Isnil)
			{
			if (_Debug_lt_pred(this->_Getcomp(), this->_Key(_Pnode), _Keyval))
				{
				_Pnode = _Pnode->_Right;	// descend right subtree
				}
			else
				{	// _Pnode not less than _Keyval, remember it
				if (_Hinode->_Isnil
						&& _Debug_lt_pred(this->_Getcomp(), _Keyval, this->_Key(_Pnode)))
					{
					_Hinode = _Pnode;	// _Pnode greater, remember it
					}

				_Lonode = _Pnode;
				_Pnode = _Pnode->_Left;	// descend left subtree
				}
			}

		_Pnode = _Hinode->_Isnil ? _My_data._Root() : _Hinode->_Left;	// continue scan for upper bound
		while (!_Pnode->_Isnil)
			{
			if (_Debug_lt_pred(this->_Getcomp(), _Keyval, this->_Key(_Pnode)))
				{	// _Pnode greater than _Keyval, remember it
				_Hinode = _Pnode;
				_Pnode = _Pnode->_Left;	// descend left subtree
				}
			else
				{
				_Pnode = _Pnode->_Right;	// descend right subtree
				}
			}

		const_iterator _First = const_iterator(_Lonode, ::std:: addressof(_My_data));
		const_iterator _Last = const_iterator(_Hinode, ::std:: addressof(_My_data));
		return (_Paircc(_First, _Last));
		}

	template<class _Other>
		_Pairii _Eqrange(const _Other& _Keyval)
		{	// find leftmost node not less than _Keyval
		_Paircc _Ans(static_cast<const _Tree *>(this)->_Eqrange(_Keyval));
		const auto _My_addr = ::std:: addressof(this->_Get_data());
		iterator _First = iterator(_Ans.first._Ptr, _My_addr);
		iterator _Last = iterator(_Ans.second._Ptr, _My_addr);
		return (_Pairii(_First, _Last));
		}

	void _Erase(_Nodeptr _Rootnode)
		{	// free entire subtree, recursively
		for (_Nodeptr _Pnode = _Rootnode; !_Pnode->_Isnil; _Rootnode = _Pnode)
			{	// free subtrees, then node
			_Erase(_Pnode->_Right);
			_Pnode = _Pnode->_Left;
			_Alnode& _Al = this->_Getal();
			_Alnode_traits::destroy(_Al, ::std:: addressof(_Rootnode->_Myval));
			_Node::_Freenode0(_Al, _Rootnode);
			}
		}

	bool _Compare(const key_type& _Left, const key_type& _Right) const
		{	// compare key_type to key_type, with debug checks
		return (_Debug_lt_pred(this->_Getcomp(), _Left, _Right));
		}

	template<class _Ty1,
		class _Ty2>
		bool _Compare(const _Ty1& _Left, const _Ty2& _Right) const
		{	// compare _Ty1 to _Ty2, without debug checks
		return (this->_Getcomp()(_Left, _Right));
		}

	template<class _Other>
		_Nodeptr _Lbound(const _Other& _Keyval) const
		{	// find leftmost node not less than _Keyval
		_Nodeptr _Wherenode = this->_Get_data()._Myhead;	// end() if search fails
		_Nodeptr _Pnode = _Wherenode->_Parent;

		while (!_Pnode->_Isnil)
			{
			if (_Compare(this->_Key(_Pnode), _Keyval))
				{
				_Pnode = _Pnode->_Right;	// descend right subtree
				}
			else
				{	// _Pnode not less than _Keyval, remember it
				_Wherenode = _Pnode;
				_Pnode = _Pnode->_Left;	// descend left subtree
				}
			}

		return (_Wherenode);	// return best remembered candidate
		}

	template<class _Other>
		_Nodeptr _Ubound(const _Other& _Keyval) const
		{	// find leftmost node greater than _Keyval
		auto& _My_data = this->_Get_data();
		_Nodeptr _Pnode = _My_data._Root();
		_Nodeptr _Wherenode = _My_data._Myhead;	// end() if search fails

		while (!_Pnode->_Isnil)
			{
			if (_Compare(_Keyval, this->_Key(_Pnode)))
				{	// _Pnode greater than _Keyval, remember it
				_Wherenode = _Pnode;
				_Pnode = _Pnode->_Left;	// descend left subtree
				}
			else
				{
				_Pnode = _Pnode->_Right;	// descend right subtree
				}
			}

		return (_Wherenode);	// return best remembered candidate
		}

 
	void _Orphan_ptr(_Nodeptr _Ptr)
		{	// orphan iterators with specified node pointers
		_Lockit _Lock(3);
		const_iterator **_Pnext = (const_iterator **)this->_Getpfirst();
		if (_Pnext != nullptr)
			{
			while (*_Pnext != nullptr)
				{
				if ((*_Pnext)->_Ptr == this->_Get_data()._Myhead
					|| (_Ptr != nullptr && (*_Pnext)->_Ptr != _Ptr))
					{
					_Pnext = (const_iterator **)(*_Pnext)->_Getpnext();
					}
				else
					{	// orphan the iterator
					(*_Pnext)->_Clrcont();
					*_Pnext = *(const_iterator **)(*_Pnext)->_Getpnext();
					}
				}
			}
		}
 

	void _Tidy()
		{	// free all storage
		erase(begin(), end());
		}

	const key_type& _Kfn(const value_type& _Val) const
		{	// get key from value
		return (_Traits::_Kfn(_Val));
		}

	const key_type& _Key(_Nodeptr _Pnode) const
		{	// return reference to key in node
		return (this->_Kfn(_Pnode->_Myval));
		}

 









































































































































































































































	};

template<class _Traits>
	 inline bool operator==(const _Tree<_Traits>& _Left, const _Tree<_Traits>& _Right)
	{	// test for _Tree equality
	return (_Left.size() == _Right.size()
		&& ::std:: equal(_Left.begin(), _Left.end(), _Right.begin()));
	}

template<class _Traits>
	 inline bool operator!=(const _Tree<_Traits>& _Left, const _Tree<_Traits>& _Right)
	{	// test for _Tree inequality
	return (!(_Left == _Right));
	}

template<class _Traits>
	 inline bool operator<(const _Tree<_Traits>& _Left, const _Tree<_Traits>& _Right)
	{	// test if _Less < _Right for _Trees
	return (::std:: lexicographical_compare(_Left.begin(), _Left.end(),
		_Right.begin(), _Right.end()));
	}

template<class _Traits>
	 inline bool operator>(const _Tree<_Traits>& _Left, const _Tree<_Traits>& _Right)
	{	// test if _Less > _Right for _Trees
	return (_Right < _Left);
	}

template<class _Traits>
	 inline bool operator<=(const _Tree<_Traits>& _Left, const _Tree<_Traits>& _Right)
	{	// test if _Less <= _Right for _Trees
	return (!(_Right < _Left));
	}

template<class _Traits>
	 inline bool operator>=(const _Tree<_Traits>& _Left, const _Tree<_Traits>& _Right)
	{	// test if _Less >= _Right for _Trees
	return (!(_Left < _Right));
	}
}

 
 
 #pragma warning(pop)
 #pragma pack(pop)



/*
 * Copyright (c) by P.J. Plauger. All rights reserved.
 * Consult your license regarding permissions and restrictions.
V6.50:0009 */






 #pragma pack(push,8)
 #pragma warning(push,3)
 #pragma warning(disable: 4455 4494  4619 4643 4702 4984 4988 )
 
 
 
namespace std {
		// CLASS TEMPLATE _Tmap_traits
template<class _Kty,	// key type
	class _Ty,	// mapped type
	class _Pr,	// comparator predicate type
	class _Alloc,	// actual allocator type (should be value allocator)
	bool _Mfl>	// true if multiple equivalent keys are permitted
	class _Tmap_traits
	{	// traits required to make _Tree behave like a map
public:
	using key_type = _Kty;
	using value_type = pair<const _Kty, _Ty>;
	using key_compare = _Pr;
	using allocator_type = _Alloc;






	enum
		{	// make multi parameter visible as an enum constant
		_Multi = _Mfl};

	class value_compare
		{	// functor for comparing two element values
	public:
		 typedef value_type first_argument_type;
		 typedef value_type second_argument_type;
		 typedef bool result_type;

		bool operator()(const value_type& _Left, const value_type& _Right) const
			{	// test if _Left precedes _Right by comparing just keys
			return (comp(_Left.first, _Right.first));
			}

	protected:
		friend _Tree<_Tmap_traits>;

		value_compare(key_compare _Pred)
			: comp(_Pred)
			{	// construct with specified predicate
			}

		key_compare comp;	// the comparator predicate for keys
		};

	template<class _Ty1,
		class _Ty2>
		static const _Kty& _Kfn(const pair<_Ty1, _Ty2>& _Val)
		{	// extract key from element value
		return (_Val.first);
		}
	};

		// CLASS TEMPLATE map
template<class _Kty,
	class _Ty,
	class _Pr = less<_Kty>,
	class _Alloc = allocator<pair<const _Kty, _Ty>>>
	class map
		: public _Tree<_Tmap_traits<_Kty, _Ty, _Pr, _Alloc, false>>
	{	// ordered red-black tree of {key, mapped} values, unique keys
public:
	static_assert(!0 || is_same_v<pair<const _Kty, _Ty>, typename _Alloc::value_type>,
		"map<Key, Value, Compare, Allocator>" " requires that Allocator's value_type match " "pair<const Key, Value>" " (See N4659 26.2.1 [container.requirements.general]/16 allocator_type)" " Either fix the allocator value_type or define _ENFORCE_MATCHING_ALLOCATORS=0" " to suppress this diagnostic.");

	using _Mybase = _Tree<_Tmap_traits<_Kty, _Ty, _Pr, _Alloc, false>>;
	using key_type = _Kty;
	using mapped_type = _Ty;
	using key_compare = _Pr;
	using value_compare = typename _Mybase::value_compare;
	using value_type = typename _Mybase::value_type;
	using allocator_type = typename _Mybase::allocator_type;
	using size_type = typename _Mybase::size_type;
	using difference_type = typename _Mybase::difference_type;
	using pointer = typename _Mybase::pointer;
	using const_pointer = typename _Mybase::const_pointer;
	using reference = value_type&;
	using const_reference = const value_type&;
	using iterator = typename _Mybase::iterator;
	using const_iterator = typename _Mybase::const_iterator;
	using reverse_iterator = typename _Mybase::reverse_iterator;
	using const_reverse_iterator = typename _Mybase::const_reverse_iterator;

	using _Alnode = typename _Mybase::_Alnode;
	using _Alnode_traits = typename _Mybase::_Alnode_traits;
	using _Pairib = typename _Mybase::_Pairib;





	map()
		: _Mybase(key_compare())
		{	// construct empty map from defaults
		}

	explicit map(const allocator_type& _Al)
		: _Mybase(key_compare(), _Al)
		{	// construct empty map from defaults, allocator
		}

	map(const map& _Right)
		: _Mybase(_Right, _Alnode_traits::select_on_container_copy_construction(_Right._Getal()))
		{	// construct map by copying _Right
		}

	map(const map& _Right, const allocator_type& _Al)
		: _Mybase(_Right, _Al)
		{	// construct map by copying _Right, allocator
		}

	explicit map(const key_compare& _Pred)
		: _Mybase(_Pred)
		{	// construct empty map from comparator
		}

	map(const key_compare& _Pred, const allocator_type& _Al)
		: _Mybase(_Pred, _Al)
		{	// construct empty map from comparator and allocator
		}

	template<class _Iter>
		map(_Iter _First, _Iter _Last)
		: _Mybase(key_compare())
		{	// construct map from [_First, _Last), defaults
		insert(_First, _Last);
		}

	template<class _Iter>
		map(_Iter _First, _Iter _Last,
			const key_compare& _Pred)
		: _Mybase(_Pred)
		{	// construct map from [_First, _Last), comparator
		insert(_First, _Last);
		}

	template<class _Iter>
		map(_Iter _First, _Iter _Last, const allocator_type& _Al)
		: _Mybase(key_compare(), _Al)
		{	// construct map from [_First, _Last), allocator
		insert(_First, _Last);
		}

	template<class _Iter>
		map(_Iter _First, _Iter _Last,
			const key_compare& _Pred, const allocator_type& _Al)
		: _Mybase(_Pred, _Al)
		{	// construct map from [_First, _Last), comparator, and allocator
		insert(_First, _Last);
		}

	map& operator=(const map& _Right)
		{	// assign by copying _Right
		_Mybase::operator=(_Right);
		return (*this);
		}

	map(map&& _Right)
		: _Mybase(::std:: move(_Right))
		{	// construct map by moving _Right
		}

	map(map&& _Right, const allocator_type& _Al)
		: _Mybase(::std:: move(_Right), _Al)
		{	// construct map by moving _Right, allocator
		}

	map& operator=(map&& _Right)
		noexcept(_Alnode_traits::is_always_equal::value && is_nothrow_move_assignable_v<_Pr>)
		{	// assign by moving _Right
		_Mybase::operator=(::std:: move(_Right));
		return (*this);
		}

	mapped_type& operator[](key_type&& _Keyval)
		{	// find element matching _Keyval or insert with default mapped
		return (try_emplace(::std:: move(_Keyval)).first->second);
		}

	void swap(map& _Right) noexcept(noexcept(_Mybase::swap(_Right))) // strengthened
		{	// exchange contents with non-movable _Right
		_Mybase::swap(_Right);
		}

	using _Mybase::insert;

	template<class _Valty,
		class = enable_if_t<is_constructible_v<value_type, _Valty>>>
		_Pairib insert(_Valty&& _Val)
		{	// insert _Val
		return (this->emplace(::std:: forward<_Valty>(_Val)));
		}

	template<class _Valty,
		class = enable_if_t<is_constructible_v<value_type, _Valty>>>
		iterator insert(const_iterator _Where, _Valty&& _Val)
		{	// insert _Val with hint
		return (this->emplace_hint(_Where, ::std:: forward<_Valty>(_Val)));
		}

	template<class _Keyty,
		class... _Mappedty>
		_Pairib _Try_emplace(_Keyty&& _Keyval,
			_Mappedty&&... _Mapval)
		{	// fail if _Keyval present, else emplace
		iterator _Where = _Mybase::lower_bound(_Keyval);
		if (_Where == _Mybase::end()
			|| _Debug_lt_pred(_Mybase::_Getcomp(), _Keyval, _Mybase::_Key(_Where._Ptr)))
			return (_Pairib(
				_Mybase::emplace_hint(_Where,
					piecewise_construct,
					::std:: forward_as_tuple(
						::std:: forward<_Keyty>(_Keyval)),
					::std:: forward_as_tuple(
						::std:: forward<_Mappedty>(_Mapval)...)),
				true));
		else
			return (_Pairib(_Where, false));
		}

	template<class... _Mappedty>
		_Pairib try_emplace(const key_type& _Keyval,
			_Mappedty&&... _Mapval)
		{	// fail if _Keyval present, else emplace
		return (_Try_emplace(_Keyval, ::std:: forward<_Mappedty>(_Mapval)...));
		}

	template<class... _Mappedty>
		iterator try_emplace(const_iterator, const key_type& _Keyval,
			_Mappedty&&... _Mapval)
		{	// fail if _Keyval present, else emplace, ignore hint
		return (_Try_emplace(_Keyval,
			::std:: forward<_Mappedty>(_Mapval)...).first);
		}

	template<class... _Mappedty>
		_Pairib try_emplace(key_type&& _Keyval,
			_Mappedty&&... _Mapval)
		{	// fail if _Keyval present, else emplace
		return (_Try_emplace(::std:: move(_Keyval),
			::std:: forward<_Mappedty>(_Mapval)...));
		}

	template<class... _Mappedty>
		iterator try_emplace(const_iterator, key_type&& _Keyval,
			_Mappedty&&... _Mapval)
		{	// fail if _Keyval present, else emplace, ignore hint
		return (_Try_emplace(::std:: move(_Keyval),
			::std:: forward<_Mappedty>(_Mapval)...).first);
		}

	template<class _Keyty,
		class _Mappedty>
		_Pairib _Insert_or_assign(_Keyty&& _Keyval,
			_Mappedty&& _Mapval)
		{	// assign if _Keyval present, else insert
		iterator _Where = _Mybase::lower_bound(_Keyval);
		if (_Where == _Mybase::end()
			|| _Debug_lt_pred(_Mybase::_Getcomp(), _Keyval, _Mybase::_Key(_Where._Ptr)))
			return (_Pairib(
				_Mybase::emplace_hint(_Where,
					::std:: forward<_Keyty>(_Keyval),
					::std:: forward<_Mappedty>(_Mapval)),
				true));
		else
			{	// _Keyval present, assign new value
			_Where->second = ::std:: forward<_Mappedty>(_Mapval);
			return (_Pairib(_Where, false));
			}
		}

	template<class _Mappedty>
		_Pairib insert_or_assign(const key_type& _Keyval,
			_Mappedty&& _Mapval)
		{	// assign if _Keyval present, else insert
		return (_Insert_or_assign(_Keyval,
			::std:: forward<_Mappedty>(_Mapval)));
		}

	template<class _Mappedty>
		iterator insert_or_assign(const_iterator, const key_type& _Keyval,
			_Mappedty&& _Mapval)
		{	// assign if _Keyval present, else insert, ignore hint
		return (_Insert_or_assign(_Keyval,
			::std:: forward<_Mappedty>(_Mapval)).first);
		}

	template<class _Mappedty>
		_Pairib insert_or_assign(key_type&& _Keyval,
			_Mappedty&& _Mapval)
		{	// assign if _Keyval present, else insert
		return (_Insert_or_assign(::std:: move(_Keyval),
			::std:: forward<_Mappedty>(_Mapval)));
		}

	template<class _Mappedty>
		iterator insert_or_assign(const_iterator, key_type&& _Keyval,
			_Mappedty&& _Mapval)
		{	// assign if _Keyval present, else insert, ignore hint
		return (_Insert_or_assign(::std:: move(_Keyval),
			::std:: forward<_Mappedty>(_Mapval)).first);
		}

	map(initializer_list<value_type> _Ilist)
		: _Mybase(key_compare())
		{	// construct from initializer_list, defaults
		insert(_Ilist);
		}

	map(initializer_list<value_type> _Ilist,
		const key_compare& _Pred)
		: _Mybase(_Pred)
		{	// construct from initializer_list, comparator
		insert(_Ilist);
		}

	map(initializer_list<value_type> _Ilist, const allocator_type& _Al)
		: _Mybase(key_compare(), _Al)
		{	// construct from initializer_list, allocator
		insert(_Ilist);
		}

	map(initializer_list<value_type> _Ilist,
		const key_compare& _Pred, const allocator_type& _Al)
		: _Mybase(_Pred, _Al)
		{	// construct from initializer_list, comparator, and allocator
		insert(_Ilist);
		}

	map& operator=(initializer_list<value_type> _Ilist)
		{	// assign initializer_list
		_Mybase::clear();
		insert(_Ilist);
		return (*this);
		}

	mapped_type& operator[](const key_type& _Keyval)
		{	// find element matching _Keyval or insert with default mapped
		return (try_emplace(_Keyval).first->second);
		}

	 mapped_type& at(const key_type& _Keyval)
		{	// find element matching _Keyval
		iterator _Where = _Mybase::lower_bound(_Keyval);
		if (_Where == _Mybase::end()
			|| _Mybase::_Getcomp()(_Keyval, _Mybase::_Key(_Where._Ptr)))
			_Xout_of_range("invalid map<K, T> key");
		return (_Where->second);
		}

	 const mapped_type& at(const key_type& _Keyval) const
		{	// find element matching _Keyval
		const_iterator _Where = _Mybase::lower_bound(_Keyval);
		if (_Where == _Mybase::end()
			|| _Mybase::_Getcomp()(_Keyval, _Mybase::_Key(_Where._Ptr)))
			_Xout_of_range("invalid map<K, T> key");
		return (_Where->second);
		}

	using _Mybase::_Unchecked_begin;
	using _Mybase::_Unchecked_end;
	};









































template<class _Kty,
	class _Ty,
	class _Pr,
	class _Alloc> inline
	void swap(map<_Kty, _Ty, _Pr, _Alloc>& _Left,
		map<_Kty, _Ty, _Pr, _Alloc>& _Right)
		noexcept(noexcept(_Left.swap(_Right)))
	{	// swap _Left and _Right maps
	_Left.swap(_Right);
	}

		// CLASS TEMPLATE multimap
template<class _Kty,
	class _Ty,
	class _Pr = less<_Kty>,
	class _Alloc = allocator<pair<const _Kty, _Ty>>>
	class multimap
		: public _Tree<_Tmap_traits<_Kty, _Ty, _Pr, _Alloc, true>>
	{	// ordered red-black tree of {key, mapped} values, non-unique keys
public:
	static_assert(!0 || is_same_v<pair<const _Kty, _Ty>, typename _Alloc::value_type>,
		"multimap<Key, Value, Compare, Allocator>" " requires that Allocator's value_type match " "pair<const Key, Value>" " (See N4659 26.2.1 [container.requirements.general]/16 allocator_type)" " Either fix the allocator value_type or define _ENFORCE_MATCHING_ALLOCATORS=0" " to suppress this diagnostic.");

	using _Mybase = _Tree<_Tmap_traits<_Kty, _Ty, _Pr, _Alloc, true>>;
	using key_type = _Kty;
	using mapped_type = _Ty;
	using key_compare = _Pr;
	using value_compare = typename _Mybase::value_compare;
	using value_type = typename _Mybase::value_type;
	using allocator_type = typename _Mybase::allocator_type;
	using size_type = typename _Mybase::size_type;
	using difference_type = typename _Mybase::difference_type;
	using pointer = typename _Mybase::pointer;
	using const_pointer = typename _Mybase::const_pointer;
	using reference = value_type&;
	using const_reference = const value_type&;
	using iterator = typename _Mybase::iterator;
	using const_iterator = typename _Mybase::const_iterator;
	using reverse_iterator = typename _Mybase::reverse_iterator;
	using const_reverse_iterator = typename _Mybase::const_reverse_iterator;

	using _Alnode = typename _Mybase::_Alnode;
	using _Alnode_traits = typename _Mybase::_Alnode_traits;

	multimap()
		: _Mybase(key_compare())
		{	// construct empty map from defaults
		}

	explicit multimap(const allocator_type& _Al)
		: _Mybase(key_compare(), _Al)
		{	// construct empty map from defaults, allocator
		}

	multimap(const multimap& _Right)
		: _Mybase(_Right, _Alnode_traits::select_on_container_copy_construction(_Right._Getal()))
		{	// construct map by copying _Right
		}

	multimap(const multimap& _Right, const allocator_type& _Al)
		: _Mybase(_Right, _Al)
		{	// construct map by copying _Right, allocator
		}

	explicit multimap(const key_compare& _Pred)
		: _Mybase(_Pred)
		{	// construct empty map from comparator
		}

	multimap(const key_compare& _Pred, const allocator_type& _Al)
		: _Mybase(_Pred, _Al)
		{	// construct empty map from comparator and allocator
		}

	template<class _Iter>
		multimap(_Iter _First, _Iter _Last)
		: _Mybase(key_compare())
		{	// construct map from [_First, _Last), defaults
		insert(_First, _Last);
		}

	template<class _Iter>
		multimap(_Iter _First, _Iter _Last,
			const key_compare& _Pred)
		: _Mybase(_Pred)
		{	// construct map from [_First, _Last), comparator
		insert(_First, _Last);
		}

	template<class _Iter>
		multimap(_Iter _First, _Iter _Last,
			const allocator_type& _Al)
		: _Mybase(key_compare(), _Al)
		{	// construct map from [_First, _Last), allocator
		insert(_First, _Last);
		}

	template<class _Iter>
		multimap(_Iter _First, _Iter _Last,
			const key_compare& _Pred, const allocator_type& _Al)
		: _Mybase(_Pred, _Al)
		{	// construct map from [_First, _Last), comparator, and allocator
		insert(_First, _Last);
		}

	multimap& operator=(const multimap& _Right)
		{	// assign by copying _Right
		_Mybase::operator=(_Right);
		return (*this);
		}

	multimap(multimap&& _Right)
		: _Mybase(::std:: move(_Right))
		{	// construct map by moving _Right
		}

	multimap(multimap&& _Right, const allocator_type& _Al)
		: _Mybase(::std:: move(_Right), _Al)
		{	// construct map by moving _Right
		}

	multimap& operator=(multimap&& _Right)
		noexcept(_Alnode_traits::is_always_equal::value && is_nothrow_move_assignable_v<_Pr>)
		{	// assign by moving _Right
		_Mybase::operator=(::std:: move(_Right));
		return (*this);
		}

	template<class... _Valty>
		iterator emplace(_Valty&&... _Val)
		{	// try to insert value_type(_Val...), favoring right side
		return (_Mybase::emplace(::std:: forward<_Valty>(_Val)...).first);
		}

	void swap(multimap& _Right) noexcept(noexcept(_Mybase::swap(_Right))) // strengthened
		{	// exchange contents with non-movable _Right
		_Mybase::swap(_Right);
		}

	using _Mybase::insert;

	template<class _Valty,
		class = enable_if_t<is_constructible_v<value_type, _Valty>>>
		iterator insert(_Valty&& _Val)
		{	// insert _Val
		return (this->emplace(::std:: forward<_Valty>(_Val)));
		}

	template<class _Valty,
		class = enable_if_t<is_constructible_v<value_type, _Valty>>>
		iterator insert(const_iterator _Where, _Valty&& _Val)
		{	// insert _Val with hint
		return (this->emplace_hint(_Where, ::std:: forward<_Valty>(_Val)));
		}

	multimap(initializer_list<value_type> _Ilist)
		: _Mybase(key_compare())
		{	// construct from initializer_list, defaults
		insert(_Ilist);
		}

	multimap(initializer_list<value_type> _Ilist,
		const key_compare& _Pred)
		: _Mybase(_Pred)
		{	// construct from initializer_list, comparator
		insert(_Ilist);
		}

	multimap(initializer_list<value_type> _Ilist,
		const allocator_type& _Al)
		: _Mybase(key_compare(), _Al)
		{	// construct from initializer_list, allocator
		insert(_Ilist);
		}

	multimap(initializer_list<value_type> _Ilist,
		const key_compare& _Pred, const allocator_type& _Al)
		: _Mybase(_Pred, _Al)
		{	// construct from initializer_list, comparator, and allocator
		insert(_Ilist);
		}

	multimap& operator=(initializer_list<value_type> _Ilist)
		{	// assign initializer_list
		_Mybase::clear();
		insert(_Ilist);
		return (*this);
		}

	using _Mybase::_Unchecked_begin;
	using _Mybase::_Unchecked_end;
	};









































template<class _Kty,
	class _Ty,
	class _Pr,
	class _Alloc> inline
	void swap(multimap<_Kty, _Ty, _Pr, _Alloc>& _Left,
		multimap<_Kty, _Ty, _Pr, _Alloc>& _Right)
		noexcept(noexcept(_Left.swap(_Right)))
	{	// swap _Left and _Right multimaps
	_Left.swap(_Right);
	}














}
 
 
 #pragma warning(pop)
 #pragma pack(pop)



/*
 * Copyright (c) by P.J. Plauger. All rights reserved.
 * Consult your license regarding permissions and restrictions.
V6.50:0009 */


using namespace std;

class unknownKeyException : exception {};

Menu* newMenu(string str);
Menu* getMenu(string str);
Menu* getMenuForGenerator(string str);

MenuElementFolder* newFD(string str, string text);
MenuElementFolder* getFD(string str);


#pragma once

//     MenuAggregator.h

// 










//  







#pragma once



class Theme
{
public:
	static void applyNext();
	static void applyCurrent();
private:
	Theme() = delete;
	static std::vector<std::string> themes;
	static int currentIndex;
	static void advanceCurrentIndex();
	static void apply(std::string theme);
	static std::string getCurrent();
};


int main()
{
	Console::hideCursor();
	Console::fixEncoding();
	Menu::setConsoleResolution();
	Theme::applyCurrent();


	newMenu("#main")->getContentGenerator() = [](){return getMenuForGenerator("#main")
		->addElement(new MenuElementTitle("    "))
		->addElement(new MenuElementFunctionButton(" ", []() { getMenu("#addMedicine")->addToStack(); }))
		->addElement(new MenuElementFunctionButton("", []() { Menu::finish(); }))
		->initChosenElementIndex();};;

	newMenu("#addMedicine")->getContentGenerator() = [](){return getMenuForGenerator("#addMedicine")
		->addElement(new MenuElementTitle(" "))
		->addElement(newFD("@addMedicine.main", " ")->addElement(new MenuElementEditField("")) ->addElement([](){auto e = new MenuElementEditField(""); e->getInput() = ""; return e;}()) ->addElement(new MenuElementFunctionButton("", []() { Menu::popStack(); })))
		->initChosenElementIndex();};;

	getMenu("#main")->addToStack();

	Menu::run();
	Console::sayGoodbye();
}
